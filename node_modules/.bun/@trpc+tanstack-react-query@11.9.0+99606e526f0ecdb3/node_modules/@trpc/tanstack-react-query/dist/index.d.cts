import { DataTag, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, InfiniteData, QueryClient, QueryFilters, SkipToken, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UnusedSkipTokenInfiniteOptions, UnusedSkipTokenOptions, UseMutationOptions } from "@tanstack/react-query";
import { TRPCClient, TRPCClientErrorLike, TRPCRequestOptions, TRPCUntypedClient } from "@trpc/client";
import { AnyTRPCProcedure, AnyTRPCRootTypes, AnyTRPCRouter, TRPCProcedureType, TRPCRouterRecord, inferProcedureInput, inferRouterContext, inferTransformedProcedureOutput } from "@trpc/server";
import * as React from "react";
import { DistributiveOmit, MaybePromise, coerceAsyncIterableToArray, inferAsyncIterableYield } from "@trpc/server/unstable-core-do-not-import";
import { TRPCConnectionState } from "@trpc/client/unstable-internals";
import { Unsubscribable } from "@trpc/server/observable";

//#region src/internals/types.d.ts
/**
 * Turn a set of optional properties into required
 * @internal
 */
type WithRequired<TObj, TKey extends keyof TObj> = TObj & { [P in TKey]-?: TObj[P] };
/**
 * @internal
 */
type ResolverDef = {
  input: any;
  output: any;
  transformer: boolean;
  errorShape: any;
  featureFlags: FeatureFlags;
};
/**
 * @remark `void` is here due to https://github.com/trpc/trpc/pull/4374
 */
type CursorInput = {
  cursor?: any;
};
type OptionalCursorInput = CursorInput | void;
/**
 * @internal
 */
type ExtractCursorType<TInput> = TInput extends CursorInput ? TInput['cursor'] : unknown;
/**
 * @internal
 */
type TRPCInfiniteData<TInput, TOutput> = InfiniteData<TOutput, NonNullable<ExtractCursorType<TInput>> | null>;
/**
 * @public
 */
interface TRPCReactRequestOptions extends Omit<TRPCRequestOptions, 'signal'> {
  /**
   * Opt out of SSR for this query by passing `ssr: false`
   */
  ssr?: boolean;
  /**
   * Opt out or into aborting request on unmount
   */
  abortOnUnmount?: boolean;
}
/**
 * @public
 */
interface TRPCQueryBaseOptions {
  /**
   * tRPC-related options
   */
  trpc?: TRPCReactRequestOptions;
}
/**
 * @public
 */
interface TRPCQueryOptionsResult {
  trpc: {
    path: string;
  };
}
/**
 * @public
 */
type QueryType = 'any' | 'infinite' | 'query';
/**
 * @public
 */
type TRPCQueryKeyWithoutPrefix = [path: string[], opts?: {
  input?: unknown;
  type?: Exclude<QueryType, 'any'>;
}];
/**
 * @public
 */
type TRPCQueryKeyWithPrefix = [prefix: string[], ...TRPCQueryKeyWithoutPrefix];
type TRPCQueryKey<TPrefixEnabled extends boolean = false> = TPrefixEnabled extends true ? TRPCQueryKeyWithPrefix : TRPCQueryKeyWithoutPrefix;
type AnyTRPCQueryKey = TRPCQueryKeyWithoutPrefix | TRPCQueryKeyWithPrefix;
/**
 * @public
 */
type TRPCMutationKeyWithPrefix = [prefix: string[], ...TRPCMutationKeyWithoutPrefix];
/**
 * @public
 */
type TRPCMutationKeyWithoutPrefix = [path: string[]];
type AnyTRPCMutationKey = TRPCMutationKeyWithoutPrefix | TRPCMutationKeyWithPrefix;
/**
 * @public
 */
type TRPCMutationKey<TPrefixEnabled extends boolean = false> = TPrefixEnabled extends true ? TRPCMutationKeyWithPrefix : TRPCMutationKeyWithoutPrefix;
/**
 * Feature flags for configuring tRPC behavior
 * @public
 */
type FeatureFlags = {
  keyPrefix: boolean;
};
/**
 * @internal
 */
type ofFeatureFlags<T extends FeatureFlags> = T;
/**
 * @internal
 */
type KeyPrefixOptions<TFeatureFlags extends FeatureFlags> = TFeatureFlags['keyPrefix'] extends true ? {
  keyPrefix: string;
} : {
  /**
   * In order to use a query key prefix, you have to initialize the context with the `keyPrefix`
   */
  keyPrefix?: never;
};
/**
 * Default feature flags with query key prefix disabled
 * @public
 */
type DefaultFeatureFlags = ofFeatureFlags<{
  keyPrefix: false;
}>;
//#endregion
//#region src/internals/infiniteQueryOptions.d.ts
type ReservedOptions$2 = 'queryKey' | 'queryFn' | 'queryHashFn' | 'queryHash' | 'initialPageParam';
interface UndefinedTRPCInfiniteQueryOptionsIn<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, ReservedOptions$2>, TRPCQueryBaseOptions {
  initialCursor?: NonNullable<ExtractCursorType<TInput>> | null;
}
interface UndefinedTRPCInfiniteQueryOptionsOut<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, 'initialPageParam'>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, TRPCInfiniteData<TInput, TData>, TError>;
  initialPageParam: NonNullable<ExtractCursorType<TInput>> | null;
}
interface DefinedTRPCInfiniteQueryOptionsIn<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, ReservedOptions$2>, TRPCQueryBaseOptions {
  initialCursor?: NonNullable<ExtractCursorType<TInput>> | null;
}
interface DefinedTRPCInfiniteQueryOptionsOut<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, 'initialPageParam'>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, TRPCInfiniteData<TInput, TData>, TError>;
  initialPageParam: NonNullable<ExtractCursorType<TInput>> | null;
}
interface UnusedSkipTokenTRPCInfiniteQueryOptionsIn<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UnusedSkipTokenInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, ReservedOptions$2>, TRPCQueryBaseOptions {
  initialCursor?: NonNullable<ExtractCursorType<TInput>> | null;
}
interface UnusedSkipTokenTRPCInfiniteQueryOptionsOut<TInput, TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UnusedSkipTokenInfiniteOptions<TQueryFnData, TError, TRPCInfiniteData<TInput, TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>, NonNullable<ExtractCursorType<TInput>> | null>, 'initialPageParam'>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, TRPCInfiniteData<TInput, TData>, TError>;
  initialPageParam: NonNullable<ExtractCursorType<TInput>> | null;
}
interface TRPCInfiniteQueryOptions<TDef extends ResolverDef> {
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'] | SkipToken, opts: DefinedTRPCInfiniteQueryOptionsIn<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>): DefinedTRPCInfiniteQueryOptionsOut<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>;
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'], opts: UnusedSkipTokenTRPCInfiniteQueryOptionsIn<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>): UnusedSkipTokenTRPCInfiniteQueryOptionsOut<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>;
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'] | SkipToken, opts?: UndefinedTRPCInfiniteQueryOptionsIn<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>): UndefinedTRPCInfiniteQueryOptionsOut<TDef['input'], TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TDef['featureFlags']>;
}
//#endregion
//#region src/internals/mutationOptions.d.ts
type ReservedOptions$1 = 'mutationKey' | 'mutationFn';
type TRPCMutationOptionsIn<TInput, TError, TOutput, TContext, TFeatureFlags extends FeatureFlags> = DistributiveOmit<UseMutationOptions<TOutput, TError, TInput, TContext>, ReservedOptions$1> & TRPCQueryBaseOptions & KeyPrefixOptions<TFeatureFlags>;
interface TRPCMutationOptionsOut<TInput, TError, TOutput, TContext, TFeatureFlags extends FeatureFlags> extends UseMutationOptions<TOutput, TError, TInput, TContext>, TRPCQueryOptionsResult {
  mutationKey: TRPCMutationKey<TFeatureFlags['keyPrefix']>;
}
interface TRPCMutationOptions<TDef extends ResolverDef, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> {
  <TContext = unknown>(opts?: TRPCMutationOptionsIn<TDef['input'], TRPCClientErrorLike<TDef>, TDef['output'], TContext, TFeatureFlags>): TRPCMutationOptionsOut<TDef['input'], TRPCClientErrorLike<TDef>, TDef['output'], TContext, TFeatureFlags>;
}
/**
 * @internal
 */
interface MutationOptionsOverride {
  onSuccess: (opts: {
    /**
     * Calls the original function that was defined in the query's `onSuccess` option
     */
    originalFn: () => MaybePromise<void>;
    queryClient: QueryClient;
    /**
     * Meta data passed in from the `useMutation()` hook
     */
    meta: Record<string, unknown>;
  }) => MaybePromise<void>;
}
//#endregion
//#region src/internals/queryOptions.d.ts
type ReservedOptions = 'queryKey' | 'queryFn' | 'queryHashFn' | 'queryHash';
interface UndefinedTRPCQueryOptionsIn<TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UndefinedInitialDataOptions<coerceAsyncIterableToArray<TQueryFnData>, TError, coerceAsyncIterableToArray<TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, ReservedOptions>, TRPCQueryBaseOptions {}
interface UndefinedTRPCQueryOptionsOut<TQueryFnData, TOutput, TError, TFeatureFlags extends FeatureFlags> extends UndefinedInitialDataOptions<coerceAsyncIterableToArray<TQueryFnData>, TError, coerceAsyncIterableToArray<TOutput>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, coerceAsyncIterableToArray<TOutput>, TError>;
}
interface DefinedTRPCQueryOptionsIn<TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<DefinedInitialDataOptions<coerceAsyncIterableToArray<NoInfer<TQueryFnData>>, TError, coerceAsyncIterableToArray<TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, ReservedOptions>, TRPCQueryBaseOptions {}
interface DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DefinedInitialDataOptions<coerceAsyncIterableToArray<TQueryFnData>, TError, coerceAsyncIterableToArray<TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, coerceAsyncIterableToArray<TData>, TError>;
}
interface UnusedSkipTokenTRPCQueryOptionsIn<TQueryFnData, TData, TError, TFeatureFlags extends FeatureFlags> extends DistributiveOmit<UnusedSkipTokenOptions<coerceAsyncIterableToArray<TQueryFnData>, TError, coerceAsyncIterableToArray<TData>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, ReservedOptions>, TRPCQueryBaseOptions {}
interface UnusedSkipTokenTRPCQueryOptionsOut<TQueryFnData, TOutput, TError, TFeatureFlags extends FeatureFlags> extends UnusedSkipTokenOptions<coerceAsyncIterableToArray<TQueryFnData>, TError, coerceAsyncIterableToArray<TOutput>, TRPCQueryKey<TFeatureFlags['keyPrefix']>>, TRPCQueryOptionsResult {
  queryKey: DataTag<TRPCQueryKey<TFeatureFlags['keyPrefix']>, coerceAsyncIterableToArray<TOutput>, TError>;
}
interface TRPCQueryOptions<TDef extends ResolverDef, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> {
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'] | SkipToken, opts: DefinedTRPCQueryOptionsIn<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>): DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>;
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'], opts?: UnusedSkipTokenTRPCQueryOptionsIn<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>): UnusedSkipTokenTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>;
  <TQueryFnData extends TDef['output'], TData = TQueryFnData>(input: TDef['input'] | SkipToken, opts?: UndefinedTRPCQueryOptionsIn<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>): UndefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>, TFeatureFlags>;
}
//#endregion
//#region src/internals/subscriptionOptions.d.ts
interface BaseTRPCSubscriptionOptionsIn<TOutput, TError> {
  enabled?: boolean;
  onStarted?: () => void;
  onData?: (data: inferAsyncIterableYield<TOutput>) => void;
  onError?: (err: TError) => void;
  onConnectionStateChange?: (state: TRPCConnectionState<TError>) => void;
}
interface UnusedSkipTokenTRPCSubscriptionOptionsIn<TOutput, TError> {
  onStarted?: () => void;
  onData?: (data: inferAsyncIterableYield<TOutput>) => void;
  onError?: (err: TError) => void;
  onConnectionStateChange?: (state: TRPCConnectionState<TError>) => void;
}
interface TRPCSubscriptionOptionsOut<TOutput, TError, TFeatureFlags extends FeatureFlags> extends UnusedSkipTokenTRPCSubscriptionOptionsIn<TOutput, TError>, TRPCQueryOptionsResult {
  enabled: boolean;
  queryKey: TRPCQueryKey<TFeatureFlags['keyPrefix']>;
  subscribe: (innerOpts: UnusedSkipTokenTRPCSubscriptionOptionsIn<TOutput, TError>) => Unsubscribable;
}
interface TRPCSubscriptionOptions<TDef extends ResolverDef, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> {
  (input: TDef['input'], opts?: UnusedSkipTokenTRPCSubscriptionOptionsIn<inferAsyncIterableYield<TDef['output']>, TRPCClientErrorLike<TDef>>): TRPCSubscriptionOptionsOut<inferAsyncIterableYield<TDef['output']>, TRPCClientErrorLike<TDef>, TFeatureFlags>;
  (input: TDef['input'] | SkipToken, opts?: BaseTRPCSubscriptionOptionsIn<inferAsyncIterableYield<TDef['output']>, TRPCClientErrorLike<TDef>>): TRPCSubscriptionOptionsOut<inferAsyncIterableYield<TDef['output']>, TRPCClientErrorLike<TDef>, TFeatureFlags>;
}
type TRPCSubscriptionStatus = 'idle' | 'connecting' | 'pending' | 'error';
interface TRPCSubscriptionBaseResult<TOutput, TError> {
  status: TRPCSubscriptionStatus;
  data: undefined | TOutput;
  error: null | TError;
  /**
   * Reset the subscription
   */
  reset: () => void;
}
interface TRPCSubscriptionIdleResult<TOutput> extends TRPCSubscriptionBaseResult<TOutput, null> {
  status: 'idle';
  data: undefined;
  error: null;
}
interface TRPCSubscriptionConnectingResult<TOutput, TError> extends TRPCSubscriptionBaseResult<TOutput, TError> {
  status: 'connecting';
  data: undefined | TOutput;
  error: TError | null;
}
interface TRPCSubscriptionPendingResult<TOutput> extends TRPCSubscriptionBaseResult<TOutput, undefined> {
  status: 'pending';
  data: TOutput | undefined;
  error: null;
}
interface TRPCSubscriptionErrorResult<TOutput, TError> extends TRPCSubscriptionBaseResult<TOutput, TError> {
  status: 'error';
  data: TOutput | undefined;
  error: TError;
}
type TRPCSubscriptionResult<TOutput, TError> = TRPCSubscriptionIdleResult<TOutput> | TRPCSubscriptionConnectingResult<TOutput, TError> | TRPCSubscriptionErrorResult<TOutput, TError> | TRPCSubscriptionPendingResult<TOutput>;
declare function useSubscription<TOutput, TError>(opts: TRPCSubscriptionOptionsOut<TOutput, TError, any>): TRPCSubscriptionResult<TOutput, TError>;
//#endregion
//#region src/internals/createOptionsProxy.d.ts
interface DecorateRouterKeyable<TFeatureFlags extends FeatureFlags> {
  /**
   * Calculate the TanStack Query Key for any path, could be used to invalidate every procedure beneath this path
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/query-keys
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryKey
   */
  pathKey: () => TRPCQueryKey<TFeatureFlags['keyPrefix']>;
  /**
   * Calculate a TanStack Query Filter for any path, could be used to manipulate every procedure beneath this path
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/filters
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryFilter
   */
  pathFilter: (filters?: QueryFilters<TRPCQueryKey<TFeatureFlags['keyPrefix']>>) => WithRequired<QueryFilters<TRPCQueryKey<TFeatureFlags['keyPrefix']>>, 'queryKey'>;
}
interface TypeHelper<TDef extends ResolverDef> {
  /**
   * @internal prefer using inferInput and inferOutput to access types
   */
  '~types': {
    input: TDef['input'];
    output: TDef['output'];
    errorShape: TDef['errorShape'];
  };
}
type inferInput<TProcedure extends DecorateInfiniteQueryProcedure<any> | DecorateQueryProcedure<any> | DecorateMutationProcedure<any>> = TProcedure['~types']['input'];
type inferOutput<TProcedure extends DecorateInfiniteQueryProcedure<any> | DecorateQueryProcedure<any> | DecorateMutationProcedure<any>> = TProcedure['~types']['output'];
interface DecorateInfiniteQueryProcedure<TDef extends ResolverDef> extends TypeHelper<TDef> {
  /**
   * Create a set of type-safe infinite query options that can be passed to `useInfiniteQuery`, `prefetchInfiniteQuery` etc.
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#infiniteQueryOptions
   */
  infiniteQueryOptions: TRPCInfiniteQueryOptions<TDef>;
  /**
   * Calculate the TanStack Query Key for a Infinite Query Procedure
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/query-keys
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryKey
   */
  infiniteQueryKey: (input?: Partial<TDef['input']>) => DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TRPCInfiniteData<TDef['input'], TDef['output']>, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>;
  /**
   * Calculate a TanStack Query Filter for a Infinite Query Procedure
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/filters
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryFilter
   */
  infiniteQueryFilter: (input?: Partial<TDef['input']>, filters?: QueryFilters<DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TRPCInfiniteData<TDef['input'], TDef['output']>, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>>) => WithRequired<QueryFilters<DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TRPCInfiniteData<TDef['input'], TDef['output']>, TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>>, 'queryKey'>;
}
interface DecorateQueryProcedure<TDef extends ResolverDef> extends TypeHelper<TDef>, DecorateRouterKeyable<TDef['featureFlags']> {
  /**
   * Create a set of type-safe query options that can be passed to `useQuery`, `prefetchQuery` etc.
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryOptions
   */
  queryOptions: TRPCQueryOptions<TDef>;
  /**
   * Calculate the TanStack Query Key for a Query Procedure
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/query-keys
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryKey
   */
  queryKey: (input?: Partial<TDef['input']>) => DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TDef['output'], TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>;
  /**
   * Calculate a TanStack Query Filter for a Query Procedure
   *
   * @see https://tanstack.com/query/latest/docs/framework/react/guides/filters
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#queryFilter
   */
  queryFilter: (input?: Partial<TDef['input']>, filters?: QueryFilters<DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TDef['output'], TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>>) => WithRequired<QueryFilters<DataTag<TRPCQueryKey<TDef['featureFlags']['keyPrefix']>, TDef['output'], TRPCClientErrorLike<{
    transformer: TDef['transformer'];
    errorShape: TDef['errorShape'];
  }>>>, 'queryKey'>;
}
interface DecorateMutationProcedure<TDef extends ResolverDef> extends TypeHelper<TDef> {
  /**
   * Create a set of type-safe mutation options that can be passed to `useMutation`
   *
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#mutationOptions
   */
  mutationOptions: TRPCMutationOptions<TDef>;
  /**
   * Calculate the TanStack Mutation Key for a Mutation Procedure
   *
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#mutationKey
   */
  mutationKey: () => TRPCMutationKey<TDef['featureFlags']['keyPrefix']>;
}
interface DecorateSubscriptionProcedure<TDef extends ResolverDef> extends TypeHelper<TDef> {
  /**
   * Create a set of type-safe subscription options that can be passed to `useSubscription`
   *
   * @see https://trpc.io/docs/client/tanstack-react-query/usage#subscriptionOptions
   */
  subscriptionOptions: TRPCSubscriptionOptions<TDef>;
}
type DecorateProcedure<TType extends TRPCProcedureType, TDef extends ResolverDef> = TType extends 'query' ? DecorateQueryProcedure<TDef> & (TDef['input'] extends OptionalCursorInput ? DecorateInfiniteQueryProcedure<TDef> : Record<string, never>) : TType extends 'mutation' ? DecorateMutationProcedure<TDef> : TType extends 'subscription' ? DecorateSubscriptionProcedure<TDef> : never;
/**
 * @internal
 */
type DecoratedRouterRecord<TRoot extends AnyTRPCRootTypes, TRecord extends TRPCRouterRecord, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> = { [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value ? $Value extends TRPCRouterRecord ? DecoratedRouterRecord<TRoot, $Value, TFeatureFlags> & DecorateRouterKeyable<TFeatureFlags> : $Value extends AnyTRPCProcedure ? DecorateProcedure<$Value['_def']['type'], {
  input: inferProcedureInput<$Value>;
  output: inferTransformedProcedureOutput<TRoot, $Value>;
  transformer: TRoot['transformer'];
  errorShape: TRoot['errorShape'];
  featureFlags: TFeatureFlags;
}> : never : never };
type TRPCOptionsProxy<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> = DecoratedRouterRecord<TRouter['_def']['_config']['$types'], TRouter['_def']['record'], TFeatureFlags> & DecorateRouterKeyable<TFeatureFlags>;
type TRPCOptionsProxyOptionsBase<TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> = {
  queryClient: QueryClient | (() => QueryClient);
  overrides?: {
    mutations?: MutationOptionsOverride;
  };
} & KeyPrefixOptions<TFeatureFlags>;
interface TRPCOptionsProxyOptionsInternal<TRouter extends AnyTRPCRouter> {
  router: TRouter;
  ctx: inferRouterContext<TRouter> | (() => MaybePromise<inferRouterContext<TRouter>>);
}
interface TRPCOptionsProxyOptionsExternal<TRouter extends AnyTRPCRouter> {
  client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>;
}
type TRPCOptionsProxyOptions<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> = TRPCOptionsProxyOptionsBase<TFeatureFlags> & (TRPCOptionsProxyOptionsInternal<TRouter> | TRPCOptionsProxyOptionsExternal<TRouter>);
/**
 * Create a typed proxy from your router types. Can also be used on the server.
 *
 * @see https://trpc.io/docs/client/tanstack-react-query/setup#3b-setup-without-react-context
 * @see https://trpc.io/docs/client/tanstack-react-query/server-components#5-create-a-trpc-caller-for-server-components
 */
declare function createTRPCOptionsProxy<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags>(opts: TRPCOptionsProxyOptions<TRouter, TFeatureFlags>): TRPCOptionsProxy<TRouter, TFeatureFlags>;
//#endregion
//#region src/internals/Context.d.ts
type TRPCProviderType<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> = React.FC<{
  children: React.ReactNode;
  queryClient: QueryClient;
  trpcClient: TRPCClient<TRouter>;
} & KeyPrefixOptions<TFeatureFlags>>;
interface CreateTRPCContextResult<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags> {
  TRPCProvider: TRPCProviderType<TRouter, TFeatureFlags>;
  useTRPC: () => TRPCOptionsProxy<TRouter, TFeatureFlags>;
  useTRPCClient: () => TRPCClient<TRouter>;
}
/**
 * Create a set of type-safe provider-consumers
 *
 * @see https://trpc.io/docs/client/tanstack-react-query/setup#3a-setup-the-trpc-context-provider
 */
declare function createTRPCContext<TRouter extends AnyTRPCRouter, TFeatureFlags extends FeatureFlags = DefaultFeatureFlags>(): CreateTRPCContextResult<TRouter, TFeatureFlags>;
//#endregion
export { AnyTRPCMutationKey, AnyTRPCQueryKey, DecorateMutationProcedure, DecorateProcedure, DecorateQueryProcedure, DecorateRouterKeyable, DecorateSubscriptionProcedure, DefaultFeatureFlags, ExtractCursorType, FeatureFlags, KeyPrefixOptions, OptionalCursorInput, QueryType, ResolverDef, TRPCInfiniteData, TRPCInfiniteQueryOptions, TRPCMutationKey, TRPCMutationKeyWithPrefix, TRPCMutationKeyWithoutPrefix, TRPCMutationOptions, TRPCOptionsProxy, TRPCQueryBaseOptions, TRPCQueryKey, TRPCQueryKeyWithPrefix, TRPCQueryKeyWithoutPrefix, TRPCQueryOptions, TRPCQueryOptionsResult, TRPCReactRequestOptions, TRPCSubscriptionConnectingResult, TRPCSubscriptionErrorResult, TRPCSubscriptionIdleResult, TRPCSubscriptionOptions, TRPCSubscriptionPendingResult, TRPCSubscriptionResult, TRPCSubscriptionStatus, WithRequired, createTRPCContext, createTRPCOptionsProxy, inferInput, inferOutput, ofFeatureFlags, useSubscription };
//# sourceMappingURL=index.d.cts.map