"use strict";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(void 0);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isFunction2 = isFunction;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        if (Number.isNaN(self.getTime())) {
          return string("Invalid Date");
        }
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys3) => {
  let h = 12289;
  for (let i = 0; i < keys3.length; i++) {
    h ^= pipe(string(keys3[i]), combine(hash(o[keys3[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        const t1 = self.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_WITH_RUNTIME = "WithRuntime";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.19.14";
var getCurrentVersion = () => moduleVersion;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isLeft2 = isLeft;
var isRight2 = isRight;
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var getOrElse = /* @__PURE__ */ dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var number2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var reverse = (O) => make2((self, that) => O(that, self));
var combine2 = /* @__PURE__ */ dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var getOrElse2 = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse2(constUndefined);
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Record.js
var map3 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var keys = (self) => Object.keys(self);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Array.js
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var tailNonEmpty = (self) => self.slice(1);
var reverse2 = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var containsWith = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence = /* @__PURE__ */ equivalence();
var intersectionWith = (isEquivalent) => {
  const has3 = containsWith(isEquivalent);
  return dual(2, (self, that) => {
    const bs = fromIterable(that);
    return fromIterable(self).filter((a) => has3(bs, a));
  });
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence);
var empty = () => [];
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap(identity);
var filter = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      right3.push(as[i]);
    } else {
      left3.push(as[i]);
    }
  }
  return [left3, right3];
});
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Chunk.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet2(that, i))));
var _equivalence2 = /* @__PURE__ */ getEquivalence(equals);
var ChunkProto = {
  [TypeId3]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence2(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId3);
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty2 = () => _empty;
var make3 = (...as) => unsafeFromNonEmptyArray(as);
var of = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array3, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy(self.backing.array, 0, array3, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array3, initial);
      copyToArray(self.right, array3, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array3[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array3[j] = unsafeGet2(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty;
      self.right = _empty;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse2(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse3(self.backing.right),
        right: reverse3(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse2(toReadonlyArray(self)));
  }
};
var reverse3 = reverseChunk;
var unsafeFromArray = (self) => self.length === 0 ? empty2() : self.length === 1 ? of(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet2(self.left, index) : unsafeGet2(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var prepend = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of(elem), self));
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var unsafeHead = (self) => unsafeGet2(self, 0);
var headNonEmpty2 = unsafeHead;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/stack.js
var make4 = (value, previous) => ({
  value,
  previous
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate3, at, v, arr) {
  let out = arr;
  if (!mutate3) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate3, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate3) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate3) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate3, at, v, arr) {
  const len = arr.length;
  if (mutate3) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size4) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size4.value;
    return new LeafNode(edit, hash2, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size4) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size4.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size4.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size4);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size4.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate3, edit, hash2, list, f, key, size4) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value) return list;
        if (isNone2(newValue2)) {
          --size4.value;
          return arraySpliceOut(mutate3, i, list);
        }
        return arrayUpdate(mutate3, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size4.value;
    return arrayUpdate(mutate3, len, new LeafNode(edit, hash2, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size4);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size4);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size4, children) {
    this.edit = edit;
    this.size = size4;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash2, key, size4);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count, newChildren);
  }
};
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make4(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size4) => {
  const map9 = Object.create(HashMapProto);
  map9._editable = editable;
  map9._edit = edit;
  map9._root = root;
  map9._size = size4;
  return map9;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map9, f) {
    this.map = map9;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty2 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty3 = () => _empty2;
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
  let node = self._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length; i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
  const size4 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size4);
  return pipe(self, setTree(newRoot, size4.value));
});
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce2(self, void 0, (_, value, key) => f(value, key)));
var reduce2 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty3 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty3());
var empty4 = () => _empty3;
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation(transient);
});
var add = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate(empty4(), (set2) => {
  forEach2(self, (value) => add(set2, value));
  for (const value of that) {
    add(set2, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/HashSet.js
var empty5 = empty4;
var size3 = size2;
var add2 = add;
var union3 = union2;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ (function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
})();

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var fail = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var causeEquals = (left3, right3) => {
  let leftStack = of(left3);
  let rightStack = of(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce4([empty5(), empty2()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce4([empty5(), empty2()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of(cause), empty2());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty5(), empty2()], ([parallel3, sequential3], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [pipe(parallel3, union3(par)), pipe(sequential3, appendAll2(seq))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse3(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var evaluateCause = (self) => {
  let cause = self;
  const stack = [];
  let _parallel = empty5();
  let _sequential = empty2();
  while (cause !== void 0) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add2(_parallel, make3(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add2(_parallel, make3(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add2(_parallel, make3(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var reduce4 = /* @__PURE__ */ dual(3, (self, zero2, pf) => {
  let accumulator = zero2;
  let cause = self;
  const causes = [];
  while (cause !== void 0) {
    const option2 = pf(accumulator, cause);
    accumulator = isSome2(option2) ? option2.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = void 0;
        break;
      }
    }
    if (cause === void 0 && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left": {
        switch (either.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span) {
    let current = span;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match3 = false;
          for (const [, location] of locationMatchAll) {
            match3 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match3) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/core.js
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span) => {
  if (isSome2(span)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var RequestResolverImpl = class _RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var YieldableError = /* @__PURE__ */ (function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
})();
var makeException = (proto2, tag) => {
  class Base extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base.prototype, proto2);
  Base.prototype.name = tag;
  return Base;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var currentSpanFromFiber = (fiber) => {
  const span = fiber.currentSpan;
  return span !== void 0 && span._tag === "Span" ? some2(span) : none2();
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Data.js
var Class2 = Structural;
var Error2 = /* @__PURE__ */ (function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
})();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error2 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/encoding/common.js
var encoder = /* @__PURE__ */ new TextEncoder();

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Encoding.js
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Graph.js
var TypeId4 = "~effect/Graph";
var Edge = class extends Class2 {
};
var ProtoGraph = {
  [TypeId4]: TypeId4,
  [Symbol.iterator]() {
    return this.nodes[Symbol.iterator]();
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    if (isGraph(that)) {
      if (this.nodes.size !== that.nodes.size || this.edges.size !== that.edges.size || this.type !== that.type) {
        return false;
      }
      for (const [nodeIndex, nodeData] of this.nodes) {
        if (!that.nodes.has(nodeIndex)) {
          return false;
        }
        const otherNodeData = that.nodes.get(nodeIndex);
        if (!equals(nodeData, otherNodeData)) {
          return false;
        }
      }
      for (const [edgeIndex, edgeData] of this.edges) {
        if (!that.edges.has(edgeIndex)) {
          return false;
        }
        const otherEdge = that.edges.get(edgeIndex);
        if (!equals(edgeData, otherEdge)) {
          return false;
        }
      }
      return true;
    }
    return false;
  },
  [symbol]() {
    let hash2 = string("Graph");
    hash2 = hash2 ^ string(this.type);
    hash2 = hash2 ^ number(this.nodes.size);
    hash2 = hash2 ^ number(this.edges.size);
    for (const [nodeIndex, nodeData] of this.nodes) {
      hash2 = hash2 ^ hash(nodeIndex) + hash(nodeData);
    }
    for (const [edgeIndex, edgeData] of this.edges) {
      hash2 = hash2 ^ hash(edgeIndex) + hash(edgeData);
    }
    return hash2;
  },
  toJSON() {
    return {
      _id: "Graph",
      nodeCount: this.nodes.size,
      edgeCount: this.edges.size,
      type: this.type
    };
  },
  toString() {
    return format(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GraphError = class extends (/* @__PURE__ */ TaggedError("GraphError")) {
};
var missingNode = (node) => new GraphError({
  message: `Node ${node} does not exist`
});
var isGraph = (u) => typeof u === "object" && u !== null && TypeId4 in u;
var directed = (mutate3) => {
  const graph = Object.create(ProtoGraph);
  graph.type = "directed";
  graph.nodes = /* @__PURE__ */ new Map();
  graph.edges = /* @__PURE__ */ new Map();
  graph.adjacency = /* @__PURE__ */ new Map();
  graph.reverseAdjacency = /* @__PURE__ */ new Map();
  graph.nextNodeIndex = 0;
  graph.nextEdgeIndex = 0;
  graph.isAcyclic = some2(true);
  graph.mutable = false;
  if (mutate3) {
    const mutable = beginMutation3(graph);
    mutate3(mutable);
    return endMutation2(mutable);
  }
  return graph;
};
var beginMutation3 = (graph) => {
  const adjacency = /* @__PURE__ */ new Map();
  const reverseAdjacency = /* @__PURE__ */ new Map();
  for (const [nodeIndex, edges2] of graph.adjacency) {
    adjacency.set(nodeIndex, [...edges2]);
  }
  for (const [nodeIndex, edges2] of graph.reverseAdjacency) {
    reverseAdjacency.set(nodeIndex, [...edges2]);
  }
  const mutable = Object.create(ProtoGraph);
  mutable.type = graph.type;
  mutable.nodes = new Map(graph.nodes);
  mutable.edges = new Map(graph.edges);
  mutable.adjacency = adjacency;
  mutable.reverseAdjacency = reverseAdjacency;
  mutable.nextNodeIndex = graph.nextNodeIndex;
  mutable.nextEdgeIndex = graph.nextEdgeIndex;
  mutable.isAcyclic = graph.isAcyclic;
  mutable.mutable = true;
  return mutable;
};
var endMutation2 = (mutable) => {
  const graph = Object.create(ProtoGraph);
  graph.type = mutable.type;
  graph.nodes = new Map(mutable.nodes);
  graph.edges = new Map(mutable.edges);
  graph.adjacency = mutable.adjacency;
  graph.reverseAdjacency = mutable.reverseAdjacency;
  graph.nextNodeIndex = mutable.nextNodeIndex;
  graph.nextEdgeIndex = mutable.nextEdgeIndex;
  graph.isAcyclic = mutable.isAcyclic;
  graph.mutable = false;
  return graph;
};
var mutate2 = /* @__PURE__ */ dual(2, (graph, f) => {
  const mutable = beginMutation3(graph);
  f(mutable);
  return endMutation2(mutable);
});
var addNode = (mutable, data) => {
  const nodeIndex = mutable.nextNodeIndex;
  mutable.nodes.set(nodeIndex, data);
  mutable.adjacency.set(nodeIndex, []);
  mutable.reverseAdjacency.set(nodeIndex, []);
  mutable.nextNodeIndex = mutable.nextNodeIndex + 1;
  return nodeIndex;
};
var getNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex) ? some2(graph.nodes.get(nodeIndex)) : none2();
var hasNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex);
var nodeCount = (graph) => graph.nodes.size;
var reverse4 = (mutable) => {
  for (const [index, edgeData] of mutable.edges) {
    mutable.edges.set(index, {
      source: edgeData.target,
      target: edgeData.source,
      data: edgeData.data
    });
  }
  mutable.adjacency.clear();
  mutable.reverseAdjacency.clear();
  for (const [edgeIndex, edgeData] of mutable.edges) {
    const sourceEdges = mutable.adjacency.get(edgeData.source) || [];
    sourceEdges.push(edgeIndex);
    mutable.adjacency.set(edgeData.source, sourceEdges);
    const targetEdges = mutable.reverseAdjacency.get(edgeData.target) || [];
    targetEdges.push(edgeIndex);
    mutable.reverseAdjacency.set(edgeData.target, targetEdges);
  }
  mutable.isAcyclic = none2();
};
var invalidateCycleFlagOnRemoval = (mutable) => {
  if (isSome2(mutable.isAcyclic) && mutable.isAcyclic.value === false) {
    mutable.isAcyclic = none2();
  }
};
var invalidateCycleFlagOnAddition = (mutable) => {
  if (isSome2(mutable.isAcyclic) && mutable.isAcyclic.value === true) {
    mutable.isAcyclic = none2();
  }
};
var addEdge = (mutable, source, target, data) => {
  if (!mutable.nodes.has(source)) {
    throw missingNode(source);
  }
  if (!mutable.nodes.has(target)) {
    throw missingNode(target);
  }
  const edgeIndex = mutable.nextEdgeIndex;
  const edgeData = new Edge({
    source,
    target,
    data
  });
  mutable.edges.set(edgeIndex, edgeData);
  const sourceAdjacency = mutable.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    sourceAdjacency.push(edgeIndex);
  }
  const targetReverseAdjacency = mutable.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    targetReverseAdjacency.push(edgeIndex);
  }
  if (mutable.type === "undirected") {
    const targetAdjacency = mutable.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      targetAdjacency.push(edgeIndex);
    }
    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      sourceReverseAdjacency.push(edgeIndex);
    }
  }
  mutable.nextEdgeIndex = mutable.nextEdgeIndex + 1;
  invalidateCycleFlagOnAddition(mutable);
  return edgeIndex;
};
var removeNode = (mutable, nodeIndex) => {
  if (!mutable.nodes.has(nodeIndex)) {
    return;
  }
  const edgesToRemove = [];
  const outgoingEdges = mutable.adjacency.get(nodeIndex);
  if (outgoingEdges !== void 0) {
    for (const edge of outgoingEdges) {
      edgesToRemove.push(edge);
    }
  }
  const incomingEdges = mutable.reverseAdjacency.get(nodeIndex);
  if (incomingEdges !== void 0) {
    for (const edge of incomingEdges) {
      edgesToRemove.push(edge);
    }
  }
  for (const edgeIndex of edgesToRemove) {
    removeEdgeInternal(mutable, edgeIndex);
  }
  mutable.nodes.delete(nodeIndex);
  mutable.adjacency.delete(nodeIndex);
  mutable.reverseAdjacency.delete(nodeIndex);
  invalidateCycleFlagOnRemoval(mutable);
};
var removeEdgeInternal = (mutable, edgeIndex) => {
  const edge = mutable.edges.get(edgeIndex);
  if (edge === void 0) {
    return false;
  }
  const {
    source,
    target
  } = edge;
  const sourceAdjacency = mutable.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    const index = sourceAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      sourceAdjacency.splice(index, 1);
    }
  }
  const targetReverseAdjacency = mutable.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    const index = targetReverseAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      targetReverseAdjacency.splice(index, 1);
    }
  }
  if (mutable.type === "undirected") {
    const targetAdjacency = mutable.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      const index = targetAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        targetAdjacency.splice(index, 1);
      }
    }
    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      const index = sourceReverseAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        sourceReverseAdjacency.splice(index, 1);
      }
    }
  }
  mutable.edges.delete(edgeIndex);
  return true;
};
var hasEdge = (graph, source, target) => {
  const adjacencyList = graph.adjacency.get(source);
  if (adjacencyList === void 0) {
    return false;
  }
  for (const edgeIndex of adjacencyList) {
    const edge = graph.edges.get(edgeIndex);
    if (edge !== void 0 && edge.target === target) {
      return true;
    }
  }
  return false;
};
var neighborsDirected = (graph, nodeIndex, direction) => {
  const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
  const adjacencyList = adjacencyMap.get(nodeIndex);
  if (adjacencyList === void 0) {
    return [];
  }
  const result = [];
  for (const edgeIndex of adjacencyList) {
    const edge = graph.edges.get(edgeIndex);
    if (edge !== void 0) {
      const neighborNode = direction === "incoming" ? edge.source : edge.target;
      result.push(neighborNode);
    }
  }
  return result;
};
var escapeMermaidLabel = (label) => {
  return label.replace(/#/g, "#35;").replace(/"/g, "#quot;").replace(/</g, "#lt;").replace(/>/g, "#gt;").replace(/&/g, "#amp;").replace(/\[/g, "#91;").replace(/\]/g, "#93;").replace(/\{/g, "#123;").replace(/\}/g, "#125;").replace(/\(/g, "#40;").replace(/\)/g, "#41;").replace(/\|/g, "#124;").replace(/\\/g, "#92;").replace(/\n/g, "<br/>");
};
var formatMermaidNode = (nodeId, label, shape) => {
  switch (shape) {
    case "rectangle":
      return `${nodeId}["${label}"]`;
    case "rounded":
      return `${nodeId}("${label}")`;
    case "circle":
      return `${nodeId}(("${label}"))`;
    case "diamond":
      return `${nodeId}{"${label}"}`;
    case "hexagon":
      return `${nodeId}{{"${label}"}}`;
    case "stadium":
      return `${nodeId}(["${label}"])`;
    case "subroutine":
      return `${nodeId}[["${label}"]]`;
    case "cylindrical":
      return `${nodeId}[("${label}")]`;
  }
};
var toMermaid = (graph, options) => {
  const {
    diagramType,
    direction = "TD",
    edgeLabel = (data) => String(data),
    nodeLabel = (data) => String(data),
    nodeShape = () => "rectangle"
  } = options ?? {};
  const finalDiagramType = diagramType ?? (graph.type === "directed" ? "flowchart" : "graph");
  const lines = [];
  lines.push(`${finalDiagramType} ${direction}`);
  for (const [nodeIndex, nodeData] of graph.nodes) {
    const nodeId = String(nodeIndex);
    const label = escapeMermaidLabel(nodeLabel(nodeData));
    const shape = nodeShape(nodeData);
    const formattedNode = formatMermaidNode(nodeId, label, shape);
    lines.push(`  ${formattedNode}`);
  }
  const edgeOperator = finalDiagramType === "flowchart" ? "-->" : "---";
  for (const [, edgeData] of graph.edges) {
    const sourceId = String(edgeData.source);
    const targetId = String(edgeData.target);
    const label = escapeMermaidLabel(edgeLabel(edgeData.data));
    if (label) {
      lines.push(`  ${sourceId} ${edgeOperator}|"${label}"| ${targetId}`);
    } else {
      lines.push(`  ${sourceId} ${edgeOperator} ${targetId}`);
    }
  }
  return lines.join("\n");
};
var Walker = class {
  // @ts-ignore
  [Symbol.iterator];
  /**
   * Visits each element and maps it to a value using the provided function.
   *
   * Takes a function that receives the index and data,
   * and returns an iterable of the mapped values. Skips elements that
   * no longer exist in the graph.
   *
   * @example
   * ```ts
   * import { Graph } from "effect"
   *
   * const graph = Graph.directed<string, number>((mutable) => {
   *   const a = Graph.addNode(mutable, "A")
   *   const b = Graph.addNode(mutable, "B")
   *   Graph.addEdge(mutable, a, b, 1)
   * })
   *
   * const dfs = Graph.dfs(graph, { start: [0] })
   *
   * // Map to just the node data
   * const values = Array.from(dfs.visit((index, data) => data))
   * console.log(values) // ["A", "B"]
   *
   * // Map to custom objects
   * const custom = Array.from(dfs.visit((index, data) => ({ id: index, name: data })))
   * console.log(custom) // [{ id: 0, name: "A" }, { id: 1, name: "B" }]
   * ```
   *
   * @since 3.18.0
   * @category iterators
   */
  visit;
  constructor(visit) {
    this.visit = visit;
    this[Symbol.iterator] = visit((index, data) => [index, data])[Symbol.iterator];
  }
};
var indices = (walker) => walker.visit((index, _) => index);
var values2 = (walker) => walker.visit((_, data) => data);
var entries = (walker) => walker.visit((index, data) => [index, data]);
var nodes = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const nodeMap = graph.nodes;
    const iterator = nodeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [nodeIndex, nodeData] = result.value;
        return {
          done: false,
          value: f(nodeIndex, nodeData)
        };
      }
    };
  }
}));
var edges = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const edgeMap = graph.edges;
    const iterator = edgeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [edgeIndex, edgeData] = result.value;
        return {
          done: false,
          value: f(edgeIndex, edgeData)
        };
      }
    };
  }
}));
var externals = (graph, config = {}) => {
  const direction = config.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const nodeMap = graph.nodes;
      const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
      const nodeIterator = nodeMap.entries();
      const nextMapped = () => {
        let current = nodeIterator.next();
        while (!current.done) {
          const [nodeIndex, nodeData] = current.value;
          const adjacencyList = adjacencyMap.get(nodeIndex);
          if (adjacencyList === void 0 || adjacencyList.length === 0) {
            return {
              done: false,
              value: f(nodeIndex, nodeData)
            };
          }
          current = nodeIterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      };
      return {
        next: nextMapped
      };
    }
  }));
};

// src/core/Nano.ts
var NanoTag = class {
  constructor(key) {
    this.key = key;
  }
};
var Tag = (identifier) => new NanoTag(identifier);
var SingleShotGen3 = class _SingleShotGen {
  called = false;
  self;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var evaluate = /* @__PURE__ */ Symbol.for("Nano.evaluate");
var contA = /* @__PURE__ */ Symbol.for("Nano.contA");
var contE = /* @__PURE__ */ Symbol.for("Nano.contE");
var contAll = /* @__PURE__ */ Symbol.for("Nano.contAll");
var NanoYield = /* @__PURE__ */ Symbol.for("Nano.yield");
var args = /* @__PURE__ */ Symbol.for("Nano.args");
var NanoDefectException = class {
  constructor(message, lastSpan) {
    this.message = message;
    this.lastSpan = lastSpan;
  }
  _tag = "@effect/language-service/NanoDefectException";
};
var PrimitiveProto = {
  [Symbol.iterator]() {
    return new SingleShotGen3(this);
  }
};
var SucceedProto = {
  ...PrimitiveProto,
  _tag: "Success",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this);
  }
};
var succeed = (value) => {
  const nano = Object.create(SucceedProto);
  nano[args] = value;
  return nano;
};
var FailureProto = {
  ...PrimitiveProto,
  _tag: "Failure",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this);
  }
};
var fail3 = (error) => {
  const nano = Object.create(FailureProto);
  nano[args] = error;
  return nano;
};
var SuspendProto = {
  ...PrimitiveProto,
  [evaluate]() {
    return this[args]();
  }
};
var suspend = (fn2) => {
  const nano = Object.create(SuspendProto);
  nano[args] = fn2;
  return nano;
};
var NanoFiber = class {
  _stack = [];
  _yielded = void 0;
  _services = {};
  _cache = {};
  _perf = false;
  _lastSpan = "";
  runLoop(nano) {
    let current = nano;
    while (true) {
      current = current[evaluate](this);
      if (current === NanoYield) {
        return this._yielded;
      }
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[contAll] && op[contAll](this);
      if (cont) return { [symbol3]: cont };
      if (op[symbol3]) return op;
    }
  }
  yieldWith(value) {
    this._yielded = value;
    return NanoYield;
  }
};
var timings = {};
var timingsCount = {};
var WithSpanProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, name] = this[args];
    if (!fiber._perf) return fa;
    const previousSpan = fiber._lastSpan;
    fiber._lastSpan = name;
    const start = performance.now();
    timingsCount[name] = (timingsCount[name] || 0) + 1;
    return match2(fa, {
      onSuccess: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        fiber._lastSpan = previousSpan;
        return succeed(_);
      },
      onFailure: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        fiber._lastSpan = previousSpan;
        return fail3(_);
      }
    });
  }
};
var withSpan = (name) => (fa) => {
  const nano = Object.create(WithSpanProto);
  nano[args] = [fa, name];
  return nano;
};
var run = (nano) => {
  const fiber = new NanoFiber();
  try {
    const result = fiber.runLoop(nano);
    if (result._tag === "Success") {
      return right2(result.value);
    }
    return left2(result.value);
  } catch (e) {
    return left2(new NanoDefectException(e, fiber._lastSpan));
  }
};
var OnSuccessProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var flatMap4 = dual(2, (fa, f) => {
  const nano = Object.create(OnSuccessProto);
  nano[args] = fa;
  nano[contA] = f;
  return nano;
});
var map8 = dual(2, (fa, f) => flatMap4(fa, (_) => succeed(f(_))));
var SyncProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const value = this[args]();
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value));
  }
};
var sync = (f) => {
  const nano = Object.create(SyncProto);
  nano[args] = f;
  return nano;
};
var void_ = succeed(void 0);
var FromIteratorProto = {
  ...PrimitiveProto,
  [contA](value, fiber) {
    const state = this[args][0].next(value);
    if (state.done) return succeed(state.value);
    fiber._stack.push(this);
    return state.value;
  },
  [evaluate](fiber) {
    return this[contA](this[args][1], fiber);
  }
};
var unsafeFromIterator = (iterator, initial) => {
  const nano = Object.create(FromIteratorProto);
  nano[args] = [iterator, initial];
  return nano;
};
var gen = (...args2) => suspend(() => unsafeFromIterator(args2[0]()));
var fn = (_) => (body) => (...args2) => withSpan(_)(suspend(() => unsafeFromIterator(body(...args2))));
var MatchProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var match2 = (fa, opts) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = opts.onSuccess;
  nano[contE] = opts.onFailure;
  return nano;
};
var orElse2 = (f) => (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail3(_) : f(_);
  return nano;
};
var firstSuccessOf = (arr) => arr.slice(1).reduce((arr2, fa) => orElse2(() => fa)(arr2), arr[0]);
var ProvideServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const prevServices = fiber._services;
    const [fa, tag, value] = this[args];
    fiber._services = {
      ...fiber._services,
      [tag.key]: value
    };
    return match2(fa, {
      onSuccess: (_) => {
        fiber._services = prevServices;
        return succeed(_);
      },
      onFailure: (_) => {
        fiber._services = prevServices;
        return fail3(_);
      }
    });
  }
};
var provideService = (tag, value) => (fa) => {
  const nano = Object.create(ProvideServiceProto);
  nano[args] = [fa, tag, value];
  return nano;
};
var ServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const tag = this[args];
    if (tag.key in fiber._services) {
      const value = fiber._services[tag.key];
      const cont2 = fiber.getCont(contA);
      return cont2 ? cont2[contA](value, fiber) : fiber.yieldWith(succeed(value));
    }
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](tag, fiber) : fiber.yieldWith(fail3(new NanoDefectException(`Service ${tag.key} not found`, fiber._lastSpan)));
  }
};
var service = (tag) => {
  const nano = Object.create(ServiceProto);
  nano[args] = tag;
  return nano;
};
var CachedProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, type, key] = this[args];
    const cache = fiber._cache[type] || /* @__PURE__ */ new WeakMap();
    fiber._cache[type] = cache;
    const cached2 = cache.get(key);
    if (cached2) return cached2;
    return match2(fa, {
      onSuccess: (_) => {
        cache.set(key, succeed(_));
        return succeed(_);
      },
      onFailure: (_) => {
        cache.set(key, fail3(_));
        return fail3(_);
      }
    });
  }
};
function cachedBy(fa, type, lookupKey) {
  return (...p) => {
    const nano = Object.create(CachedProto);
    nano[args] = [fa(...p), type, lookupKey(...p)];
    return nano;
  };
}
var option = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => succeed(some2(_));
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail3(_) : succeed(none2());
  return nano;
};
var ignore = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => void_;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail3(_) : void_;
  return nano;
};
var all = fn("all")(
  function* (...args2) {
    const results = [];
    for (const fa of args2) {
      const result = yield* fa;
      results.push(result);
    }
    return results;
  }
);

// src/core/LanguageServicePluginOptions.ts
var LanguageServicePluginOptions = Tag("PluginOptions");
function isValidSeverityLevel(value) {
  return value === "off" || value === "error" || value === "warning" || value === "message" || value === "suggestion";
}
function parseDiagnosticSeverity(config) {
  if (!isRecord(config)) return {};
  return Object.fromEntries(
    pipe(
      Object.entries(config),
      filter(([key, value]) => isString(key) && isString(value)),
      map4(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),
      filter(([_, value]) => isValidSeverityLevel(value))
    )
  );
}
var defaults = {
  refactors: true,
  diagnostics: true,
  diagnosticSeverity: {},
  diagnosticsName: true,
  missingDiagnosticNextLine: "warning",
  includeSuggestionsInTsc: true,
  quickinfo: true,
  quickinfoEffectParameters: "whentruncated",
  quickinfoMaximumLength: -1,
  completions: true,
  goto: true,
  inlays: true,
  allowedDuplicatedPackages: [],
  namespaceImportPackages: [],
  topLevelNamedReexports: "ignore",
  barrelImportPackages: [],
  importAliases: {},
  renames: true,
  noExternal: false,
  keyPatterns: [{
    target: "service",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }, {
    target: "custom",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }],
  extendedKeyDetection: false,
  ignoreEffectWarningsInTscExitCode: false,
  ignoreEffectSuggestionsInTscExitCode: true,
  pipeableMinArgCount: 2,
  effectFn: ["span"],
  layerGraphFollowDepth: 0,
  mermaidProvider: "mermaid.live"
};
function parseKeyPatterns(patterns) {
  const result = [];
  for (const entry of patterns) {
    if (!isObject(entry)) continue;
    result.push({
      target: hasProperty(entry, "target") && isString(entry.target) && ["service", "error", "custom"].includes(entry.target.toLowerCase()) ? entry.target.toLowerCase() : "service",
      pattern: hasProperty(entry, "pattern") && isString(entry.pattern) && ["package-identifier", "default", "default-hashed"].includes(entry.pattern.toLowerCase()) ? entry.pattern.toLowerCase() : "default",
      skipLeadingPath: hasProperty(entry, "skipLeadingPath") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString) ? entry.skipLeadingPath : ["src/"]
    });
  }
  return result;
}
function parse(config) {
  return {
    refactors: isObject(config) && hasProperty(config, "refactors") && isBoolean(config.refactors) ? config.refactors : defaults.refactors,
    diagnostics: isObject(config) && hasProperty(config, "diagnostics") && isBoolean(config.diagnostics) ? config.diagnostics : defaults.diagnostics,
    diagnosticSeverity: isObject(config) && hasProperty(config, "diagnosticSeverity") && isRecord(config.diagnosticSeverity) ? parseDiagnosticSeverity(config.diagnosticSeverity) : defaults.diagnosticSeverity,
    diagnosticsName: isObject(config) && hasProperty(config, "diagnosticsName") && isBoolean(config.diagnosticsName) ? config.diagnosticsName : defaults.diagnosticsName,
    missingDiagnosticNextLine: isObject(config) && hasProperty(config, "missingDiagnosticNextLine") && isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine) ? config.missingDiagnosticNextLine : defaults.missingDiagnosticNextLine,
    includeSuggestionsInTsc: isObject(config) && hasProperty(config, "includeSuggestionsInTsc") && isBoolean(config.includeSuggestionsInTsc) ? config.includeSuggestionsInTsc : defaults.includeSuggestionsInTsc,
    ignoreEffectWarningsInTscExitCode: isObject(config) && hasProperty(config, "ignoreEffectWarningsInTscExitCode") && isBoolean(config.ignoreEffectWarningsInTscExitCode) ? config.ignoreEffectWarningsInTscExitCode : defaults.ignoreEffectWarningsInTscExitCode,
    ignoreEffectSuggestionsInTscExitCode: isObject(config) && hasProperty(config, "ignoreEffectSuggestionsInTscExitCode") && isBoolean(config.ignoreEffectSuggestionsInTscExitCode) ? config.ignoreEffectSuggestionsInTscExitCode : defaults.ignoreEffectSuggestionsInTscExitCode,
    quickinfo: isObject(config) && hasProperty(config, "quickinfo") && isBoolean(config.quickinfo) ? config.quickinfo : defaults.quickinfo,
    quickinfoEffectParameters: isObject(config) && hasProperty(config, "quickinfoEffectParameters") && isString(config.quickinfoEffectParameters) && ["always", "never", "whentruncated"].includes(config.quickinfoEffectParameters.toLowerCase()) ? config.quickinfoEffectParameters.toLowerCase() : defaults.quickinfoEffectParameters,
    quickinfoMaximumLength: isObject(config) && hasProperty(config, "quickinfoMaximumLength") && isNumber(config.quickinfoMaximumLength) ? config.quickinfoMaximumLength : defaults.quickinfoMaximumLength,
    completions: isObject(config) && hasProperty(config, "completions") && isBoolean(config.completions) ? config.completions : defaults.completions,
    goto: isObject(config) && hasProperty(config, "goto") && isBoolean(config.goto) ? config.goto : defaults.goto,
    inlays: isObject(config) && hasProperty(config, "inlays") && isBoolean(config.inlays) ? config.inlays : defaults.inlays,
    allowedDuplicatedPackages: isObject(config) && hasProperty(config, "allowedDuplicatedPackages") && isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString) ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase()) : defaults.allowedDuplicatedPackages,
    namespaceImportPackages: isObject(config) && hasProperty(config, "namespaceImportPackages") && isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString) ? config.namespaceImportPackages.map((_) => _.toLowerCase()) : defaults.namespaceImportPackages,
    barrelImportPackages: isObject(config) && hasProperty(config, "barrelImportPackages") && isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString) ? config.barrelImportPackages.map((_) => _.toLowerCase()) : defaults.barrelImportPackages,
    importAliases: isObject(config) && hasProperty(config, "importAliases") && isRecord(config.importAliases) ? map3(config.importAliases, (value) => String(value)) : defaults.importAliases,
    topLevelNamedReexports: isObject(config) && hasProperty(config, "topLevelNamedReexports") && isString(config.topLevelNamedReexports) && ["ignore", "follow"].includes(config.topLevelNamedReexports.toLowerCase()) ? config.topLevelNamedReexports.toLowerCase() : defaults.topLevelNamedReexports,
    renames: isObject(config) && hasProperty(config, "renames") && isBoolean(config.renames) ? config.renames : defaults.renames,
    noExternal: isObject(config) && hasProperty(config, "noExternal") && isBoolean(config.noExternal) ? config.noExternal : defaults.noExternal,
    keyPatterns: isObject(config) && hasProperty(config, "keyPatterns") && isArray(config.keyPatterns) ? parseKeyPatterns(config.keyPatterns) : defaults.keyPatterns,
    extendedKeyDetection: isObject(config) && hasProperty(config, "extendedKeyDetection") && isBoolean(config.extendedKeyDetection) ? config.extendedKeyDetection : defaults.extendedKeyDetection,
    pipeableMinArgCount: isObject(config) && hasProperty(config, "pipeableMinArgCount") && isNumber(config.pipeableMinArgCount) ? config.pipeableMinArgCount : defaults.pipeableMinArgCount,
    effectFn: isObject(config) && hasProperty(config, "effectFn") && isArray(config.effectFn) && config.effectFn.every(isString) ? config.effectFn.map((_) => _.toLowerCase()) : defaults.effectFn,
    layerGraphFollowDepth: isObject(config) && hasProperty(config, "layerGraphFollowDepth") && isNumber(config.layerGraphFollowDepth) ? config.layerGraphFollowDepth : defaults.layerGraphFollowDepth,
    mermaidProvider: isObject(config) && hasProperty(config, "mermaidProvider") && isString(config.mermaidProvider) ? config.mermaidProvider : defaults.mermaidProvider
  };
}

// src/core/TypeScriptApi.ts
var TypeScriptApi = Tag("TypeScriptApi");
var TypeScriptProgram = Tag("TypeScriptProgram");
var ChangeTracker = Tag("ChangeTracker");
function getPackageJsonInfoCache(program) {
  try {
    if (hasProperty(program, "getModuleResolutionCache") && isFunction2(program.getModuleResolutionCache)) {
      const moduleResolutionCache = program.getModuleResolutionCache();
      if (hasProperty(moduleResolutionCache, "getPackageJsonInfoCache") && isFunction2(moduleResolutionCache.getPackageJsonInfoCache)) {
        return moduleResolutionCache.getPackageJsonInfoCache();
      }
    }
  } catch (_) {
    return void 0;
  }
  return void 0;
}
function getDirectoryPath(ts, path) {
  try {
    if (hasProperty(ts, "getDirectoryPath") && isFunction2(ts.getDirectoryPath)) {
      return ts.getDirectoryPath(path);
    }
    return path;
  } catch (_) {
    return path;
  }
}
function makeGetModuleSpecifier(ts) {
  if (!(hasProperty(ts, "moduleSpecifiers") && hasProperty(ts.moduleSpecifiers, "getModuleSpecifier") && isFunction2(ts.moduleSpecifiers.getModuleSpecifier))) return;
  const _internal = ts.moduleSpecifiers.getModuleSpecifier;
  return (compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) => {
    return _internal(
      compilerOptions,
      importingSourceFile,
      importingSourceFileName,
      toFileName,
      host,
      options
    );
  };
}
function makeGetTemporaryModuleResolutionState(ts) {
  if (hasProperty(ts, "getTemporaryModuleResolutionState") && isFunction2(ts.getTemporaryModuleResolutionState)) {
    const _internal = ts.getTemporaryModuleResolutionState;
    return (cache, program, compilerOptions) => _internal(cache, program, compilerOptions);
  }
  return void 0;
}
function makeGetPackageScopeForPath(ts) {
  if (hasProperty(ts, "getPackageScopeForPath") && isFunction2(ts.getPackageScopeForPath)) {
    const _internal = ts.getPackageScopeForPath;
    return (path, state) => _internal(path, state);
  }
}
function makeResolvePackageNameToPackageJson(ts) {
  if (hasProperty(ts, "resolvePackageNameToPackageJson") && isFunction2(ts.resolvePackageNameToPackageJson)) {
    const _internal = ts.resolvePackageNameToPackageJson;
    return (packageName, fromFileName, compilerOptions, host) => _internal(packageName, fromFileName, compilerOptions, host);
  }
}
function makeGetEntrypointsFromPackageJsonInfo(ts) {
  if (hasProperty(ts, "getEntrypointsFromPackageJsonInfo") && isFunction2(ts.getEntrypointsFromPackageJsonInfo)) {
    const _internal = ts.getEntrypointsFromPackageJsonInfo;
    return (packageJsonInfo, compilerOptions, host) => _internal(packageJsonInfo, compilerOptions, host);
  }
}

// src/core/TypeScriptUtils.ts
var TypeScriptUtils = Tag("TypeScriptUtils");
var nanoLayer = (fa) => pipe(
  service(TypeScriptApi),
  flatMap4((ts) => pipe(fa, provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))
);
function makeTypeScriptUtils(ts) {
  const getTemporaryModuleResolutionState = makeGetTemporaryModuleResolutionState(ts);
  const getPackageScopeForPath = makeGetPackageScopeForPath(ts);
  function parsePackageContentNameAndVersionFromScope(v) {
    if (!isObject(v)) return;
    if (!hasProperty(v, "packageJsonScope")) return;
    if (!v.packageJsonScope) return;
    const packageJsonScope = v.packageJsonScope;
    if (!hasProperty(packageJsonScope, "contents")) return;
    if (!hasProperty(packageJsonScope.contents, "packageJsonContent")) return;
    const packageJsonContent = packageJsonScope.contents.packageJsonContent;
    if (!hasProperty(packageJsonContent, "name")) return;
    if (!hasProperty(packageJsonScope, "packageDirectory")) return;
    if (!isString(packageJsonScope.packageDirectory)) return;
    const { name } = packageJsonContent;
    const version = hasProperty(packageJsonScope, "version") ? packageJsonScope.version : "";
    if (!isString(name)) return;
    if (!isString(version)) return;
    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) && hasProperty(packageJsonContent.peerDependencies, "effect");
    const referencedPackages = Object.keys({
      ...hasProperty(packageJsonContent, "dependencies") && isObject(packageJsonContent.dependencies) ? packageJsonContent.dependencies : {},
      ...hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) ? packageJsonContent.peerDependencies : {},
      ...hasProperty(packageJsonContent, "devDependencies") && isObject(packageJsonContent.devDependencies) ? packageJsonContent.devDependencies : {}
    });
    const exportsKeys = Object.keys(
      hasProperty(packageJsonContent, "exports") && isObject(packageJsonContent.exports) ? packageJsonContent.exports : {}
    );
    return {
      name: name.toLowerCase(),
      version: version.toLowerCase(),
      hasEffectInPeerDependencies,
      contents: packageJsonContent,
      packageDirectory: packageJsonScope.packageDirectory,
      referencedPackages,
      exportsKeys
    };
  }
  function resolveModuleWithPackageInfoFromSourceFile(program, sourceFile) {
    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile);
    if (!packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState) {
      const packageJsonInfoCache = getPackageJsonInfoCache(program);
      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(
        packageJsonInfoCache,
        program,
        program.getCompilerOptions()
      );
      const directoryPath = getDirectoryPath(ts, sourceFile.fileName);
      packageJsonScope = parsePackageContentNameAndVersionFromScope({
        ...sourceFile,
        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)
      });
    }
    return packageJsonScope;
  }
  function resolveModulePattern(program, sourceFile, pattern) {
    if (pattern.indexOf("*") === -1) return [pattern.toLowerCase()];
    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    const referencedPackages = [];
    for (const statement of sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {
        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase();
        const packageName = moduleSpecifier.startsWith("@") ? moduleSpecifier.split("/", 2).join("/") : moduleSpecifier.split("/", 1).join("/");
        referencedPackages.push(packageName);
      }
    }
    return pipe(
      referencedPackages.concat(packageJsonScope?.referencedPackages || []),
      dedupe,
      map4((packageName) => packageName.toLowerCase()),
      filter(
        (packageName) => pattern.endsWith("*") && packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))
      )
    );
  }
  function findNodeWithLeadingCommentAtPosition(sourceFile, position) {
    const sourceText = sourceFile.text;
    let result;
    function find(node) {
      const leading = ts.getLeadingCommentRanges(sourceText, node.pos);
      if (leading) {
        for (const commentRange of leading) {
          if (commentRange.pos <= position && position < commentRange.end) {
            result = { node, commentRange };
            return;
          }
        }
      }
      if (node.pos <= position && position < node.end) {
        ts.forEachChild(node, find);
      }
    }
    find(sourceFile);
    return result;
  }
  function collectSelfAndAncestorNodesInRange(node, textRange) {
    let result = empty();
    let parent = node;
    while (parent) {
      if (parent.end >= textRange.end) {
        result = pipe(result, append(parent));
      }
      parent = parent.parent;
    }
    return result;
  }
  function findNodeAtPosition(sourceFile, position) {
    function find(node) {
      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function findNodeAtPositionIncludingTrivia(sourceFile, position) {
    function find(node) {
      if (position >= node.pos && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function getAncestorNodesInRange(sourceFile, textRange) {
    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos);
    if (!nodeAtPosition) return empty();
    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange);
  }
  function getCommentAtPosition(sourceFile, pos) {
    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos);
    if (token === void 0 || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || "").length) {
      return;
    }
    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || "").length : token.pos;
    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos);
    return result;
  }
  function isCommentInRange(pos, end, kind, _nl, at) {
    return at >= pos && at < end ? { pos, end, kind } : void 0;
  }
  function toTextRange(positionOrRange) {
    return typeof positionOrRange === "number" ? { end: positionOrRange, pos: positionOrRange } : positionOrRange;
  }
  function isNodeInRange(textRange) {
    return (node) => node.pos <= textRange.pos && node.end >= textRange.end;
  }
  function transformAsyncAwaitToEffectGeneratorBody(body, onAwait) {
    function visitor(_) {
      if (ts.isAwaitExpression(_)) {
        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext);
        return ts.factory.createYieldExpression(
          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
          onAwait(expression)
        );
      }
      return ts.visitEachChild(_, visitor, ts.nullTransformationContext);
    }
    return visitor(body);
  }
  function transformAsyncAwaitToEffectFn(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const fnName = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node ? node.parent.name : void 0;
    let fnCall = ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectModuleName),
      "fn"
    );
    if (fnName) {
      fnCall = ts.factory.createCallExpression(
        fnCall,
        void 0,
        [ts.factory.createStringLiteral(ts.idText(fnName))]
      );
    }
    return tryPreserveDeclarationSemantics(
      node,
      ts.factory.createCallExpression(
        fnCall,
        void 0,
        [
          ts.factory.createFunctionExpression(
            void 0,
            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
            void 0,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.isBlock(generatorBody) ? generatorBody : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])
          )
        ]
      ),
      true
    );
  }
  function transformAsyncAwaitToEffectGen(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody);
    let currentFlags = ts.getCombinedModifierFlags(node);
    currentFlags &= ~ts.ModifierFlags.Async;
    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags);
    if (ts.isArrowFunction(node)) {
      return ts.factory.createArrowFunction(
        newModifiers,
        node.typeParameters,
        node.parameters,
        void 0,
        node.equalsGreaterThanToken,
        effectGenCallExp
      );
    }
    const newBody = ts.factory.createBlock([
      ts.factory.createReturnStatement(effectGenCallExp)
    ]);
    if (ts.isFunctionDeclaration(node)) {
      return ts.factory.createFunctionDeclaration(
        newModifiers,
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        void 0,
        newBody
      );
    }
    return ts.factory.createFunctionExpression(
      newModifiers,
      node.asteriskToken,
      node.name,
      node.typeParameters,
      node.parameters,
      void 0,
      newBody
    );
  }
  function findImportedModuleIdentifier(sourceFile, test) {
    for (const statement of sourceFile.statements) {
      if (!ts.isImportDeclaration(statement)) continue;
      const importClause = statement.importClause;
      if (!importClause) continue;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) continue;
      if (ts.isNamespaceImport(namedBindings)) {
        if (test(namedBindings.name, statement.moduleSpecifier, none2())) {
          return ts.idText(namedBindings.name);
        }
      } else if (ts.isNamedImports(namedBindings)) {
        for (const importSpecifier of namedBindings.elements) {
          const importProperty = fromNullable(importSpecifier.propertyName).pipe(
            orElse(() => some2(importSpecifier.name))
          );
          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {
            return ts.idText(importSpecifier.name);
          }
        }
      }
    }
  }
  function findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, packageName, moduleName) {
    return findImportedModuleIdentifier(
      sourceFile,
      (_, fromModule, importProperty) => {
        if (isNone2(importProperty) && ts.isStringLiteral(fromModule) && fromModule.text === packageName + "/" + moduleName) {
          return true;
        }
        if (isSome2(importProperty) && ts.isIdentifier(importProperty.value) && ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) && fromModule.text === packageName) {
          return true;
        }
        return false;
      }
    );
  }
  function simplifyTypeNode(typeNode) {
    function collectCallable(typeNode2) {
      if (ts.isParenthesizedTypeNode(typeNode2)) return collectCallable(typeNode2.type);
      if (ts.isFunctionTypeNode(typeNode2)) {
        return some2([
          ts.factory.createCallSignature(typeNode2.typeParameters, typeNode2.parameters, typeNode2.type)
        ]);
      }
      if (ts.isTypeLiteralNode(typeNode2)) {
        const allCallSignatures = typeNode2.members.every(ts.isCallSignatureDeclaration);
        if (allCallSignatures) {
          return some2(typeNode2.members);
        }
      }
      if (ts.isIntersectionTypeNode(typeNode2)) {
        const members = typeNode2.types.map((node) => collectCallable(node));
        if (members.every(isSome2)) {
          return some2(members.map((_) => isSome2(_) ? _.value : []).flat());
        }
      }
      return none2();
    }
    const callSignatures = collectCallable(typeNode);
    if (isSome2(callSignatures) && callSignatures.value.length > 1) {
      return ts.factory.createTypeLiteralNode(callSignatures.value);
    }
    return typeNode;
  }
  function tryPreserveDeclarationSemantics(nodeToReplace, node, dropAsync) {
    if (!ts.isExpression(node)) return node;
    if (ts.isFunctionDeclaration(nodeToReplace)) {
      if (!nodeToReplace.name) return node;
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createVariableStatement(
        newModifiers,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            nodeToReplace.name,
            void 0,
            void 0,
            node
          )],
          ts.NodeFlags.Const
        )
      );
    } else if (ts.isMethodDeclaration(nodeToReplace)) {
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createPropertyDeclaration(
        newModifiers,
        nodeToReplace.name,
        void 0,
        void 0,
        node
      );
    }
    return node;
  }
  function parseAccessedExpressionForCompletion(sourceFile, position) {
    const precedingToken = ts.findPrecedingToken(position, sourceFile, void 0, true);
    if (!precedingToken) return;
    let accessedObject = precedingToken;
    let replacementSpan = ts.createTextSpan(position, 0);
    let outerNode = precedingToken;
    if (ts.isIdentifier(precedingToken) && precedingToken.parent && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        spanStart,
        precedingToken.end - spanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken;
      outerNode = precedingToken;
    } else {
      return;
    }
    const importDeclaration = ts.findAncestor(accessedObject, ts.isImportDeclaration);
    if (importDeclaration) return;
    return { accessedObject, outerNode, replacementSpan, insideImportDeclaration: !!importDeclaration };
  }
  function parseDataForExtendsClassCompletion(sourceFile, position) {
    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return;
    const { accessedObject, outerNode, replacementSpan } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return;
    let classDeclaration = outerNode.parent;
    while (ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)) {
      if (!classDeclaration.parent) break;
      classDeclaration = classDeclaration.parent;
    }
    if (!ts.isClassDeclaration(classDeclaration)) return;
    if (!classDeclaration.name) return;
    return {
      accessedObject,
      classDeclaration,
      className: classDeclaration.name,
      replacementSpan
    };
  }
  function createEffectGenCallExpression(effectModuleIdentifierName, node) {
    const generator = ts.factory.createFunctionExpression(
      void 0,
      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
      void 0,
      [],
      [],
      void 0,
      node
      // NOTE(mattia): intended, to use same routine for both ConciseBody and Body
    );
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifierName),
        "gen"
      ),
      void 0,
      [generator]
    );
  }
  function createEffectGenCallExpressionWithBlock(effectModuleIdentifierName, statement) {
    return createEffectGenCallExpression(
      effectModuleIdentifierName,
      ts.factory.createBlock(isArray(statement) ? statement : [statement], false)
    );
  }
  function createReturnYieldStarStatement(expr) {
    return ts.factory.createReturnStatement(
      ts.factory.createYieldExpression(
        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
        expr
      )
    );
  }
  function createDataTaggedErrorDeclaration(dataModuleIdentifier, name, fields) {
    const invokeTaggedError = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(dataModuleIdentifier),
        "TaggedError"
      ),
      void 0,
      [
        ts.factory.createStringLiteral(name)
      ]
    );
    const withTypeFields = ts.factory.createExpressionWithTypeArguments(
      invokeTaggedError,
      [
        ts.factory.createTypeLiteralNode(fields)
      ]
    );
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      void 0,
      [
        ts.factory.createHeritageClause(
          ts.SyntaxKind.ExtendsKeyword,
          [
            withTypeFields
          ]
        )
      ],
      []
    );
  }
  function getSourceFileOfNode(current) {
    let node = current;
    while (node && node.kind !== ts.SyntaxKind.SourceFile) {
      node = node.parent;
    }
    return node;
  }
  function isOuterExpression(node, kinds = ts.OuterExpressionKinds.All) {
    switch (node.kind) {
      case ts.SyntaxKind.ParenthesizedExpression:
        return (kinds & ts.OuterExpressionKinds.Parentheses) !== 0;
      case ts.SyntaxKind.TypeAssertionExpression:
      case ts.SyntaxKind.AsExpression:
        return (kinds & ts.OuterExpressionKinds.TypeAssertions) !== 0;
      case ts.SyntaxKind.SatisfiesExpression:
        return (kinds & (ts.OuterExpressionKinds.TypeAssertions | ts.OuterExpressionKinds.Satisfies)) !== 0;
      case ts.SyntaxKind.ExpressionWithTypeArguments:
        return (kinds & ts.OuterExpressionKinds.ExpressionsWithTypeArguments) !== 0;
      case ts.SyntaxKind.NonNullExpression:
        return (kinds & ts.OuterExpressionKinds.NonNullAssertions) !== 0;
      case ts.SyntaxKind.PartiallyEmittedExpression:
        return (kinds & ts.OuterExpressionKinds.PartiallyEmittedExpressions) !== 0;
    }
    return false;
  }
  function skipOuterExpressions(node, kinds = ts.OuterExpressionKinds.All) {
    while (isOuterExpression(node, kinds)) {
      node = node.expression;
    }
    return node;
  }
  function isDeclarationKind(kind) {
    return kind === ts.SyntaxKind.ArrowFunction || kind === ts.SyntaxKind.BindingElement || kind === ts.SyntaxKind.ClassDeclaration || kind === ts.SyntaxKind.ClassExpression || kind === ts.SyntaxKind.ClassStaticBlockDeclaration || kind === ts.SyntaxKind.Constructor || kind === ts.SyntaxKind.EnumDeclaration || kind === ts.SyntaxKind.EnumMember || kind === ts.SyntaxKind.ExportSpecifier || kind === ts.SyntaxKind.FunctionDeclaration || kind === ts.SyntaxKind.FunctionExpression || kind === ts.SyntaxKind.GetAccessor || kind === ts.SyntaxKind.ImportClause || kind === ts.SyntaxKind.ImportEqualsDeclaration || kind === ts.SyntaxKind.ImportSpecifier || kind === ts.SyntaxKind.InterfaceDeclaration || kind === ts.SyntaxKind.JsxAttribute || kind === ts.SyntaxKind.MethodDeclaration || kind === ts.SyntaxKind.MethodSignature || kind === ts.SyntaxKind.ModuleDeclaration || kind === ts.SyntaxKind.NamespaceExportDeclaration || kind === ts.SyntaxKind.NamespaceImport || kind === ts.SyntaxKind.NamespaceExport || kind === ts.SyntaxKind.Parameter || kind === ts.SyntaxKind.PropertyAssignment || kind === ts.SyntaxKind.PropertyDeclaration || kind === ts.SyntaxKind.PropertySignature || kind === ts.SyntaxKind.SetAccessor || kind === ts.SyntaxKind.ShorthandPropertyAssignment || kind === ts.SyntaxKind.TypeAliasDeclaration || kind === ts.SyntaxKind.TypeParameter || kind === ts.SyntaxKind.VariableDeclaration || kind === ts.SyntaxKind.JSDocTypedefTag || kind === ts.SyntaxKind.JSDocCallbackTag || kind === ts.SyntaxKind.JSDocPropertyTag || kind === ts.SyntaxKind.NamedTupleMember;
  }
  function isVoidExpression(node) {
    const unwrapped = ts.isExpression(node) ? skipOuterExpressions(node) : node;
    if (ts.isVoidExpression(unwrapped) && ts.isNumericLiteral(unwrapped.expression) && unwrapped.expression.text === "0") {
      return true;
    }
    if (ts.isIdentifier(unwrapped) && ts.idText(unwrapped) === "undefined") {
      return true;
    }
    return false;
  }
  return {
    findNodeAtPositionIncludingTrivia,
    parsePackageContentNameAndVersionFromScope,
    resolveModulePattern,
    resolveModuleWithPackageInfoFromSourceFile,
    findNodeWithLeadingCommentAtPosition,
    getCommentAtPosition,
    getAncestorNodesInRange,
    toTextRange,
    isNodeInRange,
    transformAsyncAwaitToEffectFn,
    transformAsyncAwaitToEffectGen,
    createDataTaggedErrorDeclaration,
    findImportedModuleIdentifierByPackageAndNameOrBarrel,
    simplifyTypeNode,
    tryPreserveDeclarationSemantics,
    parseDataForExtendsClassCompletion,
    createEffectGenCallExpressionWithBlock,
    createReturnYieldStarStatement,
    parseAccessedExpressionForCompletion,
    getSourceFileOfNode,
    isOuterExpression,
    skipOuterExpressions,
    isDeclarationKind,
    isVoidExpression
  };
}

// src/core/LSP.ts
var RefactorNotApplicableError = class {
  _tag = "@effect/language-service/RefactorNotApplicableError";
};
function createRefactor(definition) {
  return definition;
}
function createDiagnostic(definition) {
  return definition;
}
function concatDiagnostics(fa, fb) {
  const result = fa.slice(0);
  for (const b of fb) {
    const existing = result.find(
      (a) => a.file === b.file && a.code === b.code && a.source === b.source && a.start === b.start && a.length === b.length && a.messageText === b.messageText
    );
    if (!existing) {
      result.push(b);
    }
  }
  return result;
}
function createCompletion(definition) {
  return definition;
}
var getSemanticDiagnosticsWithCodeFixes = fn(
  "LSP.getSemanticDiagnosticsWithCodeFixes"
)(function* (rules, sourceFile) {
  let effectDiagnostics = [];
  let effectCodeFixes = [];
  const executor = yield* createDiagnosticExecutor(sourceFile);
  for (const rule of rules) {
    const { codeFixes, diagnostics: diagnostics2 } = yield* executor.execute(rule);
    effectDiagnostics = effectDiagnostics.concat(diagnostics2);
    effectCodeFixes = effectCodeFixes.concat(codeFixes);
  }
  return {
    diagnostics: effectDiagnostics,
    codeFixes: effectCodeFixes
  };
});
function refactorNameToFullyQualifiedName(name) {
  return `@effect/language-service/refactors/${name}`;
}
var getApplicableRefactors = fn("LSP.getApplicableRefactors")(function* (refactors2, sourceFile, positionOrRange) {
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  const effectRefactors = [];
  for (const refactor of refactors2) {
    yield* pipe(
      refactor.apply(sourceFile, textRange),
      map8(
        (result) => effectRefactors.push({
          name: refactorNameToFullyQualifiedName(refactor.name),
          description: refactor.description,
          actions: [{
            name: refactorNameToFullyQualifiedName(refactor.name),
            description: result.description,
            kind: result.kind
          }]
        })
      ),
      ignore
    );
  }
  return effectRefactors;
});
var getEditsForRefactor = fn("LSP.getEditsForRefactor")(function* (refactors2, sourceFile, positionOrRange, refactorName) {
  const refactor = refactors2.find((refactor2) => refactorNameToFullyQualifiedName(refactor2.name) === refactorName);
  if (!refactor) {
    return yield* fail3(new RefactorNotApplicableError());
  }
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  return yield* refactor.apply(sourceFile, textRange);
});
var getCompletionsAtPosition = fn("LSP.getCompletionsAtPosition")(function* (completions2, sourceFile, position, options, formatCodeSettings) {
  let effectCompletions = [];
  for (const completion of completions2) {
    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings);
    effectCompletions = effectCompletions.concat(
      result.map((_) => ({ sortText: "11", ..._ }))
    );
  }
  return effectCompletions;
});
var createDiagnosticExecutor = fn("LSP.createCommentDirectivesProcessor")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    function findParentStatementForDisableNextLine(node) {
      let result;
      function find(node2) {
        if (ts.isStatement(node2)) {
          result = node2;
          return;
        }
        if (ts.isPropertyAssignment(node2)) {
          const realStart = ts.getTokenPosOfNode(node2, sourceFile);
          const starts = sourceFile.getLineStarts().filter((start) => start >= node2.pos && start <= realStart);
          if (starts.length > 0) {
            result = node2;
            return;
          }
        }
        if (result) return;
        if (node2.parent) find(node2.parent);
      }
      find(node);
      return result || node;
    }
    const lineOverrides = {};
    const sectionOverrides = {};
    const skippedRules = [];
    const regex = /@effect-diagnostics(-next-line)?((?:\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm;
    let match3;
    while ((match3 = regex.exec(sourceFile.text)) !== null) {
      const nextLineCaptureGroup = match3[1];
      const rulesCaptureGroup = match3[2];
      if (rulesCaptureGroup) {
        const trimmedRuleString = rulesCaptureGroup.trim();
        if (trimmedRuleString) {
          const individualRules = trimmedRuleString.split(/\s+/);
          for (const rulePair of individualRules) {
            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(":");
            const ruleName = rawRuleName.startsWith("effect/") ? rawRuleName.substring("effect/".length) : rawRuleName;
            if (ruleName && ruleLevel) {
              if (ruleLevel === "skip-file") skippedRules.push(ruleName);
              const isOverrideNextLine = nextLineCaptureGroup && nextLineCaptureGroup.trim().toLowerCase() === "-next-line";
              if (isOverrideNextLine) {
                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match3.index);
                if (foundNode) {
                  lineOverrides[ruleName] = lineOverrides[ruleName] || [];
                  lineOverrides[ruleName].unshift({
                    pos: foundNode.node.pos,
                    end: foundNode.node.end,
                    level: ruleLevel,
                    commentRange: foundNode.commentRange
                  });
                }
              } else {
                sectionOverrides[ruleName] = sectionOverrides[ruleName] || [];
                sectionOverrides[ruleName].unshift({
                  pos: match3.index,
                  level: ruleLevel
                });
              }
            }
          }
        }
      }
    }
    const levelToDiagnosticCategory = {
      error: ts.DiagnosticCategory.Error,
      warning: ts.DiagnosticCategory.Warning,
      message: ts.DiagnosticCategory.Message,
      suggestion: ts.DiagnosticCategory.Suggestion
    };
    const execute = (rule) => gen(function* () {
      const diagnostics2 = [];
      const codeFixes = [];
      const ruleNameLowered = rule.name.toLowerCase();
      const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity;
      if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics: diagnostics2, codeFixes };
      if (defaultLevel === "off" && (lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0) {
        return { diagnostics: diagnostics2, codeFixes };
      }
      const fixByDisableNextLine = (node) => ({
        fixName: rule.name + "_skipNextLine",
        description: "Disable " + rule.name + " for this line",
        apply: flatMap4(
          service(ChangeTracker),
          (changeTracker) => gen(function* () {
            const disableAtNode = findParentStatementForDisableNextLine(node);
            const start = ts.getTokenPosOfNode(disableAtNode, sourceFile);
            const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start);
            changeTracker.insertCommentBeforeLine(
              sourceFile,
              line,
              start,
              ` @effect-diagnostics-next-line ${rule.name}:off`
            );
          })
        )
      });
      const fixByDisableEntireFile = {
        fixName: rule.name + "_skipFile",
        description: "Disable " + rule.name + " for this entire file",
        apply: flatMap4(
          service(ChangeTracker),
          (changeTracker) => sync(
            () => changeTracker.insertText(
              sourceFile,
              0,
              `/** @effect-diagnostics ${rule.name}:skip-file */
`
            )
          )
        )
      };
      const applicableDiagnostics = [];
      yield* rule.apply(sourceFile, (entry) => {
        const range = "kind" in entry.location ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end } : entry.location;
        const node = "kind" in entry.location ? entry.location : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos);
        applicableDiagnostics.push({
          range,
          messageText: pluginOptions.diagnosticsName ? `${entry.messageText}    effect(${rule.name})` : entry.messageText,
          fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])
        });
      });
      const unusedLineOverrides = new Set(lineOverrides[ruleNameLowered] || []);
      for (const emitted of applicableDiagnostics.slice(0)) {
        let newLevel = defaultLevel;
        const lineOverride = (lineOverrides[ruleNameLowered] || []).find(
          (_) => _.pos < emitted.range.pos && _.end >= emitted.range.end
        );
        if (lineOverride) {
          newLevel = lineOverride.level;
          unusedLineOverrides.delete(lineOverride);
        } else {
          const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos);
          if (sectionOverride) newLevel = sectionOverride.level;
        }
        if (!(newLevel in levelToDiagnosticCategory)) continue;
        diagnostics2.push({
          file: sourceFile,
          start: emitted.range.pos,
          length: emitted.range.end - emitted.range.pos,
          messageText: emitted.messageText,
          category: levelToDiagnosticCategory[newLevel],
          code: rule.code,
          source: "effect"
        });
        for (const fix of emitted.fixes) {
          codeFixes.push({
            ...fix,
            code: rule.code,
            start: emitted.range.pos,
            end: emitted.range.end
          });
        }
      }
      if (pluginOptions.missingDiagnosticNextLine !== "off" && unusedLineOverrides.size > 0) {
        for (const unusedLineOverride of unusedLineOverrides) {
          diagnostics2.push({
            file: sourceFile,
            start: unusedLineOverride.commentRange.pos,
            length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,
            messageText: `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,
            category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],
            code: -1,
            source: "effect"
          });
        }
      }
      return { diagnostics: diagnostics2, codeFixes };
    });
    return { execute };
  }
);
var cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (h2 >>> 0).toString(16).padStart(8, "0") + (h1 >>> 0).toString(16).padStart(8, "0");
};
var CodegenNotApplicableError = class {
  constructor(cause) {
    this.cause = cause;
  }
  _tag = "@effect/language-service/CodegenNotApplicableError";
};
function createCodegen(definition) {
  return definition;
}
var getCodegensForSourceFile = fn("LSP.getApplicableCodegens")(function* (codegens2, sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const result = [];
  const regex = /@effect-codegens((?:\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid;
  let match3;
  while ((match3 = regex.exec(sourceFile.text)) !== null) {
    const pos = match3.indices?.[0]?.[0];
    if (!pos) continue;
    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos);
    if (!commentRange) continue;
    const commentText = sourceFile.text.slice(pos, commentRange.end);
    const codegenRegex = /(\s+)(\w+)(?::(\w+))?/gmi;
    let codegenMatch;
    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {
      const whitespace = codegenMatch[1] || "";
      const codegenName = codegenMatch[2] || "";
      const codegenHash = codegenMatch[3] || "";
      const range = {
        pos: codegenMatch.index + pos + whitespace.length,
        end: codegenMatch.index + pos + codegenMatch[0].length
      };
      const codegen = codegens2.find((codegen2) => codegen2.name === codegenName);
      if (!codegen) continue;
      result.push({ codegen, hash: codegenHash, range });
    }
  }
  return result;
});
var getEditsForCodegen = fn("LSP.getEditsForCodegen")(function* (codegens2, sourceFile, textRange) {
  const applicableCodegens = yield* getCodegensForSourceFile(codegens2, sourceFile);
  const inRangeCodegens = applicableCodegens.filter(
    (codegen2) => codegen2.range.pos <= textRange.pos && codegen2.range.end >= textRange.end
  );
  if (inRangeCodegens.length !== 1) {
    return yield* fail3(new CodegenNotApplicableError("zero or multiple codegens in range"));
  }
  const { codegen, range } = inRangeCodegens[0];
  const edit = yield* codegen.apply(sourceFile, range);
  const updateHashComment = pipe(
    service(ChangeTracker),
    map8((changeTracker) => {
      changeTracker.deleteRange(sourceFile, range);
      changeTracker.insertText(
        sourceFile,
        range.pos,
        edit.hash.length > 0 ? `${codegen.name}:${edit.hash}` : codegen.name
      );
    })
  );
  return {
    ...edit,
    apply: pipe(
      edit.apply,
      flatMap4(() => updateHashComment)
    ),
    ignore: updateHashComment
  };
});
var getEffectLspPatchSourceFileMetadata = (sourceFile) => {
  return sourceFile["@effect-lsp-patch/metadata"];
};

// src/core/KeyBuilder.ts
var makeKeyBuilder = fn("KeyBuilder")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const program = yield* service(TypeScriptProgram);
    const options = yield* service(LanguageServicePluginOptions);
    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    function createString2(classNameText, kind) {
      if (!packageInfo) return;
      for (const keyPattern of options.keyPatterns) {
        if (keyPattern.target !== kind) continue;
        const lastIndex = sourceFile.fileName.lastIndexOf("/");
        let onlyFileName = lastIndex === -1 ? "" : sourceFile.fileName.slice(lastIndex + 1);
        const lastExtensionIndex = onlyFileName.lastIndexOf(".");
        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex);
        if (onlyFileName.toLowerCase().endsWith("/index")) onlyFileName = onlyFileName.slice(0, -6);
        if (onlyFileName.startsWith("/")) onlyFileName = onlyFileName.slice(1);
        let subDirectory = getDirectoryPath(ts, sourceFile.fileName);
        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue;
        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length);
        if (!subDirectory.endsWith("/")) subDirectory = subDirectory + "/";
        if (subDirectory.startsWith("/")) subDirectory = subDirectory.slice(1);
        for (const prefix of keyPattern.skipLeadingPath) {
          if (subDirectory.startsWith(prefix)) {
            subDirectory = subDirectory.slice(prefix.length);
            break;
          }
        }
        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(
          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
        );
        if (keyPattern.pattern === "package-identifier") {
          parts = [packageInfo.name, onlyFileName].concat(
            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
          );
        }
        parts = parts.map((part) => part.startsWith("/") ? part.slice(1) : part).map(
          (part) => part.endsWith("/") ? part.slice(0, -1) : part
        );
        const fullKey = parts.filter((_) => String(_).trim().length > 0).join("/");
        return keyPattern.pattern === "default-hashed" ? cyrb53(fullKey) : fullKey;
      }
    }
    return {
      createString: createString2
    };
  }
);
var keyBuilderCache = /* @__PURE__ */ new Map();
var getOrMakeKeyBuilder = fn("getOrMakeKeyBuilder")(function* (sourceFile) {
  while (keyBuilderCache.size > 5) {
    const oldest = keyBuilderCache.keys().next().value;
    if (oldest) keyBuilderCache.delete(oldest);
  }
  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) || (yield* makeKeyBuilder(sourceFile));
  keyBuilderCache.set(sourceFile.fileName, keyBuilder);
  return keyBuilder;
});
function createString(sourceFile, identifier, kind) {
  return map8(
    getOrMakeKeyBuilder(sourceFile),
    (identifierBuilder) => identifierBuilder.createString(identifier, kind)
  );
}

// src/core/TypeCheckerApi.ts
var TypeCheckerApi = Tag("TypeChecker");
function makeResolveExternalModuleName(typeChecker) {
  if (!(hasProperty(typeChecker, "resolveExternalModuleName") && isFunction(typeChecker.resolveExternalModuleName))) {
    return;
  }
  const _internal = typeChecker.resolveExternalModuleName;
  return (moduleSpecifier) => {
    return _internal(moduleSpecifier);
  };
}

// src/core/TypeCheckerUtils.ts
var TypeCheckerUtils = Tag("TypeCheckerUtils");
var nanoLayer2 = (fa) => pipe(
  service(TypeScriptApi),
  flatMap4(
    (ts) => flatMap4(service(TypeCheckerApi), (typeChecker) => flatMap4(service(TypeScriptUtils), (typeScriptUtils) => pipe(fa, provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))
  )
);
function makeTypeCheckerUtils(ts, typeChecker, tsUtils) {
  const readonlyArraySymbol = typeChecker.resolveName("ReadonlyArray", void 0, ts.SymbolFlags.Type, false);
  const globalReadonlyArrayType = readonlyArraySymbol ? typeChecker.getDeclaredTypeOfSymbol(readonlyArraySymbol) : void 0;
  const errorSymbol = typeChecker.resolveName("Error", void 0, ts.SymbolFlags.Type, false);
  const globalErrorType = errorSymbol ? typeChecker.getDeclaredTypeOfSymbol(errorSymbol) : void 0;
  function isUnion(type) {
    return !!(type.flags & ts.TypeFlags.Union);
  }
  function isIndexType(type) {
    return !!(type.flags & ts.TypeFlags.Index);
  }
  function isThisTypeParameter(type) {
    return !!(type.flags & ts.TypeFlags.TypeParameter && type.isThisType);
  }
  function isReadonlyArrayType(type) {
    return type && "target" in type && type.target === globalReadonlyArrayType;
  }
  function isMissingIntrinsicType(type) {
    return (type.flags & ts.TypeFlags.Undefined) !== 0 && "debugIntrinsicName" in type && type.debugIntrinsicName === "missing";
  }
  function getTypeParameterAtPosition(signature, pos) {
    const type = typeChecker.getParameterType(signature, pos);
    if (isIndexType(type) && isThisTypeParameter(type.type)) {
      const constraint = typeChecker.getBaseConstraintOfType(type.type);
      if (constraint) {
        return typeChecker.getIndexType(constraint);
      }
    }
    return type;
  }
  const unrollUnionMembers = (type) => {
    const result = [];
    let toTest = [type];
    while (toTest.length > 0) {
      const type2 = toTest.pop();
      if (isUnion(type2)) {
        toTest = toTest.concat(type2.types);
      } else {
        result.push(type2);
      }
    }
    return result;
  };
  const getMissingTypeEntriesInTargetType = function(realType, expectedType) {
    if (realType === expectedType) return [];
    const result = [];
    let toTest = [realType];
    while (toTest.length > 0) {
      const type = toTest.pop();
      if (!type) return result;
      if (isUnion(type)) {
        toTest = toTest.concat(type.types);
      } else {
        const assignable = typeChecker.isTypeAssignableTo(type, expectedType);
        if (!assignable) {
          result.push(type);
        }
      }
    }
    return result;
  };
  const appendToUniqueTypesMap = fn(
    "TypeCheckerUtils.appendToUniqueTypesMap"
  )(
    function* (memory, initialType, shouldExclude) {
      const newIndexes = /* @__PURE__ */ new Set();
      const knownIndexes = /* @__PURE__ */ new Set();
      let toTest = [initialType];
      while (toTest.length > 0) {
        const type = toTest.pop();
        if (!type) break;
        if (yield* shouldExclude(type)) {
          continue;
        }
        if (isUnion(type)) {
          toTest = toTest.concat(type.types);
        } else {
          const foundMatch = [];
          for (const [typeId, knownType] of memory.entries()) {
            const areSame = typeChecker.isTypeAssignableTo(knownType, type) && typeChecker.isTypeAssignableTo(type, knownType);
            if (areSame) {
              foundMatch.push(typeId);
              break;
            }
          }
          if (foundMatch.length === 0) {
            const newId = "t" + (memory.size + 1);
            memory.set(newId, type);
            newIndexes.add(newId);
          } else {
            knownIndexes.add(foundMatch[0]);
          }
        }
      }
      return {
        newIndexes,
        knownIndexes,
        allIndexes: pipe(
          fromIterable(newIndexes),
          appendAll(fromIterable(knownIndexes))
        )
      };
    }
  );
  const deterministicTypeOrder = make2((a, b) => {
    const aName = typeChecker.typeToString(a);
    const bName = typeChecker.typeToString(b);
    if (aName < bName) return -1;
    if (aName > bName) return 1;
    return 0;
  });
  const getAncestorConvertibleDeclaration = (node) => {
    let current = node;
    while (current) {
      if (ts.isFunctionDeclaration(current) || ts.isFunctionExpression(current) || ts.isArrowFunction(current) || ts.isMethodDeclaration(current)) {
        return current;
      }
      current = current.parent;
    }
  };
  const getInferredReturnType = (declaration) => {
    if (!declaration.body) {
      return;
    }
    let returnType;
    if (typeChecker.isImplementationOfOverload(declaration)) {
      const signatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(declaration),
        ts.SignatureKind.Call
      );
      if (signatures.length > 1) {
        returnType = typeChecker.getUnionType(
          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)
        );
      }
    }
    if (!returnType) {
      const signature = typeChecker.getSignatureFromDeclaration(declaration);
      if (signature) {
        const typePredicate = typeChecker.getTypePredicateOfSignature(signature);
        if (typePredicate && typePredicate.type) {
          return typePredicate.type;
        } else {
          returnType = typeChecker.getReturnTypeOfSignature(signature);
        }
      }
    }
    return returnType;
  };
  const expectedAndRealTypeCache = /* @__PURE__ */ new WeakMap();
  const expectedAndRealType = (sourceFile) => {
    const cached2 = expectedAndRealTypeCache.get(sourceFile);
    if (cached2) return cached2;
    const result = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isVariableDeclaration(node) && node.initializer) {
        const expectedType = typeChecker.getTypeAtLocation(node.name);
        const realType = typeChecker.getTypeAtLocation(node.initializer);
        result.push([node.name, expectedType, node.initializer, realType]);
        appendNodeToVisit(node.initializer);
        continue;
      } else if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          resolvedSignature.parameters.map((parameter, index) => {
            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node);
            const realType = typeChecker.getTypeAtLocation(node.arguments[index]);
            result.push([
              node.arguments[index],
              expectedType,
              node.arguments[index],
              realType
            ]);
          });
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {
        const parent = node.parent;
        if (ts.isObjectLiteralElement(parent)) {
          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
            const type = typeChecker.getContextualType(parent.parent);
            if (type) {
              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : void 0;
              if (name) {
                const symbol3 = typeChecker.getPropertyOfType(type, name);
                if (symbol3) {
                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol3, node);
                  const realType = typeChecker.getTypeAtLocation(node);
                  result.push([node, expectedType, node, realType]);
                }
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const expectedType = typeChecker.getTypeAtLocation(node.left);
        const realType = typeChecker.getTypeAtLocation(node.right);
        result.push([node.left, expectedType, node.right, realType]);
        appendNodeToVisit(node.right);
        continue;
      } else if (ts.isReturnStatement(node) && node.expression) {
        const parentDeclaration = getAncestorConvertibleDeclaration(node);
        if (parentDeclaration) {
          const expectedType = getInferredReturnType(parentDeclaration);
          const realType = typeChecker.getTypeAtLocation(node.expression);
          if (expectedType) {
            result.push([node, expectedType, node, realType]);
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = typeChecker.getContextualType(body);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = getInferredReturnType(node);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isSatisfiesExpression(node)) {
        const expectedType = typeChecker.getTypeAtLocation(node.type);
        const realType = typeChecker.getTypeAtLocation(node.expression);
        result.push([node.expression, expectedType, node.expression, realType]);
        appendNodeToVisit(node.expression);
        continue;
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
    expectedAndRealTypeCache.set(sourceFile, result);
    return result;
  };
  function typeToSimplifiedTypeNode(type, enclosingNode, flags) {
    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0);
  }
  function isGlobalErrorType(type) {
    if (!globalErrorType) return false;
    return typeChecker.isTypeAssignableTo(type, globalErrorType) && typeChecker.isTypeAssignableTo(globalErrorType, type);
  }
  function typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, depth) {
    const fallbackStandard = () => {
      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags);
      if (!typeNode) return void 0;
      return tsUtils.simplifyTypeNode(typeNode);
    };
    if (depth > 20) return fallbackStandard();
    const members = unrollUnionMembers(type);
    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {
      const typeNodes = [];
      members.sort(deterministicTypeOrder);
      for (const member of members) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      const intersectionType = type;
      const typeNodes = [];
      for (const member of intersectionType.types) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Object && type.objectFlags & ts.ObjectFlags.Reference) {
      const typeReference = type;
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isTypeReferenceNode(standard2)) return standard2;
      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard2;
      if (standard2.typeArguments?.length !== typeReference.typeArguments?.length) return standard2;
      const typeParametersCount = (typeReference.target.typeParameters || []).length;
      for (let i = typeParametersCount - 1; i >= 0; i--) {
        const typeParameter = typeReference.target.typeParameters[i];
        const typeArgument = typeReference.typeArguments[i];
        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter);
        if (defaultType !== typeArgument || i === 0) {
          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(
            standard2,
            standard2.typeName,
            ts.factory.createNodeArray((standard2.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))
          ));
        }
      }
      return standard2;
    }
    if (type.flags & ts.TypeFlags.Object) {
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isFunctionTypeNode(standard2)) return standard2;
      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
      if (signatures.length !== 1) return standard2;
      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
      if (!returnType) return standard2;
      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1);
      if (!returnTypeNode) return standard2;
      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(
        standard2,
        standard2.typeParameters,
        standard2.parameters,
        returnTypeNode
      ));
    }
    return fallbackStandard();
  }
  function getTypeAtLocation(node) {
    if (node.parent && ts.isJsxSelfClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxAttribute(node.parent) && node.parent.name === node) return;
    if (ts.isExpression(node) || ts.isTypeNode(node)) {
      return typeChecker.getTypeAtLocation(node);
    }
  }
  return {
    isUnion,
    isReadonlyArrayType,
    isMissingIntrinsicType,
    getTypeParameterAtPosition,
    getMissingTypeEntriesInTargetType,
    unrollUnionMembers,
    appendToUniqueTypesMap,
    deterministicTypeOrder,
    getInferredReturnType,
    expectedAndRealType,
    typeToSimplifiedTypeNode,
    isGlobalErrorType,
    getTypeAtLocation
  };
}

// src/core/TypeParser.ts
var TypeParser = Tag("@effect/language-service/TypeParser");
var nanoLayer3 = (fa) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const program = yield* service(TypeScriptProgram);
  return yield* pipe(
    fa,
    provideService(TypeParser, make7(ts, tsUtils, typeChecker, typeCheckerUtils, program))
  );
});
var TypeParserIssue = class _TypeParserIssue {
  _tag = "@effect/language-service/TypeParserIssue";
  static issue = fail3(new _TypeParserIssue());
};
function typeParserIssue(_message, _type, _node) {
  return TypeParserIssue.issue;
}
function make7(ts, tsUtils, typeChecker, typeCheckerUtils, program) {
  const getSourceFilePackageInfo = cachedBy(
    fn("TypeParser.getSourceFilePackageInfo")(function* (sourceFile) {
      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    }),
    `TypeParser.getSourceFilePackageInfo`,
    (sourceFile) => sourceFile
  );
  const getSourceFilesDeclaringSymbolModule = (packageName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolModule")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const sourceFile of symbol3.declarations) {
        if (!ts.isSourceFile(sourceFile)) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push(sourceFile);
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no source file declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,
    (symbol3) => symbol3
  );
  const isSymbolReferenceToPackageModule = (givenSymbol, packageName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolModule(packageName)(symbol3),
      flatMap4(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_))
        )
      )
    );
  };
  const isNodeReferenceToPackageModule = (givenNode, packageName, isCorrectSourceFile) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolReferenceToPackageModule(symbol3, packageName, isCorrectSourceFile);
  };
  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (packageName, memberName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const declaration of symbol3.declarations) {
        const sourceFile = tsUtils.getSourceFileOfNode(declaration);
        if (!sourceFile) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (memberSymbol) {
          if (memberSymbol === symbol3) {
            result.push({ memberSymbol, moduleSymbol, sourceFile });
          } else if (memberSymbol.flags & ts.SymbolFlags.Alias) {
            const aliased = typeChecker.getAliasedSymbol(memberSymbol);
            if (aliased === symbol3) {
              result.push({ memberSymbol, moduleSymbol, sourceFile });
            }
          }
        }
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,
    (sym) => sym
  );
  const isSymbolExportOfPackageModule = (givenSymbol, packageName, memberName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol3),
      flatMap4(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))
        )
      )
    );
  };
  const isNodeReferenceToExportOfPackageModule = (givenNode, packageName, isCorrectSourceFile, memberName) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolExportOfPackageModule(symbol3, packageName, memberName, isCorrectSourceFile);
  };
  const findSymbolsMatchingPackageAndExportedName = (packageName, exportedSymbolName) => cachedBy(
    fn("TypeParser.findSymbolsMatchingPackageAndExportedName")(function* () {
      const result = [];
      for (const sourceFile of program.getSourceFiles()) {
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const symbol3 = typeChecker.tryGetMemberInModuleExports(exportedSymbolName, moduleSymbol);
        if (!symbol3) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push([symbol3, sourceFile]);
      }
      return result;
    }),
    `TypeParser.findSymbolsMatchingPackageAndExportedName(${packageName}, ${exportedSymbolName})`,
    () => program
  );
  const isCauseTypeSourceFile = cachedBy(
    fn("TypeParser.isCauseTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const causeTypeSymbol = typeChecker.tryGetMemberInModuleExports("Cause", moduleSymbol);
      if (!causeTypeSymbol) return yield* typeParserIssue("Cause type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(causeTypeSymbol);
      yield* pipeableType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isCauseTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const extendsCauseYieldableError = cachedBy(
    fn("TypeParser.extendsCauseYieldableError")(function* (givenType) {
      if (givenType.flags & ts.TypeFlags.Never) {
        return yield* typeParserIssue("Type is never", givenType);
      }
      if (givenType.flags & ts.TypeFlags.Any) {
        return yield* typeParserIssue("Type is any", givenType);
      }
      const symbols = yield* findSymbolsMatchingPackageAndExportedName("effect", "YieldableError")();
      for (const [symbol3, sourceFile] of symbols) {
        const causeFile = yield* pipe(isCauseTypeSourceFile(sourceFile), orElse2(() => void_));
        if (!causeFile) continue;
        const type = typeChecker.getDeclaredTypeOfSymbol(symbol3);
        if (!type) continue;
        if (typeChecker.isTypeAssignableTo(givenType, type)) {
          return type;
        }
      }
      return yield* typeParserIssue("Type does not extend Cause.YieldableError", givenType);
    }),
    "TypeParser.extendsCauseYieldableError",
    (type) => type
  );
  function covariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Covariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  function contravariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Contravariant type has no call signature", type);
    }
    return succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0));
  }
  function invariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Invariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  const pipeableType = cachedBy(
    function(type, atLocation) {
      const pipeSymbol = typeChecker.getPropertyOfType(type, "pipe");
      if (!pipeSymbol) {
        return typeParserIssue("Type has no 'pipe' property", type, atLocation);
      }
      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation);
      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call);
      if (signatures.length === 0) {
        return typeParserIssue("'pipe' property is not callable", type, atLocation);
      }
      return succeed(type);
    },
    "TypeParser.pipeableType",
    (type) => type
  );
  const varianceStructCovariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return covariantTypeArgument(propertyType);
  };
  const varianceStructContravariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return contravariantTypeArgument(propertyType);
  };
  const varianceStructInvariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return invariantTypeArgument(propertyType);
  };
  const effectVarianceStruct = (type, atLocation) => map8(
    all(
      varianceStructCovariantType(type, atLocation, "_A"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, E, R]) => ({ A, E, R })
  );
  const layerVarianceStruct = (type, atLocation) => map8(
    all(
      varianceStructContravariantType(type, atLocation, "_ROut"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_RIn")
    ),
    ([ROut, E, RIn]) => ({ ROut, E, RIn })
  );
  const effectType = cachedBy(
    fn("TypeParser.effectType")(function* (type, atLocation) {
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no effect variance struct", type, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("EffectTypeId") - ts.symbolName(a).indexOf("EffectTypeId")
      );
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectType",
    (type) => type
  );
  const strictEffectType = cachedBy(
    fn("TypeParser.strictEffectType")(function* (type, atLocation) {
      if (!(type.symbol && ts.symbolName(type.symbol) === "Effect" && !type.aliasSymbol)) {
        return yield* typeParserIssue("Type name should be Effect with no alias symbol", type, atLocation);
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.strictEffectType",
    (type) => type
  );
  const isEffectTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports("Effect", moduleSymbol);
      if (!effectTypeSymbol) return yield* typeParserIssue("Effect type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol);
      yield* effectType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,
    (node) => node
  );
  const layerType = cachedBy(
    fn("TypeParser.layerType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no layer variance struct", type, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("LayerTypeId") - ts.symbolName(a).indexOf("LayerTypeId")
      );
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return layerVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.layerType",
    (type) => type
  );
  const fiberType = cachedBy(
    fn("TypeParser.fiberType")(function* (type, atLocation) {
      const awaitSymbol = typeChecker.getPropertyOfType(type, "await");
      const pollSymbol = typeChecker.getPropertyOfType(type, "poll");
      if (!awaitSymbol || !pollSymbol) {
        return yield* typeParserIssue(
          "Type is not a fiber because it does not have 'await' or 'poll' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.fiberType",
    (type) => type
  );
  const effectSubtype = cachedBy(
    fn("TypeParser.effectSubtype")(function* (type, atLocation) {
      const tagSymbol = typeChecker.getPropertyOfType(type, "_tag");
      const getSymbol = typeChecker.getPropertyOfType(type, "get");
      if (!(tagSymbol || getSymbol)) {
        return yield* typeParserIssue(
          "Type is not a subtype of effect because it does not have '_tag' or 'get' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.effectSubtype",
    (type) => type
  );
  const isEffectContextSourceFile = cachedBy(
    fn("TypeParser.isEffectContextSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const contextSymbol = typeChecker.tryGetMemberInModuleExports("Context", moduleSymbol);
      if (!contextSymbol) return yield* typeParserIssue("Context not found", void 0, sourceFile);
      const tagSymbol = typeChecker.tryGetMemberInModuleExports("Tag", moduleSymbol);
      if (!tagSymbol) return yield* typeParserIssue("Tag not found", void 0, sourceFile);
      const tagType = typeChecker.getDeclaredTypeOfSymbol(tagSymbol);
      yield* contextTag(tagType, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectContextSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectContextModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectContextModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectContextSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectContextModuleApi(${memberName})`,
    (node) => node
  );
  const importedContextModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectContextSourceFile),
      map8(() => node)
    ),
    "TypeParser.importedContextModule",
    (node) => node
  );
  const importedEffectModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectTypeSourceFile),
      map8(() => node)
    ),
    "TypeParser.importedEffectModule",
    (node) => node
  );
  const isEffectDataSourceFile = cachedBy(
    fn("TypeParser.isEffectDataSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const taggedEnumSymbol = typeChecker.tryGetMemberInModuleExports("TaggedEnum", moduleSymbol);
      if (!taggedEnumSymbol) return yield* typeParserIssue("TaggedEnum not found", void 0, sourceFile);
      const taggedErrorSymbol = typeChecker.tryGetMemberInModuleExports("TaggedError", moduleSymbol);
      if (!taggedErrorSymbol) return yield* typeParserIssue("TaggedError not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectDataSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectDataModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectDataModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectDataSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectDataModuleApi(${memberName})`,
    (node) => node
  );
  const importedDataModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectDataSourceFile),
      map8(() => node)
    ),
    "TypeParser.importedDataModule",
    (node) => node
  );
  const effectGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue("Node is not a generator function", void 0, node);
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("gen")(propertyAccess),
        map8(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectGen",
    (node) => node
  );
  const effectFnUntracedGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = node.expression;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fnUntraced")(propertyAccess),
        map8(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2
        }))
      );
    },
    "TypeParser.effectFnUntracedGen",
    (node) => node
  );
  const effectFnGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue(
          "Node is not a function expression",
          void 0,
          node
        );
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map8(() => ({
          node,
          generatorFunction,
          effectModule: propertyAccess.expression,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFnGen",
    (node) => node
  );
  const findEnclosingScopes = fn("TypeParser.findEnclosingScopes")(function* (startNode) {
    let currentParent = startNode.parent;
    let scopeNode = void 0;
    let effectGenResult = void 0;
    while (currentParent) {
      const nodeToCheck = currentParent;
      if (!scopeNode) {
        if (ts.isFunctionExpression(nodeToCheck) || ts.isFunctionDeclaration(nodeToCheck) || ts.isMethodDeclaration(nodeToCheck) || ts.isArrowFunction(nodeToCheck) || ts.isGetAccessorDeclaration(nodeToCheck) || ts.isSetAccessorDeclaration(nodeToCheck)) {
          scopeNode = nodeToCheck;
        }
      }
      if (!effectGenResult) {
        const isEffectGen = yield* pipe(
          effectGen(nodeToCheck),
          map8((result) => ({
            node: result.node,
            effectModule: result.effectModule,
            generatorFunction: result.generatorFunction,
            body: result.body
          })),
          orElse2(
            () => pipe(
              effectFnUntracedGen(nodeToCheck),
              map8((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          orElse2(
            () => pipe(
              effectFnGen(nodeToCheck),
              map8((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          option
        );
        if (isSome2(isEffectGen)) {
          effectGenResult = isEffectGen.value;
        }
      }
      if (scopeNode && effectGenResult) {
        break;
      }
      currentParent = nodeToCheck.parent;
    }
    return { scopeNode, effectGen: effectGenResult };
  });
  const effectFn = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const regularFunction = node.arguments[0];
      if (!ts.isFunctionExpression(regularFunction) && !ts.isArrowFunction(regularFunction)) {
        return typeParserIssue("Node is not a function expression or arrow function", void 0, node);
      }
      if (ts.isFunctionExpression(regularFunction) && regularFunction.asteriskToken !== void 0) {
        return typeParserIssue("Node is a generator function, not a regular function", void 0, node);
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map8(() => ({
          node,
          effectModule: propertyAccess.expression,
          regularFunction,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFn",
    (node) => node
  );
  const unnecessaryEffectGen2 = cachedBy(
    fn("TypeParser.unnecessaryEffectGen")(function* (node) {
      const { body } = yield* effectGen(node);
      if (body.statements.length !== 1) {
        return yield* typeParserIssue(
          "Generator body should have a single statement",
          void 0,
          node
        );
      }
      let explicitReturn = false;
      let nodeToCheck = body.statements[0];
      while (nodeToCheck) {
        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {
          nodeToCheck = nodeToCheck.expression;
          explicitReturn = true;
          continue;
        }
        if (ts.isExpressionStatement(nodeToCheck)) {
          nodeToCheck = nodeToCheck.expression;
          continue;
        }
        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {
          const yieldedExpression = nodeToCheck.expression;
          const type = typeCheckerUtils.getTypeAtLocation(yieldedExpression);
          if (!type) continue;
          const { A: successType } = yield* effectType(type, yieldedExpression);
          let replacementNode = succeed(yieldedExpression);
          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {
            replacementNode = pipe(
              gen(function* () {
                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
                  node.getSourceFile(),
                  "effect",
                  "Effect"
                ) || "Effect";
                return ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(effectIdentifier),
                    "asVoid"
                  ),
                  void 0,
                  [
                    yieldedExpression
                  ]
                );
              }),
              provideService(TypeScriptApi, ts)
            );
          }
          return { node, body, yieldedExpression, replacementNode };
        }
        break;
      }
      return yield* typeParserIssue(
        "Not an handled node",
        void 0,
        node
      );
    }),
    "TypeParser.unnecessaryEffectGen",
    (node) => node
  );
  const effectSchemaVarianceStruct = (type, atLocation) => map8(
    all(
      varianceStructInvariantType(type, atLocation, "_A"),
      varianceStructInvariantType(type, atLocation, "_I"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, I, R]) => ({ A, I, R })
  );
  const effectSchemaType = cachedBy(
    fn("TypeParser.effectSchemaType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const ast = typeChecker.getPropertyOfType(type, "ast");
      if (!ast) return yield* typeParserIssue("Has no 'ast' property", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no schema variance struct", type, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectSchemaVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectSchemaType",
    (type) => type
  );
  const isEffectSchemaTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSchemaTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const typeSymbol = typeChecker.tryGetMemberInModuleExports("Schema", moduleSymbol);
      if (!typeSymbol) return yield* typeParserIssue("Schema type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol);
      yield* effectSchemaType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectSchemaTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSchemaModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSchemaModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectSchemaTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,
    (node) => node
  );
  const isEffectParseResultSourceFile = cachedBy(
    fn("TypeParser.isEffectParseResultSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const parseIssueSymbol = typeChecker.tryGetMemberInModuleExports("ParseIssue", moduleSymbol);
      if (!parseIssueSymbol) return yield* typeParserIssue("ParseIssue type not found", void 0, sourceFile);
      const decodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("decodeSync", moduleSymbol);
      if (!decodeSyncSymbol) return yield* typeParserIssue("decodeSync not found", void 0, sourceFile);
      const encodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("encodeSync", moduleSymbol);
      if (!encodeSyncSymbol) return yield* typeParserIssue("encodeSync not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectParseResultSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectParseResultModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectParseResultModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectParseResultSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectParseResultModuleApi(${memberName})`,
    (node) => node
  );
  const contextTagVarianceStruct = (type, atLocation) => map8(
    all(
      varianceStructInvariantType(type, atLocation, "_Identifier"),
      varianceStructInvariantType(type, atLocation, "_Service")
    ),
    ([Identifier, Service]) => ({ Identifier, Service })
  );
  const contextTag = cachedBy(
    fn("TypeParser.contextTag")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no tag variance struct", type, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return contextTagVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.contextTag",
    (type) => type
  );
  const effectFunctionImportedName = cachedBy(
    fn("TypeParser.effectFunctionImportedName")(function* (sourceFile) {
      return tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Function");
    }),
    "TypeParser.effectFunctionImportedName",
    (node) => node
  );
  const pipeCall = cachedBy(
    function(node) {
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "pipe") {
        const baseExpression = node.expression.expression;
        return pipe(
          effectFunctionImportedName(tsUtils.getSourceFileOfNode(node)),
          flatMap4((functionIdentifier) => {
            if (functionIdentifier && ts.isIdentifier(baseExpression) && ts.idText(baseExpression) === functionIdentifier) {
              if (node.arguments.length === 0) {
                return typeParserIssue("Node is not a pipe call", void 0, node);
              }
              const [subject, ...args2] = node.arguments;
              return succeed({
                node,
                subject,
                args: args2,
                kind: "pipe"
              });
            }
            return succeed({
              node,
              subject: baseExpression,
              args: Array.from(node.arguments),
              kind: "pipeable"
            });
          })
        );
      }
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === "pipe" && node.arguments.length > 0) {
        const [subject, ...args2] = node.arguments;
        return succeed({ node, subject, args: args2, kind: "pipe" });
      }
      return typeParserIssue("Node is not a pipe call", void 0, node);
    },
    "TypeParser.pipeCall",
    (node) => node
  );
  const singleArgCall = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length !== 1) {
        return typeParserIssue("Node must have exactly one argument", void 0, node);
      }
      return succeed({
        node,
        callee: node.expression,
        subject: node.arguments[0]
      });
    },
    "TypeParser.singleArgCall",
    (node) => node
  );
  const scopeType = cachedBy(
    fn("TypeParser.scopeType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.some((s) => ts.symbolName(s).indexOf("ScopeTypeId") !== -1)) {
        return type;
      }
      return yield* typeParserIssue("Type has no scope type id", type, atLocation);
    }),
    "TypeParser.scopeType",
    (type) => type
  );
  const promiseLike = cachedBy(
    function(type, atLocation) {
      const thenProperty = type.getProperty("then");
      if (!thenProperty) return typeParserIssue("not a promise - missing then property", type, atLocation);
      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation);
      if (!thenType) return typeParserIssue("not a promise - missing then property", type, atLocation);
      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {
        const parameter = callSignature.parameters[0];
        if (!parameter) continue;
        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0);
        if (!parameterType) continue;
        let callbackCallSignatures = [];
        let toTest = [parameterType];
        while (toTest.length > 0) {
          const type2 = toTest.shift();
          if (!type2) continue;
          const callSignatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
          callbackCallSignatures = callbackCallSignatures.concat(callSignatures);
          if (typeCheckerUtils.isUnion(type2)) {
            toTest = toTest.concat(type2.types);
          }
        }
        for (const callableType of callbackCallSignatures) {
          const callbackParameter = callableType.parameters[0];
          if (!callbackParameter) {
            continue;
          }
          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0);
          if (!callbackParameterType) {
            continue;
          }
          return succeed({
            type: callbackParameterType
          });
        }
      }
      return typeParserIssue("not a promise", type, atLocation);
    },
    "TypeParser.promiseLike",
    (type) => type
  );
  const extendsSchemaClass = cachedBy(
    fn("TypeParser.extendsSchemaClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.Class", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedClass = cachedBy(
    fn("TypeParser.extendsSchemaTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {
              const schemaTaggedClassTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments && schemaTaggedClassTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(schemaTaggedClassTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedClassTCall.arguments[0]) ? schemaTaggedClassTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedError = cachedBy(
    fn("TypeParser.extendsSchemaTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedErrorTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments && schemaTaggedErrorTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedError")(schemaTaggedErrorTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0]) ? schemaTaggedErrorTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedError",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedRequest = cachedBy(
    fn("TypeParser.extendsSchemaTaggedRequest")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedRequestTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedRequestTCall) && schemaTaggedRequestTCall.typeArguments && schemaTaggedRequestTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(schemaTaggedRequestTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0,
                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0]) ? schemaTaggedRequestTCall.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedRequest", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedRequest",
    (atLocation) => atLocation
  );
  const extendsDataTaggedError = cachedBy(
    fn("TypeParser.extendsDataTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedErrorCall = expression;
              const dataIdentifier = dataTaggedErrorCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedError") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedErrorCall.arguments[0]) ? dataTaggedErrorCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedError",
    (atLocation) => atLocation
  );
  const extendsDataTaggedClass = cachedBy(
    fn("TypeParser.extendsDataTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedClassCall = expression;
              const dataIdentifier = dataTaggedClassCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedClass") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedClassCall.arguments[0]) ? dataTaggedClassCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedClass",
    (atLocation) => atLocation
  );
  const extendsContextTag = cachedBy(
    fn("TypeParser.extendsContextTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const contextTagCall = wholeCall.expression;
              if (ts.isCallExpression(contextTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const contextTagIdentifier = contextTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                if (ts.isPropertyAccessExpression(contextTagIdentifier) && ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === "Tag") {
                  const parsedContextModule = yield* pipe(
                    importedContextModule(contextTagIdentifier.expression),
                    option
                  );
                  if (isSome2(parsedContextModule)) {
                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                    if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                    const type = typeChecker.getTypeOfSymbol(classSym);
                    const tagType = yield* contextTag(type, atLocation);
                    return {
                      className: atLocation.name,
                      selfTypeNode,
                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0]) ? contextTagCall.arguments[0] : void 0,
                      args: contextTagCall.arguments,
                      Identifier: tagType.Identifier,
                      Tag: parsedContextModule.value
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Context.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsContextTag",
    (atLocation) => atLocation
  );
  const extendsEffectTag = cachedBy(
    fn("TypeParser.extendsEffectTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
      if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
      const type = typeChecker.getTypeOfSymbol(classSym);
      const tagType = yield* contextTag(type, atLocation);
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectTagCall = wholeCall.expression;
              if (ts.isCallExpression(effectTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const effectTagIdentifier = effectTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                const isEffectTag = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Tag")(effectTagIdentifier),
                  option
                );
                if (isSome2(isEffectTag)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0]) ? effectTagCall.arguments[0] : void 0,
                    args: effectTagCall.arguments,
                    Identifier: tagType.Identifier,
                    Service: tagType.Service
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsEffectTag",
    (atLocation) => atLocation
  );
  const extendsEffectService = cachedBy(
    fn("TypeParser.extendsEffectService")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectServiceCall = wholeCall.expression;
              if (ts.isCallExpression(effectServiceCall) && effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0) {
                const effectServiceIdentifier = effectServiceCall.expression;
                const selfTypeNode = effectServiceCall.typeArguments[0];
                const isEffectService = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Service")(effectServiceIdentifier),
                  option
                );
                if (isSome2(isEffectService)) {
                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                  if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                  const type = typeChecker.getTypeOfSymbol(classSym);
                  const parsedContextTag = yield* pipe(
                    contextTag(type, atLocation),
                    option
                  );
                  if (isSome2(parsedContextTag)) {
                    let accessors2 = void 0;
                    let dependencies = void 0;
                    if (wholeCall.arguments.length >= 2) {
                      const args2 = wholeCall.arguments[1];
                      if (ts.isObjectLiteralExpression(args2)) {
                        for (const property of args2.properties) {
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "accessors" && property.initializer && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                            accessors2 = true;
                          }
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "dependencies" && property.initializer && ts.isArrayLiteralExpression(property.initializer)) {
                            dependencies = property.initializer.elements;
                          }
                        }
                      }
                    }
                    return {
                      ...parsedContextTag.value,
                      className: atLocation.name,
                      selfTypeNode,
                      args: wholeCall.arguments,
                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0]) ? wholeCall.arguments[0] : void 0,
                      options: wholeCall.arguments[1],
                      accessors: accessors2,
                      dependencies
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Service", void 0, atLocation);
    }),
    "TypeParser.extendsEffectService",
    (atLocation) => atLocation
  );
  const isEffectSqlModelTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSqlModelTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const classSymbol = typeChecker.tryGetMemberInModuleExports("Class", moduleSymbol);
      if (!classSymbol) return yield* typeParserIssue("Model's Class type not found", void 0, sourceFile);
      const makeRepositorySymbol = typeChecker.tryGetMemberInModuleExports("makeRepository", moduleSymbol);
      if (!makeRepositorySymbol) {
        return yield* typeParserIssue("Model's makeRepository type not found", void 0, sourceFile);
      }
      const makeDataLoadersSymbol = typeChecker.tryGetMemberInModuleExports("makeDataLoaders", moduleSymbol);
      if (!makeDataLoadersSymbol) {
        return yield* typeParserIssue("Model's makeDataLoaders type not found", void 0, sourceFile);
      }
      return sourceFile;
    }),
    "TypeParser.isEffectSqlModelTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSqlModelModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSqlModelModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "@effect/sql",
        isEffectSqlModelTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectSqlModelModuleApi(${memberName})`,
    (node) => node
  );
  const extendsEffectSqlModelClass = cachedBy(
    fn("TypeParser.extendsEffectSqlModelClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSqlModelModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend @effect/sql's Model.Class", void 0, atLocation);
    }),
    "TypeParser.extendsEffectSqlModelClass",
    (atLocation) => atLocation
  );
  const isEffectLayerTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectLayerTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const layerTypeSymbol = typeChecker.tryGetMemberInModuleExports("Layer", moduleSymbol);
      if (!layerTypeSymbol) return yield* typeParserIssue("Layer type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(layerTypeSymbol);
      yield* layerType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectLayerTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectLayerModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectLayerModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "effect",
        isEffectLayerTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectLayerModuleApi(${memberName})`,
    (node) => node
  );
  const lazyExpression = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      if (node.parameters.length !== 0) {
        return typeParserIssue("Function must have zero parameters", void 0, node);
      }
      if (node.typeParameters && node.typeParameters.length > 0) {
        return typeParserIssue("Function must have no type parameters", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (ts.isArrowFunction(node) && !ts.isBlock(body)) {
        return succeed({
          node,
          body,
          expression: body,
          returnType
        });
      }
      if (ts.isBlock(body)) {
        if (body.statements.length !== 1) {
          return typeParserIssue("Block must have exactly one statement", void 0, node);
        }
        const stmt = body.statements[0];
        if (!ts.isReturnStatement(stmt)) {
          return typeParserIssue("Statement must be a return statement", void 0, node);
        }
        if (!stmt.expression) {
          return typeParserIssue("Return statement must have an expression", void 0, node);
        }
        return succeed({
          node,
          body,
          expression: stmt.expression,
          returnType
        });
      }
      return typeParserIssue("Invalid function body", void 0, node);
    },
    "TypeParser.lazyExpression",
    (node) => node
  );
  const emptyFunction = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (!ts.isBlock(body)) {
        return typeParserIssue("Body must be a block", void 0, node);
      }
      if (body.statements.length !== 0) {
        return typeParserIssue("Block must have zero statements", void 0, node);
      }
      return succeed({
        node,
        body,
        returnType
      });
    },
    "TypeParser.emptyFunction",
    (node) => node
  );
  const pipingFlows = (includeEffectFn) => cachedBy(
    fn("TypeParser.pipingFlows")(function* (sourceFile) {
      const result = [];
      const workQueue = [[sourceFile, void 0]];
      while (workQueue.length > 0) {
        const [node, parentFlow] = workQueue.pop();
        if (ts.isCallExpression(node)) {
          const parsed = yield* pipe(
            pipeCall(node),
            map8((p) => ({ _tag: "pipe", ...p })),
            orElse2(
              () => pipe(
                singleArgCall(node),
                map8((s) => ({ _tag: "call", ...s }))
              )
            ),
            option
          );
          if (isSome2(parsed)) {
            const result2 = parsed.value;
            let transformations;
            let flowNode;
            let childrenToTraverse = [];
            if (result2._tag === "pipe") {
              const signature = typeChecker.getResolvedSignature(result2.node);
              const typeArguments = signature ? typeChecker.getTypeArgumentsForResolvedSignature(signature) : void 0;
              transformations = [];
              for (let i = 0; i < result2.args.length; i++) {
                const arg = result2.args[i];
                const outType = typeArguments?.[i + 1];
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    // e.g., Effect.map
                    args: Array.from(arg.arguments),
                    // e.g., [(x) => x + 1]
                    outType,
                    kind: result2.kind
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    // e.g., Effect.asVoid
                    args: void 0,
                    outType,
                    kind: result2.kind
                  });
                }
              }
              flowNode = result2.node;
              childrenToTraverse = result2.args;
            } else {
              const callSignature = typeChecker.getResolvedSignature(node);
              const outType = callSignature ? typeChecker.getReturnTypeOfSignature(callSignature) : void 0;
              transformations = [{
                callee: result2.callee,
                args: void 0,
                outType,
                kind: "call"
              }];
              flowNode = node;
            }
            if (parentFlow) {
              parentFlow.transformations.unshift(...transformations);
              parentFlow.subject = {
                node: result2.subject,
                outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
              };
              workQueue.push([result2.subject, parentFlow]);
            } else {
              const newFlow = {
                node: flowNode,
                subject: {
                  node: result2.subject,
                  outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
                },
                transformations
              };
              workQueue.push([result2.subject, newFlow]);
            }
            for (const child of childrenToTraverse) {
              ts.forEachChild(child, (c) => {
                workQueue.push([c, void 0]);
              });
            }
            continue;
          }
          if (includeEffectFn) {
            const effectFnGenParsed = yield* pipe(effectFnGen(node), option);
            const effectFnUntracedGenParsed = isNone2(effectFnGenParsed) ? yield* pipe(effectFnUntracedGen(node), option) : none2();
            const effectFnNonGenParsed = isNone2(effectFnGenParsed) && isNone2(effectFnUntracedGenParsed) ? yield* pipe(effectFn(node), option) : none2();
            const isEffectFnGen = isSome2(effectFnGenParsed);
            const isEffectFnUntracedGen = isSome2(effectFnUntracedGenParsed);
            const isEffectFnNonGen = isSome2(effectFnNonGenParsed);
            const transformationKind = isEffectFnUntracedGen ? "effectFnUntraced" : "effectFn";
            if (isEffectFnGen || isEffectFnUntracedGen) {
              const effectFnParsed = isEffectFnGen ? effectFnGenParsed : effectFnUntracedGenParsed;
              if (isSome2(effectFnParsed) && effectFnParsed.value.pipeArguments.length > 0) {
                const fnResult = effectFnParsed.value;
                const pipeArgs = fnResult.pipeArguments;
                const transformations = [];
                let subjectType;
                for (let i = 0; i < pipeArgs.length; i++) {
                  const arg = pipeArgs[i];
                  const contextualType = typeChecker.getContextualType(arg);
                  const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                  const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                  if (i === 0 && callSigs.length > 0) {
                    const params = callSigs[0].parameters;
                    if (params.length > 0) {
                      subjectType = typeChecker.getTypeOfSymbol(params[0]);
                    }
                  }
                  if (ts.isCallExpression(arg)) {
                    transformations.push({
                      callee: arg.expression,
                      args: Array.from(arg.arguments),
                      outType,
                      kind: transformationKind
                    });
                  } else {
                    transformations.push({
                      callee: arg,
                      args: void 0,
                      outType,
                      kind: transformationKind
                    });
                  }
                }
                const newFlow = {
                  node,
                  subject: {
                    node,
                    outType: subjectType
                  },
                  transformations
                };
                result.push(newFlow);
                workQueue.push([fnResult.body, void 0]);
                for (const arg of pipeArgs) {
                  ts.forEachChild(arg, (c) => {
                    workQueue.push([c, void 0]);
                  });
                }
                continue;
              }
            }
            if (isEffectFnNonGen && isSome2(effectFnNonGenParsed) && effectFnNonGenParsed.value.pipeArguments.length > 0) {
              const fnResult = effectFnNonGenParsed.value;
              const pipeArgs = fnResult.pipeArguments;
              const transformations = [];
              let subjectType;
              for (let i = 0; i < pipeArgs.length; i++) {
                const arg = pipeArgs[i];
                const contextualType = typeChecker.getContextualType(arg);
                const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                if (i === 0 && callSigs.length > 0) {
                  const params = callSigs[0].parameters;
                  if (params.length > 0) {
                    subjectType = typeChecker.getTypeOfSymbol(params[0]);
                  }
                }
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    args: Array.from(arg.arguments),
                    outType,
                    kind: "effectFn"
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    args: void 0,
                    outType,
                    kind: "effectFn"
                  });
                }
              }
              const newFlow = {
                node,
                subject: {
                  node,
                  outType: subjectType
                },
                transformations
              };
              result.push(newFlow);
              const regularFn = fnResult.regularFunction;
              if (ts.isArrowFunction(regularFn)) {
                if (ts.isBlock(regularFn.body)) {
                  workQueue.push([regularFn.body, void 0]);
                } else {
                  workQueue.push([regularFn.body, void 0]);
                }
              } else if (regularFn.body) {
                workQueue.push([regularFn.body, void 0]);
              }
              for (const arg of pipeArgs) {
                ts.forEachChild(arg, (c) => {
                  workQueue.push([c, void 0]);
                });
              }
              continue;
            }
          }
        }
        if (parentFlow && parentFlow.transformations.length > 0) {
          result.push(parentFlow);
        }
        ts.forEachChild(node, (child) => {
          workQueue.push([child, void 0]);
        });
      }
      result.sort((a, b) => a.node.pos - b.node.pos);
      return result;
    }),
    `TypeParser.pipingFlows(${includeEffectFn})`,
    (sourceFile) => sourceFile
  );
  const reconstructPipingFlow = (flow2) => {
    if (flow2.transformations.length > 0 && flow2.transformations.every((t) => t.kind === "effectFn" || t.kind === "effectFnUntraced")) {
      return flow2.subject.node;
    }
    let result = flow2.subject.node;
    for (const t of flow2.transformations) {
      if (t.kind === "call") {
        result = ts.factory.createCallExpression(
          t.callee,
          void 0,
          [result]
        );
      } else if (t.kind === "effectFn" || t.kind === "effectFnUntraced") {
        continue;
      } else {
        if (t.args) {
          const transformCall = ts.factory.createCallExpression(
            t.callee,
            void 0,
            t.args
          );
          result = ts.factory.createCallExpression(
            transformCall,
            void 0,
            [result]
          );
        } else {
          result = ts.factory.createCallExpression(
            t.callee,
            void 0,
            [result]
          );
        }
      }
    }
    return result;
  };
  return {
    isNodeReferenceToEffectModuleApi,
    isNodeReferenceToEffectSchemaModuleApi,
    isNodeReferenceToEffectParseResultModuleApi,
    isNodeReferenceToEffectDataModuleApi,
    isNodeReferenceToEffectContextModuleApi,
    isNodeReferenceToEffectSqlModelModuleApi,
    isNodeReferenceToEffectLayerModuleApi,
    effectType,
    strictEffectType,
    layerType,
    fiberType,
    effectSubtype,
    importedEffectModule,
    effectGen,
    effectFnUntracedGen,
    effectFnGen,
    findEnclosingScopes,
    effectFn,
    extendsCauseYieldableError,
    unnecessaryEffectGen: unnecessaryEffectGen2,
    effectSchemaType,
    contextTag,
    pipeableType,
    pipeCall,
    singleArgCall,
    scopeType,
    promiseLike,
    extendsEffectTag,
    extendsEffectService,
    extendsContextTag,
    extendsSchemaClass,
    extendsSchemaTaggedClass,
    extendsSchemaTaggedError,
    extendsDataTaggedError,
    extendsDataTaggedClass,
    extendsSchemaTaggedRequest,
    extendsEffectSqlModelClass,
    lazyExpression,
    emptyFunction,
    pipingFlows,
    reconstructPipingFlow
  };
}

// src/completions/contextSelfInClasses.ts
var contextSelfInClasses = createCompletion({
  name: "contextSelfInClasses",
  apply: fn("contextSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Context"
    ) || "Context";
    const isFullyQualified = contextIdentifier === ts.idText(accessedObject);
    const name = ts.idText(className);
    const tagKey = (yield* createString(sourceFile, name, "service")) || name;
    const completions2 = [];
    const hasTagCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectContextModuleApi("Tag")(accessedObject),
        option
      )
    );
    if (hasTagCompletion) {
      completions2.push({
        name: `Tag("${name}")`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${contextIdentifier}.Tag("${tagKey}")<${name}, ${"${0}"}>(){}` : `Tag("${tagKey}")<${name}, ${"${0}"}>(){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    return completions2;
  })
});

// src/completions/durationInput.ts
var durationInput = createCompletion({
  name: "durationInput",
  apply: fn("durationInput")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    let isInString = false;
    const previousToken = ts.findPrecedingToken(position, sourceFile);
    if (previousToken && ts.isStringTextContainingNode(previousToken)) {
      const start = ts.getTokenPosOfNode(previousToken, sourceFile);
      const end = previousToken.end;
      if (start < position && position < end) {
        isInString = true;
      }
      if (position === end) {
        isInString = !!previousToken.isUnterminated;
      }
      if (isInString && ts.isExpression(previousToken)) {
        const type = typeChecker.getContextualType(previousToken);
        if (type) {
          if (!typeCheckerUtils.isUnion(type)) return [];
          for (const member of type.types) {
            if (member.flags & ts.TypeFlags.TemplateLiteral) {
              if (hasProperty(member, "texts") && isArray(member.texts) && member.texts.length === 2 && String(member.texts[1]).trim() === "nanos") {
                return ["nanos", "micros", "millis", "seconds", "minutes", "hours", "days", "weeks"].map(
                  (name) => ({
                    name,
                    kind: ts.ScriptElementKind.string,
                    insertText: `${"${0}"} ${name}`,
                    isSnippet: true
                  })
                );
              }
            }
          }
        }
      }
    }
    return [];
  })
});

// src/refactors/writeTagClassAccessors.ts
var generate = fn("writeTagClassAccessors.generate")(function* (sourceFile, service2, className, atLocation, involvedMembers) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const changeTracker = yield* service(ChangeTracker);
  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1;
  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Effect"
  ) || "Effect";
  const createFunctionProperty = (className2, propertyName, type, forceAny) => {
    const arrowBody = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectIdentifier),
        "andThen"
      ),
      void 0,
      [
        ts.factory.createIdentifier(ts.idText(className2)),
        ts.factory.createArrowFunction(
          void 0,
          void 0,
          [ts.factory.createParameterDeclaration(
            void 0,
            void 0,
            "_",
            void 0,
            forceAny ? ts.factory.createTypeReferenceNode("any") : void 0
          )],
          void 0,
          void 0,
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createIdentifier("_"),
              propertyName
            ),
            void 0,
            [
              ts.factory.createSpreadElement(ts.factory.createIdentifier("args"))
            ]
          )
        )
      ]
    );
    return ts.factory.createPropertyDeclaration(
      [
        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),
        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)
      ],
      propertyName,
      void 0,
      type,
      ts.factory.createArrowFunction(
        void 0,
        void 0,
        [ts.factory.createParameterDeclaration(
          void 0,
          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),
          "args",
          void 0,
          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode("any")) : void 0
        )],
        void 0,
        void 0,
        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode("any")) : arrowBody
      )
    );
  };
  const generateReturnType = (type, atLocation2, className2) => pipe(
    typeParser.effectType(type, atLocation2),
    flatMap4((returnedEffect) => {
      const contextType = returnedEffect.R.flags & ts.TypeFlags.Never ? ts.factory.createTypeReferenceNode(ts.idText(className2)) : ts.factory.createUnionTypeNode(
        [
          ts.factory.createTypeReferenceNode(ts.idText(className2)),
          typeChecker.typeToTypeNode(returnedEffect.R, atLocation2, ts.NodeBuilderFlags.NoTruncation)
        ]
      );
      const successType = typeChecker.typeToTypeNode(
        returnedEffect.A,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!successType) return fail3("error generating success type");
      const failureType = typeChecker.typeToTypeNode(
        returnedEffect.E,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!failureType) return fail3("error generating failure type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [successType, failureType, contextType]
      );
      return succeed(typeNode);
    }),
    orElse2(
      () => pipe(
        typeParser.promiseLike(type, atLocation2),
        flatMap4(({ type: type2 }) => {
          const successType = typeChecker.typeToTypeNode(
            type2,
            atLocation2,
            ts.NodeBuilderFlags.NoTruncation
          );
          if (!successType) return fail3("error generating success type");
          return succeed(ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectIdentifier),
              ts.factory.createIdentifier("Effect")
            ),
            [
              successType,
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier("Cause"),
                  ts.factory.createIdentifier("UnknownException")
                )
              ),
              ts.factory.createTypeReferenceNode(ts.idText(className2))
            ]
          ));
        })
      )
    ),
    orElse2(() => {
      const successType = typeChecker.typeToTypeNode(type, atLocation2, ts.NodeBuilderFlags.NoTruncation);
      if (!successType) return fail3("error generating success type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [
          successType,
          ts.factory.createTypeReferenceNode("never"),
          ts.factory.createTypeReferenceNode(ts.idText(className2))
        ]
      );
      return succeed(typeNode);
    })
  );
  const proxySignature = (signature, atLocation2, className2) => gen(function* () {
    const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(
      signature,
      ts.SyntaxKind.FunctionType,
      atLocation2,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!signatureDeclaration) return yield* fail3("error generating signature");
    const returnType = yield* generateReturnType(
      typeChecker.getReturnTypeOfSignature(signature),
      atLocation2,
      className2
    );
    return ts.factory.createFunctionTypeNode(
      signatureDeclaration.typeParameters,
      signatureDeclaration.parameters,
      returnType
    );
  });
  for (const { property, propertyType } of involvedMembers) {
    const callSignatures = [];
    let propertyDeclaration = void 0;
    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {
      yield* pipe(
        proxySignature(signature, atLocation, className),
        map8((sig) => {
          callSignatures.push(sig);
        }),
        ignore
      );
    }
    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures);
    const type = tsUtils.simplifyTypeNode(allSignatures);
    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1);
    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {
      const symbol3 = typeChecker.getSymbolAtLocation(p.name);
      return symbol3 && ts.symbolName(symbol3) === ts.symbolName(property);
    });
    if (oldProperty) {
      const start = ts.getTokenPosOfNode(oldProperty, sourceFile);
      changeTracker.deleteRange(sourceFile, {
        pos: start,
        end: oldProperty.end
      });
      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration);
    } else {
      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: "\n" });
    }
  }
});
var parse2 = fn("writeTagClassAccessors.parse")(function* (node) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  if (!ts.isClassDeclaration(node)) return yield* fail3("not a class declaration");
  const { Service, accessors: accessors2, className, kind } = yield* pipe(
    map8(typeParser.extendsEffectService(node), (_) => ({ kind: "effectService", ..._ })),
    orElse2(
      () => map8(typeParser.extendsEffectTag(node), (_) => ({ kind: "effectTag", accessors: true, ..._ }))
    ),
    orElse2(() => fail3("not a class extending Effect.Service call"))
  );
  if (accessors2 !== true) return yield* fail3("accessors are not enabled in the Effect.Service call");
  const involvedMembers = [];
  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter(
    (_) => !(_.flags & ts.TypeFlags.Number || _.flags & ts.TypeFlags.String || _.flags & ts.TypeFlags.Boolean || _.flags & ts.TypeFlags.Literal)
  );
  if (nonPrimitiveServices.length === 0) return yield* fail3("Service type is a primitive type");
  for (const serviceShape of nonPrimitiveServices) {
    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {
      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node);
      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call);
      if (callSignatures.length > 0) {
        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0);
        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType });
      }
    }
  }
  const hash2 = involvedMembers.map(({ property, propertyType }) => {
    return ts.symbolName(property) + ": " + typeChecker.typeToString(propertyType);
  }).concat([ts.idText(className)]).join("\n");
  return { Service, className, atLocation: node, hash: cyrb53(hash2), involvedMembers, kind };
});
var writeTagClassAccessors = createRefactor({
  name: "writeTagClassAccessors",
  description: "Implement accessors methods with generics or multiple signatures",
  apply: fn("writeTagClassAccessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseNode = (node) => pipe(
      parse2(node),
      map8(({ Service, atLocation, className, involvedMembers }) => ({
        kind: "refactor.rewrite.effect.writeTagClassAccessors",
        description: "Implement Service accessors",
        apply: pipe(
          generate(sourceFile, Service, className, atLocation, involvedMembers),
          provideService(TypeScriptUtils, tsUtils),
          provideService(TypeParser, typeParser),
          provideService(TypeCheckerApi, typeChecker),
          provideService(TypeScriptApi, ts)
        )
      }))
    );
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(parentNodes.map(parseNode)),
      orElse2(() => fail3(new RefactorNotApplicableError()))
    );
  })
});

// src/codegens/accessors.ts
var accessors = createCodegen({
  name: "accessors",
  apply: fn("accessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail3(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse2(nodeAndCommentRange.node),
      map8(
        (_) => ({
          hash: _.hash,
          description: "Generate accessors for the service",
          apply: pipe(
            generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeParser, typeParser),
            provideService(TypeCheckerUtils, typeCheckerUtils)
          )
        })
      ),
      orElse2((cause) => fail3(new CodegenNotApplicableError(cause)))
    );
  })
});

// src/codegens/annotate.ts
var annotate = createCodegen({
  name: "annotate",
  apply: fn("annotate.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const parse3 = (node) => gen(function* () {
      let variableDeclarations = [];
      const result = [];
      if (ts.isVariableStatement(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarationList.declarations];
      } else if (ts.isVariableDeclarationList(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarations];
      } else if (ts.isVariableDeclaration(node)) {
        variableDeclarations = [...variableDeclarations, node];
      }
      if (variableDeclarations.length === 0) {
        return yield* fail3(new CodegenNotApplicableError("not a variable declaration"));
      }
      for (const variableDeclaration of variableDeclarations) {
        if (!variableDeclaration.initializer) continue;
        const initializerType = typeCheckerUtils.getTypeAtLocation(variableDeclaration.initializer);
        if (!initializerType) continue;
        const enclosingNode = ts.findAncestor(variableDeclaration, (_) => tsUtils.isDeclarationKind(_.kind)) || sourceFile;
        const initializerTypeNode = fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
          initializerType,
          enclosingNode,
          ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.IgnoreErrors
        )).pipe(
          getOrUndefined
        );
        if (!initializerTypeNode) continue;
        const typeNodeString = typeChecker.typeToString(initializerType, void 0, ts.TypeFormatFlags.NoTruncation);
        const hash3 = cyrb53(typeNodeString);
        result.push({ variableDeclaration, initializerTypeNode, hash: hash3 });
      }
      if (result.length === 0) {
        return yield* fail3(new CodegenNotApplicableError("no variable declarations with initializers"));
      }
      const hash2 = cyrb53(result.map((_) => _.hash).join("/"));
      return {
        hash: hash2,
        result
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail3(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse3(nodeAndCommentRange.node),
      map8(
        (_) => ({
          hash: _.hash,
          description: "Annotate with type",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            for (const { initializerTypeNode, variableDeclaration } of _.result) {
              if (variableDeclaration.type) {
                changeTracker.deleteRange(sourceFile, {
                  pos: variableDeclaration.name.end,
                  end: variableDeclaration.type.end
                });
              }
              changeTracker.insertNodeAt(
                sourceFile,
                variableDeclaration.name.end,
                initializerTypeNode,
                {
                  prefix: ": "
                }
              );
            }
          })
        })
      )
    );
  })
});

// src/utils/StructuralSchemaGen.ts
var UnsupportedTypeError = class {
  constructor(type, reason) {
    this.type = type;
    this.reason = reason;
  }
  _tag = "@effect/language-service/UnsupportedTypeError";
  toString() {
    return `Unsupported type: ${this.reason}`;
  }
};
var StructuralSchemaGenContext = Tag("StructuralSchemaGenContext");
var makeStructuralSchemaGenContext = fn("StructuralSchemaGen.makeContext")(
  function* (sourceFile, schemaIdentifier) {
    const ts = yield* service(TypeScriptApi);
    const program = yield* service(TypeScriptProgram);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const effectSchemaIdentifier = schemaIdentifier || "Schema";
    return identity({
      ts,
      program,
      typeChecker,
      typeCheckerUtils,
      sourceFile,
      createApiPropertyAccess: (apiName) => ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaIdentifier),
        apiName
      ),
      createApiCall: (apiName, args2) => ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          ts.factory.createIdentifier(effectSchemaIdentifier),
          apiName
        ),
        [],
        args2
      ),
      hoistedSchemas: /* @__PURE__ */ new Map(),
      typeToStatementIndex: /* @__PURE__ */ new Map(),
      nameToType: /* @__PURE__ */ new Map(),
      usedGlobalIdentifiers: /* @__PURE__ */ new Map(),
      schemaStatements: [],
      rangesToDelete: []
    });
  }
);
var pushHoistedStatement = fn("StructuralSchemaGen.pushHoistedStatement")(
  function* (ctx, name, type, statement, createReference) {
    ctx.usedGlobalIdentifiers.set(name, (ctx.usedGlobalIdentifiers.get(name) || 0) + 1);
    ctx.schemaStatements.push(statement);
    ctx.typeToStatementIndex.set(type, ctx.schemaStatements.length - 1);
    ctx.hoistedSchemas.set(type, createReference);
  }
);
var pushHoistedVariableStatement = fn("StructuralSchemaGen.pushHoistedVariableStatement")(
  function* (ts, ctx, name, type, result) {
    return yield* pushHoistedStatement(
      ctx,
      name,
      type,
      ts.factory.createVariableStatement(
        void 0,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(ts.factory.createIdentifier(name), void 0, void 0, result)],
          ts.NodeFlags.Const
        )
      ),
      () => ts.factory.createIdentifier(name)
    );
  }
);
var createProcessingContext = (maxDepth = 200) => ({
  depth: 0,
  maxDepth,
  hoistName: void 0
});
var processType = fn(
  "StructuralSchemaGen.processType"
)(
  function* (type, context) {
    const processingContext = context || createProcessingContext();
    const { hoistedSchemas, nameToType, ts, typeChecker, usedGlobalIdentifiers } = yield* service(
      StructuralSchemaGenContext
    );
    if (processingContext.depth >= processingContext.maxDepth) {
      return yield* fail3(new UnsupportedTypeError(type, "Maximum depth exceeded"));
    }
    let hoistName = fromIterable(nameToType.entries()).find(([_, existingType]) => existingType === type)?.[0];
    if (!hoistName && type && type.symbol && type.symbol.declarations && type.symbol.declarations.length === 1) {
      const declaration = type.symbol.declarations[0];
      if (ts.isInterfaceDeclaration(declaration)) {
        hoistName = ts.idText(declaration.name);
      } else if (declaration.parent && ts.isTypeAliasDeclaration(declaration.parent)) {
        hoistName = ts.idText(declaration.parent.name);
      }
      if (hoistName) {
        const existingType = nameToType.get(hoistName);
        const isSame = existingType && typeChecker.isTypeAssignableTo(type, existingType) && typeChecker.isTypeAssignableTo(existingType, type);
        if (!isSame) {
          const usedCount = usedGlobalIdentifiers.get(hoistName) || 0;
          usedGlobalIdentifiers.set(hoistName, usedCount + 1);
          hoistName = usedCount > 0 ? hoistName + "_" + usedCount : hoistName;
        }
      }
    }
    const nestedContext = {
      ...processingContext,
      depth: processingContext.depth + 1,
      hoistName
    };
    for (const [hoistedType, hoistedSchema] of hoistedSchemas.entries()) {
      if (hoistedType === type || typeChecker.isTypeAssignableTo(type, hoistedType) && typeChecker.isTypeAssignableTo(hoistedType, type)) {
        return hoistedSchema();
      }
    }
    const [schemaExpr, skipHoisting] = yield* processTypeImpl(type, nestedContext);
    if (!skipHoisting && hoistName) {
      const ctx = yield* service(StructuralSchemaGenContext);
      yield* pushHoistedVariableStatement(ts, ctx, hoistName, type, schemaExpr);
      return ctx.hoistedSchemas.get(type)();
    }
    return schemaExpr;
  }
);
var processTypeImpl = fn(
  "StructuralSchemaGen.processTypeImpl"
)(
  function* (type, context) {
    const { createApiCall, createApiPropertyAccess, ts, typeChecker, typeCheckerUtils } = yield* service(
      StructuralSchemaGenContext
    );
    if (type.flags & ts.TypeFlags.String) {
      return [createApiPropertyAccess("String"), true];
    }
    if (type.flags & ts.TypeFlags.Number) {
      return [createApiPropertyAccess("Number"), true];
    }
    if (type.flags & ts.TypeFlags.Boolean) {
      return [createApiPropertyAccess("Boolean"), true];
    }
    if (type.flags & ts.TypeFlags.BigInt) {
      return [createApiPropertyAccess("BigInt"), true];
    }
    if (type.flags & ts.TypeFlags.Void) {
      return [createApiPropertyAccess("Void"), true];
    }
    if (type.flags & ts.TypeFlags.Undefined) {
      return [createApiPropertyAccess("Undefined"), true];
    }
    if (type.flags & ts.TypeFlags.Null) {
      return [createApiPropertyAccess("Null"), true];
    }
    if (type.flags & ts.TypeFlags.Never) {
      return [createApiPropertyAccess("Never"), true];
    }
    if (type.flags & ts.TypeFlags.Any) {
      return [createApiPropertyAccess("Any"), true];
    }
    if (type.flags & ts.TypeFlags.Unknown) {
      return [createApiPropertyAccess("Unknown"), true];
    }
    if (type.flags & ts.TypeFlags.StringLiteral) {
      const literalType = type;
      return [createApiCall("Literal", [ts.factory.createStringLiteral(literalType.value)]), true];
    }
    if (type.flags & ts.TypeFlags.NumberLiteral) {
      const literalType = type;
      return [createApiCall("Literal", [ts.factory.createNumericLiteral(literalType.value)]), true];
    }
    if (type.flags & ts.TypeFlags.BooleanLiteral) {
      const value = type.intrinsicName === "true";
      return [createApiCall("Literal", [value ? ts.factory.createTrue() : ts.factory.createFalse()]), true];
    }
    if (typeCheckerUtils.isUnion(type)) {
      return yield* processUnionType(type.types, context);
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      return yield* processIntersectionType(type, context);
    }
    if (typeChecker.isArrayType(type)) {
      return yield* processArrayType(type, context);
    }
    if (typeChecker.isTupleType(type)) {
      return yield* processTupleType(type, context);
    }
    if (type.flags & ts.TypeFlags.Object) {
      const symbol3 = type.symbol || type.aliasSymbol;
      if (symbol3) {
        const typeName = typeChecker.symbolToString(symbol3);
        if (typeName === "Date") {
          return [createApiPropertyAccess("Date"), false];
        }
        if (typeName === "ReadonlyArray" || typeName === "Array") {
          return yield* processArrayType(type, context);
        }
      }
      const objectType = type;
      return yield* processObjectType(objectType, context);
    }
    return yield* fail3(
      new UnsupportedTypeError(
        type,
        `Type with flags ${type.flags} is not supported`
      )
    );
  }
);
var processUnionType = fn(
  "StructuralSchemaGen.processUnionType"
)(
  function* (types, context) {
    const { createApiCall, ts } = yield* service(StructuralSchemaGenContext);
    const allLiterals = types.every(
      (t) => t.flags & ts.TypeFlags.StringLiteral || t.flags & ts.TypeFlags.NumberLiteral || t.flags & ts.TypeFlags.BooleanLiteral
    );
    if (allLiterals) {
      const literals = yield* all(
        ...types.map((t) => processType(t, context))
      );
      const literalValues = literals.map((expr) => {
        if (ts.isCallExpression(expr) && expr.arguments.length > 0) {
          return expr.arguments[0];
        }
        return expr;
      }).filter((arg) => arg !== void 0);
      return [createApiCall("Literal", literalValues), false];
    }
    const members = yield* all(
      ...types.map((t) => processType(t, context))
    );
    if (members.length === 1) {
      return [members[0], false];
    }
    return [createApiCall("Union", members), false];
  }
);
var processIntersectionType = fn(
  "StructuralSchemaGen.processIntersectionType"
)(
  function* (type, context) {
    const { createApiCall, ts } = yield* service(StructuralSchemaGenContext);
    const [firstSchema, ...otherSchemas] = yield* all(
      ...type.types.map((t) => processType(t, context))
    );
    if (otherSchemas.length === 0) {
      return [firstSchema, false];
    }
    return [
      ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          firstSchema,
          "pipe"
        ),
        [],
        otherSchemas.map((schema) => createApiCall("extend", [schema]))
      ),
      false
    ];
  }
);
var processArrayType = fn(
  "StructuralSchemaGen.processArrayType"
)(
  function* (type, context) {
    const { createApiCall, typeChecker, typeCheckerUtils } = yield* service(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type);
    if (typeArgs.length === 0) {
      return yield* fail3(new UnsupportedTypeError(type, "Array type has no type arguments"));
    }
    const elementSchema = yield* processType(typeArgs[0], context);
    const expr = createApiCall("Array", [elementSchema]);
    if (typeCheckerUtils.isReadonlyArrayType(type)) return [expr, false];
    return [createApiCall("mutable", [expr]), false];
  }
);
var processTupleType = fn(
  "StructuralSchemaGen.processTupleType"
)(
  function* (type, context) {
    const { createApiCall, typeChecker } = yield* service(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type);
    const elementSchemas = yield* all(
      ...typeArgs.map((t) => processType(t, context))
    );
    return [createApiCall("Tuple", elementSchemas), false];
  }
);
var processObjectType = fn(
  "StructuralSchemaGen.processObjectType"
)(
  function* (type, context) {
    const {
      createApiCall,
      createApiPropertyAccess,
      program,
      ts,
      typeChecker,
      typeCheckerUtils
    } = yield* service(
      StructuralSchemaGenContext
    );
    let hasRecords = false;
    const properties = typeChecker.getPropertiesOfType(type);
    const propertyAssignments = [];
    for (const property of properties) {
      const propertyName = typeChecker.symbolToString(property);
      const propertyType = typeChecker.getTypeOfSymbol(property);
      const isOptional = (property.flags & ts.SymbolFlags.Optional) !== 0;
      let schemaExpr;
      if (isOptional) {
        if (program.getCompilerOptions().exactOptionalPropertyTypes) {
          if (typeCheckerUtils.isUnion(propertyType)) {
            const typeWithoutMissing = propertyType.types.filter((t) => !typeCheckerUtils.isMissingIntrinsicType(t));
            const [result, _] = yield* processUnionType(typeWithoutMissing, context);
            schemaExpr = createApiCall("optionalWith", [
              result,
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("exact", ts.factory.createTrue())
              ])
            ]);
          }
        } else {
          schemaExpr = yield* processType(propertyType, context);
          schemaExpr = createApiCall("optional", [schemaExpr]);
        }
      }
      if (!schemaExpr) {
        schemaExpr = yield* processType(propertyType, context);
      }
      const propertyNameNode = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName) ? ts.factory.createIdentifier(propertyName) : ts.factory.createStringLiteral(propertyName);
      propertyAssignments.push(
        ts.factory.createPropertyAssignment(
          propertyNameNode,
          schemaExpr
        )
      );
    }
    const indexInfos = typeChecker.getIndexInfosOfType(type);
    const args2 = [
      ts.factory.createObjectLiteralExpression(propertyAssignments, propertyAssignments.length > 0)
    ];
    for (const indexInfo of indexInfos) {
      hasRecords = true;
      const keyType = indexInfo.keyType;
      const valueType = indexInfo.type;
      const keySchema = yield* processType(keyType, context);
      const valueSchema = yield* processType(valueType, context);
      args2.push(
        ts.factory.createObjectLiteralExpression([
          ts.factory.createPropertyAssignment("key", keySchema),
          ts.factory.createPropertyAssignment("value", valueSchema)
        ])
      );
    }
    if (!hasRecords && context.hoistName) {
      const ctx = yield* service(StructuralSchemaGenContext);
      yield* pushHoistedStatement(
        ctx,
        context.hoistName,
        type,
        ts.factory.createClassDeclaration(
          void 0,
          ts.factory.createIdentifier(context.hoistName),
          [],
          [ts.factory.createHeritageClause(
            ts.SyntaxKind.ExtendsKeyword,
            [
              ts.factory.createExpressionWithTypeArguments(
                ts.factory.createCallExpression(
                  ts.factory.createCallExpression(
                    createApiPropertyAccess("Class"),
                    [ts.factory.createTypeReferenceNode(
                      context.hoistName
                    )],
                    [ts.factory.createStringLiteral(context.hoistName)]
                  ),
                  [],
                  args2
                ),
                []
              )
            ]
          )],
          []
        ),
        () => ts.factory.createIdentifier(context.hoistName)
      );
      return [ctx.hoistedSchemas.get(type)(), true];
    }
    return [createApiCall("Struct", args2), propertyAssignments.length === 0];
  }
);
var findNodeToProcess = fn("StructuralSchemaGen.findNodeToProcess")(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),
      filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),
      filter((node) => (node.typeParameters || []).length === 0),
      map4((node) => ({
        node,
        identifier: node.name,
        type: typeCheckerUtils.getTypeAtLocation(node.name),
        isExported: node.modifiers ? (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 : false
      })),
      filter(({ type }) => !!type),
      head
    );
  }
);
var process = fn("StructuralSchemaGen.process")(
  function* (sourceFile, scope, typeMap, isExported, handleCodegeneratedComments) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Schema") || "Schema";
    const ctx = yield* makeStructuralSchemaGenContext(sourceFile, schemaIdentifier);
    for (const [name, type] of typeMap.entries()) {
      ctx.nameToType.set(name, type);
    }
    if (handleCodegeneratedComments) {
      for (const declaration of sourceFile.statements) {
        const nodeText = sourceFile.text.slice(declaration.pos, declaration.end);
        if (!nodeText.toLowerCase().includes("@effect-schema-codegenerated")) continue;
        const interleavingRange = ctx.rangesToDelete.find(
          (range) => range.pos < declaration.end && range.end > declaration.pos
        );
        if (interleavingRange) {
          interleavingRange.pos = Math.min(interleavingRange.pos, declaration.pos);
          interleavingRange.end = Math.max(interleavingRange.end, declaration.end);
        } else {
          ctx.rangesToDelete.push({
            pos: declaration.pos,
            end: declaration.end
          });
        }
      }
    }
    for (const symbol3 of typeChecker.getSymbolsInScope(scope, ts.SymbolFlags.Value)) {
      const name = typeChecker.symbolToString(symbol3);
      ctx.usedGlobalIdentifiers.set(name, 1);
      const type = typeChecker.getTypeOfSymbolAtLocation(symbol3, sourceFile);
      if (type) {
        const schemaType = yield* pipe(
          typeParser.effectSchemaType(type, scope),
          orElse2(() => void_)
        );
        if (schemaType) {
          ctx.hoistedSchemas.set(
            schemaType.A,
            () => {
              const expression = typeChecker.symbolToExpression(
                symbol3,
                ts.SymbolFlags.Value,
                scope,
                ts.NodeBuilderFlags.NoTruncation
              );
              if (expression) {
                return expression;
              }
              return ts.factory.createIdentifier(name);
            }
          );
        }
      }
    }
    const results = yield* pipe(
      all(
        ...fromIterable(ctx.nameToType.entries()).map(
          ([name, type]) => pipe(
            processType(type),
            orElse2(
              (error) => succeed(ts.addSyntheticLeadingComment(
                ts.factory.createIdentifier(""),
                ts.SyntaxKind.MultiLineCommentTrivia,
                " " + String(error) + " ",
                true
              ))
            ),
            map8((_) => ({ requestedName: name, type, result: _ }))
          )
        )
      ),
      provideService(StructuralSchemaGenContext, ctx)
    );
    for (const { requestedName, result, type } of results) {
      const statementIndex = ctx.typeToStatementIndex.get(type);
      if (statementIndex !== void 0) continue;
      ctx.schemaStatements.push(ts.factory.createVariableStatement(
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            ts.factory.createIdentifier(requestedName),
            void 0,
            void 0,
            result
          )],
          ts.NodeFlags.Const
        )
      ));
      ctx.typeToStatementIndex.set(type, ctx.schemaStatements.length - 1);
    }
    if (isExported) {
      const statementsToExport = pipe(
        fromIterable(ctx.nameToType),
        map4(([_, type]) => ctx.typeToStatementIndex.get(type)),
        filter((index) => index !== void 0),
        dedupe
      );
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        if (!statementsToExport.includes(i)) continue;
        const statement = ctx.schemaStatements[i];
        if (ts.isVariableStatement(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateVariableStatement(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.declarationList
          );
        } else if (ts.isClassDeclaration(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateClassDeclaration(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.name,
            statement.typeParameters,
            statement.heritageClauses,
            statement.members
          );
        }
      }
    }
    if (handleCodegeneratedComments) {
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        const statement = ctx.schemaStatements[i];
        ctx.schemaStatements[i] = ts.addSyntheticLeadingComment(
          statement,
          ts.SyntaxKind.SingleLineCommentTrivia,
          " @effect-schema-codegenerated: This schema will be re-generated by the effect-schema-codegens command, remove this comment to disable re-generation.",
          true
        );
      }
    }
    return ctx;
  }
);
var applyAtNode = fn("StructuralSchemaGen.applyAtNode")(
  function* (sourceFile, node, identifier, type, isExported) {
    const changeTracker = yield* service(ChangeTracker);
    const ts = yield* service(TypeScriptApi);
    const ctx = yield* process(sourceFile, node, /* @__PURE__ */ new Map([[ts.idText(identifier), type]]), isExported, false);
    for (const statement of ctx.schemaStatements) {
      changeTracker.insertNodeAt(sourceFile, node.pos, statement, { prefix: "\n", suffix: "\n" });
    }
  }
);

// src/codegens/typeToSchema.ts
var typeToSchema = createCodegen({
  name: "typeToSchema",
  apply: fn("typeToSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const program = yield* service(TypeScriptProgram);
    const inThisFile = yield* getCodegensForSourceFile([typeToSchema], sourceFile);
    if (inThisFile.length > 1) {
      return yield* fail3(
        new CodegenNotApplicableError("the typeToSchema codegen can be used only once per file")
      );
    }
    const parse3 = (node) => gen(function* () {
      if (!ts.isTypeAliasDeclaration(node)) {
        return yield* fail3(
          new CodegenNotApplicableError(
            "this codegen is applicable only to a type alias where each object member is a schema to generate. e.g. `type ToGenerate = { UserSchema: User, TodoSchema: Todo}`"
          )
        );
      }
      const type = typeCheckerUtils.getTypeAtLocation(node.name);
      if (!type) {
        return yield* fail3(
          new CodegenNotApplicableError(
            "error getting the type to process"
          )
        );
      }
      const nameToType = /* @__PURE__ */ new Map();
      const typeProperties = typeChecker.getPropertiesOfType(type);
      for (const symProp of typeProperties) {
        const symName = ts.symbolName(symProp);
        const propType = typeChecker.getTypeOfSymbolAtLocation(symProp, node);
        if (propType) nameToType.set(symName, propType);
      }
      const hash2 = pipe(
        fromIterable(nameToType),
        map4(([name, type2]) => {
          const typeString = typeChecker.typeToString(
            type2,
            node,
            ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.UseStructuralFallback
          );
          return name + ": " + typeString;
        }),
        join("\n"),
        cyrb53
      );
      return {
        hash: hash2,
        nameToType
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) {
      return yield* fail3(new CodegenNotApplicableError("no node and comment range affected"));
    }
    return yield* pipe(
      parse3(nodeAndCommentRange.node),
      map8(
        (_) => ({
          hash: _.hash,
          description: "Generate Schemas from types",
          apply: pipe(
            gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const ctx = yield* process(
                sourceFile,
                nodeAndCommentRange.node,
                _.nameToType,
                true,
                true
              );
              const pos = sourceFile.end;
              for (const range of ctx.rangesToDelete) {
                changeTracker.deleteRange(sourceFile, range);
              }
              for (const statement of ctx.schemaStatements) {
                changeTracker.insertNodeAt(sourceFile, pos, statement, { prefix: "\n", suffix: "\n" });
              }
            }),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeCheckerUtils, typeCheckerUtils),
            provideService(TypeParser, typeParser),
            provideService(TypeScriptProgram, program)
          )
        })
      )
    );
  })
});

// src/codegens.ts
var codegens = [accessors, annotate, typeToSchema];

// src/completions/effectCodegensComment.ts
var effectCodegensComment = createCompletion({
  name: "effectCodegensComment",
  apply: fn("effectCodegensComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      const allCodegens = sort(Object.values(codegens).map((codegen) => codegen.name), string2).join(",");
      const enableSnippet = "${1|" + allCodegens + "|} $0";
      return [{
        name: `@effect-codegens`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-codegens " + enableSnippet,
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectDataClasses.ts
var effectDataClasses = createCompletion({
  name: "effectDataClasses",
  apply: fn("effectDataClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const effectDataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Data"
    ) || "Data";
    const isFullyQualified = effectDataIdentifier === ts.idText(accessedObject);
    const name = ts.idText(className);
    const errorTagKey = (yield* createString(sourceFile, name, "error")) || name;
    const completions2 = [];
    const hasTaggedErrorCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectDataModuleApi("TaggedError")(accessedObject),
        option
      )
    );
    if (hasTaggedErrorCompletion) {
      completions2.push({
        name: `TaggedError("${name}")`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${effectDataIdentifier}.TaggedError("${errorTagKey}")<{${"${0}"}}>{}` : `TaggedError("${errorTagKey}")<{${"${0}"}}>{}`,
        replacementSpan,
        isSnippet: true
      });
    }
    const hasTaggedClassCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectDataModuleApi("TaggedClass")(accessedObject),
        option
      )
    );
    if (hasTaggedClassCompletion) {
      completions2.push({
        name: `TaggedClass("${name}")`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${effectDataIdentifier}.TaggedClass("${name}")<{${"${0}"}}>{}` : `TaggedClass("${name}")<{${"${0}"}}>{}`,
        replacementSpan,
        isSnippet: true
      });
    }
    return completions2;
  })
});

// src/diagnostics/anyUnknownInErrorContext.ts
var anyUnknownInErrorContext = createDiagnostic({
  name: "anyUnknownInErrorContext",
  code: 28,
  description: "Detects 'any' or 'unknown' types in Effect error or requirements channels",
  severity: "off",
  apply: fn("anyUnknownInErrorContext.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const isAnyOrUnknown = (type) => (type.flags & ts.TypeFlags.Any) > 0 || (type.flags & ts.TypeFlags.Unknown) > 0;
    const matchingNodes = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.pop();
      if (ts.isTypeNode(node)) continue;
      if (ts.isTypeAliasDeclaration(node)) continue;
      if (ts.isInterfaceDeclaration(node)) continue;
      if (ts.isAsExpression(node) && node.type && node.type.kind === ts.SyntaxKind.AnyKeyword) {
        continue;
      }
      if (ts.isParameter(node) || ts.isPropertyDeclaration(node) || ts.isVariableDeclaration(node)) {
        if (node.type) {
          const typeNode = node.type;
          const type2 = typeCheckerUtils.getTypeAtLocation(node.type);
          if (!type2) continue;
          const expectedEffect = yield* pipe(
            typeParser.strictEffectType(type2, node.type),
            orElse2(() => typeParser.layerType(type2, typeNode)),
            orElse2(() => void_)
          );
          if (expectedEffect) continue;
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isExpression(node)) continue;
      let type = typeCheckerUtils.getTypeAtLocation(node);
      if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          type = typeChecker.getReturnTypeOfSignature(resolvedSignature);
        }
      }
      if (!type) continue;
      yield* pipe(
        typeParser.strictEffectType(type, node),
        orElse2(() => pipe(typeParser.layerType(type, node), map8(({ E, RIn }) => ({ E, R: RIn })))),
        map8((effectOrLayer) => {
          const { E, R } = effectOrLayer;
          const hasAnyUnknownR = isAnyOrUnknown(R);
          const hasAnyUnknownE = isAnyOrUnknown(E);
          if (hasAnyUnknownR || hasAnyUnknownE) {
            const channels = [];
            if (hasAnyUnknownR) {
              const typeName = R.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the requirements channel`);
            }
            if (hasAnyUnknownE) {
              const typeName = E.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the error channel`);
            }
            const nodeStart = ts.getTokenPosOfNode(node, sourceFile);
            const nodeEnd = node.end;
            for (let i = matchingNodes.length - 1; i >= 0; i--) {
              const existing = matchingNodes[i];
              const existingStart = ts.getTokenPosOfNode(existing.node, sourceFile);
              const existingEnd = existing.node.end;
              if (existingStart <= nodeStart && existingEnd >= nodeEnd) {
                matchingNodes.splice(i, 1);
              }
            }
            const suggestions = [`This has ${channels.join(" and ")} which is not recommended.`];
            if (hasAnyUnknownR) {
              suggestions.push(`Only service identifiers should appear in the requirements channel.`);
            }
            if (hasAnyUnknownE) {
              suggestions.push(
                `Having an unknown or any error type is not useful. Consider instead using specific error types baked by Data.TaggedError for example.`
              );
            }
            channels.push(`If you plan to later on manually cast the type, you can safely disable this diagnostic.`);
            const messageText = suggestions.join("\n");
            matchingNodes.push({ messageText, node, type });
          }
        }),
        ignore
      );
    }
    for (const { messageText, node } of matchingNodes) {
      report({
        location: node,
        messageText,
        fixes: []
      });
    }
  })
});

// src/diagnostics/catchAllToMapError.ts
var catchAllToMapError = createDiagnostic({
  name: "catchAllToMapError",
  code: 39,
  description: "Suggests using Effect.mapError instead of Effect.catchAll when the callback only wraps the error with Effect.fail",
  severity: "suggestion",
  apply: fn("catchAllToMapError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const getFunctionBody = (node) => {
      if (ts.isArrowFunction(node)) {
        return node.body;
      }
      if (ts.isFunctionExpression(node)) {
        return node.body;
      }
      return void 0;
    };
    const getEffectFailCallInfo = (body) => {
      return gen(function* () {
        if (ts.isCallExpression(body)) {
          const isFailCall = yield* pipe(
            typeParser.isNodeReferenceToEffectModuleApi("fail")(body.expression),
            option
          );
          if (isSome2(isFailCall) && body.arguments.length >= 1) {
            return some2({ failCall: body, failArg: body.arguments[0] });
          }
        }
        if (ts.isBlock(body)) {
          const statements = body.statements;
          if (statements.length === 1) {
            const stmt = statements[0];
            if (ts.isReturnStatement(stmt) && stmt.expression && ts.isCallExpression(stmt.expression)) {
              const isFailCall = yield* pipe(
                typeParser.isNodeReferenceToEffectModuleApi("fail")(stmt.expression.expression),
                option
              );
              if (isSome2(isFailCall) && stmt.expression.arguments.length >= 1) {
                return some2({ failCall: stmt.expression, failArg: stmt.expression.arguments[0] });
              }
            }
          }
        }
        return none2();
      });
    };
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchAllCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("catchAll")(transformation.callee),
          option
        );
        if (isNone2(isCatchAllCall)) {
          continue;
        }
        const callback = transformation.args[0];
        if (!callback) continue;
        const functionBody = getFunctionBody(callback);
        if (!functionBody) continue;
        const failCallInfo = yield* getEffectFailCallInfo(functionBody);
        if (isNone2(failCallInfo)) continue;
        const { failArg, failCall } = failCallInfo.value;
        report({
          location: transformation.callee,
          messageText: `You can use Effect.mapError instead of Effect.catchAll + Effect.fail to transform the error type.`,
          fixes: [{
            fixName: "catchAllToMapError_fix",
            description: "Replace with Effect.mapError",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              if (ts.isPropertyAccessExpression(transformation.callee)) {
                changeTracker.replaceNode(
                  sourceFile,
                  transformation.callee.name,
                  ts.factory.createIdentifier("mapError")
                );
              }
              changeTracker.replaceNode(sourceFile, failCall, failArg);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/catchUnfailableEffect.ts
var catchUnfailableEffect = createDiagnostic({
  name: "catchUnfailableEffect",
  code: 2,
  description: "Warns when using error handling on Effects that never fail (error type is 'never')",
  severity: "suggestion",
  apply: fn("catchUnfailableEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const catchFunctions = ["catchAll", "catch", "catchIf", "catchSome", "catchTag", "catchTags"];
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (let i = 0; i < flow2.transformations.length; i++) {
        const transformation = flow2.transformations[i];
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchCall = yield* pipe(
          firstSuccessOf(
            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(transformation.callee))
          ),
          option
        );
        if (isNone2(isCatchCall)) {
          continue;
        }
        const inputType = i === 0 ? flow2.subject.outType : flow2.transformations[i - 1].outType;
        if (!inputType) {
          continue;
        }
        const effectType = yield* pipe(
          typeParser.effectType(inputType, transformation.callee),
          option
        );
        if (isSome2(effectType)) {
          const { E } = effectType.value;
          if (E.flags & ts.TypeFlags.Never) {
            report({
              location: transformation.callee,
              messageText: `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,
              fixes: []
            });
          }
        }
      }
    }
  })
});

// src/diagnostics/classSelfMismatch.ts
var classSelfMismatch = createDiagnostic({
  name: "classSelfMismatch",
  code: 20,
  description: "Ensures Self type parameter matches the class name in Service/Tag/Schema classes",
  severity: "error",
  apply: fn("classSelfMismatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => typeParser.extendsContextTag(node)),
          orElse2(() => typeParser.extendsEffectTag(node)),
          orElse2(() => typeParser.extendsSchemaClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => typeParser.extendsEffectSqlModelClass(node)),
          orElse2(() => void_)
        );
        if (result) {
          const { className, selfTypeNode } = result;
          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end);
          if (ts.isTypeReferenceNode(selfTypeNode)) {
            if (ts.isIdentifier(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName);
            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName.right);
            }
          }
          const expectedName = ts.idText(className);
          if (actualName !== expectedName) {
            report({
              location: selfTypeNode,
              messageText: `Self type parameter should be '${expectedName}'`,
              fixes: [{
                fixName: "classSelfMismatch_fix",
                description: `Replace '${actualName}' with '${expectedName}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : void 0;
                  const newTypeReference = ts.factory.createTypeReferenceNode(
                    ts.factory.createIdentifier(expectedName),
                    typeArgs
                  );
                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/deterministicKeys.ts
var deterministicKeys = createDiagnostic({
  name: "deterministicKeys",
  code: 25,
  description: "Enforces deterministic naming for service/tag/error identifiers based on class names",
  severity: "off",
  apply: fn("deterministicKeys.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeScriptUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    const parseExtendsCustom = cachedBy(
      fn("parseExtendsCustom")(function* (classDeclaration) {
        if (!options.extendedKeyDetection) {
          return yield* typeParserIssue("Extended key detection is disabled", void 0, classDeclaration);
        }
        if (!classDeclaration.name) {
          return yield* typeParserIssue("Class has no name", void 0, classDeclaration);
        }
        if (!ts.isIdentifier(classDeclaration.name)) {
          return yield* typeParserIssue("Class name is not an identifier", void 0, classDeclaration);
        }
        const heritageClauses = classDeclaration.heritageClauses;
        if (!heritageClauses) {
          return yield* typeParserIssue("Class has no heritage clauses", void 0, classDeclaration);
        }
        const nodeToVisit2 = [...classDeclaration.heritageClauses];
        const appendNodeToVisit2 = (node) => {
          nodeToVisit2.push(node);
          return void 0;
        };
        while (nodeToVisit2.length > 0) {
          const node = nodeToVisit2.shift();
          if (ts.isCallExpression(node)) {
            for (let i = 0; i < node.arguments.length; i++) {
              const arg = node.arguments[i];
              if (!ts.isStringLiteral(arg)) continue;
              const resolvedSignature = typeChecker.getResolvedSignature(node);
              if (resolvedSignature) {
                const parameter = resolvedSignature.parameters[i];
                if (!parameter) continue;
                if (parameter.declarations) {
                  for (const declaration of parameter.declarations) {
                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration);
                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end);
                    if (paramText.toLowerCase().includes("@effect-identifier")) {
                      return { className: classDeclaration.name, keyStringLiteral: arg, target: "custom" };
                    }
                  }
                }
              }
            }
          }
          ts.forEachChild(node, appendNodeToVisit2);
        }
        return yield* typeParserIssue(
          "Class does not extend any custom pattern",
          void 0,
          classDeclaration
        );
      }),
      "deterministicKeys.parseExtendsCustom",
      (classDeclaration) => classDeclaration
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          pipe(
            typeParser.extendsEffectService(node),
            orElse2(() => typeParser.extendsContextTag(node)),
            orElse2(() => typeParser.extendsEffectTag(node)),
            map8(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "service" }))
          ),
          orElse2(
            () => pipe(
              typeParser.extendsDataTaggedError(node),
              orElse2(() => typeParser.extendsSchemaTaggedError(node)),
              map8(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "error" }))
            )
          ),
          orElse2(() => parseExtendsCustom(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral) {
          const { className, keyStringLiteral, target } = result;
          const classNameText = ts.idText(className);
          const expectedKey = yield* createString(sourceFile, classNameText, target);
          if (!expectedKey) continue;
          const actualIdentifier = keyStringLiteral.text;
          if (actualIdentifier !== expectedKey) {
            report({
              location: keyStringLiteral,
              messageText: `Key should be '${expectedKey}'`,
              fixes: [{
                fixName: "deterministicKeys_fix",
                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey);
                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/duplicatePackage.ts
var checkedPackagesCache = /* @__PURE__ */ new Map();
var programResolvedCacheSize = /* @__PURE__ */ new Map();
var duplicatePackage = createDiagnostic({
  name: "duplicatePackage",
  code: 6,
  description: "Detects when multiple versions of the same Effect package are loaded",
  severity: "warning",
  apply: fn("duplicatePackage.apply")(function* (sourceFile, report) {
    const program = yield* service(TypeScriptProgram);
    const tsUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    if (sourceFile.statements.length < 1) return;
    let resolvedPackages = checkedPackagesCache.get(sourceFile.fileName) || {};
    const newResolvedModuleSize = hasProperty(program, "resolvedModules") && hasProperty(program.resolvedModules, "size") && isNumber(program.resolvedModules.size) ? program.resolvedModules.size : 0;
    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1;
    if (newResolvedModuleSize !== oldResolvedSize) {
      const seenPackages = /* @__PURE__ */ new Set();
      resolvedPackages = {};
      program.getSourceFiles().map((_) => {
        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_);
        if (!packageInfo) return;
        const packageNameAndVersion = packageInfo.name + "@" + packageInfo.version;
        if (seenPackages.has(packageNameAndVersion)) return;
        seenPackages.add(packageNameAndVersion);
        if (!(packageInfo.name === "effect" || packageInfo.hasEffectInPeerDependencies)) return;
        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return;
        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {};
        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory;
      });
      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages);
      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize);
    }
    for (const packageName of Object.keys(resolvedPackages)) {
      if (Object.keys(resolvedPackages[packageName]).length > 1) {
        const versions = Object.keys(resolvedPackages[packageName]);
        report({
          location: sourceFile.statements[0],
          messageText: `Package ${packageName} is referenced multiple times with different versions (${versions.join(", ")}) and may cause unexpected type errors.
Cleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.
If this is intended set the LSP config "allowedDuplicatedPackages" to ${JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))}.

${versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join("\n")}`,
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/effectFnIife.ts
var effectFnIife = createDiagnostic({
  name: "effectFnIife",
  code: 46,
  description: "Effect.fn or Effect.fnUntraced is called as an IIFE (Immediately Invoked Function Expression). Use Effect.gen instead.",
  severity: "warning",
  apply: fn("effectFnIife.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const innerCall = node.expression;
      if (!ts.isCallExpression(innerCall)) continue;
      const parsed = yield* pipe(
        typeParser.effectFnGen(innerCall),
        map8((result) => ({
          kind: "fn",
          effectModule: result.effectModule,
          generatorFunction: result.generatorFunction,
          pipeArguments: result.pipeArguments,
          traceExpression: result.traceExpression
        })),
        orElse2(
          () => pipe(
            typeParser.effectFnUntracedGen(innerCall),
            map8((result) => ({
              kind: "fnUntraced",
              effectModule: result.effectModule,
              generatorFunction: result.generatorFunction,
              pipeArguments: result.pipeArguments,
              traceExpression: void 0
            }))
          )
        ),
        orElse2(
          () => pipe(
            typeParser.effectFn(innerCall),
            map8((result) => ({
              kind: "fn",
              effectModule: result.effectModule,
              generatorFunction: void 0,
              pipeArguments: result.pipeArguments,
              traceExpression: result.traceExpression
            }))
          )
        ),
        option
      );
      if (isNone2(parsed)) continue;
      const { effectModule, generatorFunction, kind, pipeArguments: pipeArguments2, traceExpression } = parsed.value;
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      const fixes = [];
      if (generatorFunction && generatorFunction.parameters.length === 0) {
        fixes.push({
          fixName: "effectFnIife_toEffectGen",
          description: "Convert to Effect.gen",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const effectGenCall = ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleName),
                "gen"
              ),
              void 0,
              [generatorFunction]
            );
            let replacementNode = effectGenCall;
            if (pipeArguments2.length > 0) {
              replacementNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(effectGenCall, "pipe"),
                void 0,
                [...pipeArguments2]
              );
            }
            changeTracker.replaceNode(sourceFile, node, replacementNode);
          })
        });
      }
      const traceExpressionText = traceExpression ? sourceFile.text.slice(traceExpression.pos, traceExpression.end) : void 0;
      report({
        location: node,
        messageText: `${effectModuleName}.${kind} returns a reusable function that can take arguments, but here it's called immediately. Use Effect.gen instead${traceExpressionText ? ` with Effect.withSpan(${traceExpressionText}) piped in the end to mantain tracing spans` : ``}.`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectFnOpportunity.ts
var effectFnOpportunity = createDiagnostic({
  name: "effectFnOpportunity",
  code: 41,
  description: "Suggests using Effect.fn for functions that returns an Effect",
  severity: "suggestion",
  apply: fn("effectFnOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const findSingleReturnStatement = (block) => {
      if (block.statements.length !== 1) return void 0;
      const statement = block.statements[0];
      if (!ts.isReturnStatement(statement)) return void 0;
      return statement;
    };
    const getBodyExpression = (fnNode) => {
      if (ts.isArrowFunction(fnNode)) {
        if (ts.isBlock(fnNode.body)) {
          return findSingleReturnStatement(fnNode.body)?.expression;
        }
        return fnNode.body;
      } else if ((ts.isFunctionExpression(fnNode) || ts.isFunctionDeclaration(fnNode)) && fnNode.body) {
        return findSingleReturnStatement(fnNode.body)?.expression;
      }
      return void 0;
    };
    const getNameIdentifier = (node) => {
      if (ts.isFunctionDeclaration(node) && node.name) {
        return node.name;
      }
      if (node.parent && ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
        return node.parent.name;
      }
      if (node.parent && ts.isPropertyAssignment(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name) || ts.isStringLiteral(name)) {
          return name;
        }
      }
      if (node.parent && ts.isPropertyDeclaration(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name)) {
          return name;
        }
      }
      return void 0;
    };
    const areParametersReferencedIn = (fnNode, nodes2) => {
      if (fnNode.parameters.length === 0 || nodes2.length === 0) return false;
      const firstParam = fnNode.parameters[0];
      const lastParam = fnNode.parameters[fnNode.parameters.length - 1];
      const paramsStart = firstParam.pos;
      const paramsEnd = lastParam.end;
      const isSymbolDeclaredInParams = (symbol3) => {
        const declarations = symbol3.declarations;
        if (!declarations) return false;
        return declarations.some((decl) => decl.pos >= paramsStart && decl.end <= paramsEnd);
      };
      const nodesToVisit = [...nodes2];
      while (nodesToVisit.length > 0) {
        const node = nodesToVisit.shift();
        if (ts.isIdentifier(node)) {
          const symbol3 = typeChecker.getSymbolAtLocation(node);
          if (symbol3 && isSymbolDeclaredInParams(symbol3)) {
            return true;
          }
        }
        if (ts.isShorthandPropertyAssignment(node)) {
          const valueSymbol = typeChecker.getShorthandAssignmentValueSymbol(node);
          if (valueSymbol && isSymbolDeclaredInParams(valueSymbol)) {
            return true;
          }
        }
        ts.forEachChild(node, (child) => {
          nodesToVisit.push(child);
          return void 0;
        });
      }
      return false;
    };
    const tryExtractWithSpanExpression = (expr) => gen(function* () {
      if (!ts.isCallExpression(expr)) return void 0;
      const callee = expr.expression;
      const isWithSpan = yield* pipe(
        typeParser.isNodeReferenceToEffectModuleApi("withSpan")(callee),
        map8(() => true),
        orElse2(() => succeed(false))
      );
      if (!isWithSpan) return void 0;
      if (expr.arguments.length === 0) return void 0;
      return expr.arguments[0];
    });
    const tryParseGenOpportunity = (fnNode) => gen(function* () {
      const bodyExpression = getBodyExpression(fnNode);
      if (!bodyExpression) return yield* TypeParserIssue.issue;
      const { pipeArguments: pipeArguments2, subject } = yield* pipe(
        typeParser.pipeCall(bodyExpression),
        map8(({ args: args2, subject: subject2 }) => ({ subject: subject2, pipeArguments: args2 })),
        orElse2(() => succeed({ subject: bodyExpression, pipeArguments: [] }))
      );
      const { effectModule, generatorFunction } = yield* typeParser.effectGen(subject);
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      let explicitTraceExpression;
      if (pipeArguments2.length > 0) {
        const lastArg = pipeArguments2[pipeArguments2.length - 1];
        const withSpanExpr = yield* tryExtractWithSpanExpression(lastArg);
        if (withSpanExpr) {
          explicitTraceExpression = withSpanExpr;
        }
      }
      return { effectModuleName, generatorFunction, pipeArguments: pipeArguments2, explicitTraceExpression };
    });
    const isInsideEffectFn = (fnNode) => {
      const parent = fnNode.parent;
      if (!parent || !ts.isCallExpression(parent)) {
        return succeed(false);
      }
      if (parent.arguments[0] !== fnNode) {
        return succeed(false);
      }
      return pipe(
        typeParser.effectFn(parent),
        orElse2(() => typeParser.effectFnGen(parent)),
        orElse2(() => typeParser.effectFnUntracedGen(parent)),
        map8(() => true),
        orElse2(() => succeed(false))
      );
    };
    const parseEffectFnOpportunityTarget = (node) => gen(function* () {
      if (!ts.isFunctionExpression(node) && !ts.isArrowFunction(node) && !ts.isFunctionDeclaration(node)) {
        return yield* TypeParserIssue.issue;
      }
      if ((ts.isFunctionExpression(node) || ts.isFunctionDeclaration(node)) && node.asteriskToken) {
        return yield* TypeParserIssue.issue;
      }
      if (ts.isFunctionExpression(node) && node.name) {
        return yield* TypeParserIssue.issue;
      }
      if (node.type) {
        return yield* TypeParserIssue.issue;
      }
      if (yield* isInsideEffectFn(node)) {
        return yield* TypeParserIssue.issue;
      }
      const functionType = typeChecker.getTypeAtLocation(node);
      if (!functionType) return yield* TypeParserIssue.issue;
      const callSignatures = typeChecker.getSignaturesOfType(functionType, ts.SignatureKind.Call);
      if (callSignatures.length !== 1) return yield* TypeParserIssue.issue;
      const signature = callSignatures[0];
      const returnType = typeChecker.getReturnTypeOfSignature(signature);
      const unionMembers = typeCheckerUtils.unrollUnionMembers(returnType);
      yield* all(...unionMembers.map((member) => typeParser.strictEffectType(member, node)));
      const nameIdentifier = getNameIdentifier(node);
      const traceName = nameIdentifier ? ts.isIdentifier(nameIdentifier) ? ts.idText(nameIdentifier) : nameIdentifier.text : void 0;
      if (!traceName) return yield* TypeParserIssue.issue;
      const opportunity = yield* pipe(
        tryParseGenOpportunity(node),
        orElse2(() => {
          if (ts.isArrowFunction(node) && !ts.isBlock(node.body)) {
            return TypeParserIssue.issue;
          }
          const body = ts.isArrowFunction(node) ? node.body : node.body;
          if (!body || !ts.isBlock(body) || body.statements.length <= 5) {
            return TypeParserIssue.issue;
          }
          return succeed({
            effectModuleName: sourceEffectModuleName,
            pipeArguments: [],
            generatorFunction: void 0,
            explicitTraceExpression: void 0
          });
        })
      );
      return {
        node,
        nameIdentifier,
        effectModuleName: opportunity.effectModuleName,
        inferredTraceName: traceName,
        explicitTraceExpression: opportunity.explicitTraceExpression,
        pipeArguments: opportunity.pipeArguments,
        generatorFunction: opportunity.generatorFunction,
        hasParamsInPipeArgs: areParametersReferencedIn(node, opportunity.pipeArguments)
      };
    });
    const getFunctionBodyBlock = (node) => {
      if (ts.isArrowFunction(node)) {
        if (ts.isBlock(node.body)) {
          return node.body;
        }
        return ts.factory.createBlock([ts.factory.createReturnStatement(node.body)], true);
      }
      return node.body;
    };
    const isGeneratorFunction = (node) => {
      if (ts.isArrowFunction(node)) return false;
      return node.asteriskToken !== void 0;
    };
    const createEffectFnNode = (originalNode, innerFunction, effectModuleName, traceNameOrExpression, pipeArguments2) => {
      const isGenerator = isGeneratorFunction(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      let fnExpression = ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleName),
        "fn"
      );
      if (traceNameOrExpression) {
        const traceArg = typeof traceNameOrExpression === "string" ? ts.factory.createStringLiteral(traceNameOrExpression) : traceNameOrExpression;
        fnExpression = ts.factory.createCallExpression(
          fnExpression,
          void 0,
          [traceArg]
        );
      }
      const effectFnCall = ts.factory.createCallExpression(fnExpression, void 0, [newFunction, ...pipeArguments2]);
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const createEffectFnUntracedNode = (originalNode, innerFunction, effectModuleName, pipeArguments2) => {
      const isGenerator = isGeneratorFunction(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      const effectFnCall = ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(effectModuleName), "fnUntraced"),
        void 0,
        [newFunction, ...pipeArguments2]
      );
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const target = yield* pipe(parseEffectFnOpportunityTarget(node), option);
      if (isNone2(target)) continue;
      if (target.value.hasParamsInPipeArgs) continue;
      const {
        effectModuleName,
        explicitTraceExpression,
        inferredTraceName,
        nameIdentifier,
        node: targetNode,
        pipeArguments: pipeArguments2
      } = target.value;
      const innerFunction = target.value.generatorFunction ?? targetNode;
      const fixes = [];
      if (pluginOptions.effectFn.includes("span") && explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnWithSpan",
          description: "Convert to Effect.fn (with span from withSpan)",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const finalPipeArguments = pipeArguments2.slice(0, -1);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              explicitTraceExpression,
              finalPipeArguments
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("untraced") && target.value.generatorFunction) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnUntraced",
          description: "Convert to Effect.fnUntraced",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnUntracedNode(targetNode, innerFunction, effectModuleName, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("no-span")) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnNoSpan",
          description: "Convert to Effect.fn (no span)",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnNode(targetNode, innerFunction, effectModuleName, void 0, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("inferred-span") && inferredTraceName && !explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnSpanInferred",
          description: `Convert to Effect.fn("${inferredTraceName}")`,
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              inferredTraceName,
              pipeArguments2
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (fixes.length === 0) continue;
      const generateExpectedSignature = () => {
        const firstFix = fixes[0];
        if (!firstFix) return "Effect.fn(function*() { ... })";
        const typeParamNames = targetNode.typeParameters ? `<${targetNode.typeParameters.map((tp) => ts.idText(tp.name)).join(", ")}>` : "";
        const paramNames = targetNode.parameters.map((param) => {
          if (ts.isIdentifier(param.name)) {
            return ts.idText(param.name);
          }
          return "_";
        }).join(", ");
        const fnSignature = `function*${typeParamNames}(${paramNames}) { ... }`;
        const pipeArgsForWithSpan = pipeArguments2.slice(0, -1);
        const pipeArgsSuffix = (args2) => args2.length > 0 ? ", ...pipeTransformations" : "";
        switch (firstFix.fixName) {
          case "effectFnOpportunity_toEffectFnWithSpan": {
            const traceName = explicitTraceExpression ? sourceFile.text.slice(explicitTraceExpression.pos, explicitTraceExpression.end).trim() : void 0;
            return `${effectModuleName}.fn(${traceName})(${fnSignature}${pipeArgsSuffix(pipeArgsForWithSpan)})`;
          }
          case "effectFnOpportunity_toEffectFnUntraced":
            return `${effectModuleName}.fnUntraced(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnNoSpan":
            return `${effectModuleName}.fn(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnSpanInferred":
            return `${effectModuleName}.fn("${inferredTraceName}")(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          default:
            return `${effectModuleName}.fn(${fnSignature})`;
        }
      };
      const expectedSignature = generateExpectedSignature();
      report({
        location: nameIdentifier ?? targetNode,
        messageText: `Can be rewritten as a reusable function: ${expectedSignature}`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectGenUsesAdapter.ts
var effectGenUsesAdapter = createDiagnostic({
  name: "effectGenUsesAdapter",
  code: 23,
  description: "Warns when using the deprecated adapter parameter in Effect.gen",
  severity: "warning",
  apply: fn("effectGenUsesAdapter.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.effectGen(node),
          map8(({ generatorFunction }) => {
            if (generatorFunction.parameters.length > 0) {
              const adapter = generatorFunction.parameters[0];
              report({
                location: adapter,
                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,
                fixes: []
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectInVoidSuccess.ts
var effectInVoidSuccess = createDiagnostic({
  name: "effectInVoidSuccess",
  code: 14,
  description: "Detects nested Effects in void success channels that may cause unexecuted effects",
  severity: "warning",
  apply: fn("effectInVoidSuccess.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForEffectInVoid = fn("effectInVoidSuccess.checkForEffectInVoid")(function* (node, expectedType, valueNode, realType) {
      const expectedEffect = yield* typeParser.effectType(expectedType, node);
      const realEffect = yield* typeParser.effectType(realType, valueNode);
      if (expectedEffect.A.flags & ts.TypeFlags.Void) {
        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A);
        const voidedEffect = yield* firstSuccessOf(
          voidValueTypes.map((_) => map8(typeParser.strictEffectType(_, node), () => _))
        );
        return { voidedEffect };
      }
      return yield* fail3(typeParserIssue("expectedEffect success is not void"));
    });
    const entries2 = typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForEffectInVoid(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map8(({ voidedEffect }) => {
            report(
              {
                location: node,
                messageText: `There is a nested '${typeChecker.typeToString(voidedEffect)}' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,
                fixes: []
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectMapVoid.ts
var effectMapVoid = createDiagnostic({
  name: "effectMapVoid",
  code: 40,
  description: "Suggests using Effect.asVoid instead of Effect.map(() => void 0), Effect.map(() => undefined), or Effect.map(() => {})",
  severity: "suggestion",
  apply: fn("effectMapVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isMapCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("map")(node.expression),
          option
        );
        if (isSome2(isMapCall)) {
          const callback = node.arguments[0];
          if (!callback) continue;
          const match3 = yield* pipe(
            typeParser.emptyFunction(callback),
            orElse2(
              () => pipe(
                typeParser.lazyExpression(callback),
                flatMap4(
                  (lazy) => tsUtils.isVoidExpression(lazy.expression) ? succeed(lazy) : typeParserIssue("Expression is not void")
                )
              )
            ),
            option
          );
          if (isNone2(match3)) continue;
          report({
            location: node.expression,
            messageText: "Effect.asVoid can be used instead to discard the success value",
            fixes: [{
              fixName: "effectMapVoid_fix",
              description: "Replace with Effect.asVoid",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                if (ts.isPropertyAccessExpression(node.expression)) {
                  const newNode = ts.factory.createPropertyAccessExpression(
                    node.expression.expression,
                    ts.factory.createIdentifier("asVoid")
                  );
                  changeTracker.replaceNode(sourceFile, node, newNode);
                }
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/effectSucceedWithVoid.ts
var effectSucceedWithVoid = createDiagnostic({
  name: "effectSucceedWithVoid",
  code: 47,
  description: "Suggests using Effect.void instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
  severity: "suggestion",
  apply: fn("effectSucceedWithVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isSucceedCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("succeed")(node.expression),
          option
        );
        if (isSome2(isSucceedCall)) {
          const argument = node.arguments[0];
          if (!argument) continue;
          if (!tsUtils.isVoidExpression(argument)) continue;
          report({
            location: node,
            messageText: "Effect.void can be used instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
            fixes: [{
              fixName: "effectSucceedWithVoid_fix",
              description: "Replace with Effect.void",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
                const newNode = ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("void")
                );
                changeTracker.replaceNode(sourceFile, node, newNode);
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/floatingEffect.ts
var floatingEffect = createDiagnostic({
  name: "floatingEffect",
  code: 3,
  description: "Ensures Effects are yielded or assigned to variables, not left floating",
  severity: "error",
  apply: fn("floatingEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isFloatingExpression(node) {
      if (!ts.isExpressionStatement(node)) return false;
      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false;
      const expression = node.expression;
      if (ts.isBinaryExpression(expression) && expression.operatorToken && (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken || expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)) return false;
      return true;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!isFloatingExpression(node)) continue;
      const type = typeCheckerUtils.getTypeAtLocation(node.expression);
      if (!type) continue;
      const effect = yield* option(typeParser.effectType(type, node.expression));
      if (isSome2(effect)) {
        const allowedFloatingEffects = yield* pipe(
          typeParser.fiberType(type, node.expression),
          orElse2(() => typeParser.effectSubtype(type, node.expression)),
          option
        );
        if (isNone2(allowedFloatingEffects)) {
          const isStrictEffect = yield* option(typeParser.strictEffectType(type, node.expression));
          const name = isSome2(isStrictEffect) ? "Effect" : "Effect-able " + typeChecker.typeToString(type);
          report({
            location: node,
            messageText: `${name} must be yielded or assigned to a variable.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/genericEffectServices.ts
var genericEffectServices = createDiagnostic({
  name: "genericEffectServices",
  code: 10,
  description: "Prevents services with type parameters that cannot be discriminated at runtime",
  severity: "warning",
  apply: fn("genericEffectServices.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          map8(() => {
            report({
              location: reportAt,
              messageText: `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,
              fixes: []
            });
          }),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectCatch.ts
var globalErrorInEffectCatch = createDiagnostic({
  name: "globalErrorInEffectCatch",
  code: 36,
  description: "Warns when catch callbacks return global Error type instead of typed errors",
  severity: "warning",
  apply: fn("globalErrorInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse2(() => void_)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && typeCheckerUtils.isGlobalErrorType(returnType)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns global 'Error', which loses type safety as untagged errors merge together. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectFailure.ts
var globalErrorInEffectFailure = createDiagnostic({
  name: "globalErrorInEffectFailure",
  code: 35,
  description: "Warns when the global Error type is used in an Effect failure channel",
  severity: "warning",
  apply: fn("globalErrorInEffectFailure.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isNewExpression(node)) {
        const newExpressionType = typeCheckerUtils.getTypeAtLocation(node);
        if (!newExpressionType || !typeCheckerUtils.isGlobalErrorType(newExpressionType)) {
          continue;
        }
        let current = node.parent;
        while (current) {
          const currentType = typeCheckerUtils.getTypeAtLocation(current);
          if (currentType) {
            const effectTypeResult = yield* pipe(
              typeParser.effectType(currentType, current),
              option
            );
            if (effectTypeResult._tag === "Some") {
              const effectType = effectTypeResult.value;
              const failureMembers = typeCheckerUtils.unrollUnionMembers(effectType.E);
              const hasGlobalError = failureMembers.some((member) => typeCheckerUtils.isGlobalErrorType(member));
              if (hasGlobalError) {
                report({
                  location: node,
                  messageText: `Global 'Error' loses type safety as untagged errors merge together in the Effect failure channel. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                  fixes: []
                });
              }
              break;
            }
          }
          current = current.parent;
        }
      }
    }
  })
});

// src/diagnostics/importFromBarrel.ts
var importFromBarrel = createDiagnostic({
  name: "importFromBarrel",
  code: 12,
  description: "Suggests importing from specific module paths instead of barrel exports",
  severity: "off",
  apply: fn("importFromBarrel.apply")(function* (sourceFile, report) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return;
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const program = yield* service(TypeScriptProgram);
    const getModuleSpecifier = makeGetModuleSpecifier(ts);
    const resolveExternalModuleName = makeResolveExternalModuleName(typeChecker);
    const packageNamesToCheck = flatten(
      languageServicePluginOptions.namespaceImportPackages.map(
        (packageName) => tsUtils.resolveModulePattern(program, sourceFile, packageName)
      )
    );
    const isImportedFromBarrelExport = (element) => {
      if (!(getModuleSpecifier && resolveExternalModuleName)) return;
      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node));
      if (!importDeclaration) return;
      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return;
      const importClause = importDeclaration.importClause;
      if (!importClause) return;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) return;
      if (!ts.isNamedImports(namedBindings)) return;
      const barrelModuleName = importDeclaration.moduleSpecifier.text;
      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return;
      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier);
      if (!moduleSymbol) return;
      if (!moduleSymbol.exports) return;
      const sourceFile2 = tsUtils.getSourceFileOfNode(importDeclaration);
      if (!sourceFile2) return;
      const nodeForSymbol = element.propertyName || element.name;
      const aliasSymbol = element.name || element.propertyName;
      const aliasedName = ts.idText(aliasSymbol);
      if (!ts.isIdentifier(nodeForSymbol)) return;
      const importedName = ts.idText(nodeForSymbol);
      if (!importedName) return;
      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName));
      if (!reexportedSymbol) return;
      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return;
      const namespaceExport = reexportedSymbol.declarations[0];
      if (!ts.isNamespaceExport(namespaceExport)) return;
      const exportDeclaration = namespaceExport.parent;
      if (!ts.isExportDeclaration(exportDeclaration)) return;
      if (!exportDeclaration.moduleSpecifier) return;
      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier);
      if (!originalModuleSymbol) return;
      if (!originalModuleSymbol.valueDeclaration) return;
      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration);
      if (!originalSourceFile) return;
      const unbarrelledFileName = getModuleSpecifier(
        program.getCompilerOptions(),
        sourceFile2,
        sourceFile2.fileName,
        originalSourceFile.fileName,
        program
      );
      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + "/") === -1) return;
      return {
        unbarrelledFileName,
        importedName,
        barrelModuleName,
        importClause,
        namedBindings,
        importDeclaration,
        aliasedName
      };
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const parent = node.parent;
      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      const result = isImportedFromBarrelExport(node);
      if (!result) continue;
      const {
        aliasedName,
        barrelModuleName,
        importClause,
        importDeclaration,
        namedBindings,
        unbarrelledFileName
      } = result;
      report({
        location: node,
        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,
        fixes: [
          {
            fixName: "replaceWithUnbarrelledImport",
            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const newImport = ts.factory.createImportDeclaration(
                void 0,
                ts.factory.createImportClause(
                  importClause.isTypeOnly || node.isTypeOnly,
                  void 0,
                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))
                ),
                ts.factory.createStringLiteral(unbarrelledFileName)
              );
              if (namedBindings.elements.length === 1) {
                changeTracker.replaceNode(
                  sourceFile,
                  importDeclaration,
                  newImport
                );
              } else {
                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport);
                changeTracker.replaceNode(
                  sourceFile,
                  namedBindings,
                  ts.factory.updateNamedImports(
                    namedBindings,
                    namedBindings.elements.filter((e) => e !== node)
                  )
                );
              }
            })
          }
        ]
      });
    }
  })
});

// src/diagnostics/instanceOfSchema.ts
var instanceOfSchema = createDiagnostic({
  name: "instanceOfSchema",
  code: 45,
  description: "Suggests using Schema.is instead of instanceof for Effect Schema types",
  severity: "off",
  apply: fn("instanceOfSchema.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
        const leftExpr = node.left;
        const rightExpr = node.right;
        const rightType = typeCheckerUtils.getTypeAtLocation(rightExpr);
        if (!rightType) {
          ts.forEachChild(node, appendNodeToVisit);
          continue;
        }
        const isSchemaType = yield* pipe(
          typeParser.effectSchemaType(rightType, rightExpr),
          option
        );
        if (isSchemaType._tag === "Some") {
          report({
            location: node,
            messageText: "Consider using Schema.is instead of instanceof for Effect Schema types.",
            fixes: [{
              fixName: "instanceOfSchema_fix",
              description: "Replace with Schema.is",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const schemaIsCall = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier("Schema"),
                    "is"
                  ),
                  void 0,
                  [rightExpr]
                );
                const fullCall = ts.factory.createCallExpression(
                  schemaIsCall,
                  void 0,
                  [leftExpr]
                );
                changeTracker.replaceNode(sourceFile, node, fullCall);
              })
            }]
          });
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/layerMergeAllWithDependencies.ts
var layerMergeAllWithDependencies = createDiagnostic({
  name: "layerMergeAllWithDependencies",
  code: 37,
  description: "Detects interdependencies in Layer.mergeAll calls where one layer provides a service that another layer requires",
  severity: "warning",
  apply: fn("layerMergeAllWithDependencies.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const checkLayerMergeAll = yield* pipe(
          typeParser.isNodeReferenceToEffectLayerModuleApi("mergeAll")(node.expression),
          orElse2(() => void_)
        );
        if (checkLayerMergeAll) {
          const layerArgs = node.arguments;
          if (layerArgs.length > 1) {
            const layerInfos = [];
            const actuallyProvidedMap = /* @__PURE__ */ new Map();
            for (const arg of layerArgs) {
              const argType = typeCheckerUtils.getTypeAtLocation(arg);
              if (!argType) continue;
              const layerTypeParsedOption = yield* option(typeParser.layerType(argType, arg));
              if (isNone2(layerTypeParsedOption)) continue;
              const layerTypeParsed = layerTypeParsedOption.value;
              const providedMembers = typeCheckerUtils.unrollUnionMembers(layerTypeParsed.ROut);
              for (const providedType of providedMembers) {
                if (providedType.flags & ts.TypeFlags.Never) continue;
                const isPassThrough = typeChecker.isTypeAssignableTo(providedType, layerTypeParsed.RIn);
                if (!isPassThrough) {
                  actuallyProvidedMap.set(providedType, arg);
                }
              }
              layerInfos.push({
                arg,
                requirementsType: layerTypeParsed.RIn
              });
            }
            const providerToConsumers = /* @__PURE__ */ new Map();
            for (const layer of layerInfos) {
              for (const [providedType, providerArg] of actuallyProvidedMap) {
                if (providerArg === layer.arg) continue;
                if (typeChecker.isTypeAssignableTo(providedType, layer.requirementsType)) {
                  const consumers = providerToConsumers.get(providerArg) || [];
                  consumers.push({ consumer: layer.arg, providedType });
                  providerToConsumers.set(providerArg, consumers);
                }
              }
            }
            for (const [providerArg, consumers] of providerToConsumers) {
              const providedTypes = Array.from(new Set(consumers.map((c) => typeChecker.typeToString(c.providedType)))).join(", ");
              report({
                location: providerArg,
                messageText: `This layer provides ${providedTypes} which is required by another layer in the same Layer.mergeAll call. Layer.mergeAll creates layers in parallel, so dependencies between layers will not be satisfied. Consider moving this layer into a Layer.provideMerge after the Layer.mergeAll.`,
                fixes: [{
                  fixName: "layerMergeAllWithDependencies_fix",
                  description: "Move layer to Layer.provideMerge",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    const providerIndex = layerArgs.indexOf(providerArg);
                    if (providerIndex === -1) return;
                    const providerArgNode = providerArg;
                    if (providerIndex === 0 && layerArgs.length > 1) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: providerArgNode.pos,
                        end: layerArgs[1].pos
                      });
                    } else if (providerIndex > 0) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: layerArgs[providerIndex - 1].end,
                        end: providerArgNode.end
                      });
                    }
                    const provideMergeCall = ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        ts.factory.createIdentifier(layerModuleIdentifier),
                        ts.factory.createIdentifier("provideMerge")
                      ),
                      void 0,
                      [providerArgNode]
                    );
                    changeTracker.insertNodeAt(sourceFile, node.end, provideMergeCall, {
                      prefix: ".pipe("
                    });
                    changeTracker.insertText(sourceFile, node.end, ")");
                  })
                }]
              });
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/leakingRequirements.ts
var leakingRequirements = createDiagnostic({
  name: "leakingRequirements",
  code: 8,
  description: "Detects implementation services leaked in service methods",
  severity: "suggestion",
  apply: fn("leakingRequirements.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseLeakedRequirements = cachedBy(
      fn("leakingServices.checkServiceLeaking")(
        function* (service2, atLocation) {
          const properties = typeChecker.getPropertiesOfType(service2);
          if (properties.length < 1) return [];
          const memory = /* @__PURE__ */ new Map();
          let sharedRequirementsKeys = void 0;
          let effectMembers = 0;
          for (const property of properties) {
            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation);
            let effectContextType = void 0;
            yield* pipe(
              typeParser.effectType(servicePropertyType, atLocation),
              map8((_) => effectContextType = _.R),
              orElse2(() => {
                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(
                  servicePropertyType,
                  ts.SignatureKind.Call
                );
                if (servicePropertyCallSignatures.length === 1) {
                  return pipe(
                    typeParser.effectType(
                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),
                      atLocation
                    ),
                    map8((_) => {
                      effectContextType = _.R;
                    })
                  );
                }
                return void_;
              }),
              ignore
            );
            if (effectContextType) {
              effectMembers++;
              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                memory,
                effectContextType,
                (type) => {
                  if (type.flags & ts.TypeFlags.Never) return succeed(true);
                  return pipe(
                    typeParser.scopeType(type, atLocation),
                    map8(() => true),
                    orElse2(() => succeed(false))
                  );
                }
              );
              if (!sharedRequirementsKeys) {
                sharedRequirementsKeys = allIndexes;
              } else {
                sharedRequirementsKeys = intersection(sharedRequirementsKeys, allIndexes);
                if (sharedRequirementsKeys.length === 0) return [];
              }
            }
          }
          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {
            return sharedRequirementsKeys.map((key) => memory.get(key)).filter(
              (type) => {
                let symbol3 = type.symbol;
                if (symbol3 && symbol3.flags & ts.SymbolFlags.Alias) {
                  symbol3 = typeChecker.getAliasedSymbol(symbol3) || symbol3;
                }
                if (!symbol3) return false;
                return !(symbol3?.declarations || []).some((declaration) => {
                  const declarationSource = tsUtils.getSourceFileOfNode(declaration);
                  if (!declarationSource) return false;
                  return declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(
                    "@effect-leakable-service"
                  ) > -1;
                });
              }
            );
          }
          return [];
        }
      ),
      "leakingServices.checkServiceLeaking",
      (_, service2) => service2
    );
    function reportLeakingRequirements(node, requirements) {
      if (requirements.length === 0) return;
      const requirementsStr = requirements.map((_) => typeChecker.typeToString(_)).join(" | ");
      report({
        location: node,
        messageText: `Methods of this Service require \`${requirementsStr}\` from every caller.

This leaks implementation details into the service's public type \u2014 callers shouldn't need to know *how* the service works internally, only *what* it provides.

Resolve these dependencies at Layer creation and provide them to each method, so the service's type reflects its purpose, not its implementation.

To suppress this diagnostic for specific dependency types that are intentionally passed through (e.g., HttpServerRequest), add \`@effect-leakable-service\` JSDoc to their interface declarations (e.g., the \`${typeChecker.typeToString(requirements[0])}\` interface), not to this service.

More info and examples at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,
        fixes: []
      });
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "GenericTag") {
        const nodeType = typeCheckerUtils.getTypeAtLocation(node);
        if (nodeType) typesToCheck.push([nodeType, node]);
      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          flatMap4(
            ({ Service }) => pipe(
              parseLeakedRequirements(Service, node),
              map8(
                (requirements) => reportLeakingRequirements(reportAt, sort(requirements, typeCheckerUtils.deterministicTypeOrder))
              )
            )
          ),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missedPipeableOpportunity.ts
var missedPipeableOpportunity = createDiagnostic({
  name: "missedPipeableOpportunity",
  code: 26,
  description: "Enforces the use of pipeable style for nested function calls",
  severity: "off",
  apply: fn("missedPipeableOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const options = yield* service(LanguageServicePluginOptions);
    const isSafelyPipeableCallee = (callee) => {
      if (ts.isCallExpression(callee)) {
        return true;
      }
      if (ts.isArrowFunction(callee)) {
        return true;
      }
      if (ts.isFunctionExpression(callee)) {
        return true;
      }
      if (ts.isParenthesizedExpression(callee)) {
        return isSafelyPipeableCallee(callee.expression);
      }
      if (ts.isIdentifier(callee)) {
        const symbol3 = typeChecker.getSymbolAtLocation(callee);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isFunctionDeclaration(decl) || ts.isVariableDeclaration(decl) || ts.isImportSpecifier(decl) || ts.isImportClause(decl) || ts.isNamespaceImport(decl)) {
            return true;
          }
        }
        return false;
      }
      if (ts.isPropertyAccessExpression(callee)) {
        const subject = callee.expression;
        const symbol3 = typeChecker.getSymbolAtLocation(subject);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isNamespaceImport(decl) || ts.isSourceFile(decl) || ts.isModuleDeclaration(decl)) {
            return true;
          }
        }
        return false;
      }
      return false;
    };
    const flows = yield* typeParser.pipingFlows(false)(sourceFile);
    for (const flow2 of flows) {
      if (flow2.transformations.length < options.pipeableMinArgCount) {
        continue;
      }
      const finalType = flow2.transformations[flow2.transformations.length - 1].outType;
      if (!finalType) {
        continue;
      }
      const callSigs = typeChecker.getSignaturesOfType(finalType, ts.SignatureKind.Call);
      if (callSigs.length > 0) {
        continue;
      }
      const isPipeableAtIndex = function* (index) {
        if (index === 0) {
          const subjectType = flow2.subject.outType;
          if (!subjectType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(subjectType, flow2.subject.node),
            option
          );
          return result._tag === "Some";
        } else {
          const t = flow2.transformations[index - 1];
          if (!t.outType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(t.outType, flow2.node),
            option
          );
          return result._tag === "Some";
        }
      };
      let searchStartIndex = 0;
      while (searchStartIndex <= flow2.transformations.length) {
        let firstPipeableIndex = -1;
        for (let i = searchStartIndex; i <= flow2.transformations.length; i++) {
          if (yield* isPipeableAtIndex(i)) {
            firstPipeableIndex = i;
            break;
          }
        }
        if (firstPipeableIndex === -1) {
          break;
        }
        const pipeableTransformations = [];
        for (let i = firstPipeableIndex; i < flow2.transformations.length; i++) {
          const t = flow2.transformations[i];
          if (!isSafelyPipeableCallee(t.callee)) {
            break;
          }
          pipeableTransformations.push(t);
        }
        const callKindCount = pipeableTransformations.filter((t) => t.kind === "call").length;
        if (callKindCount >= options.pipeableMinArgCount) {
          const pipeableEndIndex = firstPipeableIndex + pipeableTransformations.length;
          const pipeableSubjectNode = firstPipeableIndex === 0 ? flow2.subject.node : typeParser.reconstructPipingFlow({
            subject: flow2.subject,
            transformations: flow2.transformations.slice(0, firstPipeableIndex)
          });
          const afterTransformations = flow2.transformations.slice(pipeableEndIndex);
          const getOriginalSubjectNode = () => {
            if (firstPipeableIndex === 0) {
              return flow2.subject.node;
            }
            let current = flow2.node;
            for (let i = flow2.transformations.length; i > firstPipeableIndex; i--) {
              const t = flow2.transformations[i - 1];
              if (t.kind === "call" && ts.isCallExpression(current) && current.arguments.length > 0) {
                current = current.arguments[0];
              } else {
                return void 0;
              }
            }
            return current;
          };
          const originalSubjectNode = getOriginalSubjectNode();
          const subjectText = originalSubjectNode ? sourceFile.text.slice(
            ts.getTokenPosOfNode(originalSubjectNode, sourceFile),
            originalSubjectNode.end
          ).trim() : "";
          report({
            location: flow2.node,
            messageText: `Nested function calls can be converted to pipeable style for better readability; consider using ${subjectText}.pipe(...) instead.`,
            fixes: [{
              fixName: "missedPipeableOpportunity_fix",
              description: "Convert to pipe style",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const pipeArgs = pipeableTransformations.map((t) => {
                  if (t.args) {
                    return ts.factory.createCallExpression(
                      t.callee,
                      void 0,
                      t.args
                    );
                  } else {
                    return t.callee;
                  }
                });
                const pipeNode = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    pipeableSubjectNode,
                    "pipe"
                  ),
                  void 0,
                  pipeArgs
                );
                const newNode = afterTransformations.length > 0 ? typeParser.reconstructPipingFlow({
                  subject: { node: pipeNode, outType: void 0 },
                  transformations: afterTransformations
                }) : pipeNode;
                changeTracker.replaceNode(sourceFile, flow2.node, newNode);
              })
            }]
          });
          break;
        }
        searchStartIndex = firstPipeableIndex + pipeableTransformations.length + 1;
      }
    }
  })
});

// src/diagnostics/missingEffectContext.ts
var missingEffectContext = createDiagnostic({
  name: "missingEffectContext",
  code: 1,
  description: "Reports missing service requirements in Effect context channel",
  severity: "error",
  apply: fn("missingEffectContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map8(
        ([expectedEffect, realEffect]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realEffect.R,
          expectedEffect.R
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries2 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map8(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Effect context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectError.ts
var missingEffectError = createDiagnostic({
  name: "missingEffectError",
  code: 1,
  description: "Reports missing error types in Effect error channel",
  severity: "error",
  apply: fn("missingEffectError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const createDieMessage = (message) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifier),
        "dieMessage"
      ),
      void 0,
      [ts.factory.createStringLiteral(message)]
    );
    const checkForMissingErrorTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map8(
        ([expectedEffect, realEffect]) => pipe(
          typeCheckerUtils.getMissingTypeEntriesInTargetType(
            realEffect.E,
            expectedEffect.E
          ),
          (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries2 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingErrorTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map8((result) => {
            if (result.missingErrorTypes.length === 0) return;
            const fixes = [];
            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {
              fixes.push({
                fixName: "missingEffectError_catchAll",
                description: "Catch all errors with Effect.catchAll",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.insertText(
                    sourceFile,
                    ts.getTokenPosOfNode(valueNode, sourceFile),
                    effectModuleIdentifier + ".catchAll("
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ", () => ");
                  changeTracker.insertNodeAt(
                    sourceFile,
                    valueNode.end,
                    createDieMessage("TODO: catchAll not implemented")
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ")");
                })
              });
            }
            if (ts.isExpression(valueNode)) {
              const propertyAssignments = pipe(
                result.missingErrorTypes,
                map4((_) => typeChecker.getPropertyOfType(_, "_tag")),
                filter((_) => !!_),
                map4((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),
                filter((_) => !!(_.flags & ts.TypeFlags.Literal)),
                map4((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_ && ts.isLiteralTypeNode(_)),
                map4((_) => _.literal),
                filter((_) => ts.isLiteralExpression(_)),
                map4((_) => _.text),
                sort(string2),
                map4(
                  (_) => ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier(_),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)
                    )
                  )
                )
              );
              if (propertyAssignments.length === result.missingErrorTypes.length) {
                fixes.push({
                  fixName: "missingEffectError_tagged",
                  description: "Catch unexpected errors with Effect.catchTag",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.insertText(
                      sourceFile,
                      ts.getTokenPosOfNode(valueNode, sourceFile),
                      effectModuleIdentifier + ".catchTags("
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ", ");
                    changeTracker.insertNodeAt(
                      sourceFile,
                      valueNode.end,
                      ts.factory.createObjectLiteralExpression(propertyAssignments)
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ")");
                  })
                });
              }
            }
            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_));
            report(
              {
                location: node,
                messageText: `Missing '${typeNames.join(" | ")}' in the expected Effect errors.`,
                fixes
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectServiceDependency.ts
var missingEffectServiceDependency = createDiagnostic({
  name: "missingEffectServiceDependency",
  code: 22,
  description: "Checks that Effect.Service dependencies satisfy all required layer inputs",
  severity: "off",
  apply: fn("missingEffectServiceDependency.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult) {
          const { className, options } = serviceResult;
          const classSymbol = typeChecker.getSymbolAtLocation(className);
          if (classSymbol) {
            const classType = typeChecker.getTypeOfSymbol(classSymbol);
            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, "DefaultWithoutDependencies");
            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, "Default");
            if (defaultProperty) {
              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node);
              const layerResult = yield* pipe(
                typeParser.layerType(defaultType, node),
                orElse2(() => void_)
              );
              if (layerResult) {
                const servicesMemory = /* @__PURE__ */ new Map();
                const excludeNever = (type) => succeed((type.flags & ts.TypeFlags.Never) !== 0);
                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                  servicesMemory,
                  layerResult.RIn,
                  excludeNever
                );
                const providedIndexes = /* @__PURE__ */ new Set();
                let types = [];
                const optionsType = typeCheckerUtils.getTypeAtLocation(options);
                if (optionsType) {
                  const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, "dependencies");
                  if (dependenciesProperty) {
                    const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options);
                    const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number);
                    types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : [];
                  }
                }
                for (const depType of types) {
                  const depLayerResult = yield* pipe(
                    typeParser.layerType(depType, options),
                    orElse2(() => void_)
                  );
                  if (depLayerResult) {
                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                      servicesMemory,
                      depLayerResult.ROut,
                      excludeNever
                    );
                    for (const index of allIndexes) {
                      providedIndexes.add(index);
                    }
                  }
                }
                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index));
                if (missingIndexes.length > 0) {
                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index));
                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t));
                  const message = missingTypeNames.length === 1 ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies` : `Services ${missingTypeNames.map((s) => `'${s}'`).join(", ")} are required but not provided by dependencies`;
                  report({
                    location: className,
                    messageText: message,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/missingLayerContext.ts
var missingLayerContext = createDiagnostic({
  name: "missingLayerContext",
  code: 38,
  description: "Reports missing service requirements in Layer context channel",
  severity: "error",
  apply: fn("missingLayerContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.layerType(expectedType, node),
        typeParser.layerType(realType, valueNode)
      ),
      map8(
        ([expectedLayer, realLayer]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realLayer.RIn,
          expectedLayer.RIn
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries2 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map8(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Layer context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingReturnYieldStar.ts
var missingReturnYieldStar = createDiagnostic({
  name: "missingReturnYieldStar",
  code: 7,
  description: "Suggests using 'return yield*' for Effects with never success for better type narrowing",
  severity: "error",
  apply: fn("missingReturnYieldStar.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken) {
        const type = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (type) {
          const maybeEffect = yield* option(typeParser.effectType(type, node.expression));
          if (isSome2(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {
            const generatorFunctionOrReturnStatement = ts.findAncestor(
              node,
              (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isReturnStatement(_) || ts.isThrowStatement(_)
            );
            if (generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) && !ts.isThrowStatement(generatorFunctionOrReturnStatement)) {
              if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {
                const effectGenNode = generatorFunctionOrReturnStatement.parent;
                const effectGenLike = yield* pipe(
                  typeParser.effectGen(effectGenNode),
                  orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
                  orElse2(() => typeParser.effectFnGen(effectGenNode)),
                  option
                );
                if (isSome2(effectGenLike)) {
                  const fix = node.expression ? [{
                    fixName: "missingReturnYieldStar_fix",
                    description: "Add return statement",
                    apply: gen(function* () {
                      const changeTracker = yield* service(ChangeTracker);
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createReturnStatement(
                          node
                        )
                      );
                    })
                  }] : [];
                  report({
                    location: node,
                    messageText: `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,
                    fixes: fix
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/missingStarInYieldEffectGen.ts
var missingStarInYieldEffectGen = createDiagnostic({
  name: "missingStarInYieldEffectGen",
  code: 4,
  description: "Enforces using 'yield*' instead of 'yield' when yielding Effects in generators",
  severity: "error",
  apply: fn("missingStarInYieldEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const brokenGenerators = /* @__PURE__ */ new Set();
    const brokenYields = /* @__PURE__ */ new Set();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken === void 0) {
        const functionStarNode = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)
        );
        if (functionStarNode && functionStarNode.parent) {
          const effectGenNode = functionStarNode.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map8(({ generatorFunction }) => {
              if (generatorFunction) {
                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)));
              }
              brokenYields.add(node);
            }),
            ignore
          );
        }
      }
    }
    brokenGenerators.forEach(
      (pos) => report({
        location: { pos, end: pos + "function".length },
        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,
        fixes: []
      })
    );
    brokenYields.forEach((node) => {
      const fix = node.expression ? [{
        fixName: "missingStarInYieldEffectGen_fix",
        description: "Replace yield with yield*",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(
            sourceFile,
            node,
            ts.factory.createYieldExpression(
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              node.expression
            )
          );
        })
      }] : [];
      report({
        location: node,
        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,
        fixes: fix
      });
    });
  })
});

// src/diagnostics/multipleEffectProvide.ts
var multipleEffectProvide = createDiagnostic({
  name: "multipleEffectProvide",
  code: 18,
  description: "Warns against chaining Effect.provide calls which can cause service lifecycle issues",
  severity: "warning",
  apply: fn("multipleEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      let currentChunk = 0;
      const previousLayers = [[]];
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          currentChunk++;
          previousLayers.push([]);
          continue;
        }
        const isProvideCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("provide")(transformation.callee),
          option
        );
        if (isSome2(isProvideCall)) {
          const layer = transformation.args[0];
          const type = typeCheckerUtils.getTypeAtLocation(layer);
          const node = ts.findAncestor(transformation.callee, ts.isCallExpression);
          const isLayerType = type ? yield* pipe(
            typeParser.layerType(type, layer),
            option
          ) : none2();
          if (isSome2(isLayerType) && node) {
            previousLayers[currentChunk].push({ layer, node });
          } else {
            currentChunk++;
            previousLayers.push([]);
          }
        } else {
          currentChunk++;
          previousLayers.push([]);
        }
      }
      for (const chunk of previousLayers) {
        if (chunk.length < 2) continue;
        report({
          location: chunk[0].node,
          messageText: "Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.",
          fixes: [{
            fixName: "multipleEffectProvide_fix",
            description: "Combine into a single provide",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.deleteRange(sourceFile, {
                pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),
                end: chunk[chunk.length - 1].node.end
              });
              const newNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("provide")
                ),
                void 0,
                [ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(layerModuleIdentifier),
                    ts.factory.createIdentifier("mergeAll")
                  ),
                  void 0,
                  chunk.map((c) => c.layer)
                )]
              );
              changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/nonObjectEffectServiceType.ts
var nonObjectEffectServiceType = createDiagnostic({
  name: "nonObjectEffectServiceType",
  code: 24,
  description: "Ensures Effect.Service types are objects, not primitives",
  severity: "error",
  apply: fn("nonObjectEffectServiceType.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isPrimitiveType(type) {
      return typeCheckerUtils.unrollUnionMembers(type).some(
        (type2) => !!(type2.flags & ts.TypeFlags.String || type2.flags & ts.TypeFlags.Number || type2.flags & ts.TypeFlags.Boolean || type2.flags & ts.TypeFlags.StringLiteral || type2.flags & ts.TypeFlags.NumberLiteral || type2.flags & ts.TypeFlags.BooleanLiteral || type2.flags & ts.TypeFlags.Undefined || type2.flags & ts.TypeFlags.Null)
      );
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {
          const options = serviceResult.options;
          for (const property of options.properties) {
            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {
              continue;
            }
            const propertyName = ts.idText(property.name);
            const propertyValue = property.initializer;
            const errorToReport = {
              location: property.name,
              messageText: "Effect.Service requires the service type to be an object {} and not a primitive type. \nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.",
              fixes: []
            };
            if (propertyName === "succeed") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (valueType && isPrimitiveType(valueType)) {
                report(errorToReport);
              }
            } else if (propertyName === "sync") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
              for (const signature of signatures) {
                const returnType = typeChecker.getReturnTypeOfSignature(signature);
                if (isPrimitiveType(returnType)) {
                  report(errorToReport);
                  break;
                }
              }
            } else if (propertyName === "effect" || propertyName === "scoped") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const effectResult = yield* pipe(
                typeParser.effectType(valueType, propertyValue),
                orElse2(() => void_)
              );
              if (effectResult) {
                if (isPrimitiveType(effectResult.A)) {
                  report(errorToReport);
                  continue;
                }
              } else {
                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
                for (const signature of signatures) {
                  const returnType = typeChecker.getReturnTypeOfSignature(signature);
                  const effectReturnResult = yield* pipe(
                    typeParser.effectType(returnType, propertyValue),
                    orElse2(() => void_)
                  );
                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {
                    report(errorToReport);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/outdatedEffectCodegen.ts
var outdatedEffectCodegen = createDiagnostic({
  name: "outdatedEffectCodegen",
  code: 19,
  description: "Detects when generated code is outdated and needs to be regenerated",
  severity: "warning",
  apply: fn("outdatedEffectCodegen.apply")(function* (sourceFile, _report) {
    const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
    for (const { codegen, hash: hash2, range } of codegensWithRanges) {
      yield* pipe(
        getEditsForCodegen([codegen], sourceFile, range),
        map8((applicable) => {
          if (applicable.hash !== hash2) {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} result is outdated`,
              fixes: [
                {
                  fixName: "outdatedEffectCodegen_fix",
                  description: `Re-run ${codegen.name}`,
                  apply: applicable.apply
                },
                {
                  fixName: "outdatedEffectCodegen_ignore",
                  description: `Ignore this ${codegen.name} update`,
                  apply: applicable.ignore
                }
              ]
            });
          }
        }),
        orElse2(
          (e) => sync(() => {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,
              fixes: []
            });
          })
        ),
        ignore
      );
    }
  })
});

// src/diagnostics/overriddenSchemaConstructor.ts
var overriddenSchemaConstructor = createDiagnostic({
  name: "overriddenSchemaConstructor",
  code: 30,
  description: "Prevents overriding constructors in Schema classes which breaks decoding behavior",
  severity: "error",
  apply: fn("overriddenSchemaConstructor.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    function isAllowedConstructor(node) {
      if (node.body && node.body.statements.length === 1) {
        const expressionStatement = node.body.statements[0];
        if (ts.isExpressionStatement(expressionStatement)) {
          const maybeCallSuper = expressionStatement.expression;
          if (ts.isCallExpression(maybeCallSuper)) {
            if (maybeCallSuper.expression.kind === ts.SyntaxKind.SuperKeyword) {
              const expectedNames = node.parameters.map((_) => _.name).filter(ts.isIdentifier).map((_) => ts.idText(_));
              if (expectedNames.length === 2 && expectedNames.length === node.parameters.length) {
                const givenNames = maybeCallSuper.arguments.filter(ts.isIdentifier).map((_) => ts.idText(_));
                if (givenNames.length === expectedNames.length && givenNames.every((name, index) => name === expectedNames[index])) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.heritageClauses) {
        let extendsSchema = false;
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
            for (const type of heritageClause.types) {
              const typeAtLocation = typeCheckerUtils.getTypeAtLocation(type.expression);
              if (!typeAtLocation) continue;
              const isSchema = yield* pipe(
                typeParser.effectSchemaType(typeAtLocation, type.expression),
                map8(() => true),
                orElse2(() => succeed(false))
              );
              if (isSchema) {
                extendsSchema = true;
                break;
              }
            }
          }
          if (extendsSchema) break;
        }
        if (extendsSchema) {
          const members = node.members;
          for (const member of members) {
            if (ts.isConstructorDeclaration(member)) {
              if (isAllowedConstructor(member)) {
                continue;
              }
              const fixAsStaticNew = {
                fixName: "overriddenSchemaConstructor_static",
                description: "Rewrite using the static 'new' pattern",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const visitor = (node2) => {
                    if (ts.isExpressionStatement(node2) && ts.isCallExpression(node2.expression) && ts.isToken(node2.expression.expression) && node2.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
                      const constructThis = ts.factory.createNewExpression(
                        ts.factory.createIdentifier("this"),
                        void 0,
                        node2.expression.arguments
                      );
                      return ts.factory.createVariableStatement(
                        void 0,
                        ts.factory.createVariableDeclarationList(
                          [ts.factory.createVariableDeclaration(
                            "_this",
                            void 0,
                            void 0,
                            constructThis
                          )],
                          ts.NodeFlags.Const
                        )
                      );
                    }
                    if (ts.isToken(node2) && node2.kind === ts.SyntaxKind.ThisKeyword) {
                      return ts.factory.createIdentifier("_this");
                    }
                    return ts.visitEachChild(node2, visitor, ts.nullTransformationContext);
                  };
                  const newBody = visitor(member.body);
                  const bodyWithReturn = ts.factory.updateBlock(
                    newBody,
                    newBody.statements.concat([
                      ts.factory.createReturnStatement(ts.factory.createIdentifier("_this"))
                    ])
                  );
                  const newMethod = ts.factory.createMethodDeclaration(
                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),
                    void 0,
                    "new",
                    void 0,
                    member.typeParameters,
                    member.parameters,
                    member.type,
                    bodyWithReturn
                  );
                  changeTracker.replaceNode(sourceFile, member, newMethod);
                })
              };
              report({
                location: member,
                messageText: "Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.",
                fixes: (member.body ? [fixAsStaticNew] : []).concat([{
                  fixName: "overriddenSchemaConstructor_fix",
                  description: "Remove the constructor override",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.delete(sourceFile, member);
                  })
                }])
              });
              break;
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/preferSchemaOverJson.ts
var preferSchemaOverJson = createDiagnostic({
  name: "preferSchemaOverJson",
  code: 44,
  description: "Suggests using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify which may throw",
  severity: "suggestion",
  apply: fn("preferSchemaOverJson.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const parseJsonMethod = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail3("node is not a call expression");
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return yield* fail3("expression is not a property access");
      const objectExpr = expression.expression;
      const methodName = ts.idText(expression.name);
      if (!ts.isIdentifier(objectExpr) || ts.idText(objectExpr) !== "JSON") {
        return yield* fail3("object is not JSON");
      }
      if (methodName !== "parse" && methodName !== "stringify") {
        return yield* fail3("method is not parse or stringify");
      }
      return { node, methodName };
    });
    const effectTrySimple = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail3("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail3("Effect.try has no arguments");
      const lazyFn = yield* typeParser.lazyExpression(node.arguments[0]);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const effectTryObject = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail3("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail3("Effect.try has no arguments");
      const arg = node.arguments[0];
      if (!ts.isObjectLiteralExpression(arg)) return yield* fail3("argument is not an object literal");
      const tryProp = arg.properties.find(
        (p) => ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) && ts.idText(p.name) === "try"
      );
      if (!tryProp) return yield* fail3("object has no 'try' property");
      const lazyFn = yield* typeParser.lazyExpression(tryProp.initializer);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const jsonMethodInEffectGen = (node) => gen(function* () {
      const jsonMethod = yield* parseJsonMethod(node);
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) {
        return yield* fail3("not inside an Effect generator");
      }
      if (scopeNode && scopeNode !== effectGen.generatorFunction) {
        return yield* fail3("inside a nested function scope");
      }
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const match3 = yield* pipe(
        firstSuccessOf([
          effectTrySimple(node),
          effectTryObject(node),
          jsonMethodInEffectGen(node)
        ]),
        option
      );
      if (isSome2(match3)) {
        report({
          location: match3.value.node,
          messageText: "Consider using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify",
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/redundantSchemaTagIdentifier.ts
var redundantSchemaTagIdentifier = createDiagnostic({
  name: "redundantSchemaTagIdentifier",
  code: 42,
  description: "Suggests removing redundant identifier argument when it equals the tag value in Schema.TaggedClass/TaggedError/TaggedRequest",
  severity: "suggestion",
  apply: fn("redundantSchemaTagIdentifier.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsSchemaTaggedClass(node),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral && result.tagStringLiteral) {
          const { keyStringLiteral, tagStringLiteral } = result;
          if (keyStringLiteral.text === tagStringLiteral.text) {
            report({
              location: keyStringLiteral,
              messageText: `Identifier '${keyStringLiteral.text}' is redundant since it equals the _tag value`,
              fixes: [{
                fixName: "redundantSchemaTagIdentifier_removeIdentifier",
                description: `Remove redundant identifier '${keyStringLiteral.text}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.deleteRange(sourceFile, {
                    pos: ts.getTokenPosOfNode(keyStringLiteral, sourceFile),
                    end: keyStringLiteral.end
                  });
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/returnEffectInGen.ts
var returnEffectInGen = createDiagnostic({
  name: "returnEffectInGen",
  code: 11,
  description: "Warns when returning an Effect in a generator causes nested Effect<Effect<...>>",
  severity: "suggestion",
  apply: fn("returnEffectInGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isReturnStatement(node) && node.expression) {
        if (ts.isYieldExpression(node.expression)) continue;
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        const type = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (!type) continue;
        const maybeEffect = yield* option(typeParser.strictEffectType(type, node.expression));
        if (isSome2(maybeEffect)) {
          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
            const effectGenNode = generatorOrRegularFunction.parent;
            yield* pipe(
              typeParser.effectGen(effectGenNode),
              orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
              orElse2(() => typeParser.effectFnGen(effectGenNode)),
              map8(() => {
                const fix = node.expression ? [{
                  fixName: "returnEffectInGen_fix",
                  description: "Add yield* statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node.expression,
                      ts.factory.createYieldExpression(
                        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                        node.expression
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.
Maybe you wanted to return yield* instead?
Nested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,
                  fixes: fix
                });
              }),
              ignore
            );
          }
        }
      }
    }
  })
});

// src/diagnostics/runEffectInsideEffect.ts
var runEffectInsideEffect = createDiagnostic({
  name: "runEffectInsideEffect",
  code: 32,
  description: "Suggests using Runtime methods instead of Effect.run* inside Effect contexts",
  severity: "suggestion",
  apply: fn("runEffectInsideEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseEffectMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectModuleApi(methodName)(node),
      map8(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      if (node.arguments.length === 0) continue;
      const isEffectRunCall = yield* pipe(
        parseEffectMethod(node.expression, "runPromise"),
        orElse2(() => parseEffectMethod(node.expression, "runSync")),
        orElse2(() => parseEffectMethod(node.expression, "runFork")),
        orElse2(() => parseEffectMethod(node.expression, "runCallback")),
        option
      );
      if (isNone2(isEffectRunCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (effectGen && effectGen.body.statements.length > 0) {
        const nodeText = sourceFile.text.substring(
          ts.getTokenPosOfNode(node.expression, sourceFile),
          node.expression.end
        );
        if (scopeNode && scopeNode !== effectGen.generatorFunction) {
          const fixAddRuntime = gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const runtimeModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Runtime") || "Runtime";
            const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
            let runtimeIdentifier = void 0;
            for (const statement of effectGen.generatorFunction.body.statements) {
              if (ts.isVariableStatement(statement) && statement.declarationList.declarations.length === 1) {
                const declaration = statement.declarationList.declarations[0];
                if (declaration.initializer && ts.isYieldExpression(declaration.initializer) && declaration.initializer.asteriskToken && declaration.initializer.expression) {
                  const yieldedExpression = declaration.initializer.expression;
                  if (ts.isCallExpression(yieldedExpression)) {
                    const maybeEffectRuntime = yield* pipe(
                      typeParser.isNodeReferenceToEffectModuleApi("runtime")(yieldedExpression.expression),
                      option
                    );
                    if (isSome2(maybeEffectRuntime) && ts.isIdentifier(declaration.name)) {
                      runtimeIdentifier = ts.idText(declaration.name);
                    }
                  }
                }
              }
            }
            if (!runtimeIdentifier) {
              changeTracker.insertNodeAt(
                sourceFile,
                effectGen.body.statements[0].pos,
                ts.factory.createVariableStatement(
                  void 0,
                  ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(
                    "effectRuntime",
                    void 0,
                    void 0,
                    ts.factory.createYieldExpression(
                      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                      ts.factory.createCallExpression(
                        ts.factory.createPropertyAccessExpression(
                          ts.factory.createIdentifier(effectModuleIdentifier),
                          "runtime"
                        ),
                        [ts.factory.createTypeReferenceNode("never")],
                        []
                      )
                    )
                  )], ts.NodeFlags.Const)
                ),
                {
                  prefix: "\n",
                  suffix: "\n"
                }
              );
            }
            changeTracker.deleteRange(sourceFile, {
              pos: ts.getTokenPosOfNode(node.expression, sourceFile),
              end: node.arguments[0].pos
            });
            changeTracker.insertText(
              sourceFile,
              node.arguments[0].pos,
              `${runtimeModuleIdentifier}.${isEffectRunCall.value.methodName}(${runtimeIdentifier || "effectRuntime"}, `
            );
          });
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. The same runtime should generally be used instead to run child effects.
Consider extracting the Runtime by using for example Effect.runtime and then use Runtime.${isEffectRunCall.value.methodName} with the extracted runtime instead.`,
            fixes: [{
              fixName: "runEffectInsideEffect_fix",
              description: "Use a runtime to run the Effect",
              apply: fixAddRuntime
            }]
          });
        } else {
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. Effects inside generators can usually just be yielded.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/schemaStructWithTag.ts
var schemaStructWithTag = createDiagnostic({
  name: "schemaStructWithTag",
  code: 34,
  description: "Suggests using Schema.TaggedStruct instead of Schema.Struct with _tag field",
  severity: "suggestion",
  apply: fn("schemaStructWithTag.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaStructCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Struct")(node.expression),
          orElse2(() => void_)
        );
        if (isSchemaStructCall && node.arguments.length === 1) {
          const arg = node.arguments[0];
          if (ts.isObjectLiteralExpression(arg)) {
            const tagProperty = arg.properties.find(
              (prop) => ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name) && ts.idText(prop.name) === "_tag"
            );
            if (tagProperty && ts.isCallExpression(tagProperty.initializer)) {
              const isSchemaLiteralCall = yield* pipe(
                typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(
                  tagProperty.initializer.expression
                ),
                option
              );
              if (isSchemaLiteralCall._tag === "Some") {
                const literalCall = tagProperty.initializer;
                const literalArgs = fromIterable(literalCall.arguments);
                if (literalArgs.length === 1 && ts.isStringLiteral(literalArgs[0])) {
                  const tagValue = literalArgs[0].text;
                  const otherProperties = arg.properties.filter((prop) => prop !== tagProperty);
                  report({
                    location: node,
                    messageText: "Schema.Struct with a _tag field can be simplified to Schema.TaggedStruct to make the tag optional in the constructor.",
                    fixes: [{
                      fixName: "schemaStructWithTag_fix",
                      description: "Replace with Schema.TaggedStruct",
                      apply: gen(function* () {
                        const changeTracker = yield* service(ChangeTracker);
                        const newObjectLiteral = ts.factory.createObjectLiteralExpression(
                          otherProperties,
                          true
                        );
                        const newNode = ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            // Reuse the Schema identifier from the original expression
                            ts.isPropertyAccessExpression(node.expression) ? node.expression.expression : ts.factory.createIdentifier("Schema"),
                            "TaggedStruct"
                          ),
                          void 0,
                          [
                            ts.factory.createStringLiteral(tagValue),
                            newObjectLiteral
                          ]
                        );
                        changeTracker.replaceNode(sourceFile, node, newNode);
                      })
                    }]
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/schemaSyncInEffect.ts
var syncToEffectMethod = {
  decodeSync: "decode",
  decodeUnknownSync: "decodeUnknown",
  encodeSync: "encode",
  encodeUnknownSync: "encodeUnknown"
};
var schemaSyncInEffect = createDiagnostic({
  name: "schemaSyncInEffect",
  code: 43,
  description: "Suggests using Effect-based Schema methods instead of sync methods inside Effect generators",
  severity: "suggestion",
  apply: fn("schemaSyncInEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const parseSchemaSyncMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectParseResultModuleApi(methodName)(node),
      map8(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const isSchemaSyncCall = yield* pipe(
        firstSuccessOf(
          Object.keys(syncToEffectMethod).map((methodName) => parseSchemaSyncMethod(node.expression, methodName))
        ),
        option
      );
      if (isNone2(isSchemaSyncCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) continue;
      if (scopeNode && scopeNode !== effectGen.generatorFunction) continue;
      const nodeText = sourceFile.text.substring(
        ts.getTokenPosOfNode(node.expression, sourceFile),
        node.expression.end
      );
      const effectMethodName = syncToEffectMethod[isSchemaSyncCall.value.methodName];
      report({
        location: node.expression,
        messageText: `Using ${nodeText} inside an Effect generator is not recommended. Use Schema.${effectMethodName} instead to get properly typed ParseError in the error channel.`,
        fixes: []
      });
    }
  })
});

// src/diagnostics/schemaUnionOfLiterals.ts
var schemaUnionOfLiterals = createDiagnostic({
  name: "schemaUnionOfLiterals",
  code: 33,
  description: "Simplifies Schema.Union of multiple Schema.Literal calls into single Schema.Literal",
  severity: "off",
  apply: fn("schemaUnionOfLiterals.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaUnionCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Union")(node.expression),
          orElse2(() => void_)
        );
        if (isSchemaUnionCall) {
          const args2 = fromIterable(node.arguments);
          if (args2.length >= 2) {
            const allAreCallExpressions = args2.every((arg) => ts.isCallExpression(arg));
            if (allAreCallExpressions) {
              const literalChecks = args2.map((arg) => {
                const callArg = arg;
                return pipe(
                  typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(callArg.expression),
                  map8(() => callArg)
                );
              });
              const allLiteralsResult = yield* pipe(
                all(...literalChecks),
                option
              );
              if (allLiteralsResult._tag === "Some") {
                const allLiteralValues = [];
                for (const literalCall of allLiteralsResult.value) {
                  for (const arg of literalCall.arguments) {
                    allLiteralValues.push(arg);
                  }
                }
                const firstLiteralCall = allLiteralsResult.value[0];
                const schemaLiteralExpression = firstLiteralCall.expression;
                report({
                  location: node,
                  messageText: "A Schema.Union of multiple Schema.Literal calls can be simplified to a single Schema.Literal call.",
                  fixes: [{
                    fixName: "schemaUnionOfLiterals_fix",
                    description: "Replace with a single Schema.Literal call",
                    apply: gen(function* () {
                      const changeTracker = yield* service(ChangeTracker);
                      const newNode = ts.factory.createCallExpression(
                        schemaLiteralExpression,
                        void 0,
                        allLiteralValues
                      );
                      changeTracker.replaceNode(sourceFile, node, newNode);
                    })
                  }]
                });
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/scopeInLayerEffect.ts
var scopeInLayerEffect = createDiagnostic({
  name: "scopeInLayerEffect",
  code: 13,
  description: "Suggests using Layer.scoped instead of Layer.effect when Scope is in requirements",
  severity: "warning",
  apply: fn("scopeInLayerEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    function parseLayerEffectApiCall(node) {
      if (!ts.isCallExpression(node)) return;
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return;
      const calledModule = expression.expression;
      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return;
      const methodIdentifier = expression.name;
      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith("effect"))) return;
      return { methodIdentifier };
    }
    const reportIfLayerRequireScope = (type, node, methodIdentifier) => {
      const entries2 = typeCheckerUtils.unrollUnionMembers(type);
      return pipe(
        firstSuccessOf(entries2.map((type2) => typeParser.scopeType(type2, node))),
        map8(
          () => report({
            location: node,
            messageText: `Seems like you are constructing a layer with a scope in the requirements.
Consider using "scoped" instead to get rid of the scope in the requirements.`,
            fixes: methodIdentifier ? [{
              fixName: "scopeInLayerEffect_scoped",
              description: "Use scoped for Layer creation",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                changeTracker.replaceNode(
                  sourceFile,
                  methodIdentifier,
                  ts.factory.createIdentifier("scoped")
                );
              })
            }] : []
          })
        ),
        ignore
      );
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const layerEffectApiCall = parseLayerEffectApiCall(node);
      if (layerEffectApiCall) {
        const type = typeCheckerUtils.getTypeAtLocation(node);
        if (type) {
          yield* pipe(
            typeParser.layerType(type, node),
            flatMap4(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),
            ignore
          );
        }
        continue;
      }
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const classType = typeChecker.getTypeOfSymbol(classSym);
          const defaultLayer = typeChecker.getPropertyOfType(classType, "Default");
          if (defaultLayer) {
            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node);
            yield* pipe(
              typeParser.layerType(type, node),
              flatMap4(({ RIn }) => reportIfLayerRequireScope(RIn, node, void 0)),
              ignore
            );
            continue;
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/strictBooleanExpressions.ts
var strictBooleanExpressions = createDiagnostic({
  name: "strictBooleanExpressions",
  code: 17,
  description: "Enforces boolean types in conditional expressions for type safety",
  severity: "off",
  apply: fn("strictBooleanExpressions.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const conditionChecks = /* @__PURE__ */ new WeakMap();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const nodes2 = [];
      if (ts.isIfStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isWhileStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isConditionalExpression(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.condition);
      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {
        conditionChecks.set(node, true);
        nodes2.push(node.operand);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      }
      for (const nodeToCheck of nodes2) {
        if (!nodeToCheck) continue;
        if (!conditionChecks.has(nodeToCheck.parent)) continue;
        if (!ts.isExpression(nodeToCheck)) continue;
        const nodeType = typeCheckerUtils.getTypeAtLocation(nodeToCheck);
        if (!nodeType) continue;
        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType);
        let typesToCheck = [constrainedType || nodeType];
        while (typesToCheck.length > 0) {
          const type = typesToCheck.pop();
          if (typeCheckerUtils.isUnion(type)) {
            typesToCheck = typesToCheck.concat(type.types);
            continue;
          }
          if (type.flags & ts.TypeFlags.Boolean) continue;
          if (type.flags & ts.TypeFlags.Never) continue;
          if (type.flags & ts.TypeFlags.BooleanLiteral) continue;
          const typeName = typeChecker.typeToString(type);
          report({
            location: nodeToCheck,
            messageText: `Unexpected \`${typeName}\` type in condition, expected strictly a boolean instead.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/strictEffectProvide.ts
var strictEffectProvide = createDiagnostic({
  name: "strictEffectProvide",
  code: 27,
  description: "Warns when using Effect.provide with layers outside of application entry points",
  severity: "off",
  apply: fn("strictEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const parseEffectProvideWithLayer = (node) => gen(function* () {
      if (!ts.isCallExpression(node) || node.arguments.length === 0) {
        return yield* typeParserIssue("Not an Effect.provide call");
      }
      yield* typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression);
      return yield* firstSuccessOf(
        node.arguments.map((arg) => {
          const argType = typeCheckerUtils.getTypeAtLocation(arg);
          if (!argType) return typeParserIssue("Could not get argument type");
          return typeParser.layerType(argType, arg);
        })
      );
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), option);
        if (isSome2(layerCheck)) {
          report({
            location: node,
            messageText: "Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.",
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/tryCatchInEffectGen.ts
var tryCatchInEffectGen = createDiagnostic({
  name: "tryCatchInEffectGen",
  code: 15,
  description: "Discourages try/catch in Effect generators in favor of Effect error handling",
  severity: "suggestion",
  apply: fn("tryCatchInEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isTryStatement(node) && node.catchClause) {
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        if (!generatorOrRegularFunction) continue;
        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
          const effectGenNode = generatorOrRegularFunction.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map8(() => {
              report({
                location: node,
                messageText: "Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).",
                fixes: []
              });
            }),
            ignore
          );
        }
      }
    }
  })
});

// src/diagnostics/unknownInEffectCatch.ts
var unknownInEffectCatch = createDiagnostic({
  name: "unknownInEffectCatch",
  code: 31,
  description: "Warns when catch callbacks return unknown instead of typed errors",
  severity: "warning",
  apply: fn("unknownInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse2(() => void_)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && (returnType.flags & ts.TypeFlags.Unknown || returnType.flags & ts.TypeFlags.Any)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns 'unknown'. The catch callback should be used to provide typed errors.
Consider wrapping unknown errors into Effect's Data.TaggedError for example, or narrow down the type to the specific error raised.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/unnecessaryEffectGen.ts
var unnecessaryEffectGen = createDiagnostic({
  name: "unnecessaryEffectGen",
  code: 5,
  description: "Suggests removing Effect.gen when it contains only a single return statement",
  severity: "suggestion",
  apply: fn("unnecessaryEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.unnecessaryEffectGen(node),
          map8(
            ({ replacementNode }) => report({
              location: node,
              messageText: `This Effect.gen contains a single return statement.`,
              fixes: [{
                fixName: "unnecessaryEffectGen_fix",
                description: "Remove the Effect.gen, and keep the body",
                apply: gen(function* () {
                  const textChanges = yield* service(
                    ChangeTracker
                  );
                  textChanges.replaceNode(sourceFile, node, yield* replacementNode);
                })
              }]
            })
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryFailYieldableError.ts
var unnecessaryFailYieldableError = createDiagnostic({
  name: "unnecessaryFailYieldableError",
  code: 29,
  description: "Suggests yielding yieldable errors directly instead of wrapping with Effect.fail",
  severity: "suggestion",
  apply: fn("unnecessaryFailYieldableError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.asteriskToken && node.expression && ts.isCallExpression(node.expression)) {
        const callExpression = node.expression;
        yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("fail")(callExpression.expression),
          flatMap4(() => {
            if (callExpression.arguments.length > 0) {
              const failArgument = callExpression.arguments[0];
              const argumentType = typeCheckerUtils.getTypeAtLocation(failArgument);
              if (!argumentType) return void_;
              return pipe(
                typeParser.extendsCauseYieldableError(argumentType),
                map8(
                  () => report({
                    location: node,
                    messageText: `This Effect.fail call uses a yieldable error type as argument. You can yield* the error directly instead.`,
                    fixes: [{
                      fixName: "unnecessaryFailYieldableError_fix",
                      description: "Replace yield* Effect.fail with yield*",
                      apply: gen(function* () {
                        const changeTracker = yield* service(ChangeTracker);
                        changeTracker.replaceNode(
                          sourceFile,
                          callExpression,
                          failArgument
                        );
                      })
                    }]
                  })
                )
              );
            }
            return void_;
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipe.ts
var unnecessaryPipe = createDiagnostic({
  name: "unnecessaryPipe",
  code: 9,
  description: "Removes pipe calls with no arguments",
  severity: "suggestion",
  apply: fn("unnecessaryPipe.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          map8(({ args: args2, subject }) => {
            if (args2.length === 0) {
              report({
                location: node,
                messageText: `This pipe call contains no arguments.`,
                fixes: [{
                  fixName: "unnecessaryPipe_fix",
                  description: "Remove the pipe call",
                  apply: gen(function* () {
                    const textChanges = yield* service(
                      ChangeTracker
                    );
                    textChanges.replaceNode(sourceFile, node, subject);
                  })
                }]
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipeChain.ts
var unnecessaryPipeChain = createDiagnostic({
  name: "unnecessaryPipeChain",
  code: 16,
  description: "Simplifies chained pipe calls into a single pipe call",
  severity: "suggestion",
  apply: fn("unnecessaryPipeChain.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          flatMap4(
            (pipeCall) => map8(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))
          ),
          map8(({ innerCall, pipeCall }) => {
            report({
              location: node,
              messageText: `Chained pipe calls can be simplified to a single pipe call`,
              fixes: [{
                fixName: "unnecessaryPipeChain_fix",
                description: "Rewrite as single pipe call",
                apply: gen(function* () {
                  const changeTracker = yield* service(
                    ChangeTracker
                  );
                  switch (innerCall.kind) {
                    case "pipe": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createIdentifier("pipe"),
                          void 0,
                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                    case "pipeable": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            innerCall.subject,
                            "pipe"
                          ),
                          void 0,
                          [...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                  }
                })
              }]
            });
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unsupportedServiceAccessors.ts
var unsupportedServiceAccessors = createDiagnostic({
  name: "unsupportedServiceAccessors",
  code: 21,
  description: "Warns about service accessors that need codegen due to generic/complex signatures",
  severity: "warning",
  apply: fn("unsupportedServiceAccessors.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isClassDeclaration(node)) {
        const parseResult = yield* pipe(
          parse2(node),
          orElse2(() => succeed(null))
        );
        if (parseResult && parseResult.involvedMembers.length > 0) {
          const existingStaticMembers = /* @__PURE__ */ new Set();
          node.members?.forEach((member) => {
            if (ts.isPropertyDeclaration(member) && member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)) {
              if (member.name && ts.isIdentifier(member.name)) {
                existingStaticMembers.add(ts.idText(member.name));
              }
            }
          });
          const missingMembers = parseResult.involvedMembers.filter(
            ({ property }) => !existingStaticMembers.has(ts.symbolName(property))
          );
          if (missingMembers.length > 0) {
            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(", ");
            const suggestedFix = parseResult.kind === "effectTag" ? "\nEffect.Tag does not allow to disable accessors, so you may want to use Context.Tag instead." : "";
            report({
              location: parseResult.className,
              messageText: `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.${suggestedFix}`,
              fixes: [{
                fixName: "unsupportedServiceAccessors_enableCodegen",
                description: "Enable accessors codegen",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const comment = "// @effect-codegens accessors\n";
                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment);
                })
              }]
            });
          }
        }
      }
    }
  })
});

// src/diagnostics.ts
var diagnostics = [
  anyUnknownInErrorContext,
  instanceOfSchema,
  catchAllToMapError,
  catchUnfailableEffect,
  classSelfMismatch,
  duplicatePackage,
  effectGenUsesAdapter,
  missingEffectContext,
  missingEffectError,
  missingEffectServiceDependency,
  missingLayerContext,
  floatingEffect,
  missingStarInYieldEffectGen,
  unnecessaryEffectGen,
  unnecessaryFailYieldableError,
  missingReturnYieldStar,
  leakingRequirements,
  unnecessaryPipe,
  genericEffectServices,
  returnEffectInGen,
  tryCatchInEffectGen,
  importFromBarrel,
  scopeInLayerEffect,
  effectInVoidSuccess,
  unnecessaryPipeChain,
  strictBooleanExpressions,
  multipleEffectProvide,
  outdatedEffectCodegen,
  overriddenSchemaConstructor,
  unsupportedServiceAccessors,
  nonObjectEffectServiceType,
  deterministicKeys,
  missedPipeableOpportunity,
  strictEffectProvide,
  unknownInEffectCatch,
  runEffectInsideEffect,
  schemaUnionOfLiterals,
  schemaStructWithTag,
  globalErrorInEffectCatch,
  globalErrorInEffectFailure,
  layerMergeAllWithDependencies,
  effectMapVoid,
  effectSucceedWithVoid,
  effectFnIife,
  effectFnOpportunity,
  redundantSchemaTagIdentifier,
  schemaSyncInEffect,
  preferSchemaOverJson
];

// src/completions/effectDiagnosticsComment.ts
var effectDiagnosticsComment = createCompletion({
  name: "effectDiagnosticsComment",
  apply: fn("effectDiagnosticsComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      const allDiagnostics = sort(Object.values(diagnostics).map((diagnostic) => diagnostic.name), string2).join(",");
      const disableSnippet = "${1|" + allDiagnostics + "|}:${2|off,warning,error,message,suggestion|}$0";
      return [{
        name: `@effect-diagnostics`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-diagnostics " + disableSnippet,
        isSnippet: true,
        replacementSpan
      }, {
        name: `@effect-diagnostics-next-line`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-diagnostics-next-line " + disableSnippet,
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectJsdocComment.ts
var effectJsdocComment = createCompletion({
  name: "effectJsdocComment",
  apply: fn("effectJsdocComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      return [{
        name: `@effect-identifier`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-identifier",
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectSchemaSelfInClasses.ts
var effectSchemaSelfInClasses = createCompletion({
  name: "effectSchemaSelfInClasses",
  apply: fn("effectSchemaSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Schema"
    ) || "Schema";
    const isFullyQualified = schemaIdentifier === ts.idText(accessedObject);
    const name = ts.idText(className);
    const errorTagKey = (yield* createString(sourceFile, name, "error")) || name;
    const completions2 = [];
    const hasClassCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectSchemaModuleApi("Class")(accessedObject),
        option
      )
    );
    if (hasClassCompletion) {
      completions2.push({
        name: `Class<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${schemaIdentifier}.Class<${name}>("${name}")({${"${0}"}}){}` : `Class<${name}>("${name}")({${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    const hasTaggedErrorCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectSchemaModuleApi("TaggedError")(accessedObject),
        option
      )
    );
    if (hasTaggedErrorCompletion) {
      completions2.push({
        name: `TaggedError<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${schemaIdentifier}.TaggedError<${name}>()("${errorTagKey}", {${"${0}"}}){}` : `TaggedError<${name}>()("${errorTagKey}", {${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    const hasTaggedClassCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(accessedObject),
        option
      )
    );
    if (hasTaggedClassCompletion) {
      completions2.push({
        name: `TaggedClass<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${schemaIdentifier}.TaggedClass<${name}>()("${name}", {${"${0}"}}){}` : `TaggedClass<${name}>()("${name}", {${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    const hasTaggedRequestCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(accessedObject),
        option
      )
    );
    if (hasTaggedRequestCompletion) {
      completions2.push({
        name: `TaggedRequest<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${schemaIdentifier}.TaggedRequest<${name}>()("${name}", {${"${0}"}}){}` : `TaggedRequest<${name}>()("${name}", {${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    return completions2;
  })
});

// src/completions/effectSelfInClasses.ts
var effectSelfInClasses = createCompletion({
  name: "effectSelfInClasses",
  apply: fn("effectSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const isFullyQualified = effectIdentifier === ts.idText(accessedObject);
    const name = ts.idText(className);
    const tagKey = (yield* createString(sourceFile, name, "service")) || name;
    const completions2 = [];
    const hasServiceCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectModuleApi("Service")(accessedObject),
        option
      )
    );
    if (hasServiceCompletion) {
      completions2.push({
        name: `Service<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${effectIdentifier}.Service<${name}>()("${tagKey}", {${"${0}"}}){}` : `Service<${name}>()("${tagKey}", {${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    const hasTagCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectModuleApi("Tag")(accessedObject),
        option
      )
    );
    if (hasTagCompletion) {
      completions2.push({
        name: `Tag("${name}")`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${effectIdentifier}.Tag("${tagKey}")<${name}, {${"${0}"}}>(){}` : `Tag("${tagKey}")<${name}, {${"${0}"}}>(){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    return completions2;
  })
});

// src/completions/effectSqlModelSelfInClasses.ts
var effectSqlModelSelfInClasses = createCompletion({
  name: "effectSqlModelSelfInClasses",
  apply: fn("effectSqlModelSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "@effect/sql",
      "Model"
    ) || "Model";
    const isFullyQualified = schemaIdentifier === ts.idText(accessedObject);
    const name = ts.idText(className);
    const completions2 = [];
    const hasClassCompletion = isFullyQualified || isSome2(
      yield* pipe(
        typeParser.isNodeReferenceToEffectSqlModelModuleApi("Class")(accessedObject),
        option
      )
    );
    if (hasClassCompletion) {
      completions2.push({
        name: `Class<${name}>`,
        kind: ts.ScriptElementKind.constElement,
        insertText: isFullyQualified ? `${schemaIdentifier}.Class<${name}>("${name}")({${"${0}"}}){}` : `Class<${name}>("${name}")({${"${0}"}}){}`,
        replacementSpan,
        isSnippet: true
      });
    }
    return completions2;
  })
});

// src/completions/fnFunctionStar.ts
var fnFunctionStar = createCompletion({
  name: "fnFunctionStar",
  apply: fn("fnFunctionStar")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    const isEffectModule = yield* option(typeParser.importedEffectModule(accessedObject));
    if (isNone2(isEffectModule)) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    const maybeFnName = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),
      filter(ts.isVariableDeclaration),
      map4((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : ""),
      filter((_) => _.length > 0),
      head,
      map2((name) => [
        {
          name: `fn("${name}")`,
          kind: ts.ScriptElementKind.constElement,
          insertText: `fn("${name}")(function*(${"${1}"}){${"${0}"}})`,
          replacementSpan: span,
          isSnippet: true
        }
      ]),
      getOrElse2(() => [])
    );
    return maybeFnName.concat([{
      name: `fn(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `fn(function*(${"${1}"}){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }, {
      name: `fnUntraced(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `fnUntraced(function*(${"${1}"}){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }]);
  })
});

// src/completions/genFunctionStar.ts
var genFunctionStar = createCompletion({
  name: "genFunctionStar",
  apply: fn("genFunctionStar")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    const type = typeCheckerUtils.getTypeAtLocation(accessedObject);
    if (!type) return [];
    const genMemberSymbol = type.getProperty("gen");
    if (!genMemberSymbol) return [];
    const genType = typeChecker.getTypeOfSymbolAtLocation(genMemberSymbol, accessedObject);
    if (typeChecker.getSignaturesOfType(genType, ts.SignatureKind.Call).length === 0) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    return [{
      name: `gen(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `gen(function*(){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }];
  })
});

// src/completions/rpcMakeClasses.ts
var rpcMakeClasses = createCompletion({
  name: "rpcMakeClasses",
  apply: fn("rpcMakeClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const rpcIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "@effect/rpc",
      "Rpc"
    ) || "Rpc";
    if (rpcIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    return [{
      name: `make("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${rpcIdentifier}.make("${name}", {${"${0}"}}) {}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/completions/schemaBrand.ts
var schemaBrand = createCompletion({
  name: "schemaBrand",
  apply: fn("schemaBrand")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return [];
    const schemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Schema"
    ) || "Schema";
    if (schemaName !== ts.idText(accessedObject)) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),
      filter(ts.isVariableDeclaration),
      map4((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : ""),
      filter((_) => _.length > 0),
      head,
      map2((name) => [
        {
          name: `brand("${name}")`,
          kind: ts.ScriptElementKind.constElement,
          insertText: `brand("${name}")`,
          replacementSpan: span,
          isSnippet: true
        }
      ]),
      getOrElse2(() => [])
    );
  })
});

// src/completions.ts
var completions = [
  effectSqlModelSelfInClasses,
  effectSchemaSelfInClasses,
  effectSelfInClasses,
  contextSelfInClasses,
  rpcMakeClasses,
  genFunctionStar,
  fnFunctionStar,
  effectDataClasses,
  effectDiagnosticsComment,
  effectCodegensComment,
  effectJsdocComment,
  durationInput,
  schemaBrand
];

// src/core/AutoImport.ts
var makeAutoImportProvider = fn("TypeScriptApi")(function* (fromSourceFile) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const program = yield* service(TypeScriptProgram);
  const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
  const host = program;
  const getModuleSpecifier = makeGetModuleSpecifier(ts);
  const resolvePackageNameToPackageJson = makeResolvePackageNameToPackageJson(ts);
  const getEntrypointsFromPackageJsonInfo = makeGetEntrypointsFromPackageJsonInfo(ts);
  function collectSourceFileReexports(sourceFile) {
    const namespaceExports = [];
    const namedExports = [];
    for (const statement of sourceFile.statements) {
      if (!ts.isExportDeclaration(statement)) continue;
      if (!statement.exportClause) continue;
      const moduleSpecifier = statement.moduleSpecifier;
      if (!moduleSpecifier) continue;
      if (!ts.isStringLiteral(moduleSpecifier)) continue;
      const exportClause = statement.exportClause;
      if (ts.isNamespaceExport(exportClause)) {
        if (!exportClause.name) continue;
        if (!ts.isIdentifier(exportClause.name)) continue;
        namespaceExports.push({
          moduleSpecifier,
          exportClause,
          name: ts.idText(exportClause.name)
        });
      }
      if (ts.isNamedExports(exportClause)) {
        for (const exportSpecifier of exportClause.elements) {
          const exportName = exportSpecifier.propertyName || exportSpecifier.name;
          if (!ts.isIdentifier(exportName)) continue;
          if (!ts.isIdentifier(exportSpecifier.name)) continue;
          namedExports.push({
            moduleSpecifier,
            exportClause,
            name: ts.idText(exportName),
            aliasName: ts.idText(exportSpecifier.name)
          });
        }
      }
    }
    return { namespaceExports, namedExports };
  }
  function getPackageInfo(fromFileName, packageName) {
    try {
      if (!resolvePackageNameToPackageJson || !getEntrypointsFromPackageJsonInfo) return;
      const packageJsonInfo = resolvePackageNameToPackageJson(
        packageName,
        fromFileName,
        program.getCompilerOptions(),
        host
      );
      if (!packageJsonInfo) return;
      const _entrypoints = getEntrypointsFromPackageJsonInfo(
        packageJsonInfo,
        program.getCompilerOptions(),
        host
      );
      if (!_entrypoints) return;
      if (!isArray(_entrypoints)) return;
      if (!every(isString)) return;
      const entrypoints = _entrypoints.map((_) => String(_));
      const info = tsUtils.parsePackageContentNameAndVersionFromScope({ packageJsonScope: packageJsonInfo });
      if (!info) return { entrypoints, exportedKeys: [] };
      return { entrypoints, exportedKeys: info.exportsKeys };
    } catch (_) {
      return void 0;
    }
  }
  const mapFromBarrelToNamespace = /* @__PURE__ */ new Map();
  const mapFromBarrelToBarrel = /* @__PURE__ */ new Map();
  const mapFromNamespaceToBarrel = /* @__PURE__ */ new Map();
  const mapFilenameToModuleAlias = /* @__PURE__ */ new Map();
  const mapFilenameToExportExcludes = /* @__PURE__ */ new Map();
  const mapFilenameToModuleName = /* @__PURE__ */ new Map();
  const collectModuleNames = (packageName, exportedKey) => {
    const appendPart = exportedKey === "." ? "" : exportedKey.startsWith("./") ? exportedKey.slice(1) : exportedKey;
    const absoluteName = packageName + appendPart;
    const absoluteFileName = ts.resolveModuleName(
      absoluteName,
      fromSourceFile.fileName,
      program.getCompilerOptions(),
      host
    );
    if (!absoluteFileName) return;
    if (!absoluteFileName.resolvedModule) return;
    const realPath = host.realpath ? host.realpath(absoluteFileName.resolvedModule.resolvedFileName) : absoluteFileName.resolvedModule.resolvedFileName;
    if (mapFilenameToModuleName.has(realPath)) return;
    mapFilenameToModuleName.set(realPath, absoluteName);
  };
  const collectImportCache = fn("TypeScriptApi")(
    function* (packagePatterns, kind, topLevelNamedReexports) {
      for (const packagePattern of packagePatterns) {
        const packageNames = tsUtils.resolveModulePattern(program, fromSourceFile, packagePattern);
        for (const packageName of packageNames) {
          const packageInfo = getPackageInfo(fromSourceFile.fileName, packageName);
          if (!packageInfo) continue;
          for (const exportedKey of packageInfo.exportedKeys) {
            collectModuleNames(packageName, exportedKey);
          }
          for (const _fileName of packageInfo.entrypoints) {
            const realFileName = host.realpath ? host.realpath(_fileName) : _fileName;
            const isPackageRoot = mapFilenameToModuleName.get(realFileName) === packageName;
            const barrelSourceFile = program.getSourceFile(realFileName) || ts.createSourceFile(realFileName, host.readFile(realFileName) || "", fromSourceFile.languageVersion, true);
            const reExports = collectSourceFileReexports(barrelSourceFile);
            if (!reExports) continue;
            if (reExports.namespaceExports.length === 0) continue;
            for (const namespaceReexport of reExports.namespaceExports) {
              const reexportedFile = ts.resolveModuleName(
                namespaceReexport.moduleSpecifier.text,
                barrelSourceFile.fileName,
                program.getCompilerOptions(),
                host
              );
              if (!reexportedFile) continue;
              if (!reexportedFile.resolvedModule) continue;
              switch (kind) {
                case "namespace": {
                  mapFromBarrelToNamespace.set(
                    barrelSourceFile.fileName,
                    {
                      ...mapFromBarrelToNamespace.get(barrelSourceFile.fileName) || {},
                      [namespaceReexport.name]: reexportedFile.resolvedModule.resolvedFileName
                    }
                  );
                  mapFilenameToModuleAlias.set(
                    reexportedFile.resolvedModule.resolvedFileName,
                    namespaceReexport.name
                  );
                  continue;
                }
                case "barrel": {
                  mapFromNamespaceToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {
                    fileName: barrelSourceFile.fileName,
                    alias: namespaceReexport.name
                  });
                }
              }
            }
            if (isPackageRoot) {
              for (const namedExport of reExports.namedExports) {
                if (topLevelNamedReexports === "ignore") {
                  mapFilenameToExportExcludes.set(barrelSourceFile.fileName, [
                    ...mapFilenameToExportExcludes.get(barrelSourceFile.fileName) || [],
                    namedExport.name
                  ]);
                } else if (topLevelNamedReexports === "follow") {
                  const reexportedFile = ts.resolveModuleName(
                    namedExport.moduleSpecifier.text,
                    barrelSourceFile.fileName,
                    program.getCompilerOptions(),
                    host
                  );
                  if (!reexportedFile) continue;
                  if (!reexportedFile.resolvedModule) continue;
                  mapFromBarrelToBarrel.set(barrelSourceFile.fileName, {
                    ...mapFromBarrelToBarrel.get(barrelSourceFile.fileName) || {},
                    [namedExport.name]: {
                      fileName: reexportedFile.resolvedModule.resolvedFileName,
                      exportName: namedExport.name
                    }
                  });
                  mapFromBarrelToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {
                    ...mapFromBarrelToBarrel.get(reexportedFile.resolvedModule.resolvedFileName) || {},
                    [namedExport.name]: {
                      fileName: reexportedFile.resolvedModule.resolvedFileName,
                      exportName: namedExport.name
                    }
                  });
                }
              }
            }
          }
        }
      }
    }
  );
  yield* collectImportCache(
    languageServicePluginOptions.namespaceImportPackages,
    "namespace",
    languageServicePluginOptions.topLevelNamedReexports
  );
  yield* collectImportCache(languageServicePluginOptions.barrelImportPackages, "barrel", "ignore");
  const resolveModuleName = (fileName) => {
    const fixedModuleName = mapFilenameToModuleName.get(fileName);
    if (fixedModuleName) return fixedModuleName;
    if (!getModuleSpecifier) return fileName;
    const moduleSpecifier = getModuleSpecifier(
      program.getCompilerOptions(),
      fromSourceFile,
      fromSourceFile.fileName,
      fileName,
      host
    );
    if (!moduleSpecifier) return fileName;
    return moduleSpecifier;
  };
  const resolveAliasName = (chosenName) => {
    const aliasName = languageServicePluginOptions.importAliases[chosenName];
    if (aliasName) return aliasName;
    return void 0;
  };
  const resolve = (exportFileName, exportName) => {
    const excludedExports = mapFilenameToExportExcludes.get(exportFileName);
    if (excludedExports && excludedExports.includes(exportName)) return;
    const mapToBarrelRewritten = mapFromBarrelToBarrel.get(exportFileName);
    if (mapToBarrelRewritten && exportName in mapToBarrelRewritten) {
      const reexportedFile = mapToBarrelRewritten[exportName];
      if (reexportedFile) {
        return {
          _tag: "NamedImport",
          fileName: reexportedFile.fileName,
          moduleName: resolveModuleName(reexportedFile.fileName),
          name: exportName,
          aliasName: resolveAliasName(exportName),
          introducedPrefix: void 0
        };
      }
    }
    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName);
    if (mapToNamespace && exportName in mapToNamespace) {
      const namespacedFileName = mapToNamespace[exportName];
      if (namespacedFileName) {
        const introducedAlias2 = mapFilenameToModuleAlias.get(namespacedFileName);
        if (introducedAlias2) {
          return {
            _tag: "NamespaceImport",
            fileName: namespacedFileName,
            moduleName: resolveModuleName(namespacedFileName),
            name: introducedAlias2,
            aliasName: resolveAliasName(introducedAlias2),
            introducedPrefix: void 0
          };
        }
      }
    }
    const introducedAlias = mapFilenameToModuleAlias.get(exportFileName);
    if (introducedAlias) {
      return {
        _tag: "NamespaceImport",
        fileName: exportFileName,
        moduleName: resolveModuleName(exportFileName),
        name: introducedAlias,
        aliasName: resolveAliasName(introducedAlias),
        introducedPrefix: resolveAliasName(introducedAlias) || introducedAlias
      };
    }
    const mapToBarrel = mapFromNamespaceToBarrel.get(exportFileName);
    if (mapToBarrel) {
      return {
        _tag: "NamedImport",
        fileName: mapToBarrel.fileName,
        moduleName: resolveModuleName(mapToBarrel.fileName),
        name: mapToBarrel.alias,
        aliasName: resolveAliasName(mapToBarrel.alias),
        introducedPrefix: resolveAliasName(mapToBarrel.alias) || mapToBarrel.alias
      };
    }
  };
  const sortText = (exportFileName, exportName) => {
    const excludedExports = mapFilenameToExportExcludes.get(exportFileName);
    if (excludedExports && excludedExports.includes(exportName)) return;
    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName);
    if (mapToNamespace && exportName in mapToNamespace) return "99";
  };
  return { resolve, sortText };
});
var importProvidersCache = /* @__PURE__ */ new Map();
var getOrMakeAutoImportProvider = fn("getOrMakeAutoImportProvider")(function* (sourceFile) {
  while (importProvidersCache.size > 5) {
    const oldest = importProvidersCache.keys().next().value;
    if (oldest) importProvidersCache.delete(oldest);
  }
  const autoImportProvider = importProvidersCache.get(sourceFile.fileName) || (yield* makeAutoImportProvider(sourceFile));
  importProvidersCache.set(sourceFile.fileName, autoImportProvider);
  return autoImportProvider;
});
var parseImportOnlyChanges = fn("parseImportOnlyChanges")(function* (sourceFile, changes) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const deletions = [];
  const imports = [];
  for (const change of changes) {
    if (change.newText.length === 0) {
      deletions.push(change);
      continue;
    }
    if (change.newText.trim().startsWith("import") && change.newText.trim().includes("from")) {
      try {
        const parsedImport = ts.createSourceFile("test.ts", change.newText, sourceFile.languageVersion, false);
        for (const statement of parsedImport.statements) {
          if (!ts.isImportDeclaration(statement)) return;
          const moduleSpecifier = statement.moduleSpecifier;
          if (!ts.isStringLiteral(moduleSpecifier)) return;
          const moduleName = moduleSpecifier.text;
          const importClause = statement.importClause;
          if (!importClause) return;
          const namedBindings = importClause.namedBindings;
          if (!namedBindings) return;
          if (ts.isNamedImports(namedBindings)) {
            for (const importSpecifier of namedBindings.elements) {
              if (!ts.isIdentifier(importSpecifier.name)) return;
              const exportName = ts.idText(importSpecifier.name);
              imports.push({ moduleName, exportName });
              continue;
            }
          } else if (ts.isNamespaceImport(namedBindings)) {
            imports.push({ moduleName, exportName: void 0 });
            continue;
          }
        }
      } catch (_) {
        return;
      }
    } else {
      const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, {
        pos: change.span.start,
        end: change.span.start
      });
      const importNodes = ancestorNodes.filter((node) => ts.isImportDeclaration(node));
      const importNode = importNodes[0];
      if (!importNode) return;
      const moduleSpecifier = importNode.moduleSpecifier;
      if (!ts.isStringLiteral(moduleSpecifier)) return;
      const moduleName = moduleSpecifier.text;
      const exportName = change.newText.replace(/,/ig, "").trim();
      if (exportName.length === 0) return;
      imports.push({ moduleName, exportName });
    }
  }
  return { deletions, imports };
});
var addImport = (ts, sourceFile, changeTracker, preferences, effectAutoImport) => {
  let description = "";
  switch (effectAutoImport._tag) {
    case "NamespaceImport": {
      const aliasName = effectAutoImport.aliasName || effectAutoImport.name;
      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName;
      description = `Import * as ${aliasName} from "${importModule}"`;
      ts.insertImports(
        changeTracker,
        sourceFile,
        ts.factory.createImportDeclaration(
          void 0,
          ts.factory.createImportClause(
            false,
            void 0,
            ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasName))
          ),
          ts.factory.createStringLiteral(importModule)
        ),
        true,
        preferences || {}
      );
      break;
    }
    case "NamedImport": {
      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName;
      if (effectAutoImport.aliasName) {
        description = `Import { ${effectAutoImport.name} as ${effectAutoImport.aliasName} } from "${importModule}"`;
      } else {
        description = `Import { ${effectAutoImport.name} } from "${importModule}"`;
      }
      let foundImportDeclaration = false;
      for (const statement of sourceFile.statements) {
        if (ts.isImportDeclaration(statement)) {
          const moduleSpecifier = statement.moduleSpecifier;
          if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier) && moduleSpecifier.text === importModule) {
            const importClause = statement.importClause;
            if (importClause && importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {
              const namedImports = importClause.namedBindings;
              const existingImportSpecifier = namedImports.elements.find((element) => {
                if (effectAutoImport.aliasName) {
                  return ts.idText(element.name) === effectAutoImport.name && element.propertyName && ts.isIdentifier(element.propertyName) && ts.idText(element.propertyName) === effectAutoImport.aliasName;
                }
                return ts.idText(element.name) === effectAutoImport.name;
              });
              if (existingImportSpecifier) {
                foundImportDeclaration = true;
                break;
              }
              changeTracker.replaceNode(
                sourceFile,
                namedImports,
                ts.factory.createNamedImports(
                  namedImports.elements.concat([
                    ts.factory.createImportSpecifier(
                      false,
                      effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : void 0,
                      ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)
                    )
                  ])
                )
              );
              foundImportDeclaration = true;
              break;
            }
          }
        }
      }
      if (!foundImportDeclaration) {
        ts.insertImports(
          changeTracker,
          sourceFile,
          ts.factory.createImportDeclaration(
            void 0,
            ts.factory.createImportClause(
              false,
              void 0,
              ts.factory.createNamedImports(
                [
                  ts.factory.createImportSpecifier(
                    false,
                    effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : void 0,
                    ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)
                  )
                ]
              )
            ),
            ts.factory.createStringLiteral(importModule)
          ),
          true,
          preferences || {}
        );
      }
      break;
    }
  }
  return { description };
};

// src/completions/middlewareAutoImports.ts
var appendEffectCompletionEntryData = fn("appendEffectCompletionEntryData")(
  function* (_sourceFile, applicableCompletions) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0 && languageServicePluginOptions.barrelImportPackages.length === 0) return applicableCompletions;
    if (applicableCompletions) {
      return {
        ...applicableCompletions,
        entries: applicableCompletions.entries.map(
          (entry) => entry.data ? {
            ...entry,
            data: {
              ...entry.data,
              effectReplaceSpan: entry.replacementSpan || applicableCompletions.optionalReplacementSpan
            }
          } : entry
        )
      };
    }
    return applicableCompletions;
  }
);
var isAutoImportOnlyCodeActions = fn("isAutoImportOnlyCodeActions")(
  function* (sourceFile, codeActions, exportName) {
    if (!codeActions) return;
    if (codeActions.length !== 1) return;
    const action = codeActions[0];
    const changes = action.changes;
    if (changes.length !== 1) return;
    const fileTextChanges = action.changes[0];
    if (fileTextChanges.fileName !== sourceFile.fileName) return;
    const textChanges = fileTextChanges.textChanges;
    const parsedImportChanges = yield* parseImportOnlyChanges(sourceFile, textChanges);
    if (!parsedImportChanges) return;
    if (parsedImportChanges.deletions.length !== 0) return;
    if (parsedImportChanges.imports.length !== 1) return;
    if (parsedImportChanges.imports[0].exportName !== exportName) return;
    return parsedImportChanges.imports[0];
  }
);
var addImportCodeAction = fn("getImportFromNamespaceCodeActions")(function* (formatOptions, preferences, languageServiceHost, sourceFile, effectReplaceSpan, effectAutoImport) {
  const ts = yield* service(TypeScriptApi);
  let description = "auto-import";
  const formatContext = ts.formatting.getFormatContext(
    formatOptions || {},
    languageServiceHost
  );
  const changes = ts.textChanges.ChangeTracker.with(
    {
      formatContext,
      host: languageServiceHost,
      preferences: preferences || {}
    },
    (changeTracker) => {
      description = addImport(
        ts,
        sourceFile,
        changeTracker,
        preferences,
        effectAutoImport
      ).description;
      if (effectAutoImport.introducedPrefix) {
        changeTracker.insertText(
          sourceFile,
          effectReplaceSpan.start,
          effectAutoImport.introducedPrefix + "."
        );
      }
    }
  );
  return [
    {
      description,
      changes
    }
  ];
});
var postprocessCompletionEntryDetails = fn("postprocessCompletionEntryDetails")(
  function* (sourceFile, data, applicableCompletionEntryDetails, formatOptions, preferences, languageServiceHost) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0 && languageServicePluginOptions.barrelImportPackages.length === 0) return applicableCompletionEntryDetails;
    if (!applicableCompletionEntryDetails) return applicableCompletionEntryDetails;
    if (!data) return applicableCompletionEntryDetails;
    const { exportName, fileName, moduleSpecifier } = data;
    if (!fileName) return applicableCompletionEntryDetails;
    if (!exportName) return applicableCompletionEntryDetails;
    if (!moduleSpecifier) return applicableCompletionEntryDetails;
    if (!("effectReplaceSpan" in data)) return applicableCompletionEntryDetails;
    const effectReplaceSpan = data.effectReplaceSpan;
    const result = yield* isAutoImportOnlyCodeActions(
      sourceFile,
      applicableCompletionEntryDetails.codeActions,
      exportName
    );
    if (!result) return applicableCompletionEntryDetails;
    const autoImportProvider = yield* getOrMakeAutoImportProvider(sourceFile);
    const effectAutoImport = autoImportProvider.resolve(fileName, exportName);
    if (!effectAutoImport) return applicableCompletionEntryDetails;
    const codeActions = yield* addImportCodeAction(
      formatOptions,
      preferences,
      languageServiceHost,
      sourceFile,
      effectReplaceSpan,
      effectAutoImport
    );
    return {
      ...applicableCompletionEntryDetails,
      codeActions
    };
  }
);

// src/diagnostics/middlewareAutoImportQuickfixes.ts
var middlewareAutoImportQuickfixes = fn("middlewareAutoImportQuickfixes")(function* (sourceFile, languageServiceHost, formatOptions, preferences, codeFixes) {
  const ts = yield* service(TypeScriptApi);
  const program = yield* service(TypeScriptProgram);
  const autoImportProvider = yield* getOrMakeAutoImportProvider(sourceFile);
  const changedCodeFixes = [];
  const createImportAllChanges = (imports) => gen(function* () {
    const newImports = [];
    for (const importToAdd of imports) {
      if (!importToAdd.exportName) return;
      const fileName = ts.resolveModuleName(
        importToAdd.moduleName,
        sourceFile.fileName,
        program.getCompilerOptions(),
        program
      );
      if (!fileName.resolvedModule) return;
      const importKind = autoImportProvider.resolve(fileName.resolvedModule.resolvedFileName, importToAdd.exportName);
      if (!importKind) return;
      if (importKind.introducedPrefix) return;
      newImports.push(importKind);
    }
    const formatContext = ts.formatting.getFormatContext(
      formatOptions,
      languageServiceHost
    );
    const edits = ts.textChanges.ChangeTracker.with(
      {
        formatContext,
        host: languageServiceHost,
        preferences: preferences || {}
      },
      (changeTracker) => newImports.forEach((_) => addImport(ts, sourceFile, changeTracker, preferences, _))
    );
    return edits;
  });
  for (const codeFix of codeFixes) {
    const textFileChanges = codeFix.changes;
    if (textFileChanges.length !== 1) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    if (textFileChanges[0].fileName !== sourceFile.fileName) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    const parsedChanges = yield* parseImportOnlyChanges(sourceFile, textFileChanges[0].textChanges);
    if (!parsedChanges) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    if (parsedChanges.deletions.length !== 0) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    const changes = yield* pipe(
      createImportAllChanges(parsedChanges.imports),
      orElse2(() => succeed(codeFix.changes))
    );
    if (changes) {
      changedCodeFixes.push({ ...codeFix, changes });
    } else {
      changedCodeFixes.push(codeFix);
    }
  }
  return changedCodeFixes;
});

// src/goto/effectRpcDefinition.ts
function effectRpcDefinition(applicableGotoDefinition, sourceFile, position) {
  return gen(function* () {
    const program = yield* service(TypeScriptProgram);
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const textRange = tsUtils.toTextRange(position);
    function isSymbolFromEffectRpcModule(symbol3) {
      if (symbol3.valueDeclaration) {
        const sourceFile2 = tsUtils.getSourceFileOfNode(symbol3.valueDeclaration);
        if (sourceFile2) {
          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile2);
          if (packageInfo && packageInfo.name === "@effect/rpc") {
            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile2);
            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has("isRpc") && fileSymbol.exports.has("make") && fileSymbol.exports.has("fromTaggedRequest");
          }
        }
      }
      return false;
    }
    function isSymbolFromEffectRpcClientModule(symbol3) {
      if (symbol3.valueDeclaration) {
        const sourceFile2 = tsUtils.getSourceFileOfNode(symbol3.valueDeclaration);
        if (sourceFile2) {
          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile2);
          if (packageInfo && packageInfo.name === "@effect/rpc") {
            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile2);
            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has("RpcClient") && fileSymbol.exports.has("make");
          }
        }
      }
      return false;
    }
    let rpcName = null;
    let callNode = null;
    for (const node of tsUtils.getAncestorNodesInRange(sourceFile, textRange)) {
      if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && tsUtils.isNodeInRange(textRange)(node.name)) {
        const type = typeCheckerUtils.getTypeAtLocation(node);
        if (!type) return void 0;
        for (const callSig of typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)) {
          if (callSig.parameters.length >= 2 && isSymbolFromEffectRpcClientModule(callSig.parameters[1])) {
            rpcName = ts.idText(node.name);
            callNode = node.name;
          }
        }
      }
    }
    if (rpcName === null || callNode === null) return applicableGotoDefinition;
    const result = [];
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    const filesToTest = [];
    for (const programFile of program.getSourceFiles()) {
      if (programFile.isDeclarationFile) continue;
      if (programFile.text.indexOf("make") === -1 && programFile.text.indexOf("fromTaggedRequest") === -1) continue;
      if (programFile.text.indexOf(rpcName) > -1) {
        filesToTest.unshift(programFile);
      } else {
        filesToTest.push(programFile);
      }
    }
    for (const fileToTest of filesToTest) {
      if (result.length > 0) break;
      ts.forEachChild(fileToTest, appendNodeToVisit);
      while (result.length === 0 && nodeToVisit.length > 0) {
        const node = nodeToVisit.shift();
        if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && (ts.idText(node.expression.name) === "make" || ts.idText(node.expression.name) === "fromTaggedRequest")) {
          const symbol3 = typeChecker.getSymbolAtLocation(node.expression.name);
          if (symbol3 && isSymbolFromEffectRpcModule(symbol3)) {
            const type = typeCheckerUtils.getTypeAtLocation(node);
            if (type) {
              const _tag = type.getProperty("_tag");
              if (_tag) {
                const tagValue = typeChecker.getTypeOfSymbolAtLocation(_tag, node);
                if ("value" in tagValue && tagValue.value === rpcName) result.push([node, symbol3]);
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
      }
    }
    if (result.length === 0) return applicableGotoDefinition;
    const effectRpcResult = result.map(([node]) => ({
      fileName: node.getSourceFile().fileName,
      textSpan: ts.createTextSpan(node.getStart(), node.end - node.getStart()),
      kind: ts.ScriptElementKind.constElement,
      name: rpcName,
      containerKind: ts.ScriptElementKind.constElement,
      containerName: rpcName
    }));
    if (applicableGotoDefinition) {
      return {
        ...applicableGotoDefinition,
        definitions: (applicableGotoDefinition.definitions || []).concat(effectRpcResult)
      };
    }
    return {
      textSpan: ts.createTextSpan(callNode.getStart(), callNode.end - callNode.getStart()),
      definitions: effectRpcResult
    };
  });
}

// src/goto.ts
function goto(applicableGotoDefinition, sourceFile, position) {
  return effectRpcDefinition(applicableGotoDefinition, sourceFile, position);
}

// src/inlays/middlewareGenLike.ts
var middlewareGenLike = fn("middlewareGenLike")(function* (sourceFile, _span, preferences, inlayHints) {
  if (!preferences) return inlayHints;
  if (preferences.includeInlayFunctionLikeReturnTypeHints !== true) return inlayHints;
  if (!inlayHints) return inlayHints;
  const tsUtils = yield* service(TypeScriptUtils);
  const ts = yield* service(TypeScriptApi);
  const typeParser = yield* service(TypeParser);
  const result = [];
  const parseType = (node) => {
    return pipe(
      typeParser.effectGen(node),
      orElse2(() => pipe(typeParser.effectFnGen(node), orElse2(() => typeParser.effectFnUntracedGen(node))))
    );
  };
  for (const inlayHint of inlayHints) {
    let shouldOmit = false;
    if (inlayHint.kind === ts.InlayHintKind.Type) {
      const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, inlayHint.position - 1);
      if (node && node.parent) {
        const possiblyGen = node.parent;
        yield* pipe(
          parseType(possiblyGen),
          map8((_) => {
            const argsCloseParen = ts.findChildOfKind(_.generatorFunction, ts.SyntaxKind.CloseParenToken, sourceFile);
            if (argsCloseParen && _.body && inlayHint.position >= argsCloseParen.end && inlayHint.position <= _.body.getStart(sourceFile)) {
              shouldOmit = true;
            }
          }),
          ignore
        );
      }
    }
    if (!shouldOmit) result.push(inlayHint);
  }
  return result;
});

// src/quickinfo/dedupeJsDocs.ts
var SymbolDisplayPartEq = make((fa, fb) => fa.kind === fb.kind && fa.text === fb.text);
var JSDocTagInfoEq = make(
  (fa, fb) => fa.name === fb.name && typeof fa.text === typeof fb.text && (typeof fa.text !== "undefined" ? array(SymbolDisplayPartEq)(fa.text, fb.text) : true)
);
function dedupeJsDocs(quickInfo2) {
  if (!quickInfo2) return succeed(quickInfo2);
  if (quickInfo2.tags) {
    return succeed({
      ...quickInfo2,
      tags: dedupeWith(quickInfo2.tags, JSDocTagInfoEq)
    });
  }
  return succeed(quickInfo2);
}

// src/quickinfo/effectTypeArgs.ts
function effectTypeArgs(sourceFile, position, quickInfo2) {
  return pipe(
    gen(function* () {
      const ts = yield* service(TypeScriptApi);
      const typeChecker = yield* service(TypeCheckerApi);
      const typeCheckerUtils = yield* service(TypeCheckerUtils);
      const typeParser = yield* service(TypeParser);
      const tsUtils = yield* service(TypeScriptUtils);
      const options = yield* service(LanguageServicePluginOptions);
      if (options.quickinfoEffectParameters === "never") return quickInfo2;
      function formatTypeForQuickInfo(channelType, channelName) {
        let stringRepresentation = "";
        if (options.quickinfoMaximumLength > 0) {
          const typeNode = typeChecker.typeToTypeNode(
            channelType,
            void 0,
            ts.NodeBuilderFlags.None,
            // @ts-expect-error
            void 0,
            void 0,
            options.quickinfoMaximumLength
          );
          const printer = ts.createPrinter({});
          stringRepresentation = typeNode ? printer.printNode(ts.EmitHint.Unspecified, typeNode, sourceFile) : "";
        } else {
          stringRepresentation = typeChecker.typeToString(channelType, void 0, ts.TypeFormatFlags.NoTruncation);
        }
        return `type ${channelName} = ${stringRepresentation}`;
      }
      function makeSymbolDisplayParts(title, A, E, R) {
        return [{
          kind: "text",
          text: "```ts\n/* " + title + " */\n" + formatTypeForQuickInfo(A, "Success") + "\n" + formatTypeForQuickInfo(E, "Failure") + "\n" + formatTypeForQuickInfo(R, "Requirements") + "\n```\n"
        }];
      }
      function isRightSideOfPropertyAccess(node2) {
        return node2.parent && ts.isPropertyAccessExpression(node2.parent) && node2.parent.name === node2;
      }
      function isArgumentExpressionOfElementAccess(node2) {
        return node2.parent && ts.isElementAccessExpression(node2.parent) && node2.parent.argumentExpression === node2;
      }
      function isCalleeWorker(node2, pred, calleeSelector, includeElementAccess, skipPastOuterExpressions) {
        let target = includeElementAccess ? climbPastPropertyOrElementAccess(node2) : climbPastPropertyAccess(node2);
        if (skipPastOuterExpressions) {
          target = tsUtils.skipOuterExpressions(target);
        }
        return !!target && !!target.parent && pred(target.parent) && calleeSelector(target.parent) === target;
      }
      function climbPastPropertyAccess(node2) {
        return isRightSideOfPropertyAccess(node2) ? node2.parent : node2;
      }
      function climbPastPropertyOrElementAccess(node2) {
        return isRightSideOfPropertyAccess(node2) || isArgumentExpressionOfElementAccess(node2) ? node2.parent : node2;
      }
      function selectExpressionOfCallOrNewExpressionOrDecorator(node2) {
        return node2.expression;
      }
      function isCallExpressionTarget(node2, includeElementAccess = false, skipPastOuterExpressions = false) {
        return isCalleeWorker(
          node2,
          ts.isCallExpression,
          selectExpressionOfCallOrNewExpressionOrDecorator,
          includeElementAccess,
          skipPastOuterExpressions
        );
      }
      function isNewExpressionTarget(node2, includeElementAccess = false, skipPastOuterExpressions = false) {
        return isCalleeWorker(
          node2,
          ts.isNewExpression,
          selectExpressionOfCallOrNewExpressionOrDecorator,
          includeElementAccess,
          skipPastOuterExpressions
        );
      }
      function getSignatureForQuickInfo(location) {
        if (location.parent && location.parent.kind === ts.SyntaxKind.PropertyAccessExpression) {
          const right3 = location.parent.name;
          if (right3 === location || right3 && right3.getFullWidth() === 0) {
            location = location.parent;
          }
        }
        let callExpressionLike;
        if (ts.isCallOrNewExpression(location)) {
          callExpressionLike = location;
        } else if (isCallExpressionTarget(location) || isNewExpressionTarget(location)) {
          callExpressionLike = location.parent;
        }
        if (callExpressionLike) {
          const signature = typeChecker.getResolvedSignature(callExpressionLike);
          if (signature) {
            const returnType = typeChecker.getReturnTypeOfSignature(signature);
            if (returnType) {
              return {
                callExpressionLike,
                location,
                returnType
              };
            }
          }
        }
      }
      function getNodeForQuickInfo(node2) {
        if (ts.isNewExpression(node2.parent) && node2.pos === node2.parent.pos) {
          return node2.parent.expression;
        }
        if (ts.isNamedTupleMember(node2.parent) && node2.pos === node2.parent.pos) {
          return node2.parent;
        }
        if (ts.isJsxNamespacedName(node2.parent)) {
          return node2.parent;
        }
        return node2;
      }
      function getDataForQuickInfo() {
        if (!("getTouchingPropertyName" in ts && typeof ts.getTouchingPropertyName === "function")) return;
        const touchingNode = ts.getTouchingPropertyName(sourceFile, position);
        if (touchingNode === sourceFile) return;
        const adjustedNode = getNodeForQuickInfo(touchingNode);
        if (ts.isToken(adjustedNode) && adjustedNode.kind === ts.SyntaxKind.YieldKeyword) {
          if (ts.isYieldExpression(adjustedNode.parent) && adjustedNode.parent.asteriskToken && adjustedNode.parent.expression) {
            const type3 = typeCheckerUtils.getTypeAtLocation(adjustedNode.parent.expression);
            if (type3) {
              return {
                label: "Effect Type Parameters",
                type: type3,
                atLocation: adjustedNode.parent.expression,
                node: adjustedNode.parent,
                shouldTry: true
              };
            }
          }
        }
        const nodeSignature = getSignatureForQuickInfo(adjustedNode);
        if (nodeSignature) {
          return {
            label: "Returned Effect Type Parameters",
            type: nodeSignature.returnType,
            atLocation: nodeSignature.location,
            node: nodeSignature.callExpressionLike,
            shouldTry: options.quickinfoEffectParameters === "always" && quickInfo2 ? true : quickInfo2 && ts.displayPartsToString(quickInfo2.displayParts).indexOf("...") > -1
          };
        }
        const type2 = typeCheckerUtils.getTypeAtLocation(adjustedNode);
        if (type2) {
          return {
            label: "Effect Type Parameters",
            type: type2,
            atLocation: adjustedNode,
            node: adjustedNode,
            shouldTry: options.quickinfoEffectParameters === "always" && quickInfo2 ? true : quickInfo2 && ts.displayPartsToString(quickInfo2.displayParts).indexOf("...") > -1
          };
        }
      }
      const data = getDataForQuickInfo();
      if (!(data && data.shouldTry)) return quickInfo2;
      const { atLocation, label, node, type } = data;
      const effectTypeArgsDocumentation = yield* pipe(
        typeParser.effectType(
          type,
          atLocation
        ),
        map8((_) => makeSymbolDisplayParts(label, _.A, _.E, _.R))
      );
      if (!quickInfo2) {
        const start = ts.getTokenPosOfNode(node, sourceFile);
        const end = node.end;
        return {
          kind: ts.ScriptElementKind.callSignatureElement,
          kindModifiers: "",
          textSpan: { start, length: end - start },
          documentation: effectTypeArgsDocumentation
        };
      }
      if (quickInfo2.documentation) {
        return {
          ...quickInfo2,
          documentation: effectTypeArgsDocumentation.concat(quickInfo2.documentation)
        };
      }
      return {
        ...quickInfo2,
        documentation: effectTypeArgsDocumentation
      };
    }),
    orElse2(() => succeed(quickInfo2))
  );
}

// ../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size4) => {
  let len = strm.avail_in;
  if (len > size4) {
    len = size4;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match3;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match3 = cur_match;
    if (_win[match3 + best_len] !== scan_end || _win[match3 + best_len - 1] !== scan_end1 || _win[match3] !== _win[scan] || _win[++match3] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match3++;
    do {
    } while (_win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left3, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left3 = s.strstart - s.block_start;
    if (len > left3 + s.strm.avail_in) {
      len = left3 + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left3 + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left3 + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left3) {
      if (left3 > len) {
        left3 = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left3), s.strm.next_out);
      s.strm.next_out += left3;
      s.strm.avail_out -= left3;
      s.strm.total_out += left3;
      s.block_start += left3;
      len -= left3;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left3 = s.strstart - s.block_start;
  if (left3 >= min_block || (left3 || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left3 <= have) {
    len = left3 > have ? have : left3;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left3 ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head3) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head3;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left3 = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left3 > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left3 -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left3), s.pending);
      s.pending += left3;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left3 = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match3;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left3 = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left3 <<= 1;
    left3 -= count[len];
    if (left3 < 0) {
      return -1;
    }
  }
  if (left3 > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match3 = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match3 = 257;
  } else {
    base = dbase;
    extra = dext;
    match3 = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match3) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match3) {
      here_op = extra[work[sym] - match3];
      here_val = base[work[sym] - match3];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left3 = 1 << curr;
      while (curr + drop < max) {
        left3 -= count[curr + drop];
        if (left3 <= 0) {
          break;
        }
        curr++;
        left3 <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left3;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left3 = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left3;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left3;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left3) {
              copy2 = left3;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left3 -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left3 >= 258) {
            strm.next_out = put;
            strm.avail_out = left3;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left3 = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left3 === 0) {
            break inf_leave;
          }
          copy2 = _out - left3;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left3) {
            copy2 = left3;
          }
          left3 -= copy2;
          state.length -= copy2;
          do {
            output[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left3 === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left3--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left3;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left3;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left3;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head3) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head3;
  head3.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflate_1 = deflate;

// src/core/LayerGraph.ts
var formatSourceFileName = (sourceFile) => {
  let fileName = sourceFile.fileName;
  if (fileName.indexOf("/") > -1) {
    fileName = fileName.split("/").pop();
  }
  return fileName;
};
var formatSourceFileNameLineAndColumn = (ts, tsUtils, node, fromSourceFile) => {
  const nodeSourceFile = tsUtils.getSourceFileOfNode(node);
  const nodePosition = ts.getTokenPosOfNode(node, nodeSourceFile);
  const { character, line } = ts.getLineAndCharacterOfPosition(nodeSourceFile, nodePosition);
  if (!fromSourceFile || nodeSourceFile === fromSourceFile) return `ln ${line + 1} col ${character}`;
  return `in ${formatSourceFileName(nodeSourceFile)} at ln ${line + 1} col ${character}`;
};
var UnableToProduceLayerGraphError = class {
  constructor(message, node) {
    this.message = message;
    this.node = node;
  }
  _tag = "@effect/language-service/UnableToProduceLayerGraphError";
};
var extractLayerGraph = fn("extractLayerGraph")(function* (node, opts) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const tsUtils = yield* service(TypeScriptUtils);
  const sourceFile = tsUtils.getSourceFileOfNode(node);
  const layerModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Layer") || "Layer";
  const visitedNodes = /* @__PURE__ */ new WeakSet();
  const nodeInPipeContext = /* @__PURE__ */ new WeakSet();
  const nodeToGraph = /* @__PURE__ */ new WeakMap();
  const depthBudget = /* @__PURE__ */ new WeakMap();
  const nodeToVisit = [];
  const appendNodeToVisit = (node2, nodeDepthBudget) => {
    depthBudget.set(node2, nodeDepthBudget);
    nodeToVisit.push(node2);
    return void 0;
  };
  appendNodeToVisit(node, opts.followSymbolsDepth);
  const mutableGraph = beginMutation3(directed());
  const extractNodeInfo = fn("extractNodeInfo")(function* (node2) {
    let provides = [];
    let requires = [];
    let actualProvides = [];
    let layerType = void 0;
    let layerTypes = void 0;
    if (nodeInPipeContext.has(node2)) {
      if (ts.isExpression(node2)) {
        const contextualType = typeChecker.getContextualType(node2);
        if (contextualType) {
          const callSignatures = typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call);
          if (callSignatures.length === 1) {
            layerType = typeChecker.getReturnTypeOfSignature(callSignatures[0]);
          }
        }
      }
    } else if (ts.isExpression(node2)) {
      layerType = typeCheckerUtils.getTypeAtLocation(node2);
    }
    if (layerType) {
      layerTypes = yield* pipe(typeParser.layerType(layerType, node2), orElse2(() => void_));
    }
    if (!layerTypes) layerType = void 0;
    if (layerTypes) {
      provides = typeCheckerUtils.unrollUnionMembers(layerTypes.ROut).filter((_) => !(_.flags & ts.TypeFlags.Never));
      requires = typeCheckerUtils.unrollUnionMembers(layerTypes.RIn).filter((_) => !(_.flags & ts.TypeFlags.Never));
      actualProvides = provides.filter((_) => !typeChecker.isTypeAssignableTo(_, layerTypes.RIn));
    }
    let displayNode = node2;
    if (node2.parent && ts.isVariableDeclaration(node2.parent) && node2.parent.initializer === node2) {
      displayNode = node2.parent.name;
    }
    return { node: node2, displayNode, layerType, layerTypes, provides, actualProvides, requires };
  });
  const addNode2 = fn("addNode")(function* (node2, nodeInfo) {
    const graphNode = addNode(mutableGraph, nodeInfo ? nodeInfo : yield* extractNodeInfo(node2));
    nodeToGraph.set(node2, graphNode);
    return graphNode;
  });
  const isSimpleIdentifier = (node2) => {
    return ts.isIdentifier(node2) || ts.isPropertyAccessExpression(node2) && ts.isIdentifier(node2.name) && isSimpleIdentifier(node2.expression);
  };
  const getAdjustedNode2 = (node2) => ts.isPropertyDeclaration(node2) || ts.isVariableDeclaration(node2) ? node2.initializer : ts.isExpression(node2) ? node2 : void 0;
  while (nodeToVisit.length > 0) {
    const node2 = nodeToVisit.pop();
    const currentDepthBudget = depthBudget.get(node2);
    const pipeArgs = yield* pipe(typeParser.pipeCall(node2), orElse2(() => void_));
    if (pipeArgs) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2, currentDepthBudget);
        appendNodeToVisit(pipeArgs.subject, currentDepthBudget);
        pipeArgs.args.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
        pipeArgs.args.forEach((_) => nodeInPipeContext.add(_));
        visitedNodes.add(node2);
      } else {
        const childNodes = [pipeArgs.subject, ...pipeArgs.args].map((_) => nodeToGraph.get(_)).filter(
          isNumber
        ).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length === pipeArgs.args.length + 1) {
          let lastNode = null;
          for (const childNode of childNodes) {
            if (lastNode !== null) addEdge(mutableGraph, childNode, lastNode, { relationship: "pipe" });
            lastNode = childNode;
          }
          if (lastNode !== null) {
            const graphNode = yield* addNode2(node2);
            addEdge(mutableGraph, graphNode, lastNode, { relationship: "pipe" });
          }
        } else {
          childNodes.forEach((_) => removeNode(mutableGraph, _));
          const nodeInfo = yield* extractNodeInfo(node2);
          if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
        }
      }
      continue;
    }
    if (ts.isCallExpression(node2)) {
      let shouldExplode = !opts.explodeOnlyLayerCalls;
      if (opts.explodeOnlyLayerCalls) {
        const isLayerCall = ts.isPropertyAccessExpression(node2.expression) && ts.isIdentifier(node2.expression.expression) && ts.idText(node2.expression.expression) === layerModuleName;
        if (isLayerCall) shouldExplode = true;
      }
      if (shouldExplode) {
        if (!visitedNodes.has(node2)) {
          appendNodeToVisit(node2, currentDepthBudget);
          node2.arguments.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
          visitedNodes.add(node2);
        } else {
          const childNodes = node2.arguments.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
            (_) => hasNode(mutableGraph, _)
          );
          if (childNodes.length === node2.arguments.length) {
            const graphNode = yield* addNode2(node2);
            childNodes.forEach(
              (_, argumentIndex) => addEdge(mutableGraph, graphNode, _, { relationship: "call", argumentIndex })
            );
          } else {
            childNodes.forEach((_) => removeNode(mutableGraph, _));
            const nodeInfo = yield* extractNodeInfo(node2);
            if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
          }
        }
        continue;
      }
    }
    if (opts.arrayLiteralAsMerge && ts.isArrayLiteralExpression(node2)) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2, currentDepthBudget);
        node2.elements.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
        visitedNodes.add(node2);
      } else {
        const childNodes = node2.elements.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length > 0) {
          const graphNode = yield* addNode2(node2);
          childNodes.forEach(
            (_, index) => addEdge(mutableGraph, graphNode, _, { relationship: "arrayLiteral", index })
          );
        }
      }
      continue;
    }
    if (currentDepthBudget > 0 && isSimpleIdentifier(node2)) {
      let symbol3 = typeChecker.getSymbolAtLocation(node2);
      if (symbol3) {
        if (symbol3.flags & ts.SymbolFlags.Alias) {
          symbol3 = typeChecker.getAliasedSymbol(symbol3) || symbol3;
        }
        if (symbol3.declarations && symbol3.declarations.length === 1) {
          const declarationNode = getAdjustedNode2(symbol3.declarations[0]);
          if (declarationNode) {
            if (!visitedNodes.has(declarationNode)) {
              appendNodeToVisit(node2, currentDepthBudget);
              appendNodeToVisit(declarationNode, currentDepthBudget - 1);
              visitedNodes.add(node2);
              continue;
            }
            const childNode = nodeToGraph.get(declarationNode);
            if (isNumber(childNode)) {
              const graphNode = yield* addNode2(node2);
              addEdge(mutableGraph, graphNode, childNode, { relationship: "symbol" });
              continue;
            }
          }
        }
      }
    }
    if (ts.isExpression(node2)) {
      const nodeInfo = yield* extractNodeInfo(node2);
      if (nodeInfo.layerTypes) {
        yield* addNode2(node2, nodeInfo);
      }
      continue;
    }
    return yield* fail3(new UnableToProduceLayerGraphError("Unable to produce layer graph for node", node2));
  }
  return endMutation2(mutableGraph);
});
var formatLayerGraph = fn("formatLayerGraph")(
  function* (layerGraph, _fromSourceFile) {
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const ts = yield* service(TypeScriptApi);
    return toMermaid(layerGraph, {
      edgeLabel: (edge) => JSON.stringify(edge),
      nodeLabel: (graphNode) => {
        const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node);
        let text = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim();
        text += "\nprovides: " + graphNode.provides.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
          ", "
        );
        text += "\nrequires: " + graphNode.requires.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
          ", "
        );
        return text;
      }
    });
  }
);
var formatNestedLayerGraph = fn("formatNestedLayerGraph")(
  function* (layerGraph, fromSourceFile) {
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const ts = yield* service(TypeScriptApi);
    const mermaidSafe = (value) => value.replace(/\n/g, " ").replace(
      /\s+/g,
      " "
    ).substring(0, 50).replace(/"/g, "#quot;").replace(/</mg, "#lt;").replace(/>/mg, "#gt;").trim();
    const typeNameCache = /* @__PURE__ */ new Map();
    const typeName = (type) => {
      if (typeNameCache.has(type)) return typeNameCache.get(type);
      const name = typeChecker.typeToString(type, void 0, ts.TypeFormatFlags.NoTruncation);
      typeNameCache.set(type, name);
      return name;
    };
    let result = [];
    for (const [graphNodeIndex, graphNode] of entries(nodes(layerGraph))) {
      let subgraphDefs = [];
      for (const kind of ["requires", "provides"]) {
        const typesMermaidNodes = [];
        for (let i = 0; i < graphNode[kind].length; i++) {
          typesMermaidNodes.push(`${graphNodeIndex}_${kind}_${i}["${mermaidSafe(typeName(graphNode[kind][i]))}"]`);
        }
        if (typesMermaidNodes.length > 0) {
          subgraphDefs = [
            ...subgraphDefs,
            `subgraph ${graphNodeIndex}_${kind} [${kind === "provides" ? "Provides" : "Requires"}]`,
            ...typesMermaidNodes.map((_) => `  ${_}`),
            `end`,
            `style ${graphNodeIndex}_${kind} stroke:none`
          ];
        }
      }
      subgraphDefs = [
        `subgraph ${graphNodeIndex}_wrap[" "]`,
        ...subgraphDefs.map((_) => `  ${_}`),
        `end`,
        `style ${graphNodeIndex}_wrap fill:transparent`,
        `style ${graphNodeIndex}_wrap stroke:none`
      ];
      const tsNode = graphNode.displayNode;
      const sourceFile = tsUtils.getSourceFileOfNode(tsNode);
      const nodeText = sourceFile.text.substring(tsNode.pos, tsNode.end).trim();
      result = [
        ...result,
        `subgraph ${graphNodeIndex} ["\`${mermaidSafe(nodeText)}<br/><small>_${mermaidSafe(formatSourceFileNameLineAndColumn(ts, tsUtils, tsNode, fromSourceFile))}_</small>\`"]`,
        ...subgraphDefs.map((_) => `  ${_}`),
        `end`,
        `style ${graphNodeIndex} fill:transparent`
      ];
    }
    for (const edgeInfo of values2(edges(layerGraph))) {
      const sourceData = layerGraph.nodes.get(edgeInfo.source);
      const targetData = layerGraph.nodes.get(edgeInfo.target);
      let connected = false;
      for (const kind of ["requires", "provides"]) {
        for (let i = 0; i < sourceData[kind].length; i++) {
          const targetIdx = targetData[kind].indexOf(sourceData[kind][i]);
          if (targetIdx > -1) {
            result.push(`${edgeInfo.source}_${kind}_${i} -.-> ${edgeInfo.target}_${kind}_${targetIdx}`);
            connected = true;
          }
        }
      }
      if (!connected) {
        result.push(`${edgeInfo.source} -.-x ${edgeInfo.target}`);
      }
    }
    if (result.length === 0) return "";
    return [
      `flowchart TB`,
      ...result.map((_) => `  ${_}`)
    ].join("\n");
  }
);
var extractOutlineGraph = fn("extractOutlineGraph")(function* (layerGraph) {
  const typeChecker = yield* service(TypeCheckerApi);
  const mutableGraph = beginMutation3(directed());
  const providers = /* @__PURE__ */ new Map();
  const knownSymbols = /* @__PURE__ */ new WeakSet();
  const leafNodes = values2(externals(layerGraph, { direction: "outgoing" }));
  const dedupedLeafNodes = [];
  for (const leafNode of leafNodes) {
    const symbol3 = typeChecker.getSymbolAtLocation(leafNode.node);
    if (!symbol3) {
      dedupedLeafNodes.push(leafNode);
    } else if (symbol3 && !knownSymbols.has(symbol3)) {
      dedupedLeafNodes.push(leafNode);
      knownSymbols.add(symbol3);
    }
  }
  for (const leafNode of dedupedLeafNodes) {
    const nodeIndex = addNode(mutableGraph, {
      node: leafNode.node,
      displayNode: leafNode.displayNode,
      requires: leafNode.requires,
      provides: leafNode.provides,
      actualProvides: leafNode.actualProvides
    });
    for (const providedType of leafNode.actualProvides) {
      const previousProviders = providers.get(providedType) || [];
      providers.set(providedType, [...previousProviders, nodeIndex]);
    }
  }
  for (const [nodeIndex, nodeInfo] of entries(nodes(mutableGraph))) {
    for (const requiredType of nodeInfo.requires) {
      for (const [providedType, providerNodeIndexes] of providers.entries()) {
        if (requiredType === providedType || typeChecker.isTypeAssignableTo(requiredType, providedType)) {
          for (const providerNodeIndex of providerNodeIndexes) {
            if (!hasEdge(mutableGraph, nodeIndex, providerNodeIndex)) {
              addEdge(mutableGraph, nodeIndex, providerNodeIndex, {});
            }
          }
        }
      }
    }
  }
  return endMutation2(mutableGraph);
});
var collectOutlineGraphActualProvides = fn("collectOutlineGraphActualProvides")(
  function* (outlineGraph) {
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const seenTypes = /* @__PURE__ */ new Set();
    const result = [];
    for (const nodeInfo of values2(nodes(outlineGraph))) {
      for (const actualProvide of nodeInfo.actualProvides) {
        if (!seenTypes.has(actualProvide)) {
          seenTypes.add(actualProvide);
          result.push(actualProvide);
        }
      }
    }
    result.sort(typeCheckerUtils.deterministicTypeOrder);
    return result;
  }
);
var formatLayerOutlineGraph = fn("formatLayerOutlineGraph")(
  function* (layerOutlineGraph, fromSourceFile) {
    const tsUtils = yield* service(TypeScriptUtils);
    const ts = yield* service(TypeScriptApi);
    return toMermaid(layerOutlineGraph, {
      edgeLabel: () => "",
      nodeLabel: (graphNode) => {
        const tsNode = graphNode.displayNode;
        const sourceFile = tsUtils.getSourceFileOfNode(tsNode);
        const nodeText = sourceFile.text.substring(tsNode.pos, tsNode.end).trim();
        if (sourceFile === fromSourceFile) return nodeText;
        return `${nodeText}
_${formatSourceFileNameLineAndColumn(ts, tsUtils, tsNode, fromSourceFile)}_`;
      }
    });
  }
);
var dfsPostOrderWithOrder = (graph, config) => {
  const start = config.start ?? [];
  const direction = config.direction ?? "outgoing";
  const orderByIndex = mapInput(config.order, (_) => graph.nodes.get(_));
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const stack = [];
      const discovered = /* @__PURE__ */ new Set();
      const finished = /* @__PURE__ */ new Set();
      const sortedStart = sort(start, orderByIndex);
      for (let i = sortedStart.length - 1; i >= 0; i--) {
        stack.push({ node: sortedStart[i], visitedChildren: false });
      }
      const nextMapped = () => {
        while (stack.length > 0) {
          const current = stack[stack.length - 1];
          if (!discovered.has(current.node)) {
            discovered.add(current.node);
            current.visitedChildren = false;
          }
          if (!current.visitedChildren) {
            current.visitedChildren = true;
            const neighbors = neighborsDirected(graph, current.node, direction);
            const sortedNeighbors = sort(neighbors, orderByIndex);
            for (let i = sortedNeighbors.length - 1; i >= 0; i--) {
              const neighbor = sortedNeighbors[i];
              if (!discovered.has(neighbor) && !finished.has(neighbor)) {
                stack.push({ node: neighbor, visitedChildren: false });
              }
            }
          } else {
            const nodeToEmit = stack.pop().node;
            if (!finished.has(nodeToEmit)) {
              finished.add(nodeToEmit);
              const nodeData = getNode(graph, nodeToEmit);
              if (isSome2(nodeData)) {
                return { done: false, value: f(nodeToEmit, nodeData.value) };
              }
              return nextMapped();
            }
          }
        }
        return { done: true, value: void 0 };
      };
      return { next: nextMapped };
    }
  }));
};
var convertOutlineGraphToLayerMagic = fn("convertOutlineGraphToLayerMagic")(
  function* (outlineGraph, targetOutputs) {
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const ts = yield* service(TypeScriptApi);
    const result = [];
    const outputTypes = flatten(map4(targetOutputs, (_) => typeCheckerUtils.unrollUnionMembers(_)));
    const missingOutputTypes = new Set(outputTypes);
    const currentRequiredTypes = /* @__PURE__ */ new Set();
    const orderByProvidedCount = mapInput(
      reverse(number2),
      (_) => _.provides.length
    );
    const orderByRequiredCount = mapInput(
      reverse(number2),
      (_) => _.requires.length
    );
    const layerOrder = combine2(orderByProvidedCount, orderByRequiredCount);
    const reversedGraph = mutate2(outlineGraph, reverse4);
    const rootIndexes = fromIterable(indices(externals(reversedGraph, { direction: "incoming" })));
    const allNodes = fromIterable(
      values2(dfsPostOrderWithOrder(reversedGraph, { start: rootIndexes, order: layerOrder }))
    );
    for (const nodeInfo of allNodes) {
      if (!ts.isExpression(nodeInfo.node)) continue;
      const shouldMerge = nodeInfo.actualProvides.some((_) => missingOutputTypes.has(_));
      if (shouldMerge) {
        nodeInfo.actualProvides.forEach((_) => missingOutputTypes.delete(_));
      }
      nodeInfo.provides.forEach((_) => currentRequiredTypes.delete(_));
      nodeInfo.requires.forEach((_) => currentRequiredTypes.add(_));
      result.push({
        merges: shouldMerge,
        provides: true,
        layerExpression: nodeInfo.node
      });
    }
    return {
      layerMagicNodes: result,
      missingOutputTypes
    };
  }
);
var walkLeavesMatching = (graph, predicate, config = {}) => {
  const start = config.start ?? [];
  const direction = config.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      let queue = [...start];
      const discovered = /* @__PURE__ */ new Set();
      const nextMapped = () => {
        while (queue.length > 0) {
          const current = queue.shift();
          if (discovered.has(current)) continue;
          discovered.add(current);
          const neighbors = neighborsDirected(graph, current, direction);
          const neighborsMatching = [];
          for (const neighbor of neighbors) {
            const neighborNode = getNode(graph, neighbor);
            if (isSome2(neighborNode) && predicate(neighborNode.value)) {
              neighborsMatching.push(neighbor);
            }
          }
          if (neighborsMatching.length > 0) {
            queue = [...queue, ...neighborsMatching];
          } else {
            const nodeData = getNode(graph, current);
            if (isSome2(nodeData) && predicate(nodeData.value)) {
              return { done: false, value: f(current, nodeData.value) };
            }
          }
        }
        return { done: true, value: void 0 };
      };
      return { next: nextMapped };
    }
  }));
};
var extractProvidersAndRequirers = fn("extractProvidersAndRequirers")(
  function* (layerGraph) {
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const rootWalker = externals(layerGraph, { direction: "incoming" });
    const rootNodes = fromIterable(values2(rootWalker));
    const rootNodeIndexes = fromIterable(indices(rootWalker));
    const result = [];
    const walkTypes = (rootTypes, kind) => {
      const sortedTypes = pipe(fromIterable(rootTypes), sort(typeCheckerUtils.deterministicTypeOrder));
      for (const layerType of sortedTypes) {
        const tsNodes = [];
        const tsDisplayNodes = [];
        for (const layerNode of values2(
          walkLeavesMatching(
            layerGraph,
            (_) => (kind === "provided" ? _.provides : _.requires).some(
              (_2) => _2 === layerType || typeChecker.isTypeAssignableTo(_2, layerType)
            ),
            { start: rootNodeIndexes }
          )
        )) {
          tsNodes.push(layerNode.node);
          tsDisplayNodes.push(layerNode.displayNode);
        }
        result.push({
          kind,
          type: layerType,
          nodes: tsNodes,
          displayNodes: tsDisplayNodes
        });
      }
    };
    walkTypes(new Set(rootNodes.flatMap((_) => _.provides)), "provided");
    walkTypes(new Set(rootNodes.flatMap((_) => _.requires)), "required");
    return result;
  }
);
var formatLayerProvidersAndRequirersInfo = fn("formatLayerProvidersAndRequirersInfo")(
  function* (info, fromSourceFile) {
    const typeChecker = yield* service(TypeCheckerApi);
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    if (info.length === 0) return "";
    const textualExplanation = [];
    const appendInfo = (infoNode) => {
      const typeString = typeChecker.typeToString(
        infoNode.type,
        void 0,
        ts.TypeFormatFlags.NoTruncation
      );
      const positions = infoNode.displayNodes.map((_) => {
        const sourceFile = tsUtils.getSourceFileOfNode(_);
        const nodeText = sourceFile.text.substring(_.pos, _.end).trim().replace(/\n/g, " ").substr(0, 50);
        return `${formatSourceFileNameLineAndColumn(ts, tsUtils, _, fromSourceFile)} by \`${nodeText}\``;
      });
      textualExplanation.push(`- ${typeString} ${infoNode.kind} at ${positions.join(", ")}`);
    };
    const providedItems = info.filter((_) => _.kind === "provided");
    const requiredItems = info.filter((_) => _.kind === "required");
    if (providedItems.length > 0) {
      for (const item of providedItems) {
        appendInfo(item);
      }
      if (textualExplanation.length > 0 && requiredItems.length > 0) textualExplanation.push("");
    }
    if (requiredItems.length > 0) {
      for (const item of requiredItems) {
        appendInfo(item);
      }
    }
    return "/**\n" + textualExplanation.map((l) => " * " + l).join("\n") + "\n */";
  }
);

// src/quickinfo/layerInfo.ts
function generateMarmaidUri(code, mermaidProvider) {
  return gen(function* () {
    const state = JSON.stringify({ code });
    const data = new TextEncoder().encode(state);
    const compressed = deflate_1(data, { level: 9 });
    const pakoString = "pako:" + encodeBase64Url(compressed);
    if (mermaidProvider === "mermaid.com") {
      return "https://www.mermaidchart.com/play#" + pakoString;
    } else if (mermaidProvider === "mermaid.live") {
      return "https://mermaid.live/edit#" + pakoString;
    } else {
      return mermaidProvider + "/edit#" + pakoString;
    }
  });
}
function getAdjustedNode(sourceFile, position) {
  return gen(function* () {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const range = tsUtils.toTextRange(position);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, range),
      filter((_) => ts.isVariableDeclaration(_) || ts.isPropertyDeclaration(_)),
      filter((_) => tsUtils.isNodeInRange(range)(_.name)),
      head
    );
    if (isNone2(maybeNode)) return void 0;
    const node = maybeNode.value;
    const layerNode = node.initializer ? node.initializer : node;
    const layerType = typeCheckerUtils.getTypeAtLocation(layerNode);
    if (layerType) {
      const maybeLayer = yield* option(typeParser.layerType(layerType, layerNode));
      if (isNone2(maybeLayer)) return void 0;
      return { node, layerNode };
    }
  });
}
function parseLayerGraph(layerNode) {
  return gen(function* () {
    const options = yield* service(LanguageServicePluginOptions);
    const tsUtils = yield* service(TypeScriptUtils);
    const layerGraph = yield* extractLayerGraph(layerNode, {
      arrayLiteralAsMerge: false,
      explodeOnlyLayerCalls: false,
      followSymbolsDepth: options.layerGraphFollowDepth
    });
    const sourceFile = tsUtils.getSourceFileOfNode(layerNode);
    const nestedGraphMermaid = yield* formatNestedLayerGraph(layerGraph, sourceFile);
    const outlineGraph = yield* extractOutlineGraph(layerGraph);
    const outlineGraphMermaid = yield* formatLayerOutlineGraph(outlineGraph, sourceFile);
    const providersAndRequirers = yield* extractProvidersAndRequirers(layerGraph);
    const providersAndRequirersTextualExplanation = yield* formatLayerProvidersAndRequirersInfo(
      providersAndRequirers,
      sourceFile
    );
    return { nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation };
  });
}
function effectApiGetLayerGraph(sourceFile, line, character) {
  return gen(function* () {
    const ts = yield* service(TypeScriptApi);
    const position = ts.getPositionOfLineAndCharacter(sourceFile, line, character);
    const maybeNodes = yield* getAdjustedNode(sourceFile, position);
    if (!maybeNodes) return yield* fail3(new UnableToProduceLayerGraphError("No node found"));
    const { layerNode, node } = maybeNodes;
    const { nestedGraphMermaid } = yield* parseLayerGraph(layerNode);
    return { start: node.pos, end: node.end, mermaidCode: nestedGraphMermaid };
  });
}
function layerInfo(sourceFile, position, quickInfo2) {
  return pipe(
    gen(function* () {
      const ts = yield* service(TypeScriptApi);
      const options = yield* service(LanguageServicePluginOptions);
      const maybeNodes = yield* getAdjustedNode(sourceFile, position);
      if (!maybeNodes) return quickInfo2;
      const { layerNode, node } = maybeNodes;
      const layerInfoDisplayParts = yield* pipe(
        parseLayerGraph(layerNode),
        flatMap4(
          ({ nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation }) => gen(function* () {
            const linkParts = [];
            if (!options.noExternal) {
              const mermaidUri = yield* generateMarmaidUri(nestedGraphMermaid, options.mermaidProvider);
              const outlineMermaidUri = yield* generateMarmaidUri(outlineGraphMermaid, options.mermaidProvider);
              linkParts.push({ kind: "space", text: "\n" });
              linkParts.push({ kind: "link", text: "{@link " });
              linkParts.push({ kind: "linkText", text: mermaidUri + " Show full Layer graph" });
              linkParts.push({ kind: "link", text: "}" });
              linkParts.push({ kind: "text", text: " - " });
              linkParts.push({ kind: "link", text: "{@link " });
              linkParts.push({ kind: "linkText", text: outlineMermaidUri + " Show Layer outline" });
              linkParts.push({ kind: "link", text: "}" });
              linkParts.push({ kind: "space", text: "\n" });
            }
            if (providersAndRequirersTextualExplanation.length === 0) return linkParts;
            return [
              {
                kind: "text",
                text: "```\n" + providersAndRequirersTextualExplanation + "\n```\n"
              },
              ...linkParts
            ];
          })
        ),
        orElse2(() => succeed([]))
      );
      if (layerInfoDisplayParts.length === 0) return quickInfo2;
      if (!quickInfo2) {
        const start = ts.getTokenPosOfNode(node, sourceFile);
        const end = node.end;
        return {
          kind: ts.ScriptElementKind.callSignatureElement,
          kindModifiers: "",
          textSpan: { start, length: end - start },
          documentation: layerInfoDisplayParts
        };
      }
      if (quickInfo2.documentation) {
        return {
          ...quickInfo2,
          documentation: quickInfo2.documentation.concat([{ kind: "space", text: "\n" }]).concat(layerInfoDisplayParts)
        };
      }
      return {
        ...quickInfo2,
        documentation: layerInfoDisplayParts
      };
    }),
    orElse2(() => succeed(quickInfo2))
  );
}

// src/quickinfo.ts
function quickInfo(sourceFile, position, quickInfo2) {
  return gen(function* () {
    const deduped = yield* dedupeJsDocs(quickInfo2);
    const withEffectTypeArgs = yield* effectTypeArgs(sourceFile, position, deduped);
    const withLayerInfo = yield* layerInfo(sourceFile, position, withEffectTypeArgs);
    return withLayerInfo;
  });
}

// src/refactors/asyncAwaitToFn.ts
var asyncAwaitToFn = createRefactor({
  name: "asyncAwaitToFn",
  description: "Convert to Effect.fn",
  apply: fn("asyncAwaitToFn.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToFn",
      description: "Rewrite to Effect.fn",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "promise"
              ),
              void 0,
              [
                ts.factory.createArrowFunction(
                  void 0,
                  void 0,
                  [],
                  void 0,
                  void 0,
                  expression
                )
              ]
            )
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToFnTryPromise.ts
var asyncAwaitToFnTryPromise = createRefactor({
  name: "asyncAwaitToFnTryPromise",
  description: "Convert to Effect.fn with failures",
  apply: fn("asyncAwaitToFnTryPromise.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToFnTryPromise",
      description: "Rewrite to Effect.fn with failures",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Data"
          ) || "Data";
          let errorCount = 0;
          const errors = [];
          function createErrorADT() {
            errorCount++;
            const errorName = "Error" + errorCount;
            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [
              ts.factory.createPropertySignature(
                void 0,
                "cause",
                void 0,
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
              )
            ]));
            return ts.factory.createNewExpression(
              ts.factory.createIdentifier(errorName),
              void 0,
              [ts.factory.createObjectLiteralExpression([
                ts.factory.createShorthandPropertyAssignment("cause")
              ])]
            );
          }
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "tryPromise"
              ),
              void 0,
              [
                ts.factory.createObjectLiteralExpression([
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("try"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      expression
                    )
                  ),
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("catch"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [ts.factory.createParameterDeclaration(void 0, void 0, "cause")],
                      void 0,
                      void 0,
                      createErrorADT()
                    )
                  )
                ])
              ]
            )
          );
          let beforeNode = node;
          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {
            beforeNode = beforeNode.parent;
          }
          for (const error of errors) {
            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true);
          }
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToGen.ts
var asyncAwaitToGen = createRefactor({
  name: "asyncAwaitToGen",
  description: "Convert to Effect.gen",
  apply: fn("asyncAwaitToGen.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToGen",
      description: "Rewrite to Effect.gen",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "promise"
              ),
              void 0,
              [
                ts.factory.createArrowFunction(
                  void 0,
                  void 0,
                  [],
                  void 0,
                  void 0,
                  expression
                )
              ]
            )
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToGenTryPromise.ts
var asyncAwaitToGenTryPromise = createRefactor({
  name: "asyncAwaitToGenTryPromise",
  description: "Convert to Effect.gen with failures",
  apply: fn("asyncAwaitToGenTryPromise.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToGenTryPromise",
      description: "Rewrite to Effect.gen with failures",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Data"
          ) || "Data";
          let errorCount = 0;
          const errors = [];
          function createErrorADT() {
            errorCount++;
            const errorName = "Error" + errorCount;
            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [
              ts.factory.createPropertySignature(
                void 0,
                "cause",
                void 0,
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
              )
            ]));
            return ts.factory.createNewExpression(
              ts.factory.createIdentifier(errorName),
              void 0,
              [ts.factory.createObjectLiteralExpression([
                ts.factory.createShorthandPropertyAssignment("cause")
              ])]
            );
          }
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "tryPromise"
              ),
              void 0,
              [
                ts.factory.createObjectLiteralExpression([
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("try"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      expression
                    )
                  ),
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("catch"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [ts.factory.createParameterDeclaration(void 0, void 0, "cause")],
                      void 0,
                      void 0,
                      createErrorADT()
                    )
                  )
                ])
              ]
            )
          );
          let beforeNode = node;
          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {
            beforeNode = beforeNode.parent;
          }
          for (const error of errors) {
            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true);
          }
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/effectGenToFn.ts
var effectGenToFn = createRefactor({
  name: "effectGenToFn",
  description: "Convert to Effect.fn",
  apply: fn("effectGenToFn.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const skipReturnBlock = (node) => ts.isBlock(node) && node.statements.length === 1 && ts.isReturnStatement(node.statements[0]) && node.statements[0].expression ? node.statements[0].expression : node;
    const parseFunctionLikeReturnEffectGen = fn("parseFunctionLikeReturnEffect.apply")(function* (node) {
      if ((ts.isArrowFunction(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body) {
        let subject = skipReturnBlock(node.body);
        let pipeArgs2 = [];
        while (true) {
          const maybePipe = yield* option(typeParser.pipeCall(subject));
          if (isNone2(maybePipe)) break;
          subject = maybePipe.value.subject;
          pipeArgs2 = maybePipe.value.args.concat(pipeArgs2);
        }
        const fnIdentifier2 = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name) ? node.parent.name : void 0;
        const effectGen = yield* typeParser.effectGen(subject);
        return { ...effectGen, nodeToReplace: node, pipeArgs: pipeArgs2, fnIdentifier: fnIdentifier2 };
      }
      return yield* fail3(new RefactorNotApplicableError());
    });
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    if (parentNodes.length === 0) return yield* fail3(new RefactorNotApplicableError());
    const nodesFromInitializers = pipe(
      parentNodes,
      filter((_) => ts.isVariableDeclaration(_) && _.initializer ? true : false),
      filter((_) => tsUtils.isNodeInRange(textRange)(_.name)),
      map4((_) => _.initializer)
    );
    const maybeNode = yield* pipe(
      nodesFromInitializers.concat(parentNodes),
      map4(parseFunctionLikeReturnEffectGen),
      firstSuccessOf,
      option
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const { effectModule, fnIdentifier, generatorFunction, nodeToReplace, pipeArgs } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.effectGenToFn",
      description: fnIdentifier ? `Convert to Effect.fn("${ts.idText(fnIdentifier)}")` : "Convert to Effect.fn",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectFn = fnIdentifier ? ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              effectModule,
              "fn"
            ),
            void 0,
            [ts.factory.createStringLiteral(ts.idText(fnIdentifier))]
          ) : ts.factory.createPropertyAccessExpression(
            effectModule,
            "fn"
          );
          const effectFnCallWithGenerator = ts.factory.createCallExpression(
            effectFn,
            void 0,
            [ts.factory.createFunctionExpression(
              void 0,
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              void 0,
              nodeToReplace.typeParameters,
              nodeToReplace.parameters,
              nodeToReplace.type,
              generatorFunction.body
            )].concat(pipeArgs)
          );
          changeTracker.replaceNode(
            sourceFile,
            nodeToReplace,
            tsUtils.tryPreserveDeclarationSemantics(nodeToReplace, effectFnCallWithGenerator, false)
          );
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/functionToArrow.ts
var functionToArrow = createRefactor({
  name: "functionToArrow",
  description: "Convert to arrow",
  apply: fn("functionToArrow.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((_) => ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)),
      filter((_) => !!_.body),
      filter((_) => !!_.name && tsUtils.isNodeInRange(textRange)(_.name)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.functionToArrow",
      description: "Convert to arrow",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const body = node.body;
          let newBody = ts.factory.createBlock(body.statements);
          if (body.statements.length === 1) {
            const statement = body.statements[0];
            if (statement && ts.isReturnStatement(statement) && statement.expression) {
              newBody = statement.expression;
            }
          }
          let arrowFlags = ts.getCombinedModifierFlags(node);
          arrowFlags &= ~ts.ModifierFlags.Export;
          arrowFlags &= ~ts.ModifierFlags.Default;
          const arrowModifiers = ts.factory.createModifiersFromModifierFlags(arrowFlags);
          const arrowFunction = ts.factory.createArrowFunction(
            arrowModifiers,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            newBody
          );
          const newDeclaration = tsUtils.tryPreserveDeclarationSemantics(
            node,
            arrowFunction,
            false
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration, {
            leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
            trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
          });
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/layerMagic.ts
var layerMagic = createRefactor({
  name: "layerMagic",
  description: "Layer Magic",
  apply: fn("layerMagic.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const adjustedNode = (node) => {
      if (node.parent && (ts.isVariableDeclaration(node.parent) || ts.isPropertyDeclaration(node.parent)) && ts.isIdentifier(node) && node.parent.initializer && node.parent.name === node) {
        return node.parent.initializer;
      }
      return node;
    };
    const computeAsAnyAsLayerRefactor = (node) => {
      const atLocation = adjustedNode(node);
      return pipe(
        extractLayerGraph(atLocation, {
          arrayLiteralAsMerge: true,
          explodeOnlyLayerCalls: true,
          followSymbolsDepth: 0
        }),
        flatMap4(extractOutlineGraph),
        flatMap4(
          (extractedLayer) => nodeCount(extractedLayer) <= 1 ? TypeParserIssue.issue : succeed(extractedLayer)
        ),
        map8((extractedLayers) => ({
          kind: "refactor.rewrite.effect.layerMagicPrepare",
          description: "Prepare layers for automatic composition",
          apply: pipe(
            gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const layerOutputTypes = /* @__PURE__ */ new Set();
              for (const layer of values2(nodes(extractedLayers))) {
                layer.provides.forEach((_) => layerOutputTypes.add(_));
              }
              const layerNodes = pipe(
                values2(nodes(extractedLayers)),
                fromIterable,
                map4((_) => _.node),
                filter(ts.isExpression),
                sort(mapInput(
                  number2,
                  (_) => _.pos
                ))
              );
              const previouslyProvided = yield* pipe(
                typeParser.layerType(typeChecker.getTypeAtLocation(atLocation), atLocation),
                map8((_) => _.ROut),
                option
              );
              const [existingBefore, newlyIntroduced] = pipe(
                fromIterable(layerOutputTypes),
                sort(typeCheckerUtils.deterministicTypeOrder),
                partition(
                  (_) => isNone2(previouslyProvided) || typeChecker.isTypeAssignableTo(_, previouslyProvided.value)
                )
              );
              const typeReferences = pipe(
                newlyIntroduced,
                map4((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_)
              );
              const providesUnion = typeReferences.length === 0 ? ts.factory.createTypeReferenceNode("never") : ts.factory.createUnionTypeNode(typeReferences);
              const typeStrings = pipe(
                existingBefore,
                map4((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)),
                filter((_) => !!_)
              );
              const unionWithComment = typeStrings.length === 0 ? providesUnion : ts.addSyntheticTrailingComment(
                providesUnion,
                ts.SyntaxKind.MultiLineCommentTrivia,
                " " + typeStrings.join(" | ") + " ",
                false
              );
              const newDeclaration = ts.factory.createAsExpression(
                ts.factory.createAsExpression(
                  ts.factory.createArrayLiteralExpression(layerNodes),
                  ts.factory.createTypeReferenceNode("any")
                ),
                ts.factory.createTypeReferenceNode(
                  ts.factory.createQualifiedName(ts.factory.createIdentifier(layerIdentifier), "Layer"),
                  [unionWithComment]
                )
              );
              changeTracker.replaceNode(sourceFile, atLocation, newDeclaration, {
                leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
              });
            }),
            provideService(TypeScriptApi, ts)
          )
        }))
      );
    };
    const parseAsAnyAsLayer = (node) => {
      if (ts.isAsExpression(node) && ts.isTypeReferenceNode(node.type)) {
        const expression = node.expression;
        if (ts.isAsExpression(expression) && expression.type.kind === ts.SyntaxKind.AnyKeyword) {
          const type = typeChecker.getTypeAtLocation(node.type);
          return pipe(
            typeParser.layerType(type, node.type),
            map8((_) => ({ node, ..._, castedStructure: expression.expression }))
          );
        }
      }
      return TypeParserIssue.issue;
    };
    const computeBuildRefactor = (node) => {
      const atLocation = adjustedNode(node);
      return pipe(
        parseAsAnyAsLayer(atLocation),
        flatMap4(
          (_targetLayer) => pipe(
            extractLayerGraph(_targetLayer.castedStructure, {
              arrayLiteralAsMerge: true,
              explodeOnlyLayerCalls: true,
              followSymbolsDepth: 0
            }),
            flatMap4(extractOutlineGraph),
            flatMap4(
              (extractedLayer) => nodeCount(extractedLayer) <= 1 ? TypeParserIssue.issue : succeed(extractedLayer)
            ),
            map8((extractedLayers) => ({
              kind: "refactor.rewrite.effect.layerMagicBuild",
              description: "Compose layers automatically with target output services",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const { layerMagicNodes, missingOutputTypes } = yield* pipe(
                  convertOutlineGraphToLayerMagic(
                    extractedLayers,
                    [_targetLayer.ROut]
                  ),
                  provideService(TypeCheckerApi, typeChecker),
                  provideService(TypeCheckerUtils, typeCheckerUtils),
                  provideService(TypeScriptApi, ts)
                );
                const newDeclaration = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    layerMagicNodes[0].layerExpression,
                    "pipe"
                  ),
                  [],
                  layerMagicNodes.slice(1).map(
                    (_) => ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        ts.factory.createIdentifier(layerIdentifier),
                        _.merges && _.provides ? "provideMerge" : _.merges ? "merge" : "provide"
                      ),
                      [],
                      [_.layerExpression]
                    )
                  )
                );
                const newDeclarationWithComment = missingOutputTypes.size > 0 ? ts.addSyntheticTrailingComment(
                  newDeclaration,
                  ts.SyntaxKind.MultiLineCommentTrivia,
                  " Unable to find " + fromIterable(missingOutputTypes.values()).map(
                    (_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)
                  ).join(", ") + " in the provided layers. ",
                  false
                ) : newDeclaration;
                changeTracker.replaceNode(sourceFile, atLocation, newDeclarationWithComment, {
                  leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                  trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
                });
              })
            }))
          )
        )
      );
    };
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    if (parentNodes.length === 0) return yield* fail3(new RefactorNotApplicableError());
    return yield* pipe(
      firstSuccessOf(parentNodes.map(computeBuildRefactor)),
      orElse2(() => firstSuccessOf(parentNodes.map(computeAsAnyAsLayerRefactor))),
      orElse2(() => fail3(new RefactorNotApplicableError()))
    );
  })
});

// src/refactors/makeSchemaOpaque.ts
var _findSchemaVariableDeclaration = fn(
  "makeSchemaOpaque._findSchemaVariableDeclaration"
)(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const findSchema = fn("makeSchemaOpaque.apply.findSchema")(
      function* (node) {
        if (!ts.isVariableDeclaration(node)) {
          return yield* fail3("parent should be variable declaration");
        }
        const identifier = node.name;
        if (!ts.isIdentifier(identifier)) return yield* fail3("name should be an identifier");
        const initializer = node.initializer;
        if (!initializer) return yield* fail3("should have an initializer");
        const variableDeclarationList = node.parent;
        if (!variableDeclarationList || !ts.isVariableDeclarationList(variableDeclarationList)) {
          return yield* fail3("parent is not a variable declaration list");
        }
        const variableStatement = variableDeclarationList.parent;
        if (!variableStatement || !ts.isVariableStatement(variableStatement)) {
          return yield* fail3("parent not variable declaration statement");
        }
        const type = typeChecker.getTypeAtLocation(initializer);
        const types = yield* typeParser.effectSchemaType(type, initializer);
        return { identifier, variableStatement, variableDeclarationList, types };
      }
    );
    return yield* pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      map4(findSchema),
      firstSuccessOf,
      option
    );
  }
);
var _createOpaqueTypes = fn("_createOpaqueTypes")(function* (effectSchemaName, inferFromName, typeA, opaqueTypeName, typeE, opaqueEncodedName, opaqueContextName) {
  const ts = yield* service(TypeScriptApi);
  const opaqueInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Type")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const opaqueType = !(typeA.flags & ts.TypeFlags.Object) ? ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueTypeName,
    [],
    opaqueInferred
  ) : ts.factory.createInterfaceDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueTypeName,
    void 0,
    [ts.factory.createHeritageClause(
      ts.SyntaxKind.ExtendsKeyword,
      [opaqueInferred]
    )],
    []
  );
  const encodedInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Encoded")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const encodedType = !(typeE.flags & ts.TypeFlags.Object) ? ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueEncodedName,
    [],
    encodedInferred
  ) : ts.factory.createInterfaceDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueEncodedName,
    void 0,
    [ts.factory.createHeritageClause(
      ts.SyntaxKind.ExtendsKeyword,
      [encodedInferred]
    )],
    []
  );
  const contextInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Context")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const contextType = ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueContextName,
    [],
    contextInferred
  );
  return { contextType, encodedType, opaqueType };
});
var makeSchemaOpaque = createRefactor({
  name: "makeSchemaOpaque",
  description: "Make Schema opaque",
  apply: fn("makeSchemaOpaque.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.makeSchemaOpaque",
      description: `Make Schema opaque`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Schema"
          ) || "Schema";
          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + "_");
          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(
            effectSchemaName,
            ts.idText(newIdentifier),
            types.A,
            ts.idText(identifier),
            types.I,
            ts.idText(identifier) + "Encoded",
            ts.idText(identifier) + "Context"
          );
          changeTracker.replaceNode(
            sourceFile,
            identifier,
            newIdentifier
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, encodedType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, contextType);
          const newSchemaType = ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectSchemaName),
              ts.factory.createIdentifier("Schema")
            ),
            [
              ts.factory.createTypeReferenceNode(opaqueType.name),
              ts.factory.createTypeReferenceNode(encodedType.name),
              ts.factory.createTypeReferenceNode(contextType.name)
            ]
          );
          const newConstDeclaration = ts.factory.createVariableStatement(
            variableStatement.modifiers,
            ts.factory.createVariableDeclarationList(
              [ts.factory.createVariableDeclaration(
                ts.idText(identifier),
                void 0,
                newSchemaType,
                ts.factory.createIdentifier(ts.idText(newIdentifier))
              )],
              variableDeclarationList.flags
            )
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration);
          changeTracker.insertText(sourceFile, variableStatement.end, "\n");
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/makeSchemaOpaqueWithNs.ts
var makeSchemaOpaqueWithNs = createRefactor({
  name: "makeSchemaOpaqueWithNs",
  description: "Make Schema opaque with namespace",
  apply: fn("makeSchemaOpaqueWithNs.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.makeSchemaOpaqueWithNs",
      description: `Make Schema opaque with namespace`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Schema"
          ) || "Schema";
          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + "_");
          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(
            effectSchemaName,
            ts.idText(newIdentifier),
            types.A,
            ts.idText(identifier),
            types.I,
            "Encoded",
            "Context"
          );
          const namespace = ts.factory.createModuleDeclaration(
            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
            ts.factory.createIdentifier(ts.idText(identifier)),
            ts.factory.createModuleBlock([
              encodedType,
              contextType
            ]),
            ts.NodeFlags.Namespace
          );
          changeTracker.replaceNode(
            sourceFile,
            identifier,
            newIdentifier
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, namespace);
          const namespaceName = ts.isStringLiteral(namespace.name) ? namespace.name.text : ts.idText(namespace.name);
          const newSchemaType = ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectSchemaName),
              ts.factory.createIdentifier("Schema")
            ),
            [
              ts.factory.createTypeReferenceNode(opaqueType.name),
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier(
                    namespaceName
                  ),
                  ts.idText(encodedType.name)
                )
              ),
              ts.factory.createTypeReferenceNode(ts.factory.createQualifiedName(
                ts.factory.createIdentifier(namespaceName),
                ts.idText(contextType.name)
              ))
            ]
          );
          const newConstDeclaration = ts.factory.createVariableStatement(
            variableStatement.modifiers,
            ts.factory.createVariableDeclarationList(
              [ts.factory.createVariableDeclaration(
                ts.idText(identifier),
                void 0,
                newSchemaType,
                ts.factory.createIdentifier(ts.idText(newIdentifier))
              )],
              variableDeclarationList.flags
            )
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration);
          changeTracker.insertText(sourceFile, variableStatement.end, "\n");
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/pipeableToDatafirst.ts
var pipeableToDatafirst = createRefactor({
  name: "pipeableToDatafirst",
  description: "Rewrite to datafirst",
  apply: fn("pipeableToDatafirst.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const tsUtils = yield* service(TypeScriptUtils);
    function isPipeCall(node2) {
      if (!ts.isCallExpression(node2)) return false;
      const expression = node2.expression;
      if (!ts.isIdentifier(expression)) return false;
      if (ts.idText(expression) !== "pipe") return false;
      return true;
    }
    function asDataFirstExpression(node2, self) {
      if (!ts.isCallExpression(node2)) return none2();
      const signature = typeChecker.getResolvedSignature(node2);
      if (!signature) return none2();
      const callSignatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(node2.expression),
        ts.SignatureKind.Call
      );
      for (let i = 0; i < callSignatures.length; i++) {
        const callSignature = callSignatures[i];
        if (callSignature.parameters.length === node2.arguments.length + 1) {
          return some2(
            ts.factory.createCallExpression(
              node2.expression,
              [],
              [self].concat(node2.arguments)
            )
          );
        }
      }
      return none2();
    }
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(isPipeCall),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.expression)),
      filter(
        (node2) => node2.arguments.length > 0
      ),
      map4((node2) => {
        let newNode2 = node2.arguments[0];
        let didSomething = false;
        for (let i = 1; i < node2.arguments.length; i++) {
          const arg = node2.arguments[i];
          const a = asDataFirstExpression(arg, newNode2);
          if (isSome2(a)) {
            newNode2 = a.value;
            didSomething = true;
          } else {
            if (isPipeCall(newNode2)) {
              newNode2 = ts.factory.createCallExpression(
                ts.factory.createIdentifier("pipe"),
                [],
                newNode2.arguments.concat([arg])
              );
            } else {
              newNode2 = ts.factory.createCallExpression(ts.factory.createIdentifier("pipe"), [], [
                newNode2,
                arg
              ]);
            }
          }
        }
        return didSomething ? some2([node2, newNode2]) : none2();
      }),
      filter(isSome2),
      map4((_) => _.value),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const [node, newNode] = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.pipeableToDatafirst",
      description: "Rewrite to datafirst",
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        changeTracker.replaceNode(sourceFile, node, newNode);
      })
    };
  })
});

// src/refactors/removeUnnecessaryEffectGen.ts
var removeUnnecessaryEffectGen = createRefactor({
  name: "removeUnnecessaryEffectGen",
  description: "Remove unnecessary Effect.gen",
  apply: fn("removeUnnecessaryEffectGen.apply")(function* (sourceFile, textRange) {
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    for (const nodeToReplace of tsUtils.getAncestorNodesInRange(sourceFile, textRange)) {
      const maybeNode = yield* option(typeParser.unnecessaryEffectGen(nodeToReplace));
      if (isNone2(maybeNode)) continue;
      const replacementNode = maybeNode.value.replacementNode;
      return {
        kind: "refactor.rewrite.effect.removeUnnecessaryEffectGen",
        description: "Remove unnecessary Effect.gen",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(sourceFile, nodeToReplace, yield* replacementNode);
        })
      };
    }
    return yield* fail3(new RefactorNotApplicableError());
  })
});

// src/refactors/structuralTypeToSchema.ts
var structuralTypeToSchema = createRefactor({
  name: "structuralTypeToSchema",
  description: "Refactor to Schema (Structural)",
  apply: fn("structuralTypeToSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const program = yield* service(TypeScriptProgram);
    const maybeNode = yield* findNodeToProcess(sourceFile, textRange);
    if (isNone2(maybeNode)) {
      return yield* fail3(new RefactorNotApplicableError());
    }
    const { identifier, isExported, node, type } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.structuralTypeToSchema",
      description: "Refactor to Schema (Recursive Structural)",
      apply: pipe(
        applyAtNode(sourceFile, node, identifier, type, isExported),
        provideService(TypeCheckerApi, typeChecker),
        provideService(TypeScriptUtils, tsUtils),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerUtils, typeCheckerUtils),
        provideService(TypeParser, typeParser),
        provideService(TypeScriptProgram, program)
      )
    };
  })
});

// src/refactors/toggleLazyConst.ts
var toggleLazyConst = createRefactor({
  name: "toggleLazyConst",
  description: "Toggle lazy const",
  apply: fn("toggleLazyConst.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(ts.isVariableDeclaration),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.name)),
      filter(
        (node2) => !!node2.initializer && !(ts.isArrowFunction(node2.initializer) && ts.isBlock(node2.initializer.body))
      ),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.toggleLazyConst",
      description: "Toggle lazy const",
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        const initializer = node.initializer;
        if (ts.isArrowFunction(initializer) && initializer.parameters.length === 0) {
          changeTracker.deleteRange(sourceFile, {
            pos: initializer.body.end,
            end: initializer.end
          });
          changeTracker.deleteRange(sourceFile, {
            pos: initializer.pos,
            end: initializer.body.pos
          });
          return;
        }
        changeTracker.insertText(sourceFile, initializer.pos, " () =>");
      })
    };
  })
});

// src/refactors/togglePipeStyle.ts
var togglePipeStyle = createRefactor({
  name: "togglePipeStyle",
  description: "Toggle pipe style",
  apply: fn("togglePipeStyle.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const togglePipeStyle2 = (node) => gen(function* () {
      const pipeCall = yield* typeParser.pipeCall(node);
      switch (pipeCall.kind) {
        case "pipe": {
          yield* typeParser.pipeableType(typeChecker.getTypeAtLocation(pipeCall.subject), pipeCall.subject);
          return {
            kind: "refactor.rewrite.effect.togglePipeStyle",
            description: "Rewrite as X.pipe(Y, Z, ...)",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.replaceNode(
                sourceFile,
                node,
                ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    pipeCall.subject,
                    "pipe"
                  ),
                  void 0,
                  pipeCall.args
                )
              );
            })
          };
        }
        case "pipeable":
          return {
            kind: "refactor.rewrite.effect.togglePipeStyle",
            description: "Rewrite as pipe(X, Y, Z, ...)",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.replaceNode(
                sourceFile,
                node,
                ts.factory.createCallExpression(
                  ts.factory.createIdentifier("pipe"),
                  void 0,
                  [pipeCall.subject].concat(pipeCall.args)
                )
              );
            })
          };
      }
    });
    const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(ancestorNodes.map(togglePipeStyle2)),
      orElse2(() => fail3(new RefactorNotApplicableError()))
    );
  })
});

// src/refactors/toggleReturnTypeAnnotation.ts
var toggleReturnTypeAnnotation = createRefactor({
  name: "toggleReturnTypeAnnotation",
  description: "Toggle return type annotation",
  apply: fn("toggleReturnTypeAnnotation.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    function addReturnTypeAnnotation(sourceFile2, changeTracker, declaration, typeNode) {
      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile2);
      const needParens = ts.isArrowFunction(declaration) && closeParen === void 0;
      const endNode = needParens ? declaration.parameters[0] : closeParen;
      if (endNode) {
        if (needParens) {
          changeTracker.insertNodeBefore(
            sourceFile2,
            endNode,
            ts.factory.createToken(ts.SyntaxKind.OpenParenToken)
          );
          changeTracker.insertNodeAfter(
            sourceFile2,
            endNode,
            ts.factory.createToken(ts.SyntaxKind.CloseParenToken)
          );
        }
        changeTracker.insertNodeAt(sourceFile2, endNode.end, typeNode, { prefix: ": " });
      }
    }
    function removeReturnTypeAnnotation(sourceFile2, changeTracker, declaration) {
      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile2);
      const needParens = ts.isArrowFunction(declaration) && closeParen === void 0;
      const endNode = needParens ? declaration.parameters[0] : closeParen;
      if (endNode && declaration.type) {
        changeTracker.deleteRange(sourceFile2, { pos: endNode.end, end: declaration.type.end });
      }
    }
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isFunctionExpression(node2) || ts.isArrowFunction(node2) || ts.isMethodDeclaration(node2)
      ),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    if (node.type) {
      return {
        kind: "refactor.rewrite.effect.toggleReturnTypeAnnotation",
        description: "Toggle return type annotation",
        apply: pipe(
          service(ChangeTracker),
          map8((changeTracker) => removeReturnTypeAnnotation(sourceFile, changeTracker, node))
        )
      };
    }
    const returnType = typeCheckerUtils.getInferredReturnType(node);
    if (!returnType) return yield* fail3(new RefactorNotApplicableError());
    const enclosingNode = ts.findAncestor(node, (_) => tsUtils.isDeclarationKind(_.kind)) || sourceFile;
    const returnTypeNode = typeCheckerUtils.typeToSimplifiedTypeNode(
      returnType,
      enclosingNode,
      ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.IgnoreErrors
    );
    if (!returnTypeNode) return yield* fail3(new RefactorNotApplicableError());
    return {
      kind: "refactor.rewrite.effect.toggleReturnTypeAnnotation",
      description: "Toggle return type annotation",
      apply: pipe(
        service(ChangeTracker),
        map8((changeTracker) => addReturnTypeAnnotation(sourceFile, changeTracker, node, returnTypeNode))
      )
    };
  })
});

// src/refactors/toggleTypeAnnotation.ts
var toggleTypeAnnotation = createRefactor({
  name: "toggleTypeAnnotation",
  description: "Toggle type annotation",
  apply: fn("toggleTypeAnnotation.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node2) => ts.isVariableDeclaration(node2) || ts.isPropertyDeclaration(node2)),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.name)),
      filter((node2) => !!node2.initializer),
      head
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.toggleTypeAnnotation",
      description: "Toggle type annotation",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          if (node.type) {
            changeTracker.deleteRange(sourceFile, { pos: node.name.end, end: node.type.end });
            return;
          }
          const initializer = node.initializer;
          const initializerType = typeChecker.getTypeAtLocation(initializer);
          const enclosingNode = ts.findAncestor(node, (_) => tsUtils.isDeclarationKind(_.kind)) || sourceFile;
          const initializerTypeNode = fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
            initializerType,
            enclosingNode,
            ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.IgnoreErrors
          )).pipe(
            getOrUndefined
          );
          if (initializerTypeNode) {
            changeTracker.insertNodeAt(
              sourceFile,
              node.name.end,
              initializerTypeNode,
              {
                prefix: ": "
              }
            );
          }
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/utils/SchemaGen.ts
var TypeParametersNotSupportedError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/TypeParametersNotSupportedError";
  toString() {
    return `Could not process types with type parameters.`;
  }
};
var OnlyLiteralPropertiesSupportedError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/OnlyLiteralPropertiesSupportedError";
  toString() {
    return `Could not process ${this.node.getText()} as only literal properties are supported.`;
  }
};
var RequiredExplicitTypesError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/RequiredExplicitTypesError";
  toString() {
    return `Could not process ${this.node.getText()} as only explicit types are supported.`;
  }
};
var IndexSignatureWithMoreThanOneParameterError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/IndexSignatureWithMoreThanOneParameterError";
  toString() {
    return `Could not process ${this.node.getText()} as only index signatures with one parameter are supported.`;
  }
};
var SchemaGenContext = Tag("SchemaGenContext");
var makeSchemaGenContext = fn("SchemaGen.makeSchemaGenContext")(function* (sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const effectSchemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Schema"
  ) || "Schema";
  const moduleToImportedName = {};
  for (const moduleName of ["Option", "Either", "Chunk", "Duration"]) {
    const importedName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", moduleName);
    if (importedName) moduleToImportedName[moduleName] = importedName;
  }
  const ts = yield* service(TypeScriptApi);
  return {
    sourceFile,
    createApiPropertyAccess: (apiName) => ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectSchemaIdentifier),
      apiName
    ),
    createApiCall: (apiName, args2) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaIdentifier),
        apiName
      ),
      [],
      args2
    ),
    entityNameToDataTypeName: (name) => {
      if (ts.isIdentifier(name)) {
        switch (ts.idText(name)) {
          case "Date":
          case "Pick":
          case "Omit":
          case "Record":
            return some2(ts.idText(name));
          case "ReadonlyArray":
          case "Array":
            return some2("Array");
        }
        return none2();
      }
      if (!ts.isIdentifier(name.left)) return none2();
      for (const moduleName in moduleToImportedName) {
        if (ts.idText(name.left) === moduleToImportedName[moduleName] && ts.idText(name.right) === moduleName) {
          return some2(moduleName);
        }
      }
      return none2();
    },
    ts
  };
});
var typeEntityNameToNode = fn(
  "SchemaGen.typeEntityNameToNode"
)(
  function* (entityName) {
    const { ts } = yield* service(SchemaGenContext);
    if (ts.isIdentifier(entityName)) return ts.factory.createIdentifier(ts.idText(entityName));
    const left3 = yield* typeEntityNameToNode(entityName.left);
    return ts.factory.createPropertyAccessExpression(
      left3,
      ts.factory.createIdentifier(ts.idText(entityName.right))
    );
  }
);
var parseAllLiterals = fn(
  "SchemaGen.parseAllLiterals"
)(
  function* (node) {
    const { ts } = yield* service(SchemaGenContext);
    if (ts.isLiteralTypeNode(node)) {
      switch (node.literal.kind) {
        case ts.SyntaxKind.StringLiteral:
          return [ts.factory.createStringLiteral(node.literal.text)];
        case ts.SyntaxKind.NumericLiteral:
          return [ts.factory.createNumericLiteral(node.literal.text)];
        case ts.SyntaxKind.TrueKeyword:
          return [ts.factory.createTrue()];
        case ts.SyntaxKind.FalseKeyword:
          return [ts.factory.createFalse()];
      }
    }
    if (ts.isUnionTypeNode(node)) {
      return flatten(yield* all(...node.types.map((_) => parseAllLiterals(_))));
    }
    if (ts.isParenthesizedTypeNode(node)) {
      return yield* parseAllLiterals(node.type);
    }
    return yield* fail3(node);
  }
);
var createUnsupportedNodeComment = (ts, sourceFile, node) => ts.addSyntheticTrailingComment(
  ts.factory.createIdentifier(""),
  ts.SyntaxKind.MultiLineCommentTrivia,
  " Not supported conversion: " + node.getText(sourceFile) + " "
);
var processNode = (node, isVirtualTypeNode) => gen(function* () {
  const { createApiCall, createApiPropertyAccess, entityNameToDataTypeName, sourceFile, ts } = yield* service(
    SchemaGenContext
  );
  switch (node.kind) {
    case ts.SyntaxKind.AnyKeyword:
      return createApiPropertyAccess("Any");
    case ts.SyntaxKind.NeverKeyword:
      return createApiPropertyAccess("Never");
    case ts.SyntaxKind.UnknownKeyword:
      return createApiPropertyAccess("Unknown");
    case ts.SyntaxKind.VoidKeyword:
      return createApiPropertyAccess("Void");
    case ts.SyntaxKind.NullKeyword:
      return createApiPropertyAccess("Null");
    case ts.SyntaxKind.UndefinedKeyword:
      return createApiPropertyAccess("Undefined");
    case ts.SyntaxKind.StringKeyword:
      return createApiPropertyAccess("String");
    case ts.SyntaxKind.NumberKeyword:
      return createApiPropertyAccess("Number");
    case ts.SyntaxKind.BooleanKeyword:
      return createApiPropertyAccess("Boolean");
    case ts.SyntaxKind.BigIntKeyword:
      return createApiPropertyAccess("BigInt");
  }
  if (ts.isLiteralTypeNode(node)) {
    if (node.literal.kind === ts.SyntaxKind.NullKeyword) return createApiPropertyAccess("Null");
    const literalMembers = yield* option(parseAllLiterals(node));
    if (isSome2(literalMembers)) return createApiCall("Literal", literalMembers.value);
  }
  if (ts.isUnionTypeNode(node)) {
    const allLiterals = yield* option(parseAllLiterals(node));
    if (isSome2(allLiterals)) return createApiCall("Literal", allLiterals.value);
    const members = yield* all(...node.types.map((_) => processNode(_, isVirtualTypeNode)));
    return createApiCall("Union", members);
  }
  if (ts.isIntersectionTypeNode(node)) {
    const [firstSchema, ...otherSchemas] = yield* all(
      ...node.types.map((_) => processNode(_, isVirtualTypeNode))
    );
    if (otherSchemas.length === 0) return firstSchema;
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        firstSchema,
        "pipe"
      ),
      [],
      otherSchemas.map((_) => createApiCall("extend", [_]))
    );
  }
  if (ts.isTypeOperatorNode(node)) {
    if (node.operator === ts.SyntaxKind.KeyOfKeyword) {
      return createApiCall("keyof", [yield* processNode(node.type, isVirtualTypeNode)]);
    } else if (node.operator === ts.SyntaxKind.ReadonlyKeyword) {
      return yield* processNode(node.type, isVirtualTypeNode);
    }
  }
  if (ts.isArrayTypeNode(node)) {
    const typeSchema = yield* processNode(node.elementType, isVirtualTypeNode);
    return createApiCall("Array", [typeSchema]);
  }
  if (ts.isTypeLiteralNode(node)) {
    const { properties, records } = yield* processMembers(node.members, isVirtualTypeNode);
    return createApiCall(
      "Struct",
      [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)
    );
  }
  if (ts.isParenthesizedTypeNode(node)) {
    return yield* processNode(node.type, isVirtualTypeNode);
  }
  if (ts.isTypeQueryNode(node)) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const type = typeCheckerUtils.getTypeAtLocation(node.exprName);
    if (type) {
      const typeNode = typeChecker.typeToTypeNode(type, void 0, ts.NodeBuilderFlags.NoTruncation);
      if (typeNode) return yield* processNode(typeNode, true);
    }
  }
  if (!isVirtualTypeNode && ts.isIndexedAccessTypeNode(node) && ts.isParenthesizedTypeNode(node.objectType) && ts.isTypeQueryNode(node.objectType.type) && ts.isTypeOperatorNode(node.indexType) && node.indexType.operator === ts.SyntaxKind.KeyOfKeyword && ts.isTypeQueryNode(node.indexType.type) && node.indexType.type.exprName.getText().trim() === node.objectType.type.exprName.getText().trim()) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const type = typeCheckerUtils.getTypeAtLocation(node);
    if (type) {
      const typeNode = typeChecker.typeToTypeNode(type, void 0, ts.NodeBuilderFlags.NoTruncation);
      if (typeNode) return yield* processNode(typeNode, true);
    }
  }
  if (ts.isTypeReferenceNode(node)) {
    const parsedName = entityNameToDataTypeName(node.typeName);
    if (isSome2(parsedName)) {
      switch (parsedName.value) {
        case "Duration":
        case "Date":
          return createApiPropertyAccess(parsedName.value);
        case "Option":
        case "Chunk":
        case "Array": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          return createApiCall(parsedName.value, elements);
        }
        case "Record": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          if (elements.length >= 2) {
            return createApiCall(parsedName.value, [
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("key", elements[0]),
                ts.factory.createPropertyAssignment("value", elements[1])
              ])
            ]);
          }
          return createUnsupportedNodeComment(ts, sourceFile, node);
        }
        case "Either": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          if (elements.length >= 2) {
            return createApiCall(parsedName.value, [
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("right", elements[0]),
                ts.factory.createPropertyAssignment("left", elements[1])
              ])
            ]);
          }
          return createUnsupportedNodeComment(ts, sourceFile, node);
        }
        case "Pick":
        case "Omit": {
          const typeArguments = fromIterable(node.typeArguments || []);
          if (typeArguments.length !== 2) {
            return createUnsupportedNodeComment(ts, sourceFile, node);
          }
          const baseType = yield* processNode(typeArguments[0], isVirtualTypeNode);
          const stringLiteralArguments = yield* option(parseAllLiterals(typeArguments[1]));
          if (isNone2(stringLiteralArguments)) {
            return createUnsupportedNodeComment(ts, sourceFile, node);
          }
          return ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              baseType,
              "pipe"
            ),
            [],
            [createApiCall(parsedName.value.toLowerCase(), stringLiteralArguments.value)]
          );
        }
      }
    }
  }
  if (ts.isTypeReferenceNode(node)) {
    if (!(node.typeArguments && node.typeArguments.length > 0)) {
      return yield* typeEntityNameToNode(node.typeName);
    }
  }
  return createUnsupportedNodeComment(ts, sourceFile, node);
});
var processMembers = fn(
  "SchemaGen.processMembers"
)(
  function* (members, isVirtualTypeNode) {
    const { createApiCall, ts } = yield* service(
      SchemaGenContext
    );
    const properties = [];
    for (const propertySignature of members.filter(ts.isPropertySignature)) {
      const name = propertySignature.name;
      if (!(ts.isIdentifier(name) || ts.isStringLiteral(name))) {
        return yield* fail3(new OnlyLiteralPropertiesSupportedError(propertySignature));
      }
      if (!propertySignature.type) {
        return yield* fail3(new RequiredExplicitTypesError(propertySignature));
      }
      const propertyAssignment = pipe(
        yield* processNode(propertySignature.type, isVirtualTypeNode),
        propertySignature.questionToken ? (_) => createApiCall("optional", [_]) : identity,
        (_) => ts.factory.createPropertyAssignment(name, _)
      );
      properties.push(propertyAssignment);
    }
    const records = [];
    for (const indexSignature of members.filter(ts.isIndexSignatureDeclaration)) {
      if (indexSignature.parameters.length !== 1) {
        return yield* fail3(new IndexSignatureWithMoreThanOneParameterError(indexSignature));
      }
      const parameter = indexSignature.parameters[0];
      if (!parameter.type) return yield* fail3(new RequiredExplicitTypesError(parameter));
      const parameterType = parameter.type;
      const key = yield* processNode(parameterType, isVirtualTypeNode);
      const value = yield* processNode(indexSignature.type, isVirtualTypeNode);
      records.push(
        ts.factory.createObjectLiteralExpression([
          ts.factory.createPropertyAssignment("key", key),
          ts.factory.createPropertyAssignment("value", value)
        ])
      );
    }
    return { properties, records };
  }
);
var processInterfaceDeclaration = fn("SchemaGen.processInterfaceDeclaration")(
  function* (node, preferClass) {
    if (node.typeParameters && node.typeParameters.length > 0) {
      return yield* fail3(new TypeParametersNotSupportedError(node));
    }
    const { createApiCall, ts } = yield* service(
      SchemaGenContext
    );
    const { properties, records } = yield* processMembers(node.members, false);
    if (preferClass && records.length === 0) {
      return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties);
    }
    const schemaStruct = createApiCall(
      "Struct",
      [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)
    );
    return yield* createExportVariableDeclaration(ts.idText(node.name), schemaStruct);
  }
);
var processTypeAliasDeclaration = fn("SchemaGen.processInterfaceDeclaration")(
  function* (node, preferClass) {
    const { ts } = yield* service(SchemaGenContext);
    if (node.typeParameters && node.typeParameters.length > 0) {
      return yield* fail3(new TypeParametersNotSupportedError(node));
    }
    if (preferClass && ts.isTypeLiteralNode(node.type)) {
      const { properties, records } = yield* processMembers(node.type.members, false);
      if (records.length === 0) {
        return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties);
      }
    }
    const effectSchema = yield* processNode(node.type, false);
    return yield* createExportVariableDeclaration(ts.idText(node.name), effectSchema);
  }
);
var createExportVariableDeclaration = fn("SchemaGen.createExportVariableDeclaration")(
  function* (name, initializer) {
    const ts = yield* service(TypeScriptApi);
    return ts.factory.createVariableStatement(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createVariableDeclarationList([
        ts.factory.createVariableDeclaration(
          ts.factory.createIdentifier(name),
          void 0,
          void 0,
          initializer
        )
      ], ts.NodeFlags.Const)
    );
  }
);
var createExportSchemaClassDeclaration = fn("SchemaGen.createExportSchemaClassDeclaration")(
  function* (name, members) {
    const { createApiPropertyAccess } = yield* service(SchemaGenContext);
    const ts = yield* service(TypeScriptApi);
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createIdentifier(name),
      [],
      [ts.factory.createHeritageClause(
        ts.SyntaxKind.ExtendsKeyword,
        [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createCallExpression(
              ts.factory.createCallExpression(
                createApiPropertyAccess("Class"),
                [ts.factory.createTypeReferenceNode(
                  name
                )],
                [ts.factory.createStringLiteral(name)]
              ),
              [],
              [ts.factory.createObjectLiteralExpression(
                members,
                true
              )]
            ),
            []
          )
        ]
      )],
      []
    );
  }
);
var process2 = fn("SchemaGen.process")(
  function* (sourceFile, node, preferClass) {
    const ctx = yield* makeSchemaGenContext(sourceFile);
    const ts = yield* service(TypeScriptApi);
    return yield* pipe(
      ts.isInterfaceDeclaration(node) ? processInterfaceDeclaration(node, preferClass) : processTypeAliasDeclaration(node, preferClass),
      provideService(SchemaGenContext, ctx)
    );
  }
);
var findNodeToProcess2 = fn("SchemaGen.findNodeToProcess")(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),
      filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),
      filter((node) => (node.typeParameters || []).length === 0),
      head
    );
  }
);
var applyAtNode2 = fn("SchemaGen.applyAtNode")(
  function* (sourceFile, node, preferClass) {
    const ts = yield* service(TypeScriptApi);
    const changeTracker = yield* service(ChangeTracker);
    const newNode = yield* pipe(
      process2(sourceFile, node, preferClass),
      orElse2(
        (error) => succeed(ts.addSyntheticLeadingComment(
          ts.factory.createIdentifier(""),
          ts.SyntaxKind.MultiLineCommentTrivia,
          " " + String(error) + " ",
          true
        ))
      )
    );
    changeTracker.insertNodeBefore(sourceFile, node, newNode, true, {
      leadingTriviaOption: ts.textChanges.LeadingTriviaOption.StartLine
    });
  }
);

// src/refactors/typeToEffectSchema.ts
var typeToEffectSchema = createRefactor({
  name: "typeToEffectSchema",
  description: "Refactor to Schema",
  apply: fn("typeToEffectSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = yield* findNodeToProcess2(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.typeToEffectSchema",
      description: "Refactor to Schema",
      apply: pipe(
        applyAtNode2(sourceFile, node, false),
        provideService(TypeCheckerApi, typeChecker),
        provideService(TypeScriptUtils, tsUtils),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerUtils, typeCheckerUtils)
      )
    };
  })
});

// src/refactors/typeToEffectSchemaClass.ts
var typeToEffectSchemaClass = createRefactor({
  name: "typeToEffectSchemaClass",
  description: "Refactor to Schema.Class",
  apply: fn("typeToEffectSchemaClass.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = yield* findNodeToProcess2(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.typeToEffectSchemaClass",
      description: "Refactor to Schema.Class",
      apply: pipe(
        applyAtNode2(sourceFile, node, true),
        provideService(TypeCheckerApi, typeChecker),
        provideService(TypeScriptUtils, tsUtils),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerUtils, typeCheckerUtils)
      )
    };
  })
});

// src/refactors/wrapWithEffectGen.ts
var wrapWithEffectGen = createRefactor({
  name: "wrapWithEffectGen",
  description: "Wrap with Effect.gen",
  apply: fn("wrapWithEffectGen.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const findEffectToWrap = fn("wrapWithEffectGen.apply.findEffectToWrap")(
      function* (node) {
        if (!ts.isExpression(node)) return yield* fail3("is not an expression");
        if (node.parent && ts.isHeritageClause(node.parent)) return yield* fail3("is in a heritage clause");
        const parent = node.parent;
        if (parent != null && ts.isVariableDeclaration(parent) && parent.initializer !== node) return yield* fail3("is LHS of variable declaration");
        const type = typeCheckerUtils.getTypeAtLocation(node);
        if (!type) return yield* fail3("cannot get type");
        yield* typeParser.strictEffectType(type, node);
        return node;
      }
    );
    const maybeNode = yield* pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      map4(findEffectToWrap),
      firstSuccessOf,
      option
    );
    if (isNone2(maybeNode)) return yield* fail3(new RefactorNotApplicableError());
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    return {
      kind: "refactor.rewrite.effect.wrapWithEffectGen",
      description: `Wrap with Effect.gen`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectGen = tsUtils.createEffectGenCallExpressionWithBlock(
            effectModuleIdentifier,
            tsUtils.createReturnYieldStarStatement(maybeNode.value)
          );
          changeTracker.replaceNode(sourceFile, maybeNode.value, effectGen);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/wrapWithPipe.ts
var wrapWithPipe = createRefactor({
  name: "wrapWithPipe",
  description: "Wrap with pipe",
  apply: fn("wrapWithPipe.apply")(function* (sourceFile, textRange) {
    if (textRange.end - textRange.pos === 0) {
      return yield* fail3(new RefactorNotApplicableError());
    }
    return {
      kind: "refactor.rewrite.effect.wrapWithPipe",
      description: `Wrap with pipe(...)`,
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        changeTracker.insertText(sourceFile, textRange.pos, "pipe(");
        changeTracker.insertText(sourceFile, textRange.end, ")");
      })
    };
  })
});

// src/refactors.ts
var refactors = [
  layerMagic,
  asyncAwaitToGen,
  asyncAwaitToGenTryPromise,
  asyncAwaitToFn,
  asyncAwaitToFnTryPromise,
  functionToArrow,
  typeToEffectSchema,
  typeToEffectSchemaClass,
  structuralTypeToSchema,
  makeSchemaOpaque,
  makeSchemaOpaqueWithNs,
  pipeableToDatafirst,
  removeUnnecessaryEffectGen,
  toggleLazyConst,
  toggleReturnTypeAnnotation,
  toggleTypeAnnotation,
  wrapWithEffectGen,
  wrapWithPipe,
  effectGenToFn,
  togglePipeStyle,
  writeTagClassAccessors
];

// src/renames/keyStrings.ts
var renameKeyStrings = (sourceFile, position, _findInStrings, _findInComments, _preferences, renameLocations) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeParser = yield* service(TypeParser);
  const additionalPositions = [];
  const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, position);
  if (node && ts.isIdentifier(node)) {
    const textToReplace = ts.idText(node);
    const parentClass = node.parent;
    if (ts.isClassDeclaration(parentClass) && parentClass.name === node) {
      const baseIdentifier = yield* pipe(
        map8(typeParser.extendsContextTag(parentClass), (_) => [_.keyStringLiteral]),
        orElse2(() => map8(typeParser.extendsEffectService(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(() => map8(typeParser.extendsEffectTag(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(
          () => map8(typeParser.extendsSchemaTaggedClass(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])
        ),
        orElse2(
          () => map8(typeParser.extendsSchemaTaggedError(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])
        ),
        orElse2(() => map8(typeParser.extendsDataTaggedError(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(() => map8(typeParser.extendsDataTaggedClass(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(
          () => map8(
            typeParser.extendsSchemaTaggedRequest(parentClass),
            (_) => [_.keyStringLiteral, _.tagStringLiteral]
          )
        ),
        option
      );
      if (isSome2(baseIdentifier)) {
        for (const keyStringLiteral of baseIdentifier.value) {
          if (!keyStringLiteral) continue;
          const baseText = sourceFile.text.slice(keyStringLiteral.pos, keyStringLiteral.end);
          const lastIndex = baseText.lastIndexOf(textToReplace);
          if (lastIndex !== -1) {
            additionalPositions.push({
              fileName: sourceFile.fileName,
              textSpan: {
                start: keyStringLiteral.pos + lastIndex,
                length: textToReplace.length
              }
            });
          }
        }
      }
    }
  }
  return additionalPositions.length === 0 ? renameLocations : additionalPositions.concat(renameLocations || []);
});

// src/index.ts
var LSP_INJECTED_URI = "@effect/language-service/injected";
var init = (modules) => {
  const diagnosticsErrorCodes = diagnostics.map((diagnostic) => diagnostic.code);
  try {
    ;
    modules.typescript.codefix.registerCodeFix({
      errorCodes: diagnosticsErrorCodes,
      getCodeActions: () => void 0
    });
  } catch (_) {
  }
  let languageServicePluginOptions = parse({});
  function onConfigurationChanged(config) {
    languageServicePluginOptions = parse(config);
  }
  function create(info) {
    const languageService = info.languageService;
    languageServicePluginOptions = parse(info.config);
    if (languageService[LSP_INJECTED_URI]) return languageService;
    info.project.log("[@effect/language-service] Started!");
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy[LSP_INJECTED_URI] = true;
    for (const k of Object.keys(languageService)) {
      proxy[k] = (...args2) => languageService[k].apply(languageService, args2);
    }
    function runNano(program) {
      return (fa) => pipe(
        fa,
        nanoLayer3,
        nanoLayer2,
        nanoLayer,
        provideService(TypeCheckerApi, program.getTypeChecker()),
        provideService(TypeScriptProgram, program),
        provideService(TypeScriptApi, modules.typescript),
        provideService(
          LanguageServicePluginOptions,
          languageServicePluginOptions
        ),
        run
      );
    }
    const effectCodeFixesForFile = /* @__PURE__ */ new Map();
    const runDiagnosticsAndCacheCodeFixes = (fileName) => {
      const program = languageService.getProgram();
      while (effectCodeFixesForFile.size > 5) {
        const oldest = effectCodeFixesForFile.keys().next().value;
        if (oldest) effectCodeFixesForFile.delete(oldest);
      }
      if (languageServicePluginOptions.diagnostics && program) {
        effectCodeFixesForFile.delete(fileName);
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
            runNano(program),
            map(({ codeFixes, diagnostics: diagnostics2 }) => {
              effectCodeFixesForFile.set(fileName, codeFixes);
              return diagnostics2;
            }),
            getOrElse(() => [])
          );
        }
      }
      return [];
    };
    proxy.getSemanticDiagnostics = (fileName, ...args2) => {
      const applicableDiagnostics = languageService.getSemanticDiagnostics(fileName, ...args2);
      return concatDiagnostics(runDiagnosticsAndCacheCodeFixes(fileName), applicableDiagnostics);
    };
    proxy.getSupportedCodeFixes = (...args2) => languageService.getSupportedCodeFixes(...args2).concat(
      diagnosticsErrorCodes.map((_) => "" + _)
    );
    proxy.getCodeFixesAtPosition = (fileName, start, end, errorCodes, formatOptions, preferences, ...args2) => {
      const applicableCodeFixes = languageService.getCodeFixesAtPosition(
        fileName,
        start,
        end,
        errorCodes,
        formatOptions,
        preferences,
        ...args2
      );
      const program = languageService.getProgram();
      if (languageServicePluginOptions.diagnostics && program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            sync(() => {
              const effectCodeFixes = [];
              if (!effectCodeFixesForFile.has(fileName)) {
                runDiagnosticsAndCacheCodeFixes(fileName);
              }
              const applicableFixes = (effectCodeFixesForFile.get(fileName) || []).filter(
                (_) => _.start === start && _.end === end && errorCodes.indexOf(_.code) > -1
              );
              const formatContext = modules.typescript.formatting.getFormatContext(
                formatOptions,
                info.languageServiceHost
              );
              for (const applicableFix of applicableFixes) {
                const changes = modules.typescript.textChanges.ChangeTracker.with(
                  {
                    formatContext,
                    host: info.languageServiceHost,
                    preferences: preferences || {}
                  },
                  (changeTracker) => pipe(
                    applicableFix.apply,
                    provideService(ChangeTracker, changeTracker),
                    run
                  )
                );
                effectCodeFixes.push({
                  fixName: applicableFix.fixName,
                  description: applicableFix.description,
                  changes
                });
              }
              return effectCodeFixes;
            }),
            flatMap4(
              (effectCodeFixes) => pipe(
                middlewareAutoImportQuickfixes(
                  sourceFile,
                  info.languageServiceHost,
                  formatOptions,
                  preferences,
                  applicableCodeFixes
                ),
                map8((modifiedCodeFixes) => effectCodeFixes.concat(modifiedCodeFixes))
              )
            ),
            runNano(program),
            getOrElse(() => applicableCodeFixes)
          );
        }
      }
      return applicableCodeFixes;
    };
    proxy.getApplicableRefactors = (...args2) => {
      const applicableRefactors = languageService.getApplicableRefactors(...args2);
      const [fileName, positionOrRange] = args2;
      const program = languageService.getProgram();
      if (program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            getApplicableRefactors(refactors, sourceFile, positionOrRange),
            runNano(program),
            map((effectRefactors) => applicableRefactors.concat(effectRefactors)),
            getOrElse(() => applicableRefactors)
          );
        }
      }
      return applicableRefactors;
    };
    proxy.getEditsForRefactor = (fileName, formatOptions, positionOrRange, refactorName, actionName, preferences, ...args2) => {
      const program = languageService.getProgram();
      if (program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          const result = pipe(
            gen(function* () {
              const applicableRefactor = yield* getEditsForRefactor(
                refactors,
                sourceFile,
                positionOrRange,
                refactorName
              );
              const formatContext = modules.typescript.formatting.getFormatContext(
                formatOptions,
                info.languageServiceHost
              );
              const edits = modules.typescript.textChanges.ChangeTracker.with(
                {
                  formatContext,
                  host: info.languageServiceHost,
                  preferences: preferences || {}
                },
                (changeTracker) => pipe(
                  applicableRefactor.apply,
                  provideService(ChangeTracker, changeTracker),
                  run
                )
              );
              return { edits };
            }),
            runNano(program)
          );
          if (isRight2(result)) return result.right;
        }
      }
      return languageService.getEditsForRefactor(
        fileName,
        formatOptions,
        positionOrRange,
        refactorName,
        actionName,
        preferences,
        ...args2
      );
    };
    proxy.getQuickInfoAtPosition = (fileName, position, ...args2) => {
      const applicableQuickInfo = languageService.getQuickInfoAtPosition(fileName, position, ...args2);
      if (languageServicePluginOptions.quickinfo) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              quickInfo(
                sourceFile,
                position,
                applicableQuickInfo
              ),
              runNano(program),
              getOrElse(() => applicableQuickInfo)
            );
          }
        }
      }
      return applicableQuickInfo;
    };
    proxy.getCompletionsAtPosition = (fileName, position, options, formattingSettings, ...args2) => {
      const applicableCompletions = languageService.getCompletionsAtPosition(
        fileName,
        position,
        options,
        formattingSettings,
        ...args2
      );
      if (languageServicePluginOptions.completions) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              appendEffectCompletionEntryData(sourceFile, applicableCompletions),
              flatMap4(
                (augmentedCompletions) => pipe(
                  getCompletionsAtPosition(
                    completions,
                    sourceFile,
                    position,
                    options,
                    formattingSettings
                  ),
                  map8(
                    (effectCompletions) => augmentedCompletions ? {
                      ...augmentedCompletions,
                      entries: effectCompletions.concat(augmentedCompletions.entries)
                    } : effectCompletions.length > 0 ? {
                      entries: effectCompletions,
                      isGlobalCompletion: false,
                      isMemberCompletion: false,
                      isNewIdentifierLocation: false
                    } : void 0
                  )
                )
              ),
              runNano(program),
              getOrElse(() => applicableCompletions)
            );
          }
        }
      }
      return applicableCompletions;
    };
    proxy.getCompletionEntryDetails = (fileName, position, entryName, formatOptions, source, preferences, _data, ...args2) => {
      const applicableCompletionEntryDetails = languageService.getCompletionEntryDetails(
        fileName,
        position,
        entryName,
        formatOptions,
        source,
        preferences,
        _data,
        ...args2
      );
      if (languageServicePluginOptions.completions) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              postprocessCompletionEntryDetails(
                sourceFile,
                _data,
                applicableCompletionEntryDetails,
                formatOptions,
                preferences,
                info.languageServiceHost
              ),
              runNano(program),
              getOrElse(() => applicableCompletionEntryDetails)
            );
          }
        }
      }
      return applicableCompletionEntryDetails;
    };
    proxy.getDefinitionAndBoundSpan = (fileName, position, ...args2) => {
      const applicableDefinition = languageService.getDefinitionAndBoundSpan(fileName, position, ...args2);
      if (languageServicePluginOptions.goto) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              goto(applicableDefinition, sourceFile, position),
              runNano(program),
              getOrElse(() => applicableDefinition)
            );
          }
        }
      }
      return applicableDefinition;
    };
    proxy.provideInlayHints = (fileName, span, preferences, ...args2) => {
      const applicableInlayHints = languageService.provideInlayHints(fileName, span, preferences, ...args2);
      if (languageServicePluginOptions.inlays) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              middlewareGenLike(sourceFile, span, preferences, applicableInlayHints),
              runNano(program),
              getOrElse(() => applicableInlayHints)
            );
          }
        }
      }
      return applicableInlayHints;
    };
    proxy.findRenameLocations = (fileName, position, findInStrings, findInComments, userPreferences, ...args2) => {
      const applicableRenameInfo = languageService.findRenameLocations(
        fileName,
        position,
        findInStrings,
        findInComments,
        userPreferences,
        ...args2
      );
      if (languageServicePluginOptions.renames) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              renameKeyStrings(
                sourceFile,
                position,
                findInStrings,
                findInComments,
                userPreferences,
                applicableRenameInfo
              ),
              runNano(program),
              getOrElse(() => applicableRenameInfo)
            );
          }
        }
      }
      return applicableRenameInfo;
    };
    const additionalProtocolHandlers = {
      "_effectGetLayerMermaid": (arg) => {
        const { character, line, path } = arg.arguments;
        const normalizedPath = modules.typescript.server.toNormalizedPath(path);
        const projectService = info.project.projectService;
        const scriptInfo = projectService.getScriptInfoForNormalizedPath(normalizedPath);
        if (scriptInfo) {
          const targetProject = scriptInfo.getDefaultProject();
          if (targetProject) {
            const program = targetProject.getLanguageService().getProgram();
            if (program) {
              const sourceFile = targetProject.getSourceFile(scriptInfo.path);
              if (sourceFile) {
                return pipe(
                  effectApiGetLayerGraph(sourceFile, line, character),
                  map8((response) => ({
                    response: {
                      success: true,
                      ...response
                    }
                  })),
                  runNano(program),
                  getOrElse((e) => ({
                    response: {
                      success: false,
                      error: e.message
                    }
                  }))
                );
              }
            }
          }
        }
        return {
          response: {
            success: false,
            error: "No source file found"
          }
        };
      }
    };
    if (info.session) {
      for (const [key, value] of Object.entries(additionalProtocolHandlers)) {
        try {
          info.session.addProtocolHandler(key, value);
        } catch (e) {
          info.project.log("[@effect/language-service] Skipped adding " + key + " protocol handler due to error: " + e);
        }
      }
    }
    return proxy;
  }
  return { create, onConfigurationChanged };
};
module.exports = init;
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=index.js.map