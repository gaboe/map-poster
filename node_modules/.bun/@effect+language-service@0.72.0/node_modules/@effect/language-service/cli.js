#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options3) {
      options3 = options3 || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse6(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options3.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match18 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match18) {
        return;
      }
      var n = parseFloat(match18[1]);
      var type2 = (match18[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup2(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable4;
      createDebug.enable = enable4;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args3) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args3[0] = createDebug.coerce(args3[0]);
          if (typeof args3[0] !== "string") {
            args3.unshift("%O");
          }
          let index = 0;
          args3[0] = args3[0].replace(/%([a-zA-Z%])/g, (match18, format6) => {
            if (match18 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format6];
            if (typeof formatter === "function") {
              const val = args3[index];
              match18 = formatter.call(self, val);
              args3.splice(index, 1);
              index--;
            }
            return match18;
          });
          createDebug.formatArgs.call(self, args3);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args3);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend4;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend4(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable4(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split2 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split2) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable4() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled2(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup2;
  }
});

// ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args3) {
      args3[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args3[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args3.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args3[0].replace(/%[a-zA-Z%]/g, (match18) => {
        if (match18 === "%%") {
          return;
        }
        index++;
        if (match18 === "%c") {
          lastC = index;
        }
      });
      args3.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error4) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error4) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error4) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error4) {
        return "[UnexpectedJSONParseError]: " + error4.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min4 = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min4;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min4;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min4;
    }
    function getSupportLevel(stream3) {
      const level = supportsColor(stream3, stream3 && stream3.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error4) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args3) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args3[0] = prefix + args3[0].split("\n").join("\n" + prefix);
        args3.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args3[0] = getDate() + name + " " + args3[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log4(...args3) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args3) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys6 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys6.length; i++) {
        debug2.inspectOpts[keys6[i]] = exports2.inspectOpts[keys6[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/compilerOptions.js
var require_compilerOptions = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/compilerOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CORE_COMPILER_OPTIONS = void 0;
    exports2.CORE_COMPILER_OPTIONS = {
      // Required to avoid parse from causing emit to occur
      noEmit: true,
      // Flags required to make no-unused-vars work
      noUnusedLocals: true,
      noUnusedParameters: true
    };
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/getParsedConfigFile.js
var require_getParsedConfigFile = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/getParsedConfigFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedConfigFile = getParsedConfigFile;
    var fs = __importStar(require("fs"));
    var path2 = __importStar(require("path"));
    var compilerOptions_1 = require_compilerOptions();
    function getParsedConfigFile(tsserver, configFile, projectDirectory) {
      if (tsserver.sys === void 0) {
        throw new Error("`getParsedConfigFile` is only supported in a Node-like environment.");
      }
      const parsed = tsserver.getParsedCommandLineOfConfigFile(configFile, compilerOptions_1.CORE_COMPILER_OPTIONS, {
        fileExists: fs.existsSync,
        getCurrentDirectory,
        onUnRecoverableConfigFileDiagnostic: (diag) => {
          throw new Error(formatDiagnostics([diag]));
        },
        readDirectory: tsserver.sys.readDirectory,
        readFile: (file5) => fs.readFileSync(path2.isAbsolute(file5) ? file5 : path2.join(getCurrentDirectory(), file5), "utf-8"),
        useCaseSensitiveFileNames: tsserver.sys.useCaseSensitiveFileNames
      });
      if (parsed?.errors.length) {
        throw new Error([
          "Unable to parse the specified 'tsconfig' file. Ensure it's correct and has valid syntax.",
          formatDiagnostics(parsed.errors)
        ].join("\n\n"));
      }
      return parsed;
      function getCurrentDirectory() {
        return projectDirectory ? path2.resolve(projectDirectory) : process.cwd();
      }
      function formatDiagnostics(diagnostics3) {
        return tsserver.formatDiagnostics(diagnostics3, {
          getCanonicalFileName: (f) => f,
          getCurrentDirectory,
          getNewLine: () => "\n"
        });
      }
    }
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+tsconfig-utils@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/tsconfig-utils/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p3 in m) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3)) __createBinding(exports3, m, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_compilerOptions(), exports2);
    __exportStar(require_getParsedConfigFile(), exports2);
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/getParsedConfigFileFromTSServer.js
var require_getParsedConfigFileFromTSServer = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/getParsedConfigFileFromTSServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedConfigFileFromTSServer = getParsedConfigFileFromTSServer;
    var tsconfig_utils_1 = require_dist();
    function getParsedConfigFileFromTSServer(tsserver, defaultProject, throwOnFailure, tsconfigRootDir) {
      try {
        return (0, tsconfig_utils_1.getParsedConfigFile)(tsserver, defaultProject, tsconfigRootDir);
      } catch (error4) {
        if (throwOnFailure) {
          throw new Error(`Could not read Project Service default project '${defaultProject}': ${error4.message}`);
        }
      }
      return void 0;
    }
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/createProjectService.js
var require_createProjectService = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/createProjectService.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProjectService = createProjectService6;
    var debug_1 = __importDefault(require_src());
    var getParsedConfigFileFromTSServer_js_1 = require_getParsedConfigFileFromTSServer();
    var DEFAULT_PROJECT_MATCHED_FILES_THRESHOLD = 8;
    var log4 = (0, debug_1.default)("typescript-eslint:project-service:createProjectService");
    var logTsserverErr = (0, debug_1.default)("typescript-eslint:project-service:tsserver:err");
    var logTsserverInfo = (0, debug_1.default)("typescript-eslint:project-service:tsserver:info");
    var logTsserverPerf = (0, debug_1.default)("typescript-eslint:project-service:tsserver:perf");
    var logTsserverEvent = (0, debug_1.default)("typescript-eslint:project-service:tsserver:event");
    var doNothing = () => {
    };
    var createStubFileWatcher = () => ({
      close: doNothing
    });
    function createProjectService6({ jsDocParsingMode, options: optionsRaw = {}, tsconfigRootDir } = {}) {
      const options3 = {
        defaultProject: "tsconfig.json",
        ...optionsRaw
      };
      const tsserver = require("typescript/lib/tsserverlibrary");
      const system = {
        ...tsserver.sys,
        clearImmediate,
        clearTimeout,
        setImmediate,
        setTimeout,
        watchDirectory: createStubFileWatcher,
        watchFile: createStubFileWatcher,
        // We stop loading any TypeScript plugins by default, to prevent them from attaching disk watchers
        // See https://github.com/typescript-eslint/typescript-eslint/issues/9905
        ...!options3.loadTypeScriptPlugins && {
          require: () => ({
            error: {
              message: "TypeScript plugins are not required when using parserOptions.projectService."
            },
            module: void 0
          })
        }
      };
      const logger = {
        close: doNothing,
        endGroup: doNothing,
        getLogFileName: () => void 0,
        // The debug library doesn't use levels without creating a namespace for each.
        // Log levels are not passed to the writer so we wouldn't be able to forward
        // to a respective namespace.  Supporting would require an additional flag for
        // granular control.  Defaulting to all levels for now.
        hasLevel: () => true,
        info(s) {
          this.msg(s, tsserver.server.Msg.Info);
        },
        loggingEnabled: () => (
          // if none of the debug namespaces are enabled, then don't enable logging in tsserver
          logTsserverInfo.enabled || logTsserverErr.enabled || logTsserverPerf.enabled
        ),
        msg: (s, type2) => {
          switch (type2) {
            case tsserver.server.Msg.Err:
              logTsserverErr(s);
              break;
            case tsserver.server.Msg.Perf:
              logTsserverPerf(s);
              break;
            default:
              logTsserverInfo(s);
          }
        },
        perftrc(s) {
          this.msg(s, tsserver.server.Msg.Perf);
        },
        startGroup: doNothing
      };
      log4("Creating Project Service with: %o", options3);
      const service3 = new tsserver.server.ProjectService({
        cancellationToken: { isCancellationRequested: () => false },
        eventHandler: logTsserverEvent.enabled ? (e) => {
          logTsserverEvent(e);
        } : void 0,
        host: system,
        jsDocParsingMode,
        logger,
        session: void 0,
        useInferredProjectPerProjectRoot: false,
        useSingleInferredProject: false
      });
      service3.setHostConfiguration({
        preferences: {
          includePackageJsonAutoImports: "off"
        }
      });
      log4("Enabling default project: %s", options3.defaultProject);
      const configFile = (0, getParsedConfigFileFromTSServer_js_1.getParsedConfigFileFromTSServer)(tsserver, options3.defaultProject, !!optionsRaw.defaultProject, tsconfigRootDir);
      if (configFile) {
        service3.setCompilerOptionsForInferredProjects(
          // NOTE: The inferred projects API is not intended for source files when a tsconfig
          // exists. There is no API that generates an InferredProjectCompilerOptions suggesting
          // it is meant for hard coded options passed in. Hard asserting as a work around.
          // See https://github.com/microsoft/TypeScript/blob/27bcd4cb5a98bce46c9cdd749752703ead021a4b/src/server/protocol.ts#L1904
          configFile.options
        );
      }
      return {
        allowDefaultProject: options3.allowDefaultProject,
        lastReloadTimestamp: performance.now(),
        maximumDefaultProjectFileMatchCount: options3.maximumDefaultProjectFileMatchCount_THIS_WILL_SLOW_DOWN_LINTING ?? DEFAULT_PROJECT_MATCHED_FILES_THRESHOLD,
        service: service3
      };
    }
  }
});

// ../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/@typescript-eslint+project-service@8.52.0_typescript@5.9.3/node_modules/@typescript-eslint/project-service/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p3 in m) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3)) __createBinding(exports3, m, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createProjectService(), exports2);
  }
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args3 = arguments;
        return function(self) {
          return body(self, ...args3);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value5) => () => value5;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date5) => date5.getTime());
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/doNotation.js
var bindTo = (map35) => dual(2, (self, name) => map35(self, (a) => ({
  [name]: a
})));
var bind = (map35, flatMap19) => dual(3, (self, name, f) => flatMap19(self, (a) => map35(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id2, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id2)) {
    globalStore.set(id2, compute());
  }
  return globalStore.get(id2);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag4) => hasProperty(self, "_tag") && self["_tag"] === tag4);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value5) {
    this.value = value5;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max6) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max6;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value5) {
    this.#value = value5;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        if (Number.isNaN(self.getTime())) {
          return string("Invalid Date");
        }
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys6) => {
  let h = 12289;
  for (let i = 0; i < keys6.length; i++) {
    h ^= pipe(string(keys6[i]), combine(hash(o[keys6[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        const t1 = self.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var CIRCULAR = "[Circular]";
function formatDate(date5) {
  try {
    return date5.toISOString();
  } catch {
    return "Invalid Date";
  }
}
function safeToString(input) {
  try {
    const s = input.toString();
    return typeof s === "string" ? s : String(s);
  } catch {
    return "[toString threw]";
  }
}
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
function formatUnknown(input, options3) {
  const space4 = options3?.space ?? 0;
  const seen = /* @__PURE__ */ new WeakSet();
  const gap = !space4 ? "" : isNumber(space4) ? " ".repeat(space4) : space4;
  const ind = (d) => gap.repeat(d);
  const wrap = (v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  };
  const ownKeys = (o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  };
  function go2(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1) return `[${v.map((x) => go2(x, d)).join(",")}]`;
      const inner = v.map((x) => go2(x, d + 1)).join(",\n" + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v)) return formatDate(v);
    if (!options3?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
      const s = safeToString(v);
      if (v instanceof Error && v.cause) {
        return `${s} (cause: ${go2(v.cause, d)})`;
      }
      return s;
    }
    if (isString(v)) return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v)) return String(v);
    if (isBigInt(v)) return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go2(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      const keys6 = ownKeys(v);
      if (!gap || keys6.length <= 1) {
        const body2 = `{${keys6.map((k) => `${formatPropertyKey(k)}:${go2(v[k], d)}`).join(",")}}`;
        return wrap(v, body2);
      }
      const body = `{
${keys6.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go2(v[k], d + 1)}`).join(",\n")}
${ind(d)}}`;
      return wrap(v, body);
    }
    return String(v);
  }
  return go2(input, 0);
}
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value5) => typeof value5 === "object" && value5 !== null ? cache.includes(value5) ? void 0 : cache.push(value5) && (redactableState.fiberRefs !== void 0 && isRedactable(value5) ? value5[symbolRedactable](redactableState.fiberRefs) : value5) : value5, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context7, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context7;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args3) => {
  switch (args3.length) {
    case 0:
      return self;
    case 1:
      return args3[0](self);
    case 2:
      return args3[1](args3[0](self));
    case 3:
      return args3[2](args3[1](args3[0](self)));
    case 4:
      return args3[3](args3[2](args3[1](args3[0](self))));
    case 5:
      return args3[4](args3[3](args3[2](args3[1](args3[0](self)))));
    case 6:
      return args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))));
    case 7:
      return args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))));
    case 8:
      return args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))))));
    case 9:
      return args3[8](args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args3.length; i < len; i++) {
        ret = args3[i](ret);
      }
      return ret;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.19.14";
var getCurrentVersion = () => moduleVersion;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ (function() {
  function Base3() {
  }
  Base3.prototype = CommitPrototype;
  return Base3;
})();

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value5) => {
  const a = Object.create(SomeProto);
  a.value = value5;
  return a;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var fromOption = /* @__PURE__ */ dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = (evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var mapBoth = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = /* @__PURE__ */ dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);
var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Order.js
var make2 = (compare2) => (self, that) => self === that ? 0 : compare2(self, that);
var string2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var number3 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var boolean = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var reverse = (O) => make2((self, that) => O(that, self));
var combine2 = /* @__PURE__ */ dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var getOrElse2 = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse2(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Iterable.js
var findFirst = /* @__PURE__ */ dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty = () => constEmpty;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Record.js
var map3 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var keys = (self) => Object.keys(self);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max6 = Math.max(1, Math.floor(n));
  const out = new Array(max6);
  for (let i = 0; i < max6; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var match3 = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self, head5) => [head5, ...self]);
var append = /* @__PURE__ */ dual(2, (self, last5) => [...self, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as9) => i < 0 || i >= as9.length;
var clamp = (i, as9) => Math.floor(Math.min(Math.max(0, i), as9.length));
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tailNonEmpty = (self) => self.slice(1);
var initNonEmpty = (self) => self.slice(0, -1);
var take = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, clamp(n, input));
});
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
var findFirstIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self, f) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var reverse2 = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => {
  const as9 = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as9) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as9), headNonEmpty(bs))];
    const len = Math.min(as9.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as9[i], bs[i]);
    }
    return out;
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var chop = /* @__PURE__ */ dual(2, (self, f) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next = rest;
    while (isNonEmptyArray(next)) {
      const [b2, rest2] = f(next);
      out.push(b2);
      next = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var copy = (self) => self.slice();
var chunksOf = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe2 = dedupeWith(isEquivalent);
      return dedupe2(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has8 = containsWith2(isEquivalent);
  return dual(2, (self, that) => {
    const bs = fromIterable(that);
    return fromIterable(self).filter((a) => has8(bs, a));
  });
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var empty2 = () => [];
var of = (a) => [a];
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  const as9 = fromIterable(self);
  const out = [];
  for (let i = 0; i < as9.length; i++) {
    const o = f(as9[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var filter2 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as9 = fromIterable(self);
  const out = [];
  for (let i = 0; i < as9.length; i++) {
    if (predicate(as9[i], i)) {
      out.push(as9[i]);
    }
  }
  return out;
});
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var some3 = /* @__PURE__ */ dual(2, (self, predicate) => self.some(predicate));
var unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make5(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag4 = Object.create(TagProto);
  Object.defineProperty(tag4, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag4.key = key;
  return tag4;
};
var Tag = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id2, options3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id2;
  ReferenceClass.defaultValue = options3.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId3]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context7 = Object.create(ContextProto);
  context7.unsafeMap = unsafeMap;
  return context7;
};
var serviceNotFoundError = (tag4) => {
  const error4 = new Error(`Service not found${tag4.key ? `: ${String(tag4.key)}` : ""}`);
  if (tag4.stack) {
    const lines3 = tag4.stack.split("\n");
    if (lines3.length > 2) {
      const afterAt = lines3[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines3 = error4.stack.split("\n");
    lines3.splice(1, 3);
    error4.stack = lines3.join("\n");
  }
  return error4;
};
var isContext = (u) => hasProperty(u, TypeId3);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty3 = () => _empty;
var make5 = (tag4, service3) => makeContext(/* @__PURE__ */ new Map([[tag4.key, service3]]));
var add = /* @__PURE__ */ dual(3, (self, tag4, service3) => {
  const map35 = new Map(self.unsafeMap);
  map35.set(tag4.key, service3);
  return makeContext(map35);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag4) => {
  if (defaultValueCache.has(tag4.key)) {
    return defaultValueCache.get(tag4.key);
  }
  const value5 = tag4.defaultValue();
  defaultValueCache.set(tag4.key, value5);
  return value5;
};
var unsafeGetReference = (self, tag4) => {
  return self.unsafeMap.has(tag4.key) ? self.unsafeMap.get(tag4.key) : getDefaultValue(tag4);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    if (ReferenceTypeId in tag4) return getDefaultValue(tag4);
    throw serviceNotFoundError(tag4);
  }
  return self.unsafeMap.get(tag4.key);
});
var get2 = unsafeGet2;
var getOption = /* @__PURE__ */ dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    return isReference(tag4) ? some(getDefaultValue(tag4)) : none;
  }
  return some(self.unsafeMap.get(tag4.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self, that) => {
  const map35 = new Map(self.unsafeMap);
  for (const [tag4, s] of that.unsafeMap) {
    map35.set(tag4, s);
  }
  return makeContext(map35);
});
var mergeAll = (...ctxs) => {
  const map35 = /* @__PURE__ */ new Map();
  for (let i = 0; i < ctxs.length; i++) {
    ctxs[i].unsafeMap.forEach((value5, key) => {
      map35.set(key, value5);
    });
  }
  return makeContext(map35);
};
var omit = (...tags2) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag4 of tags2) {
    newEnv.delete(tag4.key);
  }
  return makeContext(newEnv);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty4 = empty3;
var make6 = make5;
var add2 = add;
var get3 = get2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Chunk.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value5, i) => isEquivalent(value5, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
  }
  return chunk4;
};
var isChunk = (u) => hasProperty(u, TypeId4);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make7 = (...as9) => unsafeFromNonEmptyArray(as9);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array7, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array7, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array7, initial);
      copyToArray(self.right, array7, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array7[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array7[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse2(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse3(self.backing.right),
        right: reverse3(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse2(toReadonlyArray(self)));
  }
};
var reverse3 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty5() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
var take2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take2(self.right, n - self.left.length)
          });
        }
        return take2(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff8 = that.depth - self.depth;
  if (Math.abs(diff8) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff8 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filter3 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter2(self, predicate)));
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead;
var map5 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map4((a, i) => f(a, i)))));
var tailNonEmpty2 = (self) => drop2(self, 1);
var takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
var reduce2 = reduce;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/stack.js
var make8 = (value5, previous) => ({
  value: value5,
  previous
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate4, at, v, arr) {
  let out = arr;
  if (!mutate4) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate4, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate4) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate4) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate4, at, v, arr) {
  const len = arr.length;
  if (mutate4) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size13) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size13.value;
    return new LeafNode(edit, hash2, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value5) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value5;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size13.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size13.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children2) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list4 = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size13);
      if (list4 === this.children) return this;
      return list4.length > 1 ? new _CollisionNode(edit, this.hash, list4) : list4[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size13.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate4, edit, hash2, list4, f, key, size13) {
    const len = list4.length;
    for (let i = 0; i < len; ++i) {
      const child = list4[i];
      if ("key" in child && equals(key, child.key)) {
        const value5 = child.value;
        const newValue2 = f(value5);
        if (newValue2 === value5) return list4;
        if (isNone2(newValue2)) {
          --size13.value;
          return arraySpliceOut(mutate4, i, list4);
        }
        return arrayUpdate(mutate4, i, new LeafNode(edit, hash2, key, newValue2), list4);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list4;
    ++size13.value;
    return arrayUpdate(mutate4, len, new LeafNode(edit, hash2, key, newValue), list4);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children2) {
    this.edit = edit;
    this.mask = mask;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    const mask = this.mask;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists3 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists3) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash2, key, size13);
      if (!_newChild) return this;
      return children2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children2) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children2));
    }
    const current = children2[indx];
    const child = current.modify(edit, shift2 + SIZE, f, hash2, key, size13);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children2.length <= 2 && isLeafNode(children2[indx ^ 1])) {
        return children2[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children2);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children2);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size13, children2) {
    this.edit = edit;
    this.size = size13;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    let count4 = this.size;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const child = children2[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash2, key, size13);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count4;
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count4;
      if (count4 <= MIN_ARRAY_NODE) {
        return pack(edit, count4, frag, children2);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children2);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    }
    if (canEdit) {
      this.size = count4;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count4, newChildren);
  }
};
function pack(edit, count4, removed, elements) {
  const children2 = new Array(count4 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children2[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children2);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count4 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count4++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count4 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h12, n1, h22, n2) {
  if (h12 === h22) return new CollisionNode(edit, h12, [n2, n1]);
  const subH1 = hashFragment(shift2, h12);
  const subH2 = hashFragment(shift2, h22);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children2);
  }
}
function mergeLeaves(edit, shift2, h12, n1, h22, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h12, n1, h22, n2);
    if (typeof res === "function") {
      stack = make8(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size13) => {
  const map35 = Object.create(HashMapProto);
  map35._editable = editable;
  map35._edit = edit;
  map35._root = root;
  map35._size = size13;
  return map35;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map35, f) {
    this.map = map35;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children2 = node.children;
      return visitLazyChildren(children2.length, children2, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children2, i, f, cont) => {
  while (i < len) {
    const child = children2[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children2, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty6 = () => _empty3;
var make9 = (...entries3) => fromIterable3(entries3);
var fromIterable3 = (entries3) => {
  const map35 = beginMutation(empty6());
  for (const entry of entries3) {
    set(map35, entry[0], entry[1]);
  }
  return endMutation(map35);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children2 = node.children;
          for (let i = 0, len = children2.length; i < len; ++i) {
            const child = children2[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash2)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self, key, value5) => modifyAt(self, key, () => some2(value5)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
  const size13 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size13);
  return pipe(self, setTree(newRoot, size13.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
var map6 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty6(), (map35, value5, key) => set(map35, key, f(value5, key))));
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, void 0, (_, value5, key) => f(value5, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children2;
  while (children2 = toVisit.pop()) {
    for (let i = 0, len = children2.length; i < len; ) {
      const child = children2[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set7 = Object.create(HashSetProto);
  set7._keyMap = keyMap;
  return set7;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
var empty7 = () => _empty4;
var fromIterable4 = (elements) => {
  const set7 = beginMutation2(empty7());
  for (const value5 of elements) {
    add3(set7, value5);
  }
  return endMutation2(set7);
};
var make10 = (...elements) => {
  const set7 = beginMutation2(empty7());
  for (const value5 of elements) {
    add3(set7, value5);
  }
  return endMutation2(set7);
};
var has2 = /* @__PURE__ */ dual(2, (self, value5) => has(self._keyMap, value5));
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self, value5) => self._keyMap._editable ? (set(value5, true)(self._keyMap), self) : makeImpl2(set(value5, true)(self._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self, value5) => self._keyMap._editable ? (remove2(value5)(self._keyMap), self) : makeImpl2(remove2(value5)(self._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self, that) => mutate(self, (set7) => {
  for (const value5 of that) {
    remove3(set7, value5);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate(empty7(), (set7) => {
  forEach2(self, (value5) => add3(set7, value5));
  for (const value5 of that) {
    add3(set7, value5);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self, zero2, f) => reduce3(self._keyMap, zero2, (z, _, a) => f(z, a)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/HashSet.js
var empty8 = empty7;
var fromIterable5 = fromIterable4;
var make11 = make10;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var reduce5 = reduce4;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty9 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error4) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error4;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId2) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId2;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isEmpty3 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self, true, (acc, cause2) => {
    switch (cause2._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isDie = (self) => isSome2(dieOption(self));
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse3(reduce6(self, empty5(), (list4, cause2) => cause2._tag === OP_FAIL ? some2(pipe(list4, prepend2(cause2.error))) : none2()));
var defects = (self) => reverse3(reduce6(self, empty5(), (list4, cause2) => cause2._tag === OP_DIE ? some2(pipe(list4, prepend2(cause2.defect))) : none2()));
var interruptors = (self) => reduce6(self, empty8(), (set7, cause2) => cause2._tag === OP_INTERRUPT ? some2(pipe(set7, add4(cause2.fiberId))) : none2());
var failureOption = (self) => find(self, (cause2) => cause2._tag === OP_FAIL ? some2(cause2.error) : none2());
var failureOrCause = (self) => {
  const option6 = failureOption(self);
  switch (option6._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option6.value);
    }
  }
};
var dieOption = (self) => find(self, (cause2) => cause2._tag === OP_DIE ? some2(cause2.defect) : none2());
var flipCauseOption = (self) => match4(self, {
  onEmpty: some2(empty9),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId2) => some2(interrupt(fiberId2)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause2) => cause2._tag === OP_INTERRUPT ? some2(cause2.fiberId) : none2());
var keepDefectsAndElectFailures = (self) => match4(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: () => empty9,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map9 = /* @__PURE__ */ dual(2, (self, f) => flatMap5(self, (e) => fail(f(e))));
var flatMap5 = /* @__PURE__ */ dual(2, (self, f) => match4(self, {
  onEmpty: empty9,
  onFail: (error4) => f(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId2) => interrupt(fiberId2),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty8(), empty5()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty8(), empty5()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause2) => {
  return flattenCauseLoop(of2(cause2), empty5());
};
var flattenCauseLoop = (causes, flattened2) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce([empty8(), empty5()], ([parallel6, sequential6], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return [pipe(parallel6, union3(par2)), pipe(sequential6, appendAll2(seq2))];
    }));
    const updated = size3(parallel5) > 0 ? pipe(flattened2, prepend2(parallel5)) : flattened2;
    if (isEmpty(sequential5)) {
      return reverse3(updated);
    }
    causes = sequential5;
    flattened2 = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option6 = pf(item);
    switch (option6._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option6;
      }
    }
  }
  return none2();
});
var evaluateCause = (self) => {
  let cause2 = self;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause2 !== void 0) {
    switch (cause2._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause2.left._tag) {
          case OP_EMPTY: {
            cause2 = cause2.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause2 = sequential(cause2.left.left, sequential(cause2.left.right, cause2.right));
            break;
          }
          case OP_PARALLEL: {
            cause2 = parallel(sequential(cause2.left.left, cause2.right), sequential(cause2.left.right, cause2.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause2.right);
            cause2 = cause2.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt2,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error4) => onFail(error4),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId2) => onInterrupt2(fiberId2),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self, zero2, pf) => {
  let accumulator = zero2;
  let cause2 = self;
  const causes = [];
  while (cause2 !== void 0) {
    const option6 = pf(accumulator, cause2);
    accumulator = isSome2(option6) ? option6.value : accumulator;
    switch (cause2._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      default: {
        cause2 = void 0;
        break;
      }
    }
    if (cause2 === void 0 && causes.length > 0) {
      cause2 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause2 = input.pop();
    switch (cause2._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context7)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context7, cause2.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context7, cause2.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context7, cause2.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._tag) {
      case "Left": {
        switch (either7.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.sequentialCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.parallelCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause2, options3) => {
  if (isInterruptedOnly(cause2)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause2).map(function(e) {
    if (options3?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause2, prefix) => {
  const lines3 = cause2.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines3[0]}`;
  for (let i = 1, len = lines3.length; i < len; i++) {
    stack += `
${prefix}${lines3[i]}`;
  }
  if (cause2.cause) {
    stack += ` {
${renderErrorCause(cause2.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines3 = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines3.length; i++) {
    if (lines3[i].includes(" at new BaseEffectError") || lines3[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines3[i].includes("Generator.next")) {
      break;
    }
    if (lines3[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines3[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match18 = false;
          for (const [, location] of locationMatchAll) {
            match18 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match18) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause2) => reduceWithContext(cause2, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error4) => {
    return [new PrettyError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Duration.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match18 = DURATION_REGEX.exec(input);
    if (match18) {
      const [_, valueStr, unit] = match18;
      const value5 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value5);
        case "second":
        case "seconds":
          return seconds(value5);
        case "minute":
        case "minutes":
          return minutes(value5);
        case "hour":
        case "hours":
          return hours(value5);
        case "day":
        case "days":
          return days(value5);
        case "week":
        case "weeks":
          return weeks(value5);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (input) => {
  const duration3 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration3.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration3.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration3.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration3.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration3.value = zeroValue;
  } else {
    duration3.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration3;
};
var isDuration = (u) => hasProperty(u, TypeId5);
var isFinite2 = (self) => self.value._tag !== "Infinity";
var isZero = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make12(0);
var infinity = /* @__PURE__ */ make12(Infinity);
var nanos = (nanos2) => make12(nanos2);
var micros = (micros2) => make12(micros2 * bigint1e3);
var millis = (millis2) => make12(millis2);
var seconds = (seconds2) => make12(seconds2 * 1e3);
var minutes = (minutes2) => make12(minutes2 * 6e4);
var hours = (hours2) => make12(hours2 * 36e5);
var days = (days2) => make12(days2 * 864e5);
var weeks = (weeks2) => make12(weeks2 * 6048e5);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = /* @__PURE__ */ dual(2, (self, options3) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options3.onNanos(_self.value.nanos);
    case "Infinity":
      return options3.onMillis(Infinity);
    case "Millis":
      return options3.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self, that, options3) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options3.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options3.onNanos(selfNanos, thatNanos);
  }
  return options3.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make12(self2 + that2),
  onNanos: (self2, that2) => make12(self2 + that2)
}));
var lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
var parts = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration3);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min4 = sec / bigint60;
  const hr = min4 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min4 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration3)) {
    return "0";
  }
  const fragments = parts(duration3);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value5) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value5;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self) => self.current;
var set2 = /* @__PURE__ */ dual(2, (self, value5) => {
  self.current = value5;
  return self;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id2, startTimeMillis) {
    this.id = id2;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var runtime = (id2, startTimeMillis) => {
  return new Runtime(id2, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var combine3 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine3(b)(a)));
};
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make11(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union3(ids(self.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id2, startTimeSeconds) => {
  return new Runtime(id2, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake = () => {
  const id2 = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id2 + 1));
  return new Runtime(id2, Date.now());
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var combine4 = combine3;
var combineAll2 = combineAll;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var unsafeMake2 = unsafeMake;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/HashMap.js
var empty10 = empty6;
var make16 = make9;
var fromIterable6 = fromIterable3;
var isEmpty4 = isEmpty2;
var get7 = get5;
var has4 = has;
var set3 = set;
var keys3 = keys2;
var size4 = size;
var modifyAt2 = modifyAt;
var map10 = map6;
var forEach3 = forEach;
var reduce7 = reduce3;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self) => fromIterable(self);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done8 = false;
    let self = this;
    return {
      next() {
        if (done8) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done8 = true;
          return this.return();
        }
        const value5 = self.head;
        self = self.tail;
        return {
          done: done8,
          value: value5
        };
      },
      return(value5) {
        if (!done8) {
          done8 = true;
        }
        return {
          done: true,
          value: value5
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head5, tail) => {
  const cons3 = Object.create(ConsProto);
  cons3.head = head5;
  cons3.tail = tail;
  return cons3;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId7);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var nil = () => _Nil;
var cons = (head5, tail) => makeCons(head5, tail);
var empty11 = nil;
var of3 = (value5) => makeCons(value5, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll(that, self));
var prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
var prependAll = /* @__PURE__ */ dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  let acc = zero2;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse4 = (self) => {
  let result = empty11();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ (function() {
  function Structural2(args3) {
    if (args3) {
      Object.assign(this, args3);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
})();
var struct = (as9) => Object.assign(Object.create(StructuralPrototype), as9);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty12 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first3, second) => {
  const o = Object.create(AndThenProto);
  o.first = first3;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = (key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update5) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update5;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch10 = empty12();
  for (const [tag4, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag4)) {
      const old = missingServices.get(tag4);
      missingServices.delete(tag4);
      if (!equals(old, newService)) {
        patch10 = combine5(makeUpdateService(tag4, () => newService))(patch10);
      }
    } else {
      missingServices.delete(tag4);
      patch10 = combine5(makeAddService(tag4, newService))(patch10);
    }
  }
  for (const [tag4] of missingServices.entries()) {
    patch10 = combine5(makeRemoveService(tag4))(patch10);
  }
  return patch10;
};
var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
var patch = /* @__PURE__ */ dual(2, (self, context7) => {
  if (self._tag === "Empty") {
    return context7;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context7.unsafeMap);
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head5.key, head5.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head5.second), head5.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head5.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head5.key, head5.update(updatedContext.get(head5.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map35 = /* @__PURE__ */ new Map();
  for (const [tag4] of context7.unsafeMap) {
    if (updatedContext.has(tag4)) {
      map35.set(tag4, updatedContext.get(tag4));
      updatedContext.delete(tag4);
    }
  }
  for (const [tag4, s] of updatedContext) {
    map35.set(tag4, s);
  }
  return makeContext(map35);
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance3(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty13 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first3, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first3;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = (value5) => {
  const o = Object.create(AddProto);
  o.value = value5;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = (value5) => {
  const o = Object.create(RemoveProto);
  o.value = value5;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch10] = reduce5([oldValue, empty13()], ([set7, patch11], value5) => {
    if (has3(value5)(set7)) {
      return [remove4(value5)(set7), patch11];
    }
    return [set7, combine6(makeAdd(value5))(patch11)];
  })(newValue);
  return reduce5(patch10, (patch11, value5) => combine6(makeRemove(value5))(patch11))(removed);
};
var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set7 = oldValue;
  let patches = of2(self);
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head5.first)(prepend2(head5.second)(tail));
        break;
      }
      case "Add": {
        set7 = add4(head5.value)(set7);
        patches = tail;
        break;
      }
      case "Remove": {
        set7 = remove4(head5.value)(set7);
        patches = tail;
      }
    }
  }
  return set7;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance4(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance4,
    _Patch: variance4
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty14 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first3, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first3;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = (values4) => {
  const o = Object.create(AppendProto);
  o.values = values4;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = (index, patch10) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch10;
  return o;
};
var diff3 = (options3) => {
  let i = 0;
  let patch10 = empty14();
  while (i < options3.oldValue.length && i < options3.newValue.length) {
    const oldElement = options3.oldValue[i];
    const newElement = options3.newValue[i];
    const valuePatch = options3.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options3.differ.empty)) {
      patch10 = combine7(patch10, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options3.oldValue.length) {
    patch10 = combine7(patch10, makeSlice(0, i));
  }
  if (i < options3.newValue.length) {
    patch10 = combine7(patch10, makeAppend(drop(i)(options3.newValue)));
  }
  return patch10;
};
var combine7 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head5 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head5.first, head5.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value5 of head5.values) {
          readonlyArray2.push(value5);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head5.from, head5.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray2[head5.index] = differ3.patch(head5.patch, readonlyArray2[head5.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray2;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make17 = (params) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params.empty;
  differ3.diff = params.diff;
  differ3.combine = params.combine;
  differ3.patch = params.patch;
  return differ3;
};
var environment = () => make17({
  empty: empty12(),
  combine: (first3, second) => combine5(second)(first3),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch10, oldValue) => patch(oldValue)(patch10)
});
var hashSet = () => make17({
  empty: empty13(),
  combine: (first3, second) => combine6(second)(first3),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch10, oldValue) => patch2(oldValue)(patch10)
});
var readonlyArray = (differ3) => make17({
  empty: empty14(),
  combine: (first3, second) => combine7(first3, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch10, oldValue) => patch3(patch10, oldValue, differ3)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make17({
  empty: identity,
  combine: (first3, second) => {
    if (first3 === identity) {
      return second;
    }
    if (second === identity) {
      return first3;
    }
    return (a) => second(first3(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch10, oldValue) => f(oldValue, patch10(oldValue))
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch10) => patch10 & BIT_MASK;
var enabled = (patch10) => patch10 >> BIT_SHIFT & BIT_MASK;
var make18 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty15 = /* @__PURE__ */ make18(0, 0);
var enable = (flag) => make18(flag, flag);
var disable = (flag) => make18(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self, flag) => make18(active(self) & ~flag, enabled(self)));
var andThen = /* @__PURE__ */ dual(2, (self, that) => self | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self) => isEnabled(self, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled(self, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
var make19 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make19(None2);
var runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics);
var windDown = (self) => isEnabled(self, WindDown);
var diff4 = /* @__PURE__ */ dual(2, (self, that) => make18(self ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self, patch10) => self & (invert(active(patch10)) | enabled(patch10)) | active(patch10) & enabled(patch10));
var differ = /* @__PURE__ */ make17({
  empty: empty15,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first3, second) => andThen(second)(first3),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/blockedRequests.js
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var flatten2 = (self) => {
  let current = of3(self);
  let updated = empty11();
  while (1) {
    const [parallel5, sequential5] = reduce8(current, [parallelCollectionEmpty(), empty11()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse4(updated);
    }
    current = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty11();
  let sequential5 = empty11();
  while (1) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map35) {
    this.map = map35;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty10());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce7(self.map, that.map, (map35, value5, key) => set3(map35, key, match2(get7(map35, key), {
  onNone: () => value5,
  onSome: (other) => appendAll2(value5, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty4(self.map);
var parallelCollectionKeys = (self) => Array.from(keys3(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map10(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map35) {
    this.map = map35;
  }
};
var sequentialCollectionMake = (map35) => new SequentialImpl(map35);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce7(that.map, self.map, (map35, value5, key) => set3(map35, key, match2(get7(map35, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value5)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys3(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect3) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect3
  };
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect3 = new EffectPrimitive("Blocked");
  effect3.effect_instruction_i0 = blockedRequests;
  effect3.effect_instruction_i1 = _continue3;
  return effect3;
};
var runRequestBlock = (blockedRequests) => {
  const effect3 = new EffectPrimitive("RunBlocked");
  effect3.effect_instruction_i0 = blockedRequests;
  return effect3;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch10, op) {
    this.patch = patch10;
    this.op = op;
  }
};
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect3 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect3.effect_instruction_i0 = withRuntime;
  return effect3;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit4) => {
  return suspend(() => release(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause2) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause2));
        case OP_SUCCESS:
          return failCause(cause2);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self, value5) => flatMap7(self, () => succeed(value5)));
var asVoid = (self) => as(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect3 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect3.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect3.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect3, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect4) {
      if (backingResume) {
        backingResume(effect4);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect4;
      }
    }
    const effect3 = new EffectPrimitive(OP_ASYNC);
    effect3.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect3.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect3, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect3;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
  const effect3 = new EffectPrimitive(OP_ON_FAILURE);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = f;
  return effect3;
});
var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause2) => {
  const either7 = failureOrCause(cause2);
  switch (either7._tag) {
    case "Left":
      return predicate(either7.left) ? f(either7.left) : failCause(cause2);
    case "Right":
      return failCause(either7.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause2) => {
  const either7 = failureOrCause(cause2);
  switch (either7._tag) {
    case "Left":
      return pipe(pf(either7.left), getOrElse2(() => failCause(cause2)));
    case "Right":
      return failCause(either7.right);
  }
}));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p3) {
        return p3 === spanSymbol || p3 === originalSymbol || p3 in target;
      },
      get(target, p3) {
        if (p3 === spanSymbol) {
          return span2.value;
        }
        if (p3 === originalSymbol) {
          return obj;
        }
        return target[p3];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate3) => flatMap7(sync(evaluate3), fail2);
var failCause = (cause2) => {
  const effect3 = new EffectPrimitiveFailure(OP_FAILURE);
  effect3.effect_instruction_i0 = cause2;
  return effect3;
};
var failCauseSync = (evaluate3) => flatMap7(sync(evaluate3), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => {
  const effect3 = new EffectPrimitive(OP_ON_SUCCESS);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = f;
  return effect3;
});
var step2 = (self) => {
  const effect3 = new EffectPrimitive("OnStep");
  effect3.effect_instruction_i0 = self;
  return effect3;
};
var flatten3 = (self) => flatMap7(self, identity);
var matchCause = /* @__PURE__ */ dual(2, (self, options3) => matchCauseEffect(self, {
  onFailure: (cause2) => succeed(options3.onFailure(cause2)),
  onSuccess: (a) => succeed(options3.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options3) => {
  const effect3 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = options3.onFailure;
  effect3.effect_instruction_i2 = options3.onSuccess;
  return effect3;
});
var matchEffect = /* @__PURE__ */ dual(2, (self, options3) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(electFailures(cause2));
    }
    const failures2 = failures(cause2);
    if (failures2.length > 0) {
      return options3.onFailure(unsafeHead(failures2));
    }
    return failCause(cause2);
  },
  onSuccess: options3.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = enable3(Interruption);
  effect3.effect_instruction_i1 = () => self;
  return effect3;
};
var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map11 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self, options3) => matchEffect(self, {
  onFailure: (e) => failSync(() => options3.onFailure(e)),
  onSuccess: (a) => sync(() => options3.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const either7 = failureOrCause(cause2);
    switch (either7._tag) {
      case "Left": {
        return failSync(() => f(either7.left));
      }
      case "Right": {
        return failCause(either7.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_ : cleanup(exit4.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause2) => isInterruptedOnly(cause2) ? asVoid(cleanup(interruptors(cause2))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var succeed = (value5) => {
  const effect3 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect3.effect_instruction_i0 = value5;
  return effect3;
};
var suspend = (evaluate3) => {
  const effect3 = new EffectPrimitive(OP_COMMIT);
  effect3.commit = evaluate3;
  return effect3;
};
var sync = (thunk) => {
  const effect3 = new EffectPrimitive(OP_SYNC);
  effect3.effect_instruction_i0 = thunk;
  return effect3;
};
var tap = /* @__PURE__ */ dual((args3) => args3.length === 3 || args3.length === 2 && !(isObject(args3[1]) && "onlyEffect" in args3[1]), (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope4 = pipe(scopeOverride, getOrElse2(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope4)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause2)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = disable3(Interruption);
  effect3.effect_instruction_i1 = () => self;
  return effect3;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = disable3(Interruption);
  effect3.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect3;
});
var void_ = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = (patch10) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = patch10;
  effect3.effect_instruction_i1 = void 0;
  return effect3;
};
var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => {
  if (b) {
    return pipe(self, map11(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options3) => {
  const effect3 = new EffectPrimitive(OP_WHILE);
  effect3.effect_instruction_i0 = options3.while;
  effect3.effect_instruction_i1 = options3.body;
  effect3.effect_instruction_i2 = options3.step;
  return effect3;
};
var fromIterator = (iterator) => suspend(() => {
  const effect3 = new EffectPrimitive(OP_ITERATOR);
  effect3.effect_instruction_i0 = iterator();
  return effect3;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args3) {
  return fromIterator(() => body.apply(this, args3));
} : function(...args3) {
  let effect3 = fromIterator(() => body.apply(this, args3));
  for (const x of pipeables) {
    effect3 = x(effect3, ...args3);
  }
  return effect3;
}, "length", {
  value: body.length,
  configurable: true
});
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update5) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = update5;
  effect3.effect_instruction_i1 = () => self;
  return effect3;
});
var yieldNow = (options3) => {
  const effect3 = new EffectPrimitive(OP_YIELD);
  return typeof options3?.priority !== "undefined" ? withSchedulingPriority(effect3, options3.priority) : effect3;
};
var zip2 = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => map11(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap7(self, (a) => map11(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap7(fiberId, (fiberId2) => pipe(self, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId2) => flatMap7(self.interruptAsFork(fiberId2), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap7(fiberRefGet(self), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self, value5) => fiberRefModify(self, () => [void 0, value5]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var RequestResolverImpl = class _RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value5) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value5)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
var fiberRefUnsafeMake = (initial, options3) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options3?.fork ?? identity,
  join: options3?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options3) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options3.differ.diff(oldValue, newValue),
    combine: (first3, second) => options3.differ.combine(first3, second),
    patch: (patch10) => (oldValue) => options3.differ.patch(patch10, oldValue),
    fork: options3.fork,
    join: options3.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty9, {
  fork: () => empty9,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty10()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer2) => self.addFinalizer(() => asVoid(finalizer2));
var scopeAddFinalizerExit = (self, finalizer2) => self.addFinalizer(finalizer2);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
  const option6 = pipe(self, failureOption, map2(f));
  switch (option6._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id2) => `#${id2}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option6.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ (function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
})();
var makeException = (proto25, tag4) => {
  class Base3 extends YieldableError {
    _tag = tag4;
  }
  Object.assign(Base3.prototype, proto25);
  Base3.prototype.name = tag4;
  return Base3;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration3) => new TimeoutException(`Operation timed out after '${format2(duration3)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ (function() {
  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause2, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause2
      });
      this.error = cause2;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
})();
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self, value5) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value5);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCollectAll = (exits, options3) => exitCollectAllInternal(exits, options3?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause2) => {
  const effect3 = new EffectPrimitiveFailure(OP_FAILURE);
  effect3.effect_instruction_i0 = cause2;
  return effect3;
};
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map9(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value5) => {
  const effect3 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect3.effect_instruction_i0 = value5;
  return effect3;
};
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list4 = fromIterable2(exits);
  if (!isNonEmpty(list4)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list4), reduce(pipe(headNonEmpty2(list4), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list5, value5) => pipe(list5, prepend2(value5)),
    onFailure: combineCauses
  }))), exitMap(reverse3), exitMap((chunk4) => toReadonlyArray(chunk4)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap7(fiberId, (id2) => deferredMakeAs(id2));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self, effect3) => intoDeferred(effect3, self));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect3) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect3));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect3);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = /* @__PURE__ */ dual(2, (self, error4) => deferredCompleteWith(self, fail2(error4)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause2) => deferredCompleteWith(self, failCause(cause2)));
var deferredInterrupt = (self) => flatMap7(fiberId, (fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE);
var deferredSucceed = /* @__PURE__ */ dual(2, (self, value5) => deferredCompleteWith(self, succeed(value5)));
var deferredUnsafeDone = (self, effect3) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect3));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect3);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap7(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocally(currentContext, context7)(self));
var provideSomeContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context7))(self));
var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context7) => provideContext(self, f(context7))));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== void 0 && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options3) => Object.assign(Object.create(NoopSpanProto), options3);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration3) {
    const millis2 = toMillis(duration3);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ (function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined" || typeof performance.now !== "function") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
})();
var processOrPerformanceNow = /* @__PURE__ */ (function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
})();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration3) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_), duration3);
      return asVoid(sync(canceler));
    });
  }
};
var make20 = () => new ClockImpl();

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Number.js
var Order = number3;
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};
var round = /* @__PURE__ */ dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/RegExp.js
var escape = (string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_AND;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var Or = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_OR;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var InvalidData = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_INVALID_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Invalid data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_MISSING_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Missing data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path2, message, cause2, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path2;
  error4.message = message;
  error4.cause = cause2;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Source unavailable at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_UNSUPPORTED;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Unsupported operation at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error4 = input.pop();
    switch (error4._op) {
      case OP_AND: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context7, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context7, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context7, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context7, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._op) {
      case "Left": {
        switch (either7.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.andCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.orCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, void 0, IsMissingDataOnlyReducer);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty16 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path2, patch10) => {
  let input = of3(patch10);
  let output = path2;
  while (isCons(input)) {
    const patch11 = input.head;
    switch (patch11._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch11.first, cons(patch11.second, input.tail));
        break;
      }
      case "MapName": {
        output = map4(output, patch11.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch11.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch11.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch11.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = (options3) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options3
});
var makeFlat = (options3) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options3.patch,
  load: (path2, config2, split2 = true) => options3.load(path2, config2, split2),
  enumerateChildren: options3.enumerateChildren
});
var fromFlat = (flat) => make21({
  load: (config2) => flatMap7(fromFlatLoop(flat, empty2(), config2, false), (chunk4) => match2(head(chunk4), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options3) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options3);
  const makePathString = (path2) => pipe(path2, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path2, primitive2, split2 = true) => {
    const pathString = makePathString(path2);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path2, `Expected ${pathString} to exist in the process context`)), flatMap7((value5) => parsePrimitive(value5, path2, primitive2, seqDelim, split2)));
  };
  const enumerateChildren = (path2) => sync(() => {
    const current = getEnv();
    const keys6 = Object.keys(current);
    const keyPaths = keys6.map((value5) => unmakePathString(value5.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path2.length; i++) {
        const pathComponent = pipe(path2, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path2.length, path2.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty16
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path2, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path2.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path2;
};
var fromFlatLoop = (flat, prefix, config2, split2) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split2));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split2)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split2), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split2));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split2), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split2));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split2), flatMap7((values4) => {
        if (values4.length === 0) {
          const name = pipe(last(prefix2), getOrElse2(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values4);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices2) => {
        if (indices2.length === 0) {
          return suspend(() => map11(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices2, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map11((chunkChunk) => {
          const flattened2 = flatten(chunkChunk);
          if (flattened2.length === 0) {
            return of(empty2());
          }
          return of(flattened2);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys6) => {
        return pipe(keys6, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split2)), map11((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map4((values4) => fromIterable6(zip(fromIterable(keys6), values4))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split2), either2, flatMap7((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split2), either2, flatMap7((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path2 = pipe(prefix, join("."));
          const fail19 = fromFlatLoopFail(prefix, path2);
          const [lefts, rights] = extend(fail19, fail19, pipe(left3.right, map4(right2)), pipe(right3.right, map4(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map11(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path2) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path2}" was missing`));
var splitPathString = (text10, delim) => {
  const split2 = text10.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split2;
};
var parsePrimitive = (text10, path2, primitive2, delimiter, split2) => {
  if (!split2) {
    return pipe(primitive2.parse(text10), mapBoth2({
      onFailure: prefixed(path2),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text10, delimiter), forEachSequential((char4) => primitive2.parse(char4.trim())), mapError(prefixed(path2)));
};
var transpose = (array7) => {
  return Object.keys(array7[0]).map((column3) => array7.map((row) => row[column3]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map11(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match18 = str.match(QUOTED_INDEX_REGEX);
  if (match18 !== null) {
    const matchedIndex = match18[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId8]: TypeId8,
  assert(condition, ...args3) {
    return sync(() => {
      console.assert(condition, ...args3);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args3) {
    return sync(() => {
      console.debug(...args3);
    });
  },
  dir(item, options3) {
    return sync(() => {
      console.dir(item, options3);
    });
  },
  dirxml(...args3) {
    return sync(() => {
      console.dirxml(...args3);
    });
  },
  error(...args3) {
    return sync(() => {
      console.error(...args3);
    });
  },
  group(options3) {
    return options3?.collapsed ? sync(() => console.groupCollapsed(options3?.label)) : sync(() => console.group(options3?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args3) {
    return sync(() => {
      console.info(...args3);
    });
  },
  log(...args3) {
    return sync(() => {
      console.log(...args3);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args3) {
    return sync(() => {
      console.timeLog(label, ...args3);
    });
  },
  trace(...args3) {
    return sync(() => {
      console.trace(...args3);
    });
  },
  warn(...args3) {
    return sync(() => {
      console.warn(...args3);
    });
  },
  unsafe: console
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map11(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min4, max6) {
    return map11(this.next, (n) => (max6 - min4) * n + min4);
  }
  nextIntBetween(min4, max6) {
    return sync(() => this.PRNG.integer(max6 - min4) + min4);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer3) => {
    const numbers = [];
    for (let i = buffer3.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map11((k) => swap(buffer3, n - 1, k)))), as(fromIterable2(buffer3)));
  })));
};
var swap = (buffer3, index1, index2) => {
  const tmp = buffer3[index1];
  buffer3[index1] = buffer3[index2];
  buffer3[index2] = tmp;
  return buffer3;
};
var make22 = (seed) => new RandomImpl(hash(seed));
var FixedRandomImpl = class {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values4) {
    this.values = values4;
    if (values4.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value5 = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value5;
  }
  get next() {
    return sync(() => {
      const value5 = this.getNextValue();
      if (typeof value5 === "number") {
        return Math.max(0, Math.min(1, value5));
      }
      return hash(value5) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value5 = this.getNextValue();
      if (typeof value5 === "boolean") {
        return value5;
      }
      return hash(value5) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value5 = this.getNextValue();
      if (typeof value5 === "number" && Number.isFinite(value5)) {
        return Math.round(value5);
      }
      return Math.abs(hash(value5));
    });
  }
  nextRange(min4, max6) {
    return map11(this.next, (n) => (max6 - min4) * n + min4);
  }
  nextIntBetween(min4, max6) {
    return sync(() => {
      const value5 = this.getNextValue();
      if (typeof value5 === "number" && Number.isFinite(value5)) {
        return Math.max(min4, Math.min(max6 - 1, Math.round(value5)));
      }
      const hash2 = Math.abs(hash(value5));
      return min4 + hash2 % (max6 - min4);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = (options3) => ({
  [TracerTypeId]: TracerTypeId,
  ...options3
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ (function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
})();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context7, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context7;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value5) {
    this.attributes.set(key, value5);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make23({
  span: (name, parent, context7, links, startTime, kind) => new NativeSpan(name, parent, context7, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options3) => {
  if (options3?.captureStackTrace === false) {
    return options3;
  } else if (options3?.captureStackTrace !== void 0 && typeof options3.captureStackTrace !== "boolean") {
    return options3;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options3,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration3) => {
  const decodedDuration = decode(duration3);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Boolean.js
var not = (self) => !self;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var Class2 = class extends Base2 {
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake3(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty17() {
  return unsafeMake3(/* @__PURE__ */ new Map());
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self, fiberId2, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch10 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch10)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
  const map35 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map35, childId);
  return new FiberRefsImpl(map35);
});
var unsafeForkAs = (self, map35, fiberId2) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map35.set(fiberRef, stack);
    } else {
      map35.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get8(self, fiberRef), getOrElse2(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self, {
  fiberId: fiberId2,
  fiberRef,
  value: value5
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId2, value5]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value5);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value5) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value5)) {
        return;
      } else {
        newStack = [[fiberId2, value5], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value5], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value5]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self, {
  entries: entries3,
  forkAs: forkAs2
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self, locals, forkAs2);
  }
  entries3.forEach(([fiberRef, values4]) => {
    if (values4.length === 1) {
      unsafeUpdateAs(locals, values4[0][0], fiberRef, values4[0][1]);
    } else {
      values4.forEach(([fiberId2, value5]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value5);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberRefs.js
var get9 = get8;
var getOrDefault2 = getOrDefault;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty18 = empty17;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty19 = {
  _tag: OP_EMPTY2
};
var diff5 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch10 = empty19;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch10 = combine8({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch10);
      }
    } else {
      patch10 = combine8({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch10);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch10 = combine8({
      _tag: OP_REMOVE,
      fiberRef
    })(patch10);
  }
  return patch10;
};
var combine8 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self, fiberId2, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head5 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head5._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId2,
          fiberRef: head5.fiberRef,
          value: head5.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head5.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value5 = getOrDefault(fiberRefs3, head5.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId2,
          fiberRef: head5.fiberRef,
          value: head5.fiberRef.patch(head5.patch)(value5)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head5.first)(prepend(head5.second)(tail));
        break;
      }
    }
  }
  return fiberRefs3;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done2 = /* @__PURE__ */ new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone = (self) => self._tag === OP_DONE;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberStatus.js
var done3 = done2;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = (literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Micro.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context7, interruptible5 = true) {
    this.context = context7;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect3) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect3);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap8(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect3) {
    let yielding = false;
    let current = effect3;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error4) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error4);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol3]: cont
      };
      if (op[symbol3]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value5) {
    this._yielded = value5;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll = (fibers) => suspend2(() => {
  for (const fiber of fibers) fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
});
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId9]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options3) => ({
  ...MicroProto,
  [identifier]: options3.op,
  [evaluate]: options3.eval ?? defaultEvaluate,
  [successCont]: options3.contA,
  [failureCont]: options3.contE,
  [ensureCont]: options3.ensure
});
var makePrimitive = (options3) => {
  const Proto4 = makePrimitiveProto(options3);
  return function() {
    const self = Object.create(Proto4);
    self[args] = options3.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options3) => {
  const Proto4 = {
    ...makePrimitiveProto(options3),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options3.op,
    get [options3.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options3.op,
        [options3.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options3.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options3.op))(hash(this[args])));
    }
  };
  return function(value5) {
    const self = Object.create(Proto4);
    self[args] = value5;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed2 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause2 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var sync2 = /* @__PURE__ */ makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value5 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value5, fiber) : fiber.yieldWith(exitSucceed2(value5));
  }
});
var suspend2 = /* @__PURE__ */ makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed2(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var asyncOptions = /* @__PURE__ */ makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect3) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect3);
      } else {
        yielded = effect3;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = /* @__PURE__ */ makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause2, _fiber) {
    return causeIsInterrupt(cause2) ? flatMap8(this[args](), () => failCause2(cause2)) : failCause2(cause2);
  }
});
var async = (register) => asyncOptions(register, register.length >= 2);
var as2 = /* @__PURE__ */ dual(2, (self, value5) => map12(self, (_) => value5));
var exit2 = (self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
});
var flatMap8 = /* @__PURE__ */ dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map12 = /* @__PURE__ */ dual(2, (self, f) => flatMap8(self, (a) => succeed2(f(a))));
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed2;
var exitFailCause2 = failCause2;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var exitVoidAll = (exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
};
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
};
var CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
})) {
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
})) {
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options3) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self;
  primitive2[successCont] = options3.onSuccess;
  primitive2[failureCont] = options3.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = /* @__PURE__ */ dual(2, (self, options3) => matchCauseEffect2(self, {
  onFailure: (cause2) => sync2(() => options3.onFailure(cause2)),
  onSuccess: (value5) => sync2(() => options3.onSuccess(value5))
}));
var MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class _MicroScopeImpl {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer2) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer2);
    }
  }
  addFinalizer(finalizer2) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer2);
        return void_2;
      }
      return finalizer2(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer2) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer2);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap8(forEach4(finalizers, (finalizer2) => exit2(finalizer2(microExit))), exitVoidAll);
      }
      return void_2;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause2) => flatMap8(f(exitFailCause2(cause2)), () => failCause2(cause2)),
  onSuccess: (a) => flatMap8(f(exitSucceed2(a)), () => succeed2(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var whileLoop2 = /* @__PURE__ */ makePrimitive({
  op: "While",
  contA(value5, fiber) {
    this[args].step(value5);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach4 = (iterable, f, options3) => withMicroFiber((parent) => {
  const concurrencyOption = options3?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options3?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable(iterable);
  let length3 = items.length;
  if (length3 === 0) {
    return options3?.discard ? void_2 : succeed2([]);
  }
  const out = options3?.discard ? void 0 : new Array(length3);
  let index = 0;
  if (concurrency === 1) {
    return as2(whileLoop2({
      while: () => index < items.length,
      body: () => f(items[index], index),
      step: out ? (b) => out[index++] = b : (_) => index++
    }), out);
  }
  return async((resume2) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted2 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length3) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit4) => {
            fibers.delete(child);
            if (interrupted2) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length3 = index;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length3) {
              resume2(result ?? succeed2(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length3 = index;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend2(() => {
      interrupted2 = true;
      index = length3;
      return fiberInterruptAll(fibers);
    });
  });
});
var unsafeFork = (parent, effect3, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect3);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect3), 0);
  }
  return child;
};
var runFork = (effect3, options3) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options3?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect3);
  if (options3?.signal) {
    if (options3.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options3.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options3.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Readable.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId10]: TypeId10,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var RefImpl = class extends Class2 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake4 = (value5) => new RefImpl(make13(value5));
var make24 = (value5) => sync(() => unsafeMake4(value5));
var get10 = (self) => self.get;
var set4 = /* @__PURE__ */ dual(2, (self, value5) => self.modify(() => [void 0, value5]));
var modify3 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Ref.js
var make25 = make24;
var get11 = get10;
var modify4 = modify3;
var set5 = set4;
var update3 = update2;
var updateAndGet2 = updateAndGet;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential5, unbounded6, bounded4) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded6();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded6() : concurrency2 > 1 ? bounded4(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded4(concurrency) : sequential5();
  }
};
var matchSimple = (concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var Clock = clockTag;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/logSpan.js
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Tracer.js
var ParentSpan = spanTag;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value5) {
    this.key = key;
    this.value = value5;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make26 = (key, value5) => {
  return new MetricLabelImpl(key, value5);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith(args3[0], currentLogAnnotations, typeof args3[1] === "string" ? set3(args3[1], args3[2]) : (annotations2) => Object.entries(args3[1]).reduce((acc, [key, value5]) => set3(acc, key, value5), annotations2));
});
var asSome = (self) => map11(self, some2);
var try_2 = (arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error4) {
      return fail2(onFailure ? internalCall(() => onFailure(error4)) : new UnknownException(error4, "An unknown error occurred in Effect.try"));
    }
  });
};
var catchTag = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, ...args3) => {
  const f = args3[args3.length - 1];
  let predicate;
  if (args3.length === 2) {
    predicate = isTagged(args3[0]);
  } else {
    predicate = (e) => {
      const tag4 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag4) return false;
      for (let i = 0; i < args3.length - 1; i++) {
        if (args3[i] === tag4) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
  let keys6;
  return catchIf(self, (e) => {
    keys6 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys6.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff5);
var bind2 = /* @__PURE__ */ bind(map11, flatMap7);
var bindTo2 = /* @__PURE__ */ bindTo(map11);
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse16) => flatMap7(self, (a) => predicate(a) ? succeed(a) : orElse16(a)));
var match8 = /* @__PURE__ */ dual(2, (self, options3) => matchEffect(self, {
  onFailure: (e) => succeed(options3.onFailure(e)),
  onSuccess: (a) => succeed(options3.onSuccess(a))
}));
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== void 0) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === void 0) {
    cause2 = empty9;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var negate = (self) => map11(self, (b) => !b);
var option = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate3) => orElse2(self, () => failSync(evaluate3)));
var patchFiberRefs = (patch10) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch10, patch6(fiberId2, fiberRefs3)));
var provideService = /* @__PURE__ */ dual(3, (self, tag4, service3) => contextWithEffect((env2) => provideContext(self, add2(env2, tag4, service3))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag4, effect3) => contextWithEffect((env2) => flatMap7(effect3, (service3) => provideContext(self, pipe(env2, add2(tag4, service3))))));
var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap7(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var summarized = /* @__PURE__ */ dual(3, (self, summary5, f) => flatMap7(summary5, (start4) => flatMap7(self, (value5) => map11(summary5, (end5) => [f(start4, end5), value5]))));
var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var tryPromise = (arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail19 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate3.length >= 1) {
    return async_((resolve3, signal) => {
      try {
        evaluate3(signal).then((a) => resolve3(succeed(a)), (e) => resolve3(fail19(e)));
      } catch (e) {
        resolve3(fail19(e));
      }
    });
  }
  return async_((resolve3) => {
    try {
      evaluate3().then((a) => resolve3(succeed(a)), (e) => resolve3(fail19(e)));
    } catch (e) {
      resolve3(fail19(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self, options3) => flatMap7(self, (a) => try_2({
  try: () => options3.try(a),
  catch: options3.catch
})));
var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => b ? succeedNone : asSome(self)));
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map11(self, some2) : succeed(none2())));
var serviceOption = (tag4) => map11(context(), getOption2(tag4));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name, options3) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options3.context && get3(options3.context, DisablePropagation);
  const context7 = fiber.getFiberRef(currentContext);
  const parent = options3.parent ? some2(options3.parent) : options3.root ? none2() : filterDisablePropagation(getOption2(context7, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name,
      parent,
      context: add2(options3.context ?? empty4(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get3(services, tracerTag);
    const clock3 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get9(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get9(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options3.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options3.links ?? []] : toReadonlyArray(linksFromEnv.value) : options3.links ?? empty2();
    span2 = tracer2.span(name, parent, options3.context ?? empty4(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options3.kind ?? "internal", options3);
    if (annotationsFromEnv._tag === "Some") {
      forEach3(annotationsFromEnv.value, (value5, key) => span2.attribute(key, value5));
    }
    if (options3.attributes !== void 0) {
      Object.entries(options3.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options3.captureStackTrace === "function") {
    spanToTrace.set(span2, options3.captureStackTrace);
  }
  return span2;
};
var endSpan = (span2, exit4, clock3, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit4);
});
var useSpan = (name, ...args3) => {
  const options3 = addSpanStackTrace(args3.length === 1 ? void 0 : args3[0]);
  const evaluate3 = args3[args3.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name, options3);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span2), (exit4) => endSpan(span2, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self, span2) => provideService(self, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options3 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options3, (span2) => withParentSpan(self, span2));
  }
  return (self) => useSpan(name, options3, (span2) => withParentSpan(self, span2));
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Exit.js
var isFailure = exitIsFailure;
var isSuccess = exitIsSuccess;
var all2 = exitCollectAll;
var die3 = exitDie;
var fail3 = exitFail;
var failCause3 = exitFailCause;
var map13 = exitMap;
var mapBoth3 = exitMapBoth;
var match9 = exitMatch;
var succeed3 = exitSucceed;
var void_3 = exitVoid;
var zip3 = exitZip;
var zipRight2 = exitZipRight;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect3) => ({
  _tag: OP_RESUME,
  effect: effect3
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake5 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await = (self) => self.await;
var inheritAll = (self) => self.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId2) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId2);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId2);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var join2 = (self) => zipLeft(flatten3(self.await), self.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var currentFiberURI = "effect/FiberCurrent";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log4) => ({
  [LoggerTypeId]: loggerVariance,
  log: log4,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none6 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date: date5,
  fiberId: fiberId2,
  logLevel: logLevel2,
  message,
  spans: spans2
}) => {
  const formatValue = (value5) => value5.match(textOnly) ? value5 : quoteValue(value5);
  const format6 = (label, value5) => `${formatLabel(label)}=${formatValue(value5)}`;
  const append4 = (label, value5) => " " + format6(label, value5);
  let out = format6("timestamp", date5.toISOString());
  out += append4("level", logLevel2.label);
  out += append4("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans2) {
    out += " " + render(date5.getTime())(span2);
  }
  for (const [label, value5] of annotations2) {
    out += append4(label, toStringUnknown(value5, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var withColor = (text10, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text10 + "\x1B[0m";
};
var withColorNoop = (text10, ..._colors) => text10;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date5) => `${date5.getHours().toString().padStart(2, "0")}:${date5.getMinutes().toString().padStart(2, "0")}:${date5.getSeconds().toString().padStart(2, "0")}.${date5.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options3) => {
  const mode_ = options3?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options3?.colors === "boolean" ? options3.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = options3?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options3?.stderr === true
  });
};
var prettyLoggerTty = (options3) => {
  const color3 = options3.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context7,
    date: date5,
    fiberId: fiberId2,
    logLevel: logLevel2,
    message: message_,
    spans: spans2
  }) => {
    const services = getOrDefault2(context7, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const log4 = options3.stderr === true ? console2.error : console2.log;
    const message = ensure(message_);
    let firstLine = color3(`[${options3.formatDate(date5)}]`, colors.white) + ` ${color3(logLevel2.label, ...logLevelColors[logLevel2._tag])} (${threadName(fiberId2)})`;
    if (isCons(spans2)) {
      const now = date5.getTime();
      const render5 = render(now);
      for (const span2 of spans2) {
        firstLine += " " + render5(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color3(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log4(firstLine);
    console2.group();
    if (!isEmpty3(cause2)) {
      log4(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log4(redact(message[messageIndex]));
      }
    }
    if (size4(annotations2) > 0) {
      for (const [key, value5] of annotations2) {
        log4(color3(`${key}:`, colors.bold, colors.white), redact(value5));
      }
    }
    console2.groupEnd();
  });
};
var prettyLoggerBrowser = (options3) => {
  const color3 = options3.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context7,
    date: date5,
    fiberId: fiberId2,
    logLevel: logLevel2,
    message: message_,
    spans: spans2
  }) => {
    const services = getOrDefault2(context7, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color3}[${options3.formatDate(date5)}]`;
    const firstParams = [];
    if (options3.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color3}${logLevel2.label}${color3} (${threadName(fiberId2)})`;
    if (options3.colors) {
      firstParams.push(logLevelStyle[logLevel2._tag], "");
    }
    if (isCons(spans2)) {
      const now = date5.getTime();
      const render5 = render(now);
      for (const span2 of spans2) {
        firstLine += " " + render5(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color3}${firstMaybeString}`;
        if (options3.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console2.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty3(cause2)) {
      console2.error(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console2.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations2) > 0) {
      for (const [key, value5] of annotations2) {
        const redacted4 = redact(value5);
        if (options3.colors) {
          console2.log(`%c${key}:`, "color:gray", redacted4);
        } else {
          console2.log(`${key}:`, redacted4);
        }
      }
    }
    console2.groupEnd();
  });
};
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values4) {
    this.values = values4;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values4 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values4);
};
var exponential = (options3) => pipe(makeBy(options3.count - 1, (i) => options3.start * Math.pow(options3.factor, i)), unsafeFromArray, fromIterable7);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol]() {
    return FrequencyKeyTypeHash;
  }
  [symbol2](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryKeyType = class {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error4, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error4;
    this.quantiles = quantiles;
    this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = (options3) => new CounterKeyType(options3?.incremental ?? false, options3?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags2 = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags2;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options3) => new MetricKeyImpl(name, counter(options3), fromNullable(options3?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty20 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var get12 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove8 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value5 = bucket[i][1];
      if (remove8) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value5);
    }
  }
  return none2();
};
var has5 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get12(self, key)));
var set6 = /* @__PURE__ */ dual(3, (self, key, value5) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value5);
    return self;
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === void 0) {
    self.buckets.set(hash2, [[key, value5]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value5]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count4) {
    this.count = count4;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value5) {
    this.value = value5;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count4, min4, max6, sum3) {
    this.buckets = buckets;
    this.count = count4;
    this.min = min4;
    this.max = max6;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error4, quantiles, count4, min4, max6, sum3) {
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count4;
    this.min = min4;
    this.max = max6;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = (count4) => new CounterState(count4);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count4) => new GaugeState(count4);
var histogram3 = (options3) => new HistogramState(options3.buckets, options3.count, options3.min, options3.max, options3.sum);
var summary2 = (options3) => new SummaryState(options3.error, options3.quantiles, options3.count, options3.min, options3.max, options3.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make27 = (options3) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options3
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value5) => value5 >= bigint03 : (value5) => value5 >= 0 : (_value) => true;
  const update5 = (value5) => {
    if (canUpdate(value5)) {
      sum3 = sum3 + value5;
    }
  };
  return make27({
    get: () => counter3(sum3),
    update: update5,
    modify: update5
  });
};
var frequency3 = (key) => {
  const values4 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values4.set(word, 0);
  }
  const update5 = (word) => {
    const slotCount = values4.get(word) ?? 0;
    values4.set(word, slotCount + 1);
  };
  return make27({
    get: () => frequency2(values4),
    update: update5,
    modify: update5
  });
};
var gauge3 = (_key, startAt) => {
  let value5 = startAt;
  return make27({
    get: () => gauge2(value5),
    update: (v) => {
      value5 = v;
    },
    modify: (v) => {
      value5 = value5 + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size13 = bounds.length;
  const values4 = new Uint32Array(size13 + 1);
  const boundaries = new Float64Array(size13);
  let count4 = 0;
  let sum3 = 0;
  let min4 = Number.MAX_VALUE;
  let max6 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map4((n, i) => {
    boundaries[i] = n;
  }));
  const update5 = (value5) => {
    let from = 0;
    let to = size13;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value5 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value5 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values4[from] = values4[from] + 1;
    count4 = count4 + 1;
    sum3 = sum3 + value5;
    if (value5 < min4) {
      min4 = value5;
    }
    if (value5 > max6) {
      max6 = value5;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size13);
    let cumulated = 0;
    for (let i = 0; i < size13; i++) {
      const boundary = boundaries[i];
      const value5 = values4[i];
      cumulated = cumulated + value5;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make27({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count4,
      min: min4,
      max: max6,
      sum: sum3
    }),
    update: update5,
    modify: update5
  });
};
var summary3 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values4 = allocate(maxSize);
  let head5 = 0;
  let count4 = 0;
  let sum3 = 0;
  let min4 = 0;
  let max6 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values4[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value5, timestamp) => {
    if (maxSize > 0) {
      head5 = head5 + 1;
      const target = head5 % maxSize;
      values4[target] = [timestamp, value5];
    }
    min4 = count4 === 0 ? value5 : Math.min(min4, value5);
    max6 = count4 === 0 ? value5 : Math.max(max6, value5);
    count4 = count4 + 1;
    sum3 = sum3 + value5;
  };
  return make27({
    get: () => summary2({
      error: error4,
      quantiles: snapshot(Date.now()),
      count: count4,
      min: min4,
      max: max6,
      sum: sum3
    }),
    update: ([value5, timestamp]) => observe(value5, timestamp),
    modify: ([value5, timestamp]) => observe(value5, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head5 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head5, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map4(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var unsafeMake6 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty20();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake6(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value5 = counter6;
    }
    return value5;
  }
  getFrequency(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const frequency5 = frequency3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, frequency5));
      }
      value5 = frequency5;
    }
    return value5;
  }
  getGauge(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const gauge5 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, gauge5));
      }
      value5 = gauge5;
    }
    return value5;
  }
  getHistogram(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value5 = histogram6;
    }
    return value5;
  }
  getSummary(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const summary5 = summary3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, summary5));
      }
      value5 = summary5;
    }
    return value5;
  }
};
var make28 = () => {
  return new MetricRegistryImpl();
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make28());
var make29 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect3) => tap(effect3, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options3) => fromMetricKey(counter2(name, options3));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make29(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self, key, value5) => taggedWithLabels2(self, [make26(key, value5)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
  return make29(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags2) => sync(() => self.unsafeUpdate(input, tags2))));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var complete = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map35) => sync(() => {
  if (map35.has(self)) {
    const entry = map35.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = ({
  color: color3,
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value5
}) => ({
  color: color3,
  key,
  value: value5,
  left: left3,
  right: right3,
  count: count4
});
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var repaint = ({
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value5
}, color3) => ({
  color: color3,
  key,
  value: value5,
  left: left3,
  right: right3,
  count: count4
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash2 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var findFirst4 = /* @__PURE__ */ dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has6 = /* @__PURE__ */ dual(2, (self, key) => isSome2(findFirst4(self, key)));
var insert = /* @__PURE__ */ dual(3, (self, key, value5) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value5,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p3 = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p3.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p3) {
      if (p3.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p3.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p3.right;
          p3.color = Color.Black;
          p3.right = pp;
          n_stack[s - 2] = p3;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p3;
            } else {
              ppp.right = p3;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p3.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p3.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p3;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p3;
          recount(pp);
          recount(p3);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p3.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p3.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p3.left;
          p3.color = Color.Black;
          p3.left = pp;
          n_stack[s - 2] = p3;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p3;
            } else {
              ppp.left = p3;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p3.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p3.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p3;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p3;
          recount(pp);
          recount(p3);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys4(self, Direction.Forward);
var keys4 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count4 = 0;
  return {
    [Symbol.iterator]: () => keys4(self, direction),
    next: () => {
      count4++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count4
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var removeFirst = /* @__PURE__ */ dual(2, (self, key) => {
  if (!has6(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split2 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split2 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split2 - 1].key = n.key;
    cstack[split2 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split2; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split2 - 1].left = cstack[split2];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p3 = cstack[cstack.length - 2];
    if (p3.left === n) {
      p3.left = void 0;
    } else if (p3.right === n) {
      p3.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var fixDoubleBlack = (stack) => {
  let n, p3, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p3 = stack[i - 1];
    if (p3.left === n) {
      s = p3.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p3.right = clone(s);
        z = s.right = clone(s.right);
        p3.right = s.left;
        s.left = p3;
        s.right = z;
        s.color = p3.color;
        n.color = Color.Black;
        p3.color = Color.Black;
        z.color = Color.Black;
        recount(p3);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p3) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p3.right = clone(s);
        z = s.left = clone(s.left);
        p3.right = z.left;
        s.left = z.right;
        z.left = p3;
        z.right = s;
        z.color = p3.color;
        p3.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p3);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p3) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p3.color === Color.Red) {
          p3.color = Color.Black;
          p3.right = repaint(s, Color.Red);
          return;
        } else {
          p3.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p3.right = s.left;
        s.left = p3;
        s.color = p3.color;
        p3.color = Color.Red;
        recount(p3);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p3) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p3;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p3.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p3.left = clone(s);
        z = s.left = clone(s.left);
        p3.left = s.right;
        s.right = p3;
        s.left = z;
        s.color = p3.color;
        n.color = Color.Black;
        p3.color = Color.Black;
        z.color = Color.Black;
        recount(p3);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p3) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p3.left = clone(s);
        z = s.right = clone(s.right);
        p3.left = z.right;
        s.right = z.left;
        z.right = p3;
        z.left = s;
        z.color = p3.color;
        p3.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p3);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p3) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p3.color === Color.Red) {
          p3.color = Color.Black;
          p3.left = repaint(s, Color.Red);
          return;
        } else {
          p3.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p3.left = s.right;
        s.right = p3;
        s.color = p3.color;
        p3.color = Color.Red;
        recount(p3);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p3) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p3;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/RedBlackTree.js
var has7 = has6;
var insert2 = insert;
var keys5 = keysForward;
var removeFirst2 = removeFirst;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/SortedSet.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId12]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId12)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId12);
var add5 = /* @__PURE__ */ dual(2, (self, value5) => has7(self.keyTree, value5) ? self : fromTree(insert2(self.keyTree, value5, true)));
var remove5 = /* @__PURE__ */ dual(2, (self, value5) => fromTree(removeFirst2(self.keyTree, value5)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var ProxySupervisor = class _ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context7, effect3, parent, fiber) {
    this.underlying.onStart(context7, effect3, parent, fiber);
  }
  onEnd(value5, fiber) {
    this.underlying.onEnd(value5, fiber);
  }
  onEffect(fiber, effect3) {
    this.underlying.onEffect(fiber, effect3);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context7, effect3, parent, fiber) {
    this.left.onStart(context7, effect3, parent, fiber);
    this.right.onStart(context7, effect3, parent, fiber);
  }
  onEnd(value5, fiber) {
    this.left.onEnd(value5, fiber);
    this.right.onEnd(value5, fiber);
  }
  onEffect(fiber, effect3) {
    this.left.onEffect(fiber, effect3);
    this.right.onEffect(fiber, effect3);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var Track = class {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect3) {
    this.effect = effect3;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn = class {
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync(() => get6(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), remove5(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var fromEffect = (effect3) => {
  return new Const(effect3);
};
var none7 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Differ.js
var make31 = make17;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty23 = {
  _tag: OP_EMPTY3
};
var combine9 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch8 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    switch (head5._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head5.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head5.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head5.first)(prepend2(head5.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none7;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet2 = (self) => {
  if (equals(self, none7)) {
    return empty8();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union3(toSet2(self.right)));
    } else {
      return make11(self);
    }
  }
};
var diff7 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty23;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty23, (patch10, supervisor) => combine9(patch10, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty23, (patch10, supervisor) => combine9(patch10, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine9(added, removed);
};
var differ2 = /* @__PURE__ */ make31({
  empty: empty23,
  patch: patch8,
  combine: combine9,
  diff: diff7
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value5) => {
    return internalCall(() => cont.effect_instruction_i1(value5));
  },
  ["OnStep"]: (_, _cont, value5) => {
    return exitSucceed(exitSucceed(value5));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value5) => {
    return internalCall(() => cont.effect_instruction_i2(value5));
  },
  [OP_REVERT_FLAGS]: (self, cont, value5) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value5);
    }
  },
  [OP_WHILE]: (self, cont, value5) => {
    internalCall(() => cont.effect_instruction_i2(value5));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self, cont, value5) => {
    while (true) {
      const state = internalCall(() => cont.effect_instruction_i0.next(value5));
      if (state.done) {
        return exitSucceed(state.value);
      }
      const primitive2 = yieldWrapGet(state.value);
      if (!exitIsExit(primitive2)) {
        self.pushStack(cont);
        return primitive2;
      } else if (primitive2._tag === "Failure") {
        return primitive2;
      }
      value5 = primitive2.value;
    }
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten2(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map35 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map35.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map35);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags2);
      fiberActive.unsafeUpdate(1, tags2);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect3) {
    this.tell(resume(effect3));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status2) => status2);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status2) => {
      if (isDone2(status2)) {
        return state.currentRuntimeFlags;
      }
      return status2.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake5(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status2) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status2)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch10 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch10);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value5) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value5
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope4) {
    const children2 = this._children;
    this._children = null;
    if (children2 !== null && children2.size > 0) {
      for (const child of children2) {
        if (child._exitValue === null) {
          scope4.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone6 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone6 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone6,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags2);
      fiberActive.unsafeUpdate(-1, tags2);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags2);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags2);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel2 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan2(minimumLogLevel2, logLevel2)) {
      return;
    }
    const spans2 = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date5 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause2,
            context: contextMap,
            spans: spans2,
            annotations: annotations2,
            date: date5
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done3 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect3 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect3 !== null) {
        const eff = effect3;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect3 = null;
            } else {
              effect3 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect3 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect3 = flatMap7(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect3 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect3) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect3);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect3));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect3) {
    this.tell(resume(effect3));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch10) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch10);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect3) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect3));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value5 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value5);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value5);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check3 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check3()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty9, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause2,
  context: context7,
  fiberId: fiberId2,
  logLevel: logLevel2,
  message
}) => {
  const span2 = getOption2(getOrDefault(context7, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context7, currentServices), clockTag);
  const attributes = {};
  for (const [key, value5] of annotations2) {
    attributes[key] = value5;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make11(defaultLogger, tracerLogger)));
var acquireRelease = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit4) => release(a, exit4)))));
var addFinalizer = (finalizer2) => withFiberRuntime((runtime5) => {
  const acquireRefs = runtime5.getFiberRefs();
  const acquireFlags = disable2(runtime5.currentRuntimeFlags, Interruption);
  return flatMap7(scope, (scope4) => scopeAddFinalizerExit(scope4, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer2(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var filter6 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, predicate, options3) => {
  const predicate_ = options3?.negate ? (a, i) => map11(predicate(a, i), not) : predicate;
  return matchSimple(options3?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect3, a, i) => zipWith2(effect3, suspend(() => predicate_(a, i)), (list4, b) => b ? [a, ...list4] : list4), sync(() => new Array()))), () => map11(forEach7(elements, (a, i) => map11(predicate_(a, i), (b) => b ? some2(a) : none2()), options3), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys6 = Object.keys(input);
  const size13 = keys6.length;
  return [keys6.map((k) => input[k]), some2((values4) => {
    const res = {};
    for (let i = 0; i < size13; i++) {
      ;
      res[keys6[i]] = values4[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options3) => {
  const eitherEffects = [];
  for (const effect3 of effects) {
    eitherEffects.push(either2(effect3));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options3?.concurrency,
    batching: options3?.batching,
    concurrentFinalizers: options3?.concurrentFinalizers
  }), (eithers) => {
    const none12 = none2();
    const size13 = eithers.length;
    const errors = new Array(size13);
    const successes = new Array(size13);
    let errored = false;
    for (let i = 0; i < size13; i++) {
      const either7 = eithers[i];
      if (either7._tag === "Left") {
        errors[i] = some2(either7.left);
        errored = true;
      } else {
        successes[i] = either7.right;
        errors[i] = none12;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options3?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options3) => {
  const eitherEffects = [];
  for (const effect3 of effects) {
    eitherEffects.push(either2(effect3));
  }
  if (options3?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options3?.concurrency,
      batching: options3?.batching,
      discard: true,
      concurrentFinalizers: options3?.concurrentFinalizers
    });
  }
  return map11(forEach7(eitherEffects, identity, {
    concurrency: options3?.concurrency,
    batching: options3?.batching,
    concurrentFinalizers: options3?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all3 = (arg, options3) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options3?.mode === "validate") {
    return allValidate(effects, reconcile, options3);
  } else if (options3?.mode === "either") {
    return allEither(effects, reconcile, options3);
  }
  return options3?.discard !== true && reconcile._tag === "Some" ? map11(forEach7(effects, identity, options3), reconcile.value) : forEach7(effects, identity, options3);
};
var forEach7 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (self, f, options3) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options3?.batching === true || options3?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options3?.discard) {
    return match7(options3.concurrency, () => finalizersMaskInternal(sequential3, options3?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options3?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options3?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options3?.concurrency, () => finalizersMaskInternal(sequential3, options3?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options3?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options3?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as9 = fromIterable(self);
  const array7 = new Array(as9.length);
  const fn3 = (a, i) => flatMap7(f(a, i), (b) => sync(() => array7[i] = b));
  return zipRight(forEachConcurrentDiscard(as9, fn3, batching, false), succeed(array7));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted2 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll2 = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted2 = true;
    interruptAll2();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted2) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap7(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted2) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse2(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse2(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten3(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count4 = 0;
        let index = 0;
        const check3 = (index2, hitNext) => (exit4) => {
          exits[index2] = exit4;
          count4++;
          if (count4 === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check3(index, true));
          index++;
        };
        processingFiber.addObserver(check3(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as9 = fromIterable(self);
  const array7 = new Array(as9.length);
  const fn3 = (a, i) => map11(f(a, i), (b) => array7[i] = b);
  return zipRight(forEachConcurrentDiscard(as9, fn3, batching, false, n), succeed(array7));
});
var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
var unsafeFork2 = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect3, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect3);
  return childFiber;
};
var unsafeForkUnstarted = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect3, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect3, some2(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse2(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var parallelFinalizers = (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    switch (scope4.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope4, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    if (scope4.strategy._tag === "ParallelN" && scope4.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap7(scopeFork(scope4, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope4) => {
    if (concurrentFinalizers === true) {
      const patch10 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope4.strategy._tag) {
        case "Parallel":
          return patch10(self(parallelFinalizers));
        case "Sequential":
          return patch10(self(sequentialFinalizers));
        case "ParallelN":
          return patch10(self(parallelNFinalizers(scope4.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f) => flatMap7(scopeTag, f);
var scopedWith = (f) => flatMap7(scopeMake(), (scope4) => onExit(f(scope4), (exit4) => scope4.close(exit4)));
var scopedEffect = (effect3) => flatMap7(scopeMake(), (scope4) => scopeUse(effect3, scope4));
var sequentialFinalizers = (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    switch (scope4.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope4, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var zipOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options3) => zipWithOptions(self, that, (a, b) => [a, b], options3));
var zipLeftOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options3) => {
  if (options3?.concurrent !== true && (options3?.batching === void 0 || options3.batching === false)) {
    return zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options3);
});
var zipRightOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options3) => {
  if (options3?.concurrent !== true && (options3?.batching === void 0 || options3.batching === false)) {
    return zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options3);
});
var zipWithOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, f, options3) => map11(all3([self, that], {
  concurrency: options3?.concurrent ? 2 : 1,
  batching: options3?.batching,
  concurrentFinalizers: options3?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope4, fin) => {
  if (scope4.state._tag === "Open") {
    scope4.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap7((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope4 = Object.create(ScopeImplProto);
  scope4.strategy = strategy;
  scope4.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope4;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect3, scope4) => mapInputContext(
  effect3,
  // @ts-expect-error
  merge3(make6(scopeTag, scope4))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect3, scope4) => pipe(effect3, scopeExtend(scope4), onExit((exit4) => scope4.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty23
});
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none7);
var raceWith = /* @__PURE__ */ dual(3, (self, other, options3) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options3.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options3.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options3.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options3.onOtherDone(exit4, loser);
      }
    }
  })
}));
var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value5) => pipe(right3, interruptAsFiber(parentFiberId), as(value5))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value5) => pipe(left3, interruptAsFiber(parentFiberId), as(value5))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options3) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options3.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options3.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options3.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options3.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine4(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self, finalizer2) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer2, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer2, a)
})));
var invokeWithInterrupt = (self, entries3, onInterrupt2) => fiberIdWith((id2) => flatMap7(flatMap7(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count4) => count4 === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f) => f());
    cb(exit4);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = (count4) => {
      counts[i] = count4;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id2)));
})));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Cause.js
var empty25 = empty9;
var fail4 = fail;
var die4 = die;
var interrupt3 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isDie2 = isDie;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map14 = map9;
var squash = causeSquash;
var reduceWithContext3 = reduceWithContext;
var NoSuchElementException2 = NoSuchElementException;
var pretty2 = pretty;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty26 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make32 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty26;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
var min2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var isEmpty6 = (self) => {
  return self.startMillis >= self.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self, that) => {
  const start4 = Math.max(self.startMillis, that.startMillis);
  const end5 = Math.min(self.endMillis, that.endMillis);
  return make32(start4, end5);
});
var size8 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var after = (startMilliseconds) => {
  return make32(startMilliseconds, Number.POSITIVE_INFINITY);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ScheduleInterval.js
var make33 = make32;
var empty27 = empty26;
var lessThan3 = lessThan2;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size9 = size8;
var after2 = after;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make34 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make34(reverse3(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse2(() => empty27)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse2(() => empty27)).endMillis;
};
var lessThan4 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
var isNonEmpty3 = (self) => {
  return isNonEmpty(self.intervals);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ScheduleIntervals.js
var make35 = make34;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty4 = isNonEmpty3;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make35(of2(interval))
  };
};
var done4 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone3 = (self) => {
  return self._tag === OP_DONE2;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done5 = done4;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork = scopeFork;
var make36 = scopeMake;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = (permits) => asVoid(withFiberRuntime((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  }));
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self)), this.release(n));
  }));
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class2 {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self) => {
    return zipRight(this.await, self);
  };
};
var unsafeMakeLatch = (open3) => new Latch(open3 ?? false);
var forkIn = /* @__PURE__ */ dual(2, (self, scope4) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope4;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer2 = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer2);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self) => scopeWith((scope4) => forkIn(self, scope4));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var timeout = /* @__PURE__ */ dual(2, (self, duration3) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration3),
  duration: duration3
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self, {
  duration: duration3,
  onTimeout
}) => flatten3(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutTo = /* @__PURE__ */ dual(2, (self, {
  duration: duration3,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration3)), {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SynchronizedImpl = class extends Class2 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get10(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get10(this.ref), f), flatMap7(([b, a]) => as(set4(this.ref, a), b))));
  }
};
var makeSynchronized = (value5) => sync(() => unsafeMakeSynchronized(value5));
var unsafeMakeSynchronized = (value5) => {
  const ref = unsafeMake4(value5);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_MERGE_ALL = "MergeAll";
var OP_ZIP_WITH2 = "ZipWith";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Fiber.js
var _await2 = _await;
var inheritAll2 = inheritAll;
var interrupt4 = interruptFiber;
var interruptAs = interruptAsFiber;
var interruptAllAs2 = interruptAllAs;
var join3 = join2;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime5 = arguments[0];
    return (effect3, ...args3) => f(runtime5, effect3, ...args3);
  }
  return f.apply(this, arguments);
};
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime5, self, options3) => {
  const fiberId2 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime5.context]]]];
  if (options3?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options3.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime5.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options3?.updateRefs) {
    fiberRefs3 = options3.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime5.runtimeFlags);
  let effect3 = self;
  if (options3?.scope) {
    effect3 = flatMap7(fork(options3.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none7) {
    supervisor.onStart(runtime5.context, effect3, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime5.runtimeFlags, fiberRuntime);
  if (options3?.immediate === false) {
    fiberRuntime.resume(effect3);
  } else {
    fiberRuntime.start(effect3);
  }
  return fiberRuntime;
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime5, effect3) => {
  const result = unsafeRunSyncExit(runtime5)(effect3);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error4;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head5 = prettyErrors(cause2)[0];
    super(head5?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head5 ? `(FiberFailure) ${head5.name}` : "FiberFailure";
    if (head5?.stack) {
      this.stack = head5.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error4;
};
var fastPath = (effect3) => {
  const op = effect3;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(new NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime5, effect3) => {
  const op = fastPath(effect3);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime5)(effect3, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime5, effect3, options3) => new Promise((resolve3) => {
  const op = fastPath(effect3);
  if (op) {
    resolve3(op);
  }
  const fiber = unsafeFork3(runtime5)(effect3);
  fiber.addObserver((exit4) => {
    resolve3(exit4);
  });
  if (options3?.signal !== void 0) {
    if (options3.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options3.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context7, runtimeFlags2, fiberRefs3) {
    this.context = context7;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make37 = (options3) => new RuntimeImpl(options3.context, options3.runtimeFlags, options3.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make19(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make37({
  context: /* @__PURE__ */ empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty18()
});
var updateContext2 = /* @__PURE__ */ dual(2, (self, f) => make37({
  context: f(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));
var updateEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect((value5) => map11(f(value5), (result) => [void 0, result])));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer12, scope4) {
    return pipe(modifyEffect(this.ref, (map35) => {
      const inMap = map35.get(layer12);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap7(([patch10, b]) => pipe(patchFiberRefs(patch10), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope4, release)
        })));
        return succeed([cached3, map35]);
      }
      return pipe(make24(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make24(() => void_), map11((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer12, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight(scopeClose(innerScope, exit4)), zipRight(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope4, (exit5) => pipe(sync(() => map35.delete(layer12)), zipRight(get10(finalizerRef)), flatMap7((finalizer2) => finalizer2(exit5))))), zipRight(deferredSucceed(deferred, exit4.effect_instruction_i0)), as(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit4) => pipe(get10(finalizerRef), flatMap7((finalizer2) => finalizer2(exit4)))];
        return [resource, isFresh(layer12) ? map35 : map35.set(layer12, memoized)];
      }))))));
    }), flatten3);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map11(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var buildWithScope = /* @__PURE__ */ dual(2, (self, scope4) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope4)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope4) => flatMap7(makeBuilder(self, scope4), (run10) => provideService(run10(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope4, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope4)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope5) => memoMap.getOrElseMemoize(op.layer, scope5)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope4), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope4),
        onSuccess: (value5) => memoMap.getOrElseMemoize(op.successK(value5), scope4)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope4)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope4));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope4), flatMap7((env2) => pipe(memoMap.getOrElseMemoize(op.second, scope4), provideContext(env2)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope4)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope4));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope4));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope4), zipWith2(memoMap.getOrElseMemoize(op.second, scope4), op.zipK)));
    }
    case "ZipWith": {
      return gen(function* () {
        const parallelScope = yield* scopeFork(scope4, parallel2);
        const firstScope = yield* scopeFork(parallelScope, sequential2);
        const secondScope = yield* scopeFork(parallelScope, sequential2);
        return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
          concurrent: true
        }));
      });
    }
    case "MergeAll": {
      const layers = op.layers;
      return map11(scopeFork(scope4, parallel2), (parallelScope) => (memoMap) => {
        const contexts = new Array(layers.length);
        return map11(forEachConcurrentDiscard(layers, fnUntraced(function* (layer12, i) {
          const scope5 = yield* scopeFork(parallelScope, sequential2);
          const context7 = yield* memoMap.getOrElseMemoize(layer12, scope5);
          contexts[i] = context7;
        }), false, false), () => mergeAll2(...contexts));
      });
    }
  }
};
var context2 = () => fromEffectContext(context());
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect3 = tagFirst ? b : a;
  return fromEffectContext(map11(effect3, (service3) => make6(tag4, service3)));
});
function fromEffectContext(effect3) {
  const fromEffect9 = Object.create(proto3);
  fromEffect9._op_layer = OP_FROM_EFFECT;
  fromEffect9.effect = effect3;
  return fromEffect9;
}
var merge5 = /* @__PURE__ */ dual(2, (self, that) => zipWith3(self, that, (a, b) => merge3(a, b)));
var mergeAll3 = (...layers) => {
  const mergeAll8 = Object.create(proto3);
  mergeAll8._op_layer = OP_MERGE_ALL;
  mergeAll8.layers = layers;
  return mergeAll8;
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect3 = tagFirst ? b : a;
  return scopedContext(map11(effect3, (service3) => make6(tag4, service3)));
});
var scopedContext = (effect3) => {
  const scoped6 = Object.create(proto3);
  scoped6._op_layer = OP_SCOPED;
  scoped6.effect = effect3;
  return scoped6;
};
var succeed5 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make6(tag4, resource)));
});
var suspend3 = (evaluate3) => {
  const suspend12 = Object.create(proto3);
  suspend12._op_layer = OP_SUSPEND;
  suspend12.evaluate = evaluate3;
  return suspend12;
};
var provide = /* @__PURE__ */ dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll3(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
  const zipWith10 = Object.create(proto3);
  zipWith10._op_layer = OP_PROVIDE_MERGE;
  zipWith10.first = self;
  zipWith10.second = provide(that, self);
  zipWith10.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith10;
});
var zipWith3 = /* @__PURE__ */ dual(3, (self, that, f) => suspend3(() => {
  const zipWith10 = Object.create(proto3);
  zipWith10._op_layer = OP_ZIP_WITH2;
  zipWith10.first = self;
  zipWith10.second = that;
  zipWith10.zipK = f;
  return zipWith10;
}));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer12) => scopedWith((scope4) => flatMap7(buildWithScope(layer12, scope4), (context7) => provideSomeContext(self, context7))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll3(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId13 in source) {
    return flatMap7(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/console.js
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var error = (...args3) => consoleWith((_) => _.error(...args3));
var log = (...args3) => consoleWith((_) => _.log(...args3));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var tagged2 = (tag4) => (args3) => {
  const value5 = args3 === void 0 ? Object.create(StructuralPrototype) : struct2(args3);
  value5._tag = tag4;
  return value5;
};
var Class3 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag4, _receiver) {
    if (tag4 === "$is") {
      return isTagged;
    } else if (tag4 === "$match") {
      return taggedMatch;
    }
    return tagged2(tag4);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value6) {
      return cases2[value6._tag](value6);
    };
  }
  const value5 = arguments[0];
  const cases = arguments[1];
  return cases[value5._tag](value5);
}
var Error3 = /* @__PURE__ */ (function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args3) {
        super(args3?.message, args3?.cause ? {
          cause: args3.cause
        } : void 0);
        if (args3) {
          Object.assign(this, args3);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args3,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
})();
var TaggedError = (tag4) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag4;
    }
  };
  O.BaseEffectError.prototype.name = tag4;
  return O.BaseEffectError;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/String.js
var Order4 = string2;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule2, ref) {
    this.schedule = schedule2;
    this.ref = ref;
  }
  get state() {
    return map11(get10(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap7(get10(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake4(defaultIterationMetadata);
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set4(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map11(get10(this.ref), (tuple3) => tuple3[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out, decision]) => {
      const setState = set4(this.ref, [some2(out), state2]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
      }
      const duration3 = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration3)), as(out));
    }))))));
  }
};
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration3) => map11(f(out), (delay2) => sum(duration3, decode(delay2)))));
var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, done5]);
  }
  return map11(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done5]);
})));
var driver = (self) => pipe(make24([none2(), self.initial]), map11((ref) => new ScheduleDriverImpl(self, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith2(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap7(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done5]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap7(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out2], done5]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out, out22], done5]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var map16 = /* @__PURE__ */ dual(2, (self, f) => mapEffect2(self, (out) => sync(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => map11(f(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay2 = size9(make33(now, start2(intervals)));
  return map11(f(out, delay2), (durationInput) => {
    const duration3 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration3);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make33(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map11(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var spaced = (duration3) => addDelay(forever2, () => duration3);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error4) {
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error4) => fail(error4.error)
});
var scheduleDefectRefail = (effect3) => catchAllCause(effect3, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule2) => repeatOrElse_Effect(self, schedule2, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self, options3) => {
  if (isSchedule(options3)) {
    return repeat_Effect(self, options3);
  }
  const base = options3.schedule ?? passthrough(forever2);
  const withWhile = options3.while ? whileInputEffect(base, (a) => {
    const applied = options3.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options3.until ? untilInputEffect(withWhile, (a) => {
    const applied = options3.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options3.times ? intersect5(withUntil, recurs(options3.times)).pipe(map16((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule2, orElse16) => flatMap7(driver(schedule2), (driver2) => matchEffect(self, {
  onFailure: (error4) => orElse16(error4, none2()),
  onSuccess: (value5) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get10(driver2.iterationMeta)), driver2, (error4, option6) => provideServiceEffect(orElse16(error4, option6), CurrentIterationMetadata, get10(driver2.iterationMeta)), value5)
})));
var repeatOrElseEffectLoop = (self, driver2, orElse16, value5) => matchEffect(driver2.next(value5), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error4) => orElse16(error4, some2(b)),
    onSuccess: (value6) => repeatOrElseEffectLoop(self, driver2, orElse16, value6)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self, options3) => {
  if (isSchedule(options3)) {
    return retry_Effect(self, options3);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options3)));
});
var fromRetryOptions = (options3) => {
  const base = options3.schedule ?? forever2;
  const withWhile = options3.while ? whileInputEffect(base, (e) => {
    const applied = options3.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options3.until ? untilInputEffect(withWhile, (e) => {
    const applied = options3.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options3.times !== void 0 ? intersect5(withUntil, recurs(options3.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse16) => flatMap7(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get10(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse16(e, out), CurrentIterationMetadata, get10(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver2, orElse16) => {
  return catchAll(self, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap7((out) => orElse16(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver2, orElse16)
  }));
};
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make38 = deferredMake;
var _await3 = deferredAwait;
var complete2 = deferredComplete;
var fail6 = deferredFail;
var failCause5 = deferredFailCause;
var interrupt5 = deferredInterrupt;
var isDone5 = deferredIsDone;
var succeed6 = deferredSucceed;
var unsafeDone = deferredUnsafeDone;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/MutableList.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId14]: TypeId14,
  [Symbol.iterator]() {
    let done8 = false;
    let head5 = this.head;
    return {
      next() {
        if (done8) {
          return this.return();
        }
        if (head5 == null) {
          done8 = true;
          return this.return();
        }
        const value5 = head5.value;
        head5 = head5.next;
        return {
          done: done8,
          value: value5
        };
      },
      return(value5) {
        if (!done8) {
          done8 = true;
        }
        return {
          done: true,
          value: value5
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value5) => ({
  value: value5,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty29 = () => {
  const list4 = Object.create(MutableListProto);
  list4.head = void 0;
  list4.tail = void 0;
  list4._length = 0;
  return list4;
};
var isEmpty8 = (self) => length(self) === 0;
var length = (self) => self._length;
var append3 = /* @__PURE__ */ dual(2, (self, value5) => {
  const node = makeNode(value5);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head5 = self.head;
  if (head5 !== void 0) {
    remove6(self, head5);
    return head5.value;
  }
  return void 0;
};
var remove6 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/MutableQueue.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId15]: TypeId15,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make39 = (capacity3) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty29();
  queue.capacity = capacity3;
  return queue;
};
var bounded = (capacity3) => make39(capacity3);
var unbounded = () => make39(void 0);
var length2 = (self) => length(self.queue);
var isEmpty9 = (self) => isEmpty8(self.queue);
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = /* @__PURE__ */ dual(2, (self, value5) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append3(value5)(self.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self, values4) => {
  const iterator = values4[Symbol.iterator]();
  let next;
  let remainder2 = empty5();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self);
  }
  while (next != null && !next.done) {
    remainder2 = prepend2(next.value)(remainder2);
    next = iterator.next();
  }
  return reverse3(remainder2);
});
var poll2 = /* @__PURE__ */ dual(2, (self, def) => {
  if (isEmpty8(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
  let result = empty5();
  let count4 = 0;
  while (count4 < n) {
    const element = poll2(EmptyMutableQueue)(self);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count4 += 1;
  }
  return reverse3(result);
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Effect.js
var isEffect2 = isEffect;
var all4 = all3;
var filter8 = filter6;
var forEach8 = forEach7;
var async2 = async_;
var withFiberRuntime2 = withFiberRuntime;
var fail7 = fail2;
var failSync2 = failSync;
var failCause6 = failCause;
var die5 = die2;
var dieMessage2 = dieMessage;
var gen2 = gen;
var succeed7 = succeed;
var suspend4 = suspend;
var sync4 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var catchAll2 = catchAll;
var catchAllCause2 = catchAllCause;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var ignore2 = ignore;
var retry = retry_combined;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryPromise2 = tryPromise;
var interrupt6 = interrupt2;
var interruptible4 = interruptible2;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var as4 = as;
var asVoid2 = asVoid;
var map17 = map11;
var mapBoth4 = mapBoth2;
var mapError2 = mapError;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var scope2 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var fiberIdWith2 = fiberIdWith;
var forkDaemon2 = forkDaemon;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var timeout2 = timeout;
var contextWithEffect2 = contextWithEffect;
var provide2 = effect_provide;
var provideService2 = provideService;
var serviceOption2 = serviceOption;
var option2 = option;
var either3 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var filterOrDieMessage2 = filterOrDieMessage;
var unlessEffect2 = unlessEffect;
var when2 = when;
var flatMap9 = flatMap7;
var flatten5 = flatten3;
var race2 = race;
var raceWith2 = raceWith;
var tap2 = tap;
var tapErrorCause2 = tapErrorCause;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var match11 = match8;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var annotateLogs2 = annotateLogs;
var orDie2 = orDie;
var orElse4 = orElse2;
var orElseFail2 = orElseFail;
var runtime4 = runtime3;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var runFork2 = unsafeForkEffect;
var runSync = unsafeRunSyncEffect;
var zip5 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith4 = zipWithOptions;
var withSpan2 = withSpan;
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args3,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options3 = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args3,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options3,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length3, fn3) {
  return Object.defineProperty(fn3, "length", {
    value: length3,
    configurable: true
  });
}
function fnApply(options3) {
  let effect3;
  let fnError = void 0;
  if (isGeneratorFunction(options3.body)) {
    effect3 = fromIterator(() => options3.body.apply(options3.self, options3.args));
  } else {
    try {
      effect3 = options3.body.apply(options3.self, options3.args);
    } catch (error4) {
      fnError = error4;
      effect3 = die5(error4);
    }
  }
  if (options3.pipeables.length > 0) {
    try {
      for (const x of options3.pipeables) {
        effect3 = x(effect3, ...options3.args);
      }
    } catch (error4) {
      effect3 = fnError ? failCause6(sequential(die(fnError), die(error4))) : die5(error4);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options3.errorCall.stack) {
      const stackDef = options3.errorDef.stack.trim().split("\n");
      const stackCall = options3.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options3.spanOptions && "captureStackTrace" in options3.spanOptions ? options3.spanOptions : {
    captureStackTrace,
    ...options3.spanOptions
  };
  return withSpan2(effect3, options3.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/internal/color.js
var black = {
  _tag: "Black"
};
var red = {
  _tag: "Red"
};
var green = {
  _tag: "Green"
};
var yellow = {
  _tag: "Yellow"
};
var blue = {
  _tag: "Blue"
};
var magenta = {
  _tag: "Magenta"
};
var cyan = {
  _tag: "Cyan"
};
var white = {
  _tag: "White"
};
var toCode = (color3) => {
  switch (color3._tag) {
    case "Black": {
      return 0;
    }
    case "Red": {
      return 1;
    }
    case "Green": {
      return 2;
    }
    case "Yellow": {
      return 3;
    }
    case "Blue": {
      return 4;
    }
    case "Magenta": {
      return 5;
    }
    case "Cyan": {
      return 6;
    }
    case "White": {
      return 7;
    }
  }
};

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/Color.js
var red2 = red;
var magenta2 = magenta;
var cyan2 = cyan;
var white2 = white;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Console.js
var error2 = error;
var log3 = log;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/SynchronizedRef.js
var make40 = makeSynchronized;
var get13 = get10;
var updateEffect2 = updateEffect;

// ../../node_modules/.pnpm/@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/typeclass/dist/esm/internal/Iterable.js
function reduce11(b, f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.reduce(f, b);
    }
    let result = b;
    for (const n of iterable) {
      result = f(result, n);
    }
    return result;
  };
}
function map18(f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.map(f);
    }
    return (function* () {
      for (const n of iterable) {
        yield f(n);
      }
    })();
  };
}

// ../../node_modules/.pnpm/@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/typeclass/dist/esm/Product.js
var struct3 = (F) => (fields) => {
  const keys6 = Object.keys(fields);
  return F.imap(F.productAll(keys6.map((k) => fields[k])), (values4) => {
    const out = {};
    for (let i = 0; i < values4.length; i++) {
      out[keys6[i]] = values4[i];
    }
    return out;
  }, (r) => keys6.map((k) => r[k]));
};

// ../../node_modules/.pnpm/@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/typeclass/dist/esm/Semigroup.js
var make41 = (combine13, combineMany = (self, collection) => reduce11(self, combine13)(collection)) => ({
  combine: combine13,
  combineMany
});
var constant2 = (a) => make41(() => a, () => a);
var first2 = () => make41((a) => a, (a) => a);
var imap = /* @__PURE__ */ dual(3, (S, to, from) => make41((self, that) => to(S.combine(from(self), from(that))), (self, collection) => to(S.combineMany(from(self), map18(from)(collection)))));
var product = (self, that) => make41(([xa, xb], [ya, yb]) => [self.combine(xa, ya), that.combine(xb, yb)]);
var productAll = (collection) => {
  return make41((x, y) => {
    const len = Math.min(x.length, y.length);
    const out = [];
    let collectionLength = 0;
    for (const s of collection) {
      if (collectionLength >= len) {
        break;
      }
      out.push(s.combine(x[collectionLength], y[collectionLength]));
      collectionLength++;
    }
    return out;
  });
};
var productMany = (self, collection) => {
  const semigroup = productAll(collection);
  return make41((x, y) => [self.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);
};
var of4 = constant2;
var Product = {
  of: of4,
  imap,
  product,
  productMany,
  productAll
};
var array3 = () => make41((self, that) => self.concat(that));
var struct4 = /* @__PURE__ */ struct3(Product);

// ../../node_modules/.pnpm/@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/typeclass/dist/esm/Monoid.js
var fromSemigroup = (S, empty39) => ({
  combine: S.combine,
  combineMany: S.combineMany,
  empty: empty39,
  combineAll: (collection) => S.combineMany(empty39, collection)
});
var array4 = () => fromSemigroup(array3(), []);
var struct5 = (fields) => {
  const empty39 = {};
  for (const k in fields) {
    if (Object.prototype.hasOwnProperty.call(fields, k)) {
      empty39[k] = fields[k].empty;
    }
  }
  return fromSemigroup(struct4(fields), empty39);
};

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/internal/sgr.js
var reset = {
  _tag: "Reset"
};
var setBold = (bold3) => ({
  _tag: "SetBold",
  bold: bold3
});
var setColor = (color3, vivid, layer12) => ({
  _tag: "SetColor",
  color: color3,
  vivid,
  layer: layer12
});
var setItalicized = (italicized3) => ({
  _tag: "SetItalicized",
  italicized: italicized3
});
var setStrikethrough = (strikethrough3) => ({
  _tag: "SetStrikethrough",
  strikethrough: strikethrough3
});
var setUnderlined = (underlined3) => ({
  _tag: "SetUnderlined",
  underlined: underlined3
});
var toCode2 = (self) => {
  switch (self._tag) {
    case "Reset": {
      return 0;
    }
    case "SetBold": {
      return self.bold ? 1 : 22;
    }
    case "SetColor": {
      switch (self.layer) {
        case "foreground": {
          return self.vivid ? 90 + toCode(self.color) : 30 + toCode(self.color);
        }
        case "background": {
          return self.vivid ? 100 + toCode(self.color) : 40 + toCode(self.color);
        }
      }
    }
    case "SetItalicized": {
      return self.italicized ? 3 : 23;
    }
    case "SetStrikethrough": {
      return self.strikethrough ? 9 : 29;
    }
    case "SetUnderlined": {
      return self.underlined ? 4 : 24;
    }
  }
};
var toEscapeSequence = (sgrs) => csi("m", sgrs);
var csi = (controlFunction, sgrs) => {
  const params = Array.from(sgrs).map((sgr) => `${toCode2(sgr)}`).join(";");
  return `\x1B[${params}${controlFunction}`;
};

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/internal/ansi.js
var AnsiSymbolKey = "@effect/printer-ansi/Ansi";
var AnsiTypeId = /* @__PURE__ */ Symbol.for(AnsiSymbolKey);
var make42 = (params) => ({
  ...AnsiMonoid.empty,
  ...params
});
var typeIdSemigroup = /* @__PURE__ */ first2();
var getFirstSomeSemigroup = /* @__PURE__ */ make41((self, that) => isSome2(self) ? self : that);
var AnsiSemigroup = /* @__PURE__ */ struct4({
  [AnsiTypeId]: typeIdSemigroup,
  commands: /* @__PURE__ */ array3(),
  foreground: getFirstSomeSemigroup,
  background: getFirstSomeSemigroup,
  bold: getFirstSomeSemigroup,
  italicized: getFirstSomeSemigroup,
  strikethrough: getFirstSomeSemigroup,
  underlined: getFirstSomeSemigroup
});
var typeIdMonoid = /* @__PURE__ */ fromSemigroup(typeIdSemigroup, AnsiTypeId);
var monoidOrElse = /* @__PURE__ */ fromSemigroup(getFirstSomeSemigroup, /* @__PURE__ */ none2());
var AnsiMonoid = /* @__PURE__ */ struct5({
  [AnsiTypeId]: typeIdMonoid,
  commands: /* @__PURE__ */ array4(),
  foreground: monoidOrElse,
  background: monoidOrElse,
  bold: monoidOrElse,
  italicized: monoidOrElse,
  strikethrough: monoidOrElse,
  underlined: monoidOrElse
});
var none9 = AnsiMonoid.empty;
var ESC = "\x1B[";
var BEL = "\x07";
var SEP = ";";
var bold = /* @__PURE__ */ make42({
  bold: /* @__PURE__ */ some2(/* @__PURE__ */ setBold(true))
});
var italicized = /* @__PURE__ */ make42({
  italicized: /* @__PURE__ */ some2(/* @__PURE__ */ setItalicized(true))
});
var strikethrough = /* @__PURE__ */ make42({
  strikethrough: /* @__PURE__ */ some2(/* @__PURE__ */ setStrikethrough(true))
});
var underlined = /* @__PURE__ */ make42({
  underlined: /* @__PURE__ */ some2(/* @__PURE__ */ setUnderlined(true))
});
var brightColor = (color3) => make42({
  foreground: some2(setColor(color3, true, "foreground"))
});
var color = (color3) => make42({
  foreground: some2(setColor(color3, false, "foreground"))
});
var bgColorBright = (color3) => make42({
  background: some2(setColor(color3, true, "background"))
});
var bgColor = (color3) => make42({
  background: some2(setColor(color3, false, "background"))
});
var black2 = /* @__PURE__ */ color(black);
var red3 = /* @__PURE__ */ color(red);
var green2 = /* @__PURE__ */ color(green);
var yellow2 = /* @__PURE__ */ color(yellow);
var blue2 = /* @__PURE__ */ color(blue);
var cyan3 = /* @__PURE__ */ color(cyan);
var white3 = /* @__PURE__ */ color(white);
var blackBright = /* @__PURE__ */ brightColor(black);
var cyanBright = /* @__PURE__ */ brightColor(cyan);
var bgRed = /* @__PURE__ */ bgColor(red);
var bgYellow = /* @__PURE__ */ bgColor(yellow);
var bgBlue = /* @__PURE__ */ bgColor(blue);
var bgCyan = /* @__PURE__ */ bgColor(cyan);
var bgBlackBright = /* @__PURE__ */ bgColorBright(black);
var beep = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(BEL)
});
var cursorTo = (column3, row) => {
  if (row === void 0) {
    const command2 = `${ESC}${Math.max(column3 + 1, 0)}G`;
    return make42({
      commands: of(command2)
    });
  }
  const command = `${ESC}${row + 1}${SEP}${Math.max(column3 + 1, 0)}H`;
  return make42({
    commands: of(command)
  });
};
var cursorMove = (column3, row = 0) => {
  let command = "";
  if (row < 0) {
    command += `${ESC}${-row}A`;
  }
  if (row > 0) {
    command += `${ESC}${row}B`;
  }
  if (column3 > 0) {
    command += `${ESC}${column3}C`;
  }
  if (column3 < 0) {
    command += `${ESC}${-column3}D`;
  }
  return make42({
    commands: of(command)
  });
};
var cursorDown = (lines3 = 1) => {
  const command = `${ESC}${lines3}B`;
  return make42({
    commands: of(command)
  });
};
var cursorLeft = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}G`)
});
var cursorSavePosition = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}s`)
});
var cursorRestorePosition = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}u`)
});
var cursorHide = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}?25l`)
});
var cursorShow = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}?25h`)
});
var eraseLines = (rows) => {
  let command = "";
  for (let i = 0; i < rows; i++) {
    command += `${ESC}2K` + (i < rows - 1 ? `${ESC}1A` : "");
  }
  if (rows > 0) {
    command += `${ESC}G`;
  }
  return make42({
    commands: of(command)
  });
};
var eraseEndLine = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}K`)
});
var eraseStartLine = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}1K`)
});
var eraseLine = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}2K`)
});
var eraseDown = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}J`)
});
var eraseUp = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}1J`)
});
var eraseScreen = /* @__PURE__ */ make42({
  commands: /* @__PURE__ */ of(`${ESC}2J`)
});
var stringify = (self) => stringifyInternal(self);
var combine10 = /* @__PURE__ */ dual(2, (self, that) => combineInternal(self, that));
var combineInternal = (self, that) => AnsiSemigroup.combine(self, that);
var stringifyInternal = (self) => {
  const displaySequence = toEscapeSequence(getSomes([some2(reset), self.foreground, self.background, self.bold, self.italicized, self.strikethrough, self.underlined]));
  const commandSequence = join(self.commands, "");
  return `${displaySequence}${commandSequence}`;
};

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/Ansi.js
var bold2 = bold;
var italicized2 = italicized;
var strikethrough2 = strikethrough;
var underlined2 = underlined;
var color2 = color;
var black3 = black2;
var red4 = red3;
var green3 = green2;
var yellow3 = yellow2;
var blue3 = blue2;
var cyan4 = cyan3;
var white4 = white3;
var blackBright2 = blackBright;
var cyanBright2 = cyanBright;
var bgRed2 = bgRed;
var bgYellow2 = bgYellow;
var bgBlue2 = bgBlue;
var bgCyan2 = bgCyan;
var bgBlackBright2 = bgBlackBright;
var combine11 = combine10;

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/flatten.js
var FlattenSymbolKey = "@effect/printer/Flatten";
var FlattenTypeId = /* @__PURE__ */ Symbol.for(FlattenSymbolKey);
var protoHash = {
  Flattened: (self) => combine(hash(self.value))(string(FlattenSymbolKey)),
  AlreadyFlat: (_) => combine(string("@effect/printer/Flattened/AlreadyFlat"))(string(FlattenSymbolKey)),
  NeverFlat: (_) => combine(string("@effect/printer/Flattened/NeverFlat"))(string(FlattenSymbolKey))
};
var protoEqual = {
  Flattened: (self, that) => isFlatten(that) && that._tag === "Flattened" && equals(self.value, that.value),
  AlreadyFlat: (_, that) => isFlatten(that) && that._tag === "AlreadyFlat",
  NeverFlat: (_, that) => isFlatten(that) && that._tag === "NeverFlat"
};
var proto4 = {
  [FlattenTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual[this._tag](this, that);
  }
};
var isFlatten = (u) => typeof u === "object" && u != null && FlattenTypeId in u;
var isFlattened = (self) => self._tag === "Flattened";
var isAlreadyFlat = (self) => self._tag === "AlreadyFlat";
var isNeverFlat = (self) => self._tag === "NeverFlat";
var flattened = (value5) => (() => {
  const op = Object.create(proto4);
  op._tag = "Flattened";
  op.value = value5;
  return op;
})();
var alreadyFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto4);
  op._tag = "AlreadyFlat";
  return op;
})();
var neverFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto4);
  op._tag = "NeverFlat";
  return op;
})();
var map19 = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case "Flattened": {
      return flattened(f(self.value));
    }
    case "AlreadyFlat": {
      return alreadyFlat;
    }
    case "NeverFlat": {
      return neverFlat;
    }
  }
});

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/doc.js
var DocSymbolKey = "@effect/printer/Doc";
var DocTypeId = /* @__PURE__ */ Symbol.for(DocSymbolKey);
var protoHash2 = {
  Fail: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Fail")),
  Empty: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Empty")),
  Char: (self) => combine(hash(DocSymbolKey))(string(self.char)),
  Text: (self) => combine(hash(DocSymbolKey))(string(self.text)),
  Line: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Line")),
  FlatAlt: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Cat: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Nest: (self) => combine(hash(DocSymbolKey))(combine(hash(self.indent))(hash(self.doc))),
  Union: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Column: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  WithPageWidth: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Nesting: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Annotated: (self) => combine(hash(DocSymbolKey))(combine(hash(self.annotation))(hash(self.doc)))
};
var protoEqual2 = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self, that) => isDoc(that) && that._tag === "Char" && self.char === that.char,
  Text: (self, that) => isDoc(that) && that._tag === "Text" && self.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self, that) => isDoc(that) && that._tag === "FlatAlt" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Cat: (self, that) => isDoc(that) && that._tag === "Cat" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Nest: (self, that) => isDoc(that) && that._tag === "Nest" && self.indent === that.indent && equals(that.doc)(self.doc),
  Union: (self, that) => isDoc(that) && that._tag === "Union" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Column: (self, that) => isDoc(that) && that._tag === "Column" && equals(that.react)(self.react),
  WithPageWidth: (self, that) => isDoc(that) && that._tag === "WithPageWidth" && equals(that.react)(self.react),
  Nesting: (self, that) => isDoc(that) && that._tag === "Nesting" && equals(that.react)(self.react),
  Annotated: (self, that) => isDoc(that) && that._tag === "Annotated" && equals(that.annotation)(self.annotation) && equals(that.doc)(self.doc)
};
var proto5 = {
  [DocTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash2[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual2[this._tag](this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isDoc = (u) => typeof u === "object" && u != null && DocTypeId in u;
var isEmpty10 = (self) => self._tag === "Empty";
var isChar = (self) => self._tag === "Char";
var isText = (self) => self._tag === "Text";
var isCat = (self) => self._tag === "Cat";
var isNest = (self) => self._tag === "Nest";
var char = (char4) => {
  const op = Object.create(proto5);
  op._tag = "Char";
  op.char = char4;
  return op;
};
var text = (text10) => {
  const op = Object.create(proto5);
  op._tag = "Text";
  op.text = text10;
  return op;
};
var flatAlt = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "FlatAlt";
  op.left = self;
  op.right = that;
  return op;
});
var union8 = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "Union";
  op.left = self;
  op.right = that;
  return op;
});
var cat = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "Cat";
  op.left = self;
  op.right = that;
  return op;
});
var empty30 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Empty";
  return op;
})();
var fail8 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Fail";
  return op;
})();
var hardLine = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Line";
  return op;
})();
var line = /* @__PURE__ */ flatAlt(hardLine, /* @__PURE__ */ char(" "));
var lineBreak = /* @__PURE__ */ flatAlt(hardLine, empty30);
var space = /* @__PURE__ */ char(" ");
var cats = (docs) => group2(vcat(docs));
var catWithLine = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(line, that)));
var catWithLineBreak = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(lineBreak, that)));
var catWithSpace = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(space, that)));
var concatWith = /* @__PURE__ */ dual(2, (docs, f) => matchRight(fromIterable(docs), {
  onEmpty: () => empty30,
  onNonEmpty: (init, last5) => reduceRight(init, last5, (curr, acc) => f(acc, curr))
}));
var vcat = (docs) => concatWith(docs, (left3, right3) => catWithLineBreak(left3, right3));
var hsep = (docs) => concatWith(docs, (left3, right3) => catWithSpace(left3, right3));
var vsep = (docs) => concatWith(docs, (left3, right3) => catWithLine(left3, right3));
var group2 = (self) => {
  switch (self._tag) {
    case "FlatAlt": {
      const flattened2 = changesUponFlattening(self.right);
      switch (flattened2._tag) {
        case "Flattened": {
          return union8(flattened2.value, self.left);
        }
        case "AlreadyFlat": {
          return union8(self.right, self.left);
        }
        case "NeverFlat": {
          return self.left;
        }
      }
    }
    case "Union": {
      return self;
    }
    default: {
      const flattened2 = changesUponFlattening(self);
      return isFlattened(flattened2) ? union8(flattened2.value, self) : self;
    }
  }
};
var column = (react) => {
  const op = Object.create(proto5);
  op._tag = "Column";
  op.react = react;
  return op;
};
var nesting = (react) => {
  const op = Object.create(proto5);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
var pageWidth = (react) => {
  const op = Object.create(proto5);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
var nest = /* @__PURE__ */ dual(2, (self, indent3) => indent3 === 0 ? self : (() => {
  const op = Object.create(proto5);
  op._tag = "Nest";
  op.indent = indent3;
  op.doc = self;
  return op;
})());
var align = (self) => column((position) => nesting((level) => nest(self, position - level)));
var hang = /* @__PURE__ */ dual(2, (self, indent3) => align(nest(self, indent3)));
var indent = /* @__PURE__ */ dual(2, (self, indent3) => hang(cat(spaces(indent3), self), indent3));
var flatten6 = (self) => runSync(flattenSafe(self));
var flattenSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail": {
      return self;
    }
    case "Empty": {
      return self;
    }
    case "Char": {
      return self;
    }
    case "Text": {
      return self;
    }
    case "Line": {
      return fail8;
    }
    case "FlatAlt": {
      return yield* flattenSafe(self.right);
    }
    case "Cat": {
      const left3 = yield* flattenSafe(self.left);
      const right3 = yield* flattenSafe(self.right);
      return cat(left3, right3);
    }
    case "Nest": {
      const doc = yield* flattenSafe(self.doc);
      return nest(doc, self.indent);
    }
    case "Union": {
      return yield* flattenSafe(self.left);
    }
    case "Column": {
      return column((position) => flatten6(self.react(position)));
    }
    case "WithPageWidth": {
      return pageWidth((pageWidth3) => flatten6(self.react(pageWidth3)));
    }
    case "Nesting": {
      return nesting((level) => flatten6(self.react(level)));
    }
    case "Annotated": {
      const doc = yield* flattenSafe(self.doc);
      return annotate(doc, self.annotation);
    }
  }
});
var changesUponFlattening = (self) => runSync(changesUponFlatteningSafe(self));
var changesUponFlatteningSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail":
    case "Line": {
      return neverFlat;
    }
    case "Empty":
    case "Char":
    case "Text": {
      return alreadyFlat;
    }
    case "FlatAlt": {
      const doc = yield* flattenSafe(self.right);
      return flattened(doc);
    }
    case "Cat": {
      const left3 = yield* changesUponFlatteningSafe(self.left);
      const right3 = yield* changesUponFlatteningSafe(self.right);
      if (isNeverFlat(left3) || isNeverFlat(right3)) {
        return neverFlat;
      }
      if (isFlattened(left3) && isFlattened(right3)) {
        return flattened(cat(left3.value, right3.value));
      }
      if (isFlattened(left3) && isAlreadyFlat(right3)) {
        return flattened(cat(left3.value, self.right));
      }
      if (isAlreadyFlat(left3) && isFlattened(right3)) {
        return flattened(cat(self.left, right3.value));
      }
      if (isAlreadyFlat(left3) && isAlreadyFlat(right3)) {
        return alreadyFlat;
      }
      throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document - please open an issue at https://github.com/IMax153/contentlayer/issues/new");
    }
    case "Nest": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map17(map19((doc) => nest(doc, self.indent))));
    }
    case "Union": {
      return flattened(self.left);
    }
    case "Column": {
      const doc = column((position) => runSync(flattenSafe(self.react(position))));
      return flattened(doc);
    }
    case "WithPageWidth": {
      const doc = pageWidth((pageWidth3) => runSync(flattenSafe(self.react(pageWidth3))));
      return flattened(doc);
    }
    case "Nesting": {
      const doc = nesting((level) => runSync(flattenSafe(self.react(level))));
      return flattened(doc);
    }
    case "Annotated": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map17(map19((doc) => annotate(doc, self.annotation))));
    }
  }
});
var annotate = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto5);
  op._tag = "Annotated";
  op.doc = self;
  op.annotation = annotation;
  return op;
});
var spaces = (n) => {
  if (n <= 0) {
    return empty30;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
var textSpaces = (n) => {
  let s = "";
  for (let i = 0; i < n; i++) {
    s = s += " ";
  }
  return s;
};

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/docStream.js
var DocStreamSymbolKey = "@effect/printer/DocStream";
var DocStreamTypeId = /* @__PURE__ */ Symbol.for(DocStreamSymbolKey);
var protoHash3 = {
  FailedStream: (_) => pipe(string("@effect/printer/DocStream/FailedStream"), combine(string(DocStreamSymbolKey))),
  EmptyStream: (_) => pipe(string("@effect/printer/DocStream/EmptyStream"), combine(string(DocStreamSymbolKey))),
  CharStream: (self) => pipe(hash("@effect/printer/DocStream/CharStream"), combine(string(DocStreamSymbolKey)), combine(string(self.char)), combine(hash(self.stream))),
  TextStream: (self) => pipe(string("@effect/printer/DocStream/TextStream"), combine(string(DocStreamSymbolKey)), combine(string(self.text)), combine(hash(self.stream))),
  LineStream: (self) => pipe(string("@effect/printer/DocStream/LineStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream))),
  PushAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.annotation)), combine(hash(self.stream))),
  PopAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream)))
};
var protoEqual3 = {
  FailedStream: (self, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self, that) => isDocStream(that) && that._tag === "CharStream" && self.char === that.char && equals(self.stream, that.stream),
  TextStream: (self, that) => isDocStream(that) && that._tag === "TextStream" && self.text === that.text && equals(self.stream, that.stream),
  LineStream: (self, that) => isDocStream(that) && that._tag === "LineStream" && equals(self.stream, that.stream),
  PushAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && equals(self.annotation, that.annotation) && equals(self.stream, that.stream),
  PopAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && equals(self.stream, that.stream)
};
var proto6 = {
  [DocStreamTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash3[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual3[this._tag](this, that);
  }
};
var isDocStream = (u) => typeof u === "object" && u != null && DocStreamTypeId in u;
var isEmptyStream = (self) => self._tag === "EmptyStream";
var isLineStream = (self) => self._tag === "LineStream";
var failed = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto6);
  op._tag = "FailedStream";
  return op;
})();
var empty31 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto6);
  op._tag = "EmptyStream";
  return op;
})();
var char2 = /* @__PURE__ */ dual(2, (self, char4) => {
  const op = Object.create(proto6);
  op._tag = "CharStream";
  op.char = char4;
  op.stream = self;
  return op;
});
var text2 = /* @__PURE__ */ dual(2, (self, text10) => {
  const op = Object.create(proto6);
  op._tag = "TextStream";
  op.text = text10;
  op.stream = self;
  return op;
});
var line2 = /* @__PURE__ */ dual(2, (self, indentation) => {
  const op = Object.create(proto6);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self;
  return op;
});
var pushAnnotation = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto6);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self;
  return op;
});
var popAnnotation = (stream3) => {
  const op = Object.create(proto6);
  op._tag = "PopAnnotationStream";
  op.stream = stream3;
  return op;
};

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/layoutPipeline.js
var nil2 = {
  _tag: "Nil"
};
var cons2 = (indent3, document2, pipeline) => ({
  _tag: "Cons",
  indent: indent3,
  document: document2,
  pipeline
});
var undoAnnotation = (pipeline) => ({
  _tag: "UndoAnnotation",
  pipeline
});

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/pageWidth.js
var PageWidthSymbolKey = "@effect/printer/PageWidth";
var PageWidthTypeId = /* @__PURE__ */ Symbol.for(PageWidthSymbolKey);
var protoHash4 = {
  AvailablePerLine: (self) => pipe(hash("@effect/printer/PageWidth/AvailablePerLine"), combine(hash(PageWidthSymbolKey)), combine(hash(self.lineWidth)), combine(hash(self.ribbonFraction))),
  Unbounded: (_) => pipe(hash("@effect/printer/PageWidth/Unbounded"), combine(hash(PageWidthSymbolKey)))
};
var protoEqual4 = {
  AvailablePerLine: (self, that) => isPageWidth(that) && that._tag === "AvailablePerLine" && self.lineWidth === that.lineWidth && self.ribbonFraction === that.ribbonFraction,
  Unbounded: (self, that) => isPageWidth(that) && that._tag === "Unbounded"
};
var proto7 = {
  [PageWidthTypeId]: PageWidthTypeId,
  [symbol]() {
    return cached(this, protoHash4[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual4[this._tag](this, that);
  }
};
var isPageWidth = (u) => typeof u === "object" && u != null && PageWidthTypeId in u;
var availablePerLine = (lineWidth, ribbonFraction) => {
  const op = Object.create(proto7);
  op._tag = "AvailablePerLine";
  op.lineWidth = lineWidth;
  op.ribbonFraction = ribbonFraction;
  return op;
};
var unbounded2 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto7);
  op._tag = "Unbounded";
  return op;
})();
var defaultPageWidth = /* @__PURE__ */ availablePerLine(80, 1);
var remainingWidth = (pageWidth3, ribbonFraction, indentation, currentColumn) => {
  const columnsLeftInLine = pageWidth3 - currentColumn;
  const ribbonWidth = Math.max(0, Math.min(pageWidth3, Math.floor(pageWidth3 * ribbonFraction)));
  const columnsLeftInRibbon = indentation + ribbonWidth - currentColumn;
  return Math.min(columnsLeftInLine, columnsLeftInRibbon);
};

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/layout.js
var options = (pageWidth3) => ({
  pageWidth: pageWidth3
});
var wadlerLeijen = /* @__PURE__ */ dual(3, (self, fits, options3) => runSync(wadlerLeijenSafe(cons2(0, self, nil2), 0, 0, fits, options3)));
var wadlerLeijenSafe = (self, nestingLevel, currentColumn, fits, options3) => {
  const best = (self2, nl, cc) => gen2(function* () {
    switch (self2._tag) {
      case "Nil": {
        return empty31;
      }
      case "Cons": {
        switch (self2.document._tag) {
          case "Fail": {
            return failed;
          }
          case "Empty": {
            return yield* best(self2.pipeline, nl, cc);
          }
          case "Char": {
            const stream3 = yield* best(self2.pipeline, nl, cc + 1);
            return char2(stream3, self2.document.char);
          }
          case "Text": {
            const length3 = self2.document.text.length;
            const stream3 = yield* best(self2.pipeline, nl, cc + length3);
            return text2(stream3, self2.document.text);
          }
          case "Line": {
            const stream3 = yield* best(self2.pipeline, self2.indent, self2.indent);
            const nextIndent = isEmptyStream(stream3) || isLineStream(stream3) ? 0 : self2.indent;
            return line2(stream3, nextIndent);
          }
          case "FlatAlt": {
            const next = cons2(self2.indent, self2.document.left, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Cat": {
            const inner = cons2(self2.indent, self2.document.right, self2.pipeline);
            const outer = cons2(self2.indent, self2.document.left, inner);
            return yield* best(outer, nl, cc);
          }
          case "Nest": {
            const indent3 = self2.indent + self2.document.indent;
            const next = cons2(indent3, self2.document.doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Union": {
            const leftPipeline = cons2(self2.indent, self2.document.left, self2.pipeline);
            const rightPipeline = cons2(self2.indent, self2.document.right, self2.pipeline);
            const left3 = best(leftPipeline, nl, cc);
            const right3 = best(rightPipeline, nl, cc);
            return selectNicer(fits, nl, cc, left3, right3);
          }
          case "Column": {
            const doc = self2.document.react(cc);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "WithPageWidth": {
            const doc = self2.document.react(options3.pageWidth);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Nesting": {
            const doc = self2.document.react(self2.indent);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Annotated": {
            const undo = undoAnnotation(self2.pipeline);
            const next = cons2(self2.indent, self2.document.doc, undo);
            const stream3 = yield* best(next, nl, cc);
            return pushAnnotation(stream3, self2.document.annotation);
          }
        }
      }
      case "UndoAnnotation": {
        const stream3 = yield* best(self2.pipeline, nestingLevel, currentColumn);
        return popAnnotation(stream3);
      }
    }
  });
  return best(self, nestingLevel, currentColumn);
};
var selectNicer = (fits, lineIndent, currentColumn, left3, right3) => {
  const leftStream = runSync(left3);
  let rightStream = void 0;
  return fits(leftStream, lineIndent, currentColumn, () => rightStream ?? (rightStream = runSync(right3), rightStream)) ? leftStream : rightStream ?? runSync(right3);
};
var compact2 = (self) => runSync(compactSafe(of3(self), 0));
var compactSafe = (docs, i) => gen2(function* () {
  if (isNil(docs)) {
    return empty31;
  }
  const head5 = docs.head;
  const tail = docs.tail;
  switch (head5._tag) {
    case "Fail": {
      return failed;
    }
    case "Empty": {
      return yield* compactSafe(tail, i);
    }
    case "Char": {
      const stream3 = yield* compactSafe(tail, i + 1);
      return char2(stream3, head5.char);
    }
    case "Text": {
      const stream3 = yield* compactSafe(tail, i + head5.text.length);
      return text2(stream3, head5.text);
    }
    case "Line": {
      const stream3 = yield* compactSafe(tail, 0);
      return line2(stream3, 0);
    }
    case "FlatAlt": {
      return yield* compactSafe(cons(head5.left, tail), i);
    }
    case "Cat": {
      const list4 = cons(head5.left, cons(head5.right, tail));
      return yield* compactSafe(list4, i);
    }
    case "Nest": {
      return yield* compactSafe(cons(head5.doc, tail), i);
    }
    case "Union": {
      return yield* compactSafe(cons(head5.right, tail), i);
    }
    case "Column": {
      return yield* compactSafe(cons(head5.react(i), tail), i);
    }
    case "WithPageWidth": {
      return yield* compactSafe(cons(head5.react(unbounded2), tail), i);
    }
    case "Nesting": {
      return yield* compactSafe(cons(head5.react(0), tail), i);
    }
    case "Annotated": {
      return yield* compactSafe(cons(head5.doc, tail), i);
    }
  }
});
var pretty4 = /* @__PURE__ */ dual(2, (self, options3) => {
  const width3 = options3.pageWidth;
  if (width3._tag === "AvailablePerLine") {
    return wadlerLeijen(self, (stream3, indentation, currentColumn) => {
      const remainingWidth2 = remainingWidth(width3.lineWidth, width3.ribbonFraction, indentation, currentColumn);
      return fitsPretty(stream3, remainingWidth2);
    }, options3);
  }
  return unbounded3(self);
});
var fitsPretty = (self, width3) => {
  let w = width3;
  let stream3 = self;
  while (w >= 0) {
    switch (stream3._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        w = w - stream3.text.length;
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        return true;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  return false;
};
var smart = /* @__PURE__ */ dual(2, (self, options3) => {
  const width3 = options3.pageWidth;
  if (width3._tag === "AvailablePerLine") {
    return wadlerLeijen(self, fitsSmart(width3.lineWidth, width3.ribbonFraction), options3);
  }
  return unbounded3(self);
});
var fitsSmart = (pageWidth3, ribbonFraction) => {
  return (stream3, indentation, currentColumn, comparator) => {
    const availableWidth = remainingWidth(pageWidth3, ribbonFraction, indentation, currentColumn);
    return fitsSmartLoop(stream3, comparator, pageWidth3, currentColumn, availableWidth);
  };
};
var fitsSmartLoop = (self, comparator, pageWidth3, currentColumn, availableWidth) => {
  let minNestingLevel;
  let stream3 = self;
  let w = availableWidth;
  while (w >= 0) {
    switch (stream3._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        w = w - stream3.text.length;
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        if (!minNestingLevel) {
          minNestingLevel = match2(getInitialIndentation(comparator()), {
            // Definitely not a hanging layout. Return the same `minNestingLevel` that
            // subsequent lines with the same indentation use
            onNone: () => currentColumn,
            // Could be a (less wide) hanging layout, so take the minimum of the indent
            // and the current column
            onSome: (value5) => Math.min(value5, currentColumn)
          });
        }
        if (minNestingLevel < stream3.indentation) {
          return false;
        }
        w = pageWidth3 - stream3.indentation;
        stream3 = stream3.stream;
        break;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  return false;
};
var getInitialIndentation = (self) => {
  let stream3 = self;
  while (stream3._tag === "LineStream" || stream3._tag === "PushAnnotationStream" || stream3._tag === "PopAnnotationStream") {
    if (stream3._tag === "LineStream") {
      return some2(stream3.indentation);
    }
    stream3 = stream3.stream;
  }
  return none2();
};
var unbounded3 = (self) => wadlerLeijen(self, (stream3) => !failsOnFirstLine(stream3), {
  pageWidth: unbounded2
});
var failsOnFirstLine = (self) => {
  let stream3 = self;
  while (1) {
    switch (stream3._tag) {
      case "FailedStream": {
        return true;
      }
      case "EmptyStream": {
        return false;
      }
      case "CharStream": {
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        return false;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  throw new Error("bug");
};

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/Doc.js
var char3 = char;
var text3 = text;
var empty32 = empty30;
var hardLine2 = hardLine;
var space2 = space;
var cat2 = cat;
var cats2 = cats;
var hsep2 = hsep;
var vsep2 = vsep;
var nest2 = nest;
var align2 = align;
var indent2 = indent;
var annotate2 = annotate;

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/internal/ansiDoc.js
var beep2 = /* @__PURE__ */ annotate2(empty32, beep);
var cursorTo2 = (column3, row) => annotate2(empty32, cursorTo(column3, row));
var cursorMove2 = (column3, row) => annotate2(empty32, cursorMove(column3, row));
var cursorDown2 = (lines3 = 1) => annotate2(empty32, cursorDown(lines3));
var cursorLeft2 = /* @__PURE__ */ annotate2(empty32, cursorLeft);
var cursorSavePosition2 = /* @__PURE__ */ annotate2(empty32, cursorSavePosition);
var cursorRestorePosition2 = /* @__PURE__ */ annotate2(empty32, cursorRestorePosition);
var cursorHide2 = /* @__PURE__ */ annotate2(empty32, cursorHide);
var cursorShow2 = /* @__PURE__ */ annotate2(empty32, cursorShow);
var eraseLines2 = (rows) => annotate2(empty32, eraseLines(rows));
var eraseLine2 = /* @__PURE__ */ annotate2(empty32, eraseLine);

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/PageWidth.js
var defaultPageWidth2 = defaultPageWidth;

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/Layout.js
var options2 = options;
var compact3 = compact2;
var pretty5 = pretty4;
var smart2 = smart;

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/internal/ansiRender.js
var render2 = /* @__PURE__ */ dual(2, (self, config2) => {
  switch (config2.style) {
    case "compact": {
      return renderStream(compact3(self));
    }
    case "pretty": {
      const width3 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream(pretty5(self, options2(width3)));
    }
    case "smart": {
      const width3 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream(smart2(self, options2(width3)));
    }
  }
});
var renderStream = (self) => runSync(renderSafe(self, of3(none9)));
var unsafePeek = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePeek - peeked at an empty stack - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return stack.head;
};
var unsafePop = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePop - popped from an empty stack - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return [stack.head, stack.tail];
};
var renderSafe = (self, stack) => {
  switch (self._tag) {
    case "FailedStream": {
      return dieMessage2("BUG: AnsiRender.renderSafe - attempted to render a failed doc stream - please report an issue at https://github.com/Effect-TS/printer/issues");
    }
    case "EmptyStream": {
      return succeed7("");
    }
    case "CharStream": {
      return map17(suspend4(() => renderSafe(self.stream, stack)), (rest) => self.char + rest);
    }
    case "TextStream": {
      return map17(suspend4(() => renderSafe(self.stream, stack)), (rest) => self.text + rest);
    }
    case "LineStream": {
      let indent3 = "\n";
      for (let i = 0; i < self.indentation; i++) {
        indent3 = indent3 += " ";
      }
      return map17(suspend4(() => renderSafe(self.stream, stack)), (rest) => indent3 + rest);
    }
    case "PushAnnotationStream": {
      const currentStyle = unsafePeek(stack);
      const nextStyle = combine10(self.annotation, currentStyle);
      return map17(suspend4(() => renderSafe(self.stream, cons(self.annotation, stack))), (rest) => stringify(nextStyle) + rest);
    }
    case "PopAnnotationStream": {
      const [, styles] = unsafePop(stack);
      const nextStyle = unsafePeek(styles);
      return map17(suspend4(() => renderSafe(self.stream, styles)), (rest) => stringify(nextStyle) + rest);
    }
  }
};

// ../../node_modules/.pnpm/@effect+printer-ansi@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer-ansi/dist/esm/AnsiDoc.js
var beep3 = beep2;
var cursorTo3 = cursorTo2;
var cursorMove3 = cursorMove2;
var cursorDown3 = cursorDown2;
var cursorLeft3 = cursorLeft2;
var cursorSavePosition3 = cursorSavePosition2;
var cursorRestorePosition3 = cursorRestorePosition2;
var cursorHide3 = cursorHide2;
var cursorShow3 = cursorShow2;
var eraseLines3 = eraseLines2;
var eraseLine3 = eraseLine2;
var render3 = render2;

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/internal/optimize.js
var optimize2 = /* @__PURE__ */ dual(2, (self, depth) => runSync(optimizeSafe(self, depth)));
var optimizeSafe = (self, depth) => {
  const optimize4 = (self2) => gen2(function* () {
    switch (self2._tag) {
      case "Fail":
      case "Empty":
      case "Char":
      case "Text":
      case "Line": {
        return self2;
      }
      case "FlatAlt": {
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return flatAlt(left3, right3);
      }
      case "Cat": {
        if (isEmpty10(self2.left)) {
          return yield* optimize4(self2.right);
        }
        if (isEmpty10(self2.right)) {
          return yield* optimize4(self2.left);
        }
        if (isChar(self2.left) && isChar(self2.right)) {
          return text(self2.left.char + self2.right.char);
        }
        if (isText(self2.left) && isChar(self2.right)) {
          return text(self2.left.text + self2.right.char);
        }
        if (isChar(self2.left) && isText(self2.right)) {
          return text(self2.left.char + self2.right.text);
        }
        if (isText(self2.left) && isText(self2.right)) {
          return text(self2.left.text + self2.right.text);
        }
        if (isChar(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isChar(self2.left) && isCat(self2.right) && isText(self2.right.left) || isText(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isText(self2.left) && isCat(self2.right) && isText(self2.right.left)) {
          const inner = yield* optimize4(cat(self2.left, self2.right.left));
          return yield* optimize4(cat(inner, self2.right.right));
        }
        if (isCat(self2.left) && isChar(self2.left.right) || isCat(self2.left) && isText(self2.left.right)) {
          const inner = yield* optimize4(cat(self2.left.right, self2.right));
          return yield* optimize4(cat(self2.left.left, inner));
        }
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return cat(left3, right3);
      }
      case "Nest": {
        if (self2.indent === 0) {
          return yield* optimize4(self2.doc);
        }
        if (isEmpty10(self2.doc) || isChar(self2.doc) || isText(self2.doc)) {
          return self2.doc;
        }
        if (isNest(self2.doc)) {
          const indent3 = self2.indent + self2.doc.indent;
          return yield* optimize4(nest(self2.doc.doc, indent3));
        }
        return nest(yield* optimize4(self2.doc), self2.indent);
      }
      case "Union": {
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return union8(left3, right3);
      }
      case "Column": {
        return depth._tag === "Shallow" ? self2 : column((position) => runSync(optimizeSafe(self2.react(position), depth)));
      }
      case "WithPageWidth": {
        return depth._tag === "Shallow" ? self2 : pageWidth((pageWidth3) => runSync(optimizeSafe(self2.react(pageWidth3), depth)));
      }
      case "Nesting": {
        return depth._tag === "Shallow" ? self2 : nesting((level) => runSync(optimizeSafe(self2.react(level), depth)));
      }
      case "Annotated": {
        return annotate(yield* optimize4(self2.doc), self2.annotation);
      }
    }
  });
  return optimize4(self);
};

// ../../node_modules/.pnpm/@effect+printer@0.47.0_@effect+typeclass@0.38.0_effect@3.19.14/node_modules/@effect/printer/dist/esm/Optimize.js
var Deep = {
  _tag: "Deep"
};
var optimize3 = optimize2;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/helpDoc/span.js
var text4 = (value5) => ({
  _tag: "Text",
  value: value5
});
var empty33 = /* @__PURE__ */ text4("");
var space3 = /* @__PURE__ */ text4(" ");
var code = (value5) => highlight(value5, white2);
var error3 = (value5) => highlight(value5, red2);
var highlight = (value5, color3) => ({
  _tag: "Highlight",
  value: typeof value5 === "string" ? text4(value5) : value5,
  color: color3
});
var strong = (value5) => ({
  _tag: "Strong",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var weak = (value5) => ({
  _tag: "Weak",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var isText3 = (self) => self._tag === "Text";
var concat2 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Sequence",
  left: self,
  right: that
}));
var getText = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value;
    }
    case "Highlight":
    case "Weak":
    case "Strong": {
      return getText(self.value);
    }
    case "Sequence": {
      return getText(self.left) + getText(self.right);
    }
  }
};
var spans = (spans2) => {
  const elements = fromIterable(spans2);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(concat2, elements[0]);
  }
  return empty33;
};
var isEmpty12 = (self) => size10(self) === 0;
var size10 = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value.length;
    }
    case "Highlight":
    case "Strong":
    case "Weak": {
      return size10(self.value);
    }
    case "Sequence": {
      return size10(self.left) + size10(self.right);
    }
  }
};
var toAnsiDoc = (self) => {
  switch (self._tag) {
    case "Highlight": {
      return annotate2(toAnsiDoc(self.value), color2(self.color));
    }
    case "Sequence": {
      return cat2(toAnsiDoc(self.left), toAnsiDoc(self.right));
    }
    case "Strong": {
      return annotate2(toAnsiDoc(self.value), bold2);
    }
    case "Text": {
      return text3(self.value);
    }
    case "URI": {
      return annotate2(text3(self.value), underlined2);
    }
    case "Weak": {
      return annotate2(toAnsiDoc(self.value), black3);
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/helpDoc.js
var isEmpty13 = (helpDoc) => helpDoc._tag === "Empty";
var isHeader = (helpDoc) => helpDoc._tag === "Header";
var isParagraph = (helpDoc) => helpDoc._tag === "Paragraph";
var isDescriptionList = (helpDoc) => helpDoc._tag === "DescriptionList";
var empty34 = {
  _tag: "Empty"
};
var sequence = /* @__PURE__ */ dual(2, (self, that) => {
  if (isEmpty13(self)) {
    return that;
  }
  if (isEmpty13(that)) {
    return self;
  }
  return {
    _tag: "Sequence",
    left: self,
    right: that
  };
});
var blocks = (helpDocs) => {
  const elements = fromIterable(helpDocs);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty34;
};
var getSpan = (self) => isHeader(self) || isParagraph(self) ? self.value : empty33;
var descriptionList = (definitions) => ({
  _tag: "DescriptionList",
  definitions
});
var enumeration = (elements) => ({
  _tag: "Enumeration",
  elements
});
var h1 = (value5) => ({
  _tag: "Header",
  value: typeof value5 === "string" ? text4(value5) : value5,
  level: 1
});
var p = (value5) => ({
  _tag: "Paragraph",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var mapDescriptionList = /* @__PURE__ */ dual(2, (self, f) => isDescriptionList(self) ? descriptionList(map4(self.definitions, ([span2, helpDoc]) => f(span2, helpDoc))) : self);
var toAnsiDoc2 = (self) => optimize3(toAnsiDocInternal(self), Deep);
var toAnsiText = (self) => render3(toAnsiDoc2(self), {
  style: "pretty"
});
var toAnsiDocInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty32;
    }
    case "Header": {
      return pipe(annotate2(toAnsiDoc(self.value), bold2), cat2(hardLine2));
    }
    case "Paragraph": {
      return pipe(toAnsiDoc(self.value), cat2(hardLine2));
    }
    case "DescriptionList": {
      const definitions = self.definitions.map(([span2, doc]) => cats2([annotate2(toAnsiDoc(span2), bold2), empty32, indent2(toAnsiDocInternal(doc), 2)]));
      return vsep2(definitions);
    }
    case "Enumeration": {
      const elements = self.elements.map((doc) => cat2(text3("- "), toAnsiDocInternal(doc)));
      return indent2(vsep2(elements), 2);
    }
    case "Sequence": {
      return vsep2([toAnsiDocInternal(self.left), toAnsiDocInternal(self.right)]);
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/HelpDoc.js
var p2 = p;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ConfigError.js
var isConfigError2 = isConfigError;
var isMissingDataOnly2 = isMissingDataOnly;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto8 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make43 = (value5) => {
  const redacted4 = Object.create(proto8);
  redactedRegistry.set(redacted4, value5);
  return redacted4;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto8,
  [SecretTypeId]: SecretTypeId
};
var make44 = (bytes) => {
  const secret4 = Object.create(SecretProto);
  Object.defineProperty(secret4, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret4, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret4, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret4, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret4;
};
var fromString = (text10) => {
  return make44(text10.split("").map((char4) => char4.charCodeAt(0)));
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto9 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Config.js
var isConfig2 = isConfig;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var memoizeThunk = (f) => {
  let done8 = false;
  let a;
  return () => {
    if (done8) {
      return a;
    }
    a = f();
    done8 = true;
    return a;
  };
};
var isNonEmpty5 = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path2) => isNonEmpty5(path2) ? path2.map(formatPathKey).join("") : formatPathKey(path2);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path2, ast) => {
  let out = reason;
  if (path2 && isNonEmptyReadonlyArray(path2)) {
    out += `
at path: ${formatPath(path2)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getSchemaExtendErrorMessage = (x, y, path2) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path2);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type2) => getErrorMessage("Duplicate index signature", `${type2} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/SchemaAST.js
var TypeConstructorAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/TypeConstructor");
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown3, encodeUnknown3, annotations2 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown3;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag4) => (ast) => ast._tag === tag4;
var Literal = class {
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal2, annotations2 = {}) {
    this.literal = literal2;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var UniqueSymbol = class {
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations2 = {}) {
    this.symbol = symbol3;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var UndefinedKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var VoidKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "VoidKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var NeverKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var UnknownKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var AnyKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var StringKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var SymbolKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var Type = class {
  type;
  annotations;
  constructor(type2, annotations2 = {}) {
    this.type = type2;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  isOptional;
  constructor(type2, isOptional, annotations2 = {}) {
    super(type2, annotations2);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations2 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations2;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head5, tail) => {
      const formattedHead = String(head5);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var PropertySignature = class extends OptionalType {
  name;
  isReadonly;
  constructor(name, type2, isOptional, isReadonly, annotations2) {
    super(type2, isOptional, annotations2);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type2, isReadonly) {
    this.type = type2;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations2 = {}) {
    this.annotations = annotations2;
    const keys6 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten8 = (candidates) => flatMap2(candidates, (ast) => isUnion3(ast) ? flatten8(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type2 = typeof ast.literal;
        switch (type2) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type2];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var Union = class _Union {
  types;
  annotations;
  static make = (types, annotations2) => {
    return isMembers(types) ? new _Union(types, annotations2) : types.length === 1 ? types[0] : neverKeyword;
  };
  /** @internal */
  static unify = (candidates, annotations2) => {
    return _Union.make(unify(flatten8(candidates)), annotations2);
  };
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations2 = {}) {
    this.types = types;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var mapMembers = (members, f) => members.map(f);
var isMembers = (as9) => as9.length > 1;
var isUnion3 = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f, annotations2 = {}) {
    this.f = f;
    this.annotations = annotations2;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse2(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var Refinement = class {
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter11, annotations2 = {}) {
    this.from = from;
    this.filter = filter11;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse2(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations2 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode4, encode3) {
    this.decode = decode4;
    this.encode = encode3;
  }
};
var createTransformationGuard = (tag4) => (ast) => ast._tag === tag4;
var ComposeTransformation = class {
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
var composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var PropertySignatureTransformation = class {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode4, encode3) {
    this.from = from;
    this.to = to;
    this.decode = decode4;
    this.encode = encode3;
  }
};
var TypeLiteralTransformation = class {
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value5 = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value5[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value5;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type2, capture2) => {
  switch (type2._tag) {
    case "Literal":
      return escape(String(type2.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type2, capture2, false);
    case "Union":
      return type2.types.map((type3) => getTemplateLiteralSpanTypePattern(type3, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type2, s, capture2, top) => {
  if (isUnion3(type2)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head5 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head5})` : head5;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture2, top);
    if (span2.literal !== "") {
      const literal2 = escape(span2.literal);
      pattern2 += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern2;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var record = (key, value5) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go2 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value5, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value5, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value5, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value5, false, true));
        break;
      case "Union":
        key2.types.forEach(go2);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go2(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = void 0;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out === void 0) {
        out = {};
      }
      out[id2] = annotated.annotations[id2];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id2 of annotationIds) {
    delete out[id2];
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = typeAST(e.type);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type2) => new Type(type2)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p3) => {
        const type2 = typeAST(p3.type);
        return type2 === p3.type ? p3 : new PropertySignature(p3.name, type2, p3.isOptional, p3.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = typeAST(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
function changeMap(as9, f) {
  let changed = false;
  const out = allocate(as9.length);
  for (let i = 0; i < as9.length; i++) {
    const a = as9[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as9;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = encodedAST_(e.type, isBound);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type2 = encodedAST_(ps.type, isBound);
        return type2 === ps.type ? ps : new PropertySignature(ps.name, type2, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = encodedAST_(is3.type, isBound);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = void 0;
      const identifier2 = getJSONIdentifier(ast);
      if (isSome2(identifier2)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier2.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) return ast;
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var formatKeyword = (ast) => getOrElse2(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path2, actual, issue) {
    this.path = path2;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var ParseError = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError({
  issue
});
var succeed9 = right2;
var fail11 = left2;
var _try = try_;
var fromOption3 = fromOption2;
var isEither3 = isEither2;
var flatMap10 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: left2,
    onRight: f
  }) : flatMap9(self, f);
});
var map23 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? map(self, f) : map17(self, f);
});
var mapError3 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? mapLeft(self, f) : mapError2(self, f);
});
var mapBoth5 = /* @__PURE__ */ dual(2, (self, options3) => {
  return isEither3(self) ? mapBoth(self, {
    onLeft: options3.onFailure,
    onRight: options3.onSuccess
  }) : mapBoth4(self, options3);
});
var orElse7 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: f,
    onRight: right2
  }) : catchAll2(self, f);
});
var mergeInternalOptions = (options3, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options3;
  }
  if (options3 === void 0) {
    return overrideOptions;
  }
  return {
    ...options3,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options3, overrideOptions));
};
var getSync = (ast, isDecoding, options3) => {
  const parser = getEither(ast, isDecoding, options3);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options3, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options3) => getSync(schema.ast, true, options3);
var decodeUnknown = (schema, options3) => getEffect(schema.ast, true, options3);
var encodeUnknownSync = (schema, options3) => getSync(schema.ast, false, options3);
var encodeUnknown = (schema, options3) => getEffect(schema.ast, false, options3);
var decodeSync = decodeUnknownSync;
var validateSync = (schema, options3) => getSync(typeAST(schema.ast), true, options3);
var is = (schema, options3) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options3, overrideOptions)
  }));
};
var encodeSync = encodeUnknownSync;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options3) => raw(i, mergeInternalOptions(options3, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options3) => handleForbidden(orElse7(parserWithOptions(i, options3), decodingFallbackAnnotation.value), ast, i, options3) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options3) => {
          options3 = options3 ?? defaultParseOption;
          const allErrors = options3?.errors === "all";
          const result = flatMap10(orElse7(from(i, options3), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options3, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options3, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options3);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options3) => handleForbidden(flatMap10(from(i, options3), (a) => to(a, options3)), ast, i, options3);
      }
    }
    case "Transformation": {
      const transform3 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options3) => handleForbidden(flatMap10(mapError3(from(i, options3), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap10(mapError3(transform3(a, options3 ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError3(to(i2, options3), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options3);
    }
    case "Declaration": {
      const parse6 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options3) => handleForbidden(parse6(i, options3 ?? defaultParseOption, ast), ast, i, options3);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value5]) => value5 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head5, ...tail] = rest;
          for (; i < len - tail.length; i++) {
            const te = head5(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options3);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is3) => [goMemo(is3.parameter, isDecoding), goMemo(is3.type, isDecoding), is3.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is3) => is3.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options3?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options3?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options3);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options3?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options3);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap9(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type2 = indexSignature[1];
          const keys6 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = parameter(key, options3);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type2(input[key], options3);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options3?.propertyOrder === "original") {
            const keys6 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map35 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map35.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options3) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map35.get(candidate)(input, options3);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap9(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get16 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options3) => get16()(a, options3);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type2 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type2) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type2]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type2 = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type2) && !element.isOptional) {
          out.push([i, type2]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags2 = getLiterals(member, isDecoding);
    if (tags2.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags2.length; j++) {
        const [key, literal2] = tags2[j];
        const hash2 = String(literal2.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags2.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect3, ast, actual, options3) => {
  if (options3?.isEffectAllowed === true) {
    return effect3;
  }
  if (isEither3(effect3)) {
    return effect3;
  }
  const scheduler = new SyncScheduler();
  const fiber = runFork2(effect3, {
    scheduler
  });
  scheduler.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess(exit4)) {
      return right2(exit4.value);
    }
    const cause2 = exit4.cause;
    if (isFailType2(cause2)) {
      return left2(cause2.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause2)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map23(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value5, forest = []) => ({
  value: value5,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map23(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error4) => TreeFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => TreeFormatter.formatIssueSync(error4.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union11 = messageAnnotation(issue);
    if (isString(union11)) {
      return right2({
        message: union11,
        override: false
      });
    }
    if (isEffect2(union11)) {
      return map17(union11, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union11.message)) {
      return right2({
        message: union11.message,
        override: union11.override
      });
    }
    return map17(union11.message, (message) => ({
      message,
      override: union11.override
    }));
  }
}));
var createParseIssueGuard = (tag4) => (issue) => issue._tag === tag4;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap10(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse2(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map23(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map23(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map23(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map23(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty5(issue.issues) ? map23(forEach8(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map23(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/layer/circular.js
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Layer.js
var effect = fromEffect3;
var merge7 = merge5;
var mergeAll5 = mergeAll3;
var scoped3 = scoped;
var succeed10 = succeed5;
var provide3 = provide;
var provideMerge2 = provideMerge;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/cliConfig.js
var Tag3 = /* @__PURE__ */ GenericTag("@effect/cli/CliConfig");
var defaultConfig = {
  isCaseSensitive: false,
  autoCorrectLimit: 2,
  finalCheckBuiltIn: false,
  showAllNames: true,
  showBuiltIns: true,
  showTypes: true
};
var normalizeCase = /* @__PURE__ */ dual(2, (self, text10) => self.isCaseSensitive ? text10 : text10.toLowerCase());

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/autoCorrect.js
var levensteinDistance = (first3, second, config2) => {
  if (first3.length === 0 && second.length === 0) {
    return 0;
  }
  if (first3.length === 0) {
    return second.length;
  }
  if (second.length === 0) {
    return first3.length;
  }
  const rowCount = first3.length;
  const columnCount = second.length;
  const matrix = new Array(rowCount);
  const normalFirst = normalizeCase(config2, first3);
  const normalSecond = normalizeCase(config2, second);
  for (let x = 0; x <= rowCount; x++) {
    matrix[x] = new Array(columnCount);
    matrix[x][0] = x;
  }
  for (let y = 0; y <= columnCount; y++) {
    matrix[0][y] = y;
  }
  for (let row = 1; row <= rowCount; row++) {
    for (let col = 1; col <= columnCount; col++) {
      const cost = normalFirst.charAt(row - 1) === normalSecond.charAt(col - 1) ? 0 : 1;
      matrix[row][col] = Math.min(matrix[row][col - 1] + 1, Math.min(matrix[row - 1][col] + 1, matrix[row - 1][col - 1] + cost));
    }
  }
  return matrix[rowCount][columnCount];
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Brand.js
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var nominal = () => {
  return Object.assign((args3) => args3, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args3) => some2(args3),
    either: (args3) => right2(args3),
    is: (_args) => true
  });
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberRef.js
var currentContext2 = currentContext;
var currentLoggers2 = currentLoggers;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var QueueImpl = class extends Class2 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map11(this.size, (size13) => size13 <= 0);
  }
  get isFull() {
    return map11(this.size, (size13) => size13 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value5) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value5);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value5);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value5) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value5);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value5);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value5], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values4 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values4.length)) : empty2;
      const [forTakers, remaining] = pipe(values4, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values4 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values4);
      });
    });
  }
  takeUpTo(max6) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values4 = this.queue.pollUpTo(max6);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values4);
    }));
  }
  takeBetween(min4, max6) {
    return suspend(() => takeRemainderLoop(this, min4, max6, empty5()));
  }
};
var takeRemainderLoop = (self, min4, max6, acc) => {
  if (max6 < min4) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max6), flatMap7((bs) => {
    const remaining = min4 - bs.length;
    if (remaining === 1) {
      return pipe(take3(self), map11((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take3(self), flatMap7((b) => takeRemainderLoop(self, remaining - 1, max6 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make45(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make45(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make45(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded4 = () => pipe(sync(() => unbounded()), flatMap7((queue) => make45(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake7 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make45 = (queue, strategy) => pipe(deferredMake(), map11((deferred) => unsafeMake7(queue, unbounded(), deferred, make13(false), strategy)));
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable2) {
    this.mutable = mutable2;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable2) => new BackingQueueFromMutableQueue(mutable2);
var size11 = (self) => self.size;
var shutdown = (self) => self.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self, value5) => self.offer(value5));
var take3 = (self) => self.take;
var takeUpTo = /* @__PURE__ */ dual(2, (self, max6) => self.takeUpTo(max6));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap7((fiberId2) => pipe(sync(() => unsafePollAll(this.putters)), flatMap7((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId2), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown3) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown3) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value5 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value5, deferred, true]));
      } else {
        pipe(this.putters, offer([value5, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
};
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as9) => {
  return pipe(queue, offerAll(as9));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max6) => {
  return pipe(queue, pollUpTo(max6));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Queue.js
var bounded3 = bounded2;
var dropping2 = dropping;
var sliding2 = sliding;
var unbounded5 = unbounded4;
var size12 = size11;
var shutdown2 = shutdown;
var offer3 = offer2;
var take4 = take3;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto10 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto10);
  op._tag = OP_CONTINUE2;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer2) {
    this.finalizer = finalizer2;
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto11 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto11);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto12 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
  const op = Object.create(proto12);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release;
  return op;
});
var collectElements = (self) => {
  return suspend6(() => {
    const builder = [];
    return flatMap12(pipeTo(self, collectElementsReader(builder)), (value5) => sync6(() => [fromIterable2(builder), value5]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap12(sync6(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail13,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto12);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h) => {
  const op = Object.create(proto12);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self, input) => {
  const op = Object.create(proto12);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer2) => {
  const op = Object.create(proto12);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer2;
  return op;
});
var fail13 = (error4) => failCause8(fail4(error4));
var failCause8 = (cause2) => failCauseSync3(() => cause2);
var failCauseSync3 = (evaluate3) => {
  const op = Object.create(proto12);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
};
var flatMap12 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto12);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause8);
  return op;
});
var fromEffect4 = (effect3) => {
  const op = Object.create(proto12);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect3;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto12);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var readWith = (options3) => readWithCause({
  onInput: options3.onInput,
  onFailure: (cause2) => match(failureOrCause2(cause2), {
    onLeft: options3.onFailure,
    onRight: failCause8
  }),
  onDone: options3.onDone
});
var readWithCause = (options3) => {
  const op = Object.create(proto12);
  op._tag = OP_READ;
  op.more = options3.onInput;
  op.done = new ContinuationKImpl(options3.onDone, options3.onFailure);
  return op;
};
var succeed11 = (value5) => sync6(() => value5);
var succeedNow = (result) => {
  const op = Object.create(proto12);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend6 = (evaluate3) => {
  const op = Object.create(proto12);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
};
var sync6 = (evaluate3) => {
  const op = Object.create(proto12);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto12);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto13 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto13);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto13);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect3) => {
  const op = Object.create(proto13);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect3;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone2) => {
  const op = Object.create(proto13);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone2;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : void 0;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith4(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith4(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith4(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value5, next) {
    this.value = value5;
    this.next = next;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto14 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value5) => {
  const op = Object.create(proto14);
  op._tag = OP_PULLED;
  op.value = value5;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto14);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap9(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: (value5) => bridgeInput.done(value5)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap9(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause2) => bridgeInput.error(cause2));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap9(forkDaemon2(interruptible4(drainer())), (fiber) => sync4(() => this.addFinalizer((exit4) => flatMap9(interrupt4(fiber), () => suspend4(() => {
                    const effect3 = this.restorePipe(exit4, inputExecutor);
                    return effect3 !== void 0 ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync4(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value5) => channel.k(value5), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request) => channel.onPull(request), (value5) => channel.onEmit(value5));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect3, {
                  onFailure: (cause2) => {
                    const state = this.doneHalt(cause2);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value5) => {
                    const state = this.doneSucceed(value5);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect3 = this.restorePipe(exit4, previousInput);
                  return effect3 !== void 0 ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync4(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read3 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read3.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read3.done.onExit(die3(error4));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit3 = (exit5) => {
                    return read3.done.onExit(exit5);
                  };
                  this._currentChannel = onExit3(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause8(die4(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer2) {
    this._inProgressFinalizer = finalizer2;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect3 = currInput.close(exit4);
      return effect3;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer2 = this._inProgressFinalizer;
    if (finalizer2 !== void 0) {
      runInProgressFinalizers = pipe(finalizer2, ensuring2(sync4(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync4(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip5(exit3(ifNotNull(runInProgressFinalizers))),
      zip5(exit3(ifNotNull(closeSelf))),
      map17(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap9((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value5) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value5);
      this._currentChannel = void 0;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head5.onSuccess(value5);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value5);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value5));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync4(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync4(() => this.doneSucceed(value5))));
    return fromEffect5(effect3);
  }
  doneHalt(cause2) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head5.onHalt(cause2);
      } catch (error4) {
        this._currentChannel = failCause8(die4(error4));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause2));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync4(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync4(() => this.doneHalt(cause2))));
    return fromEffect5(effect3);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause2) => sync4(() => {
        this._currentChannel = failCause8(cause2);
      }),
      onSuccess: (out) => sync4(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === void 0) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring8) {
    this.addFinalizer(ensuring8.finalizer);
    this._currentChannel = ensuring8.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match9(exit4, {
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value5) => this.doneSucceed(value5)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach8((closeFunc) => pipe(sync4(() => closeFunc(subexecutorDone)), flatMap9((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value5) => this.doneSucceed(value5)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: (cause2) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause2), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map17(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map17(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map13((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed7(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect3) => effect3 !== void 0 ? effect3 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach8(finalizers, (fin) => exit3(fin(exit4))), map17((exits) => pipe(all2(exits), getOrElse2(() => void_3))), flatMap9((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read3 = () => {
    const current = readStack.pop();
    if (current === void 0 || current.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause2((cause2) => suspend4(() => {
          const doneEffect = current.onDone(failCause3(cause2));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend4(() => read3());
      }
    }
  };
  return read3();
};
var runIn = /* @__PURE__ */ dual(2, (self, scope4) => {
  const run10 = (channelDeferred, scopeDeferred, scope5) => acquireUseRelease2(sync4(() => new ChannelExecutor(self, void 0, identity)), (exec2) => suspend4(() => runScopedInterpret(exec2.run(), exec2).pipe(intoDeferred2(channelDeferred), zipRight3(_await3(channelDeferred)), zipLeft2(_await3(scopeDeferred)))), (exec2, exit4) => {
    const finalize = exec2.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause2(finalize, (cause2) => addFinalizer2(scope5, failCause6(cause2)));
  });
  return uninterruptibleMask3((restore) => all4([fork(scope4, sequential3), make38(), make38()]).pipe(flatMap9(([child, channelDeferred, scopeDeferred]) => restore(run10(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope4), flatMap9((fiber) => scope4.addFinalizer((exit4) => {
    const interruptors3 = isFailure(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone5(channelDeferred).pipe(flatMap9((isDone6) => isDone6 ? succeed6(scopeDeferred, void 0).pipe(zipRight3(_await2(fiber)), zipRight3(inheritAll2(fiber))) : succeed6(scopeDeferred, void 0).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt4(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await3(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec2) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap9(() => runScopedInterpret(exec2.run(), exec2)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec2.run(), exec2);
    }
    case OP_DONE3: {
      return suspend4(() => exec2.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec2.run(), exec2), failCause6);
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto15 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Await = (f) => {
  const op = Object.create(proto15);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto16 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto16);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto16);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto16);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto17 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto17);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto17);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match15 = /* @__PURE__ */ dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause2) => ({
  _tag: OP_STATE_ERROR,
  cause: cause2
});
var stateDone = (done8) => ({
  _tag: OP_STATE_DONE2,
  done: done8
});
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten5(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await3(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId2) => this.error(interrupt3(fiberId2)));
  }
  done(value5) {
    return flatten5(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => succeed6(deferred, left2(value5)), {
            discard: true
          }), stateDone(value5)];
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap9(make38(), (deferred) => flatten5(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed6(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    })));
  }
  error(cause2) {
    return flatten5(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => failCause5(deferred, cause2), {
            discard: true
          }), stateError(cause2)];
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause2) => failCause3(map14(cause2, left2)), (elem) => succeed3(elem), (done8) => fail3(right2(done8)));
  }
  takeWith(onError4, onElement, onDone2) {
    return flatMap9(make38(), (deferred) => flatten5(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed6(state.notifyProducer, void 0), matchCause3(_await3(deferred), {
            onFailure: onError4,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause3(_await3(deferred), {
            onFailure: onError4,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed7(onError4(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed7(onDone2(state.done)), state];
        }
      }
    })));
  }
};
var make46 = () => pipe(make38(), flatMap9((deferred) => make25(stateEmpty(deferred))), map17((ref) => new SingleProducerAsyncInputImpl(ref)));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap12(fromEffect4(make25(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap2(acquire, (a) => set5(ref, (exit4) => release(a, exit4))))), flatMap12(use), ensuringWith((exit4) => flatMap9(get11(ref), (f) => f(exit4)))));
var concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause8,
    onDone: succeed11
  });
  return pipeTo(self, drainer);
};
var ensuring3 = /* @__PURE__ */ dual(2, (self, finalizer2) => ensuringWith(self, () => finalizer2));
var flatten10 = (self) => flatMap12(self, identity);
var fromInput = (input) => unwrap2(input.takeWith(failCause8, (elem) => flatMap12(write(elem), () => fromInput(input)), succeed11));
var identityChannel = () => readWith({
  onInput: (input) => flatMap12(write(input), () => identityChannel()),
  onFailure: fail13,
  onDone: succeedNow
});
var map25 = /* @__PURE__ */ dual(2, (self, f) => flatMap12(self, (a) => sync6(() => f(a))));
var mapOut = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(f(outElem)), () => reader),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap12(write), flatMap12(() => reader)),
    onFailure: failCause8,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mergeAll6 = (options3) => {
  return (channels) => mergeAllWith(options3)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope4) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make46();
  const queueReader = fromInput(input);
  const queue = yield* bounded3(bufferSize);
  yield* addFinalizer2(scope4, shutdown2(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope4, shutdown2(cancelers));
  const lastDone = yield* make25(none2());
  const errorSignal = yield* make38();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope4);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap9(match({
      onLeft: (done8) => succeed7(some2(done8)),
      onRight: (outElem) => as4(offer3(queue, succeed7(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap9((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause2((cause2) => isInterrupted2(cause2) ? failCause6(cause2) : offer3(queue, failCause6(cause2)).pipe(zipRight3(succeed6(errorSignal, void 0)), asVoid2)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause2) => offer3(queue, failCause6(cause2)).pipe(zipRight3(succeed7(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await3(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as4(interrupt4(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight3(interrupt4(failureAwait), get11(lastDone).pipe(flatMap9(match2({
          onNone: () => offer3(queue, succeed7(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed7(left2(f(lastDone2, outDone))))
        })), as4(false)))
      }),
      onRight: (channel) => match15(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make38();
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => race2(exit3(evaluatePull(pull2)), exit3(interruptible4(_await3(errorSignal))))), flatMap9(identity)));
          yield* succeed6(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make38();
          const latch = yield* make38();
          const size13 = yield* size12(cancelers);
          yield* take4(cancelers).pipe(flatMap9((canceler2) => succeed6(canceler2, void 0)), when2(() => size13 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => exit3(evaluatePull(pull2)).pipe(race2(exit3(interruptible4(_await3(errorSignal)))), race2(exit3(interruptible4(_await3(canceler)))))), flatMap9(identity)));
          yield* succeed6(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope4));
  const consumer = pipe(take4(queue), flatten5, matchCause3({
    onFailure: failCause8,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap12(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self, f, options3) => mergeAll6(options3)(mapOut(self, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self, options3) => {
  function merge10(scope4) {
    return gen2(function* () {
      const input = yield* make46();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope4);
      const pullR = yield* toPullIn(pipeTo(queueReader, options3.other), scope4);
      function handleSide(exit4, fiber, pull) {
        return (done8, both2, single) => {
          function onDecision2(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed7(fromEffect4(zipRight3(interrupt4(fiber), op.effect)));
            }
            return map17(_await2(fiber), match9({
              onFailure: (cause2) => fromEffect4(op.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done9) => fromEffect4(op.f(succeed3(done9))),
                onRight: (elem) => zipRight4(write(elem), go2(single(op.f)))
              })
            }));
          }
          return match9(exit4, {
            onFailure: (cause2) => onDecision2(done8(failCause3(cause2))),
            onSuccess: match({
              onLeft: (z) => onDecision2(done8(succeed3(z))),
              onRight: (elem) => succeed7(flatMap12(write(elem), () => flatMap12(fromEffect4(forkIn2(interruptible4(pull), scope4)), (leftFiber) => go2(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go2(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt4(rf), handleSide(leftExit, state.right, pullL)(options3.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt4(lf), handleSide(rightExit, state.left, pullR)(options3.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map17(exit3(pullR), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map17(exit3(pullL), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope4));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope4));
        return zipWith4(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap12(go2), embedInput(input));
    });
  }
  return unwrapScopedWith(merge10);
});
var pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend6(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause8(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap12(() => writer)),
    onFailure: (cause2) => isDieType2(cause2) && isChannelException(cause2.defect) && equals(cause2.defect, channelException) ? fail13(cause2.defect.error) : failCause8(cause2),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var run = (self) => scopedWith2((scope4) => runIn(self, scope4));
var runDrain = (self) => run(drain(self));
var runScoped = (self) => scopeWith2((scope4) => runIn(self, scope4));
var scoped4 = (effect3) => unwrap2(uninterruptibleMask3((restore) => map17(make36(), (scope4) => acquireReleaseOut(tapErrorCause2(restore(extend2(effect3, scope4)), (cause2) => close(scope4, failCause3(cause2))), (_, exit4) => close(scope4, exit4)))));
var scopedWith3 = (f) => unwrapScoped2(map17(scope2, (scope4) => flatMap12(fromEffect4(f(scope4)), write)));
var splitLines = () => suspend6(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk4) => {
    const chunkBuilder = [];
    map5(chunk4, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop2 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop2 : flatMap12(write(out), () => loop2);
    },
    onFailure: (cause2) => stringBuilder.length === 0 ? failCause8(cause2) : flatMap12(write(of2(stringBuilder)), () => failCause8(cause2)),
    onDone: (done8) => stringBuilder.length === 0 ? succeed11(done8) : flatMap12(write(of2(stringBuilder)), () => succeed11(done8))
  });
  return loop2;
});
var toPullIn = /* @__PURE__ */ dual(2, (self, scope4) => zip5(sync4(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap2(([executor, runtime5]) => addFinalizerExit(scope4, (exit4) => {
  const finalizer2 = executor.close(exit4);
  return finalizer2 !== void 0 ? provide2(finalizer2, runtime5) : _void;
})), uninterruptible2, map17(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec2) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec2.getDone(), {
        onFailure: failCause6,
        onSuccess: (done8) => succeed7(left2(done8))
      });
    }
    case OP_EMIT2: {
      return succeed7(right2(exec2.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap9(() => interpretToPull(exec2.run(), exec2)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec2.run(), exec2), (cause2) => failCause6(cause2));
    }
  }
};
var unwrap2 = (channel) => flatten10(fromEffect4(channel));
var unwrapScoped2 = (self) => concatAllWith(scoped4(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk4) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk4, unsafeGet4(idx))), flatMap12(() => writeChunkWriter(idx + 1, len, chunk4)));
};
var zip7 = /* @__PURE__ */ dual((args3) => isChannel(args3[1]), (self, that, options3) => options3?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip3(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip3(exit1, exit22)))
}) : flatMap12(self, (a) => map25(that, (b) => [a, b])));
var zipRight4 = /* @__PURE__ */ dual((args3) => isChannel(args3[1]), (self, that, options3) => options3?.concurrent ? map25(zip7(self, that, {
  concurrent: true
}), (tuple3) => tuple3[1]) : flatMap12(self, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var SinkImpl = class {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var suspend7 = (evaluate3) => new SinkImpl(suspend6(() => toChannel(evaluate3())));
var collectAll = () => new SinkImpl(collectAllLoop(empty5()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))),
  onFailure: failCause8,
  onDone: () => succeed11(acc)
});
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var foldChunks = (s, contFn, f) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail13,
    onDone: () => succeedNow(s)
  });
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var forEach9 = (f) => {
  const process3 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach8(input, (v) => f(v), {
      discard: true
    })), flatMap12(() => process3)),
    onFailure: failCause8,
    onDone: () => void_5
  });
  return new SinkImpl(process3);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect6(self)) : self.channel;
var unwrapScoped3 = (effect3) => new SinkImpl(unwrapScoped2(effect3.pipe(map17((sink) => toChannel(sink)))));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/rcRef.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance5 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class2 {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId16] = variance5;
  [TypeId10] = TypeId10;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context7, scope4, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context7;
    this.scope = scope4;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get14(this);
  }
  get;
  commit() {
    return this.get;
  }
};
var make47 = (options3) => withFiberRuntime((fiber) => {
  const context7 = fiber.getFiberRef(currentContext);
  const scope4 = get3(context7, scopeTag);
  const ref = new RcRefImpl(options3.acquire, context7, scope4, options3.idleTimeToLive ? decode(options3.idleTimeToLive) : void 0);
  return as(scope4.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close3 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
    ref.state = stateClosed;
    return close3;
  }))), ref);
});
var get14 = (self_) => {
  const self = self_;
  const isInfinite = self.idleTimeToLive && !isFinite2(self.idleTimeToLive);
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo2("scope"), bind2("value", ({
          scope: scope4
        }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope4)))), map11(({
          scope: scope4,
          value: value5
        }) => {
          const state = {
            _tag: "Acquired",
            value: value5,
            scope: scope4,
            fiber: void 0,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo2("state"), bind2("scope", () => scopeTag), tap(({
    scope: scope4,
    state
  }) => scope4.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0 || isInfinite) {
      return void_;
    }
    if (self.idleTimeToLive === void 0) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_;
    })), ensuring(sync(() => {
      state.fiber = void 0;
    })), forkIn(self.scope), tap((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map11(({
    state
  }) => state.value));
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/RcRef.js
var make48 = make47;
var get15 = get14;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork3;
var runPromiseExit = unsafeRunPromiseExit;
var updateContext3 = updateContext2;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Schedule.js
var spaced2 = spaced;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/stream/emit.js
var make49 = (emit) => {
  const ops = {
    chunk(as9) {
      return this(succeed7(as9));
    },
    die(defect) {
      return this(die5(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth3(exit4, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail7(none2()));
    },
    fail(e) {
      return this(fail7(some2(e)));
    },
    fromEffect(effect3) {
      return this(mapBoth4(effect3, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect3) {
      return this(pipe(effect3, mapError2(some2)));
    },
    halt(cause2) {
      return this(failCause6(pipe(cause2, map14(some2))));
    },
    single(value5) {
      return this(succeed7(of2(value5)));
    }
  };
  return Object.assign(emit, ops);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk3 = (chunk4) => new TakeImpl(succeed3(chunk4));
var done7 = (self) => suspend4(() => self.exit);
var end3 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail3(/* @__PURE__ */ none2()));
var failCause9 = (cause2) => new TakeImpl(failCause3(pipe(cause2, map14(some2))));
var fromPull = (pull) => matchCause3(pull, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: () => end3,
    onSome: failCause9
  }),
  onSuccess: chunk3
});
var match16 = /* @__PURE__ */ dual(2, (self, {
  onEnd: onEnd2,
  onFailure,
  onSuccess
}) => match9(self.exit, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: onEnd2,
    onSome: onFailure
  }),
  onSuccess
}));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/stream/pull.js
var end4 = () => fail7(none2());

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var StreamImpl = class {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded3(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping2(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding2(bufferSize.bufferSize ?? 16);
    default:
      return bounded3(bufferSize.bufferSize ?? 16);
  }
};
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap9((output) => pipe(runtime4(), flatMap9((runtime5) => pipe(register(make49((k) => pipe(fromPull(k), flatMap9((take7) => offer3(output, take7)), asVoid2, runPromiseExit(runtime5)).then((exit4) => {
  if (isFailure(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight3(make25(false)), flatMap9((ref) => pipe(get11(ref), map17((isDone6) => isDone6 ? end4() : pipe(take4(output), flatMap9(done7), onError2(() => pipe(set5(ref, true), zipRight3(shutdown2(output)))))))))))), scoped5, flatMap14(repeatEffectChunkOption));
var bufferChunks = /* @__PURE__ */ dual(2, (self, options3) => {
  if (options3.strategy === "dropping") {
    return bufferChunksDropping(self, options3.capacity);
  } else if (options3.strategy === "sliding") {
    return bufferChunksSliding(self, options3.capacity);
  }
  const queue = toQueue(self, options3);
  return new StreamImpl(unwrapScoped2(map17(queue, (queue2) => {
    const process3 = pipe(fromEffect4(take4(queue2)), flatMap12(match16({
      onEnd: () => void_5,
      onFailure: failCause8,
      onSuccess: (value5) => pipe(write(value5), flatMap12(() => process3))
    })));
    return process3;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity3) => {
  const queue = acquireRelease2(dropping2(capacity3), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity3) => {
  const queue = acquireRelease2(sliding2(capacity3), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferSignal = (scoped6, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take7) => pipe(get11(ref), tap2(_await3), zipRight3(make38()), flatMap9((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight3(set5(ref, deferred)), zipRight3(_await3(deferred)))), asVoid2, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make38(), flatMap9((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap9((added) => pipe(set5(ref, deferred), when2(() => added))))), asVoid2, fromEffect4, flatMap12(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause9(error4)),
      onDone: () => terminate(end3)
    });
  };
  const consumer = (queue) => {
    const process3 = pipe(fromEffect4(take4(queue)), flatMap12(([take7, deferred]) => zipRight4(fromEffect4(succeed6(deferred, void 0)), match16(take7, {
      onEnd: () => void_5,
      onFailure: failCause8,
      onSuccess: (value5) => pipe(write(value5), flatMap12(() => process3))
    }))));
    return process3;
  };
  return unwrapScoped2(pipe(scoped6, flatMap9((queue) => pipe(make38(), tap2((start4) => succeed6(start4, void 0)), flatMap9((start4) => pipe(make25(start4), flatMap9((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as4(consumer(queue))))))));
};
var flatMap14 = /* @__PURE__ */ dual((args3) => isStream(args3[0]), (self, f, options3) => {
  const bufferSize = options3?.bufferSize ?? 16;
  if (options3?.switch) {
    return matchConcurrency(options3?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options3?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as9) => pipe(as9, map5((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options3))));
});
var matchConcurrency = (concurrency, sequential5, bounded4) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded4(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded4(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten12 = /* @__PURE__ */ dual((args3) => isStream(args3[0]), (self, options3) => flatMap14(self, identity, options3));
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream3) => {
  if ("channel" in stream3) {
    return stream3.channel;
  } else if (isEffect2(stream3)) {
    return toChannel2(fromEffect7(stream3));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromEffect7 = (effect3) => pipe(effect3, mapError2(some2), fromEffectOption);
var fromEffectOption = (effect3) => new StreamImpl(unwrap2(match11(effect3, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail13
  }),
  onSuccess: (a) => write(of2(a))
})));
var mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var repeatEffectChunkOption = (effect3) => unfoldChunkEffect(effect3, (effect4) => pipe(map17(effect4, (chunk4) => some2([chunk4, effect4])), catchAll2(match2({
  onNone: () => succeed7(none2()),
  onSome: fail7
}))));
var run3 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self) => run3(self, collectAll());
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap12(write(chunk3(input)), () => writer),
    onFailure: (cause2) => write(failCause9(cause2)),
    onDone: () => write(end3)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid2);
});
var scoped5 = (effect3) => new StreamImpl(ensuring3(scoped4(pipe(effect3, map17(of2))), _void));
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var suspend8 = (stream3) => new StreamImpl(suspend6(() => toChannel2(stream3())));
var toQueue = /* @__PURE__ */ dual((args3) => isStream(args3[0]), (self, options3) => tap2(acquireRelease2(options3?.strategy === "unbounded" ? unbounded5() : options3?.strategy === "dropping" ? dropping2(options3.capacity ?? 2) : options3?.strategy === "sliding" ? sliding2(options3.capacity ?? 2) : bounded3(options3?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var transduce = /* @__PURE__ */ dual(2, (self, sink) => {
  const newChannel = suspend6(() => {
    const leftovers = {
      ref: empty5()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer3 = suspend6(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap12(() => buffer3)),
          onFailure: fail13,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty5();
      return pipe(writeChunk(leftover2), flatMap12(() => buffer3));
    });
    const concatAndGet = (chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll2(leftover2, filter3(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap12(write(input), () => upstreamMarker),
      onFailure: fail13,
      onDone: (done8) => zipRight4(sync6(() => {
        upstreamDone.ref = true;
      }), succeedNow(done8))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap12(([leftover2, z]) => pipe(succeed11([upstreamDone.ref, concatAndGet(leftover2)]), flatMap12(([done8, newLeftovers]) => {
      const nextChannel = done8 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap12(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer3), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var unfoldChunkEffect = (s, f) => suspend8(() => {
  const loop2 = (s2) => unwrap2(map17(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk4, s3]) => flatMap12(write(chunk4), () => loop2(s3))
  })));
  return new StreamImpl(loop2(s));
});
var unwrap3 = (effect3) => flatten12(fromEffect7(effect3));
var unwrapScoped4 = (effect3) => flatten12(scoped5(effect3));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var ensuring5 = ensuring3;
var flatMap15 = flatMap12;
var fromEffect8 = fromEffect4;
var suspend9 = suspend6;
var void_6 = void_5;
var write2 = write;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Sink.js
var drain3 = drain2;
var foldLeftChunks2 = foldLeftChunks;
var forEach10 = forEach9;
var fromChannel3 = fromChannel;
var unwrapScoped5 = unwrapScoped3;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Stream.js
var asyncScoped2 = asyncScoped;
var bufferChunks2 = bufferChunks;
var fromChannel4 = fromChannel2;
var mapChunks2 = mapChunks;
var run4 = run3;
var runCollect3 = runCollect;
var splitLines3 = splitLines2;
var transduce2 = transduce;
var unwrap5 = unwrap3;
var unwrapScoped6 = unwrapScoped4;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var encoder = /* @__PURE__ */ new TextEncoder();
var decoder = /* @__PURE__ */ new TextDecoder();

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length3 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length3; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length3 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length3 = stripped.length;
  if (length3 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length3}`));
  }
  const index = stripped.indexOf("=");
  if (index !== -1 && (index < length3 - 2 || index === length3 - 2 && stripped[length3 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length3 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length3; i += 4, j += 3) {
      const buffer3 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer3 >> 16;
      result[j + 1] = buffer3 >> 8 & 255;
      result[j + 2] = buffer3 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code2 = base64codes[charCode];
  if (code2 === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code2;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_) => decoder.decode(_));

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Redacted.js
var make51 = make43;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Struct.js
var pick2 = /* @__PURE__ */ dual((args3) => isObject(args3[0]), (s, ...keys6) => {
  const out = {};
  for (const k of keys6) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = /* @__PURE__ */ dual((args3) => isObject(args3[0]), (s, ...keys6) => {
  const out = {
    ...s
  };
  for (const k of keys6) {
    delete out[k];
  }
  return out;
});

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Schema.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make52(ast) {
  return class SchemaClass {
    [TypeId17] = variance6;
    static ast = ast;
    static annotations(annotations2) {
      return make52(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId17] = variance6;
  };
}
var variance6 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var builtInAnnotations = {
  typeConstructor: TypeConstructorAnnotationId,
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations2[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
function asSchema(schema) {
  return schema;
}
var format4 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make52(encodedAST(schema.ast));
var typeSchema = (schema) => make52(typeAST(schema.ast));
var encodeUnknown2 = (schema, options3) => {
  const encodeUnknown3 = encodeUnknown(schema, options3);
  return (u, overrideOptions) => mapError3(encodeUnknown3(u, overrideOptions), parseError);
};
var encode2 = encodeUnknown2;
var decodeUnknown2 = (schema, options3) => {
  const decodeUnknown3 = decodeUnknown(schema, options3);
  return (u, overrideOptions) => mapError3(decodeUnknown3(u, overrideOptions), parseError);
};
var decode3 = decodeUnknown2;
var isSchema = (u) => hasProperty(u, TypeId17) && isObject(u[TypeId17]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make52(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options3, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options3.decode(...typeParameters2.map(make52)), (...typeParameters2) => options3.encode(...typeParameters2.map(make52)), toASTAnnotations(annotations2)));
var declarePrimitive = (is3, annotations2) => {
  const decodeUnknown3 = () => (input, _, ast) => is3(input) ? succeed9(input) : fail11(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown3;
  return makeDeclareClass([], new Declaration([], decodeUnknown3, encodeUnknown3, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make52(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options3 = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options3, annotations3);
  }
  const is3 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is3, annotations2);
};
var Undefined = class extends (/* @__PURE__ */ make52(undefinedKeyword)) {
};
var Never = class extends (/* @__PURE__ */ make52(neverKeyword)) {
};
var Unknown = class extends (/* @__PURE__ */ make52(unknownKeyword)) {
};
var String$ = class extends (/* @__PURE__ */ make52(stringKeyword)) {
};
var Number$ = class extends (/* @__PURE__ */ make52(numberKeyword)) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make52(ast) {
    static annotations(annotations2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var UndefinedOr = (self) => Union2(self, Undefined);
var ElementImpl = class _ElementImpl {
  ast;
  from;
  [TypeId17];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations2) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations2)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
};
var ToPropertySignature = class extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p3) => {
  if (p3 === void 0) {
    return "never";
  }
  if (isString(p3)) {
    return JSON.stringify(p3);
  }
  return String(p3);
};
var PropertySignatureTransformation2 = class {
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode4, encode3) {
    this.from = from;
    this.to = to;
    this.decode = decode4;
    this.encode = encode3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations2) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations2
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations2
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class _PropertySignatureImpl {
  ast;
  [TypeId17];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations2) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
  }
  toString() {
    return String(this.ast);
  }
};
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations2) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var optional = (self) => {
  const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys = Reflect.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type2, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type2), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type2, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is3) => {
          issFrom.push(is3);
          issTo.push(new IndexSignature(is3.parameter, typeAST(is3.type), is3.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is3) => iss.push(is3));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys = Reflect.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make52(ast) {
    static annotations(annotations2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options3) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options3) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys6) {
      return Struct(pick2(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct(omit3(fields, ...keys6));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
function makeRecordClass(key, value5, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value5
  }], ast) {
    static annotations(annotations2) {
      return makeRecordClass(key, value5, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static key = key;
    static value = value5;
  };
}
var Record = (options3) => makeRecordClass(options3.key, options3.value);
var intersectTypeLiterals = (x, y, path2) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type2
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type2, ps.type, path2.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path2) => Union.make(intersectUnionMembers([x], [y], path2));
var getTypes = (ast) => isUnion3(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path2) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path2);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path2))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path2));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path2);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path2))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path2)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path2);
          const to = intersectTypeLiterals(x.to, typeAST(y), path2);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options3, ast, fromI) => map23(transformation.decode(fromA, options3, ast, fromI), (partial2) => ({
                ...fromA,
                ...partial2
              })), (toI, options3, ast, toA) => map23(transformation.encode(toI, options3, ast, toA), (partial2) => ({
                ...toI,
                ...partial2
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path2), intersectTypeLiterals(x.to, y.to, path2), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path2);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
}));
var extend3 = /* @__PURE__ */ dual(2, (self, that) => make52(extendAST(self.ast, that.ast, [])));
var compose3 = /* @__PURE__ */ dual((args3) => isSchema(args3[1]), (from, to) => makeTransformationClass(from, to, compose(from.ast, to.ast)));
var suspend10 = (f) => make52(new Suspend(() => f().ast));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter11, ast) {
  return class RefineClass extends make52(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter11;
    static make = (a, options3) => {
      return getDisableValidationMakeOption(options3) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter10(predicate, annotations2) {
  return (self) => {
    function filter11(input, options3, ast2) {
      return toFilterParseIssue(predicate(input, options3, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter11, toASTAnnotations(annotations2));
    return makeRefineClass(self, filter11, ast);
  };
}
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make52(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args3) => isSchema(args3[0]) && isSchema(args3[1]), (from, to, options3) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options3.decode, options3.encode))));
var transform2 = /* @__PURE__ */ dual((args3) => isSchema(args3[0]) && isSchema(args3[1]), (from, to, options3) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed9(options3.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed9(options3.encode(toI, toA))
}));
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations2) => (self) => {
  const source = regex.source;
  return self.pipe(filter10((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations2
  }));
};
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options3) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => JSON.parse(i, options3?.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _, ast) => _try({
    try: () => JSON.stringify(a, options3?.replacer, options3?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose3(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations2) => (self) => self.pipe(filter10((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations2
}));
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption3(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed9(String(a))
  });
}
var NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
};
var Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
};
var toComposite = (eff, onSuccess, ast, actual) => mapBoth5(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var makeEncodingTransformation = (id2, decode4, encode3) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id2}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode4(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed9(encode3(a))
}).annotations({
  identifier: `StringFrom${id2}`
});
var StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations2) => (self) => self.pipe(filter10((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations2
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
  typeConstructor: {
    _tag: "Date"
  },
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date5) => `new Date(${JSON.stringify(date5)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
};
var DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
};
var Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var getClassTag = (tag4) => withConstructorDefault(propertySignature(Literal2(tag4)), () => tag4);
var TaggedError2 = (identifier2) => (tag4, fieldsOr, annotations2) => {
  class Base3 extends Error3 {
  }
  ;
  Base3.prototype.name = tag4;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag4)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag4,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations2,
    disableToString: true
  }) {
    static _tag = tag4;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${Reflect.ownKeys(fields).map((p3) => `${formatPropertyKey(p3)}: ${formatUnknown(this[p3])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of Reflect.ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options3) {
  return isBoolean(options3) ? options3 : options3?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations2) => {
  if (annotations2 === void 0) {
    return [];
  } else if (Array.isArray(annotations2)) {
    return annotations2;
  } else {
    return [annotations2];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations2,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = /* @__PURE__ */ Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations2);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options3 = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options3)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId17] = variance6;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed9(input) : fail11(new Type2(ast, input)),
        encode: () => (input, options3) => input instanceof this ? succeed9(input) : map23(encodeUnknown(typeSide)(input, options3), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty6) => (self) => `${identifier2}(${pretty6(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations3) {
      return make52(this.ast).annotations(annotations3);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args3) {
      return new this(...args3);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations3) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options3, annotations3) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options3, annotations3) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${Reflect.ownKeys(fields).map((p3) => `${formatPropertyKey(p3)}: ${formatUnknown(this[p3])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend10(() => FiberIdEncoded),
  right: suspend10(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId2) => {
  switch (fiberId2._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId2.id}, ${fiberId2.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId2.right)}, ${fiberIdPretty(fiberId2.left)})`;
  }
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal2("Fail"),
  error: error4
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error4, defect) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const suspended3 = suspend10(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format4(error4)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause2) => {
  const f = (cause3) => {
    switch (cause3._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause3.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause3)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause3.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause3.left)}, ${f(cause3.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause3.left)}, ${f(cause3.right)})`;
    }
  };
  return f(cause2);
};
var causeParse = (decodeUnknown3) => (u, options3, ast) => isCause2(u) ? toComposite(decodeUnknown3(causeEncode(u), options3), causeDecode, ast, u) : fail11(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown(causeEncoded(error5, defect2)))
  }, {
    typeConstructor: {
      _tag: "effect/Cause"
    },
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return empty25;
    case "Fail":
      return fail4(cause2.error);
    case "Die":
      return die4(cause2.defect);
    case "Interrupt":
      return interrupt3(fiberIdDecode(cause2.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause2.left), causeDecode(cause2.right));
    case "Parallel":
      return parallel4(causeDecode(cause2.left), causeDecode(cause2.right));
  }
}
function causeEncode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause2.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause2.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause2.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};
var Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return prettyErrorMessage(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Error.js
var TypeId18 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
var Module = /* @__PURE__ */ Literal2("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");
var BadArgument = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/BadArgument")("BadArgument", {
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  /**
   * @since 1.0.0
   */
  [TypeId18] = TypeId18;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
  }
};
var SystemErrorReason = /* @__PURE__ */ Literal2("AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero");
var SystemError = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/SystemError")("SystemError", {
  reason: SystemErrorReason,
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  syscall: /* @__PURE__ */ optional(String$),
  pathOrDescriptor: /* @__PURE__ */ optional(/* @__PURE__ */ Union2(String$, Number$)),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  /**
   * @since 1.0.0
   */
  [TypeId18] = TypeId18;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.reason}: ${this.module}.${this.method}${this.pathOrDescriptor !== void 0 ? ` (${this.pathOrDescriptor})` : ""}${this.description ? `: ${this.description}` : ""}`;
  }
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
var make53 = (impl) => {
  return tag.of({
    ...impl,
    exists: (path2) => pipe(impl.access(path2), as4(true), catchTag2("SystemError", (e) => e.reason === "NotFound" ? succeed7(false) : fail7(e))),
    readFileString: (path2, encoding) => tryMap2(impl.readFile(path2), {
      try: (_) => new TextDecoder(encoding).decode(_),
      catch: (cause2) => new BadArgument({
        module: "FileSystem",
        method: "readFileString",
        description: "invalid encoding",
        cause: cause2
      })
    }),
    stream: (path2, options3) => pipe(impl.open(path2, {
      flag: "r"
    }), options3?.offset ? tap2((file5) => file5.seek(options3.offset, "start")) : identity, map17((file5) => stream(file5, options3)), unwrapScoped6),
    sink: (path2, options3) => pipe(impl.open(path2, {
      flag: "w",
      ...options3
    }), map17((file5) => forEach10((_) => file5.writeAll(_))), unwrapScoped5),
    writeFileString: (path2, data, options3) => flatMap9(try_3({
      try: () => new TextEncoder().encode(data),
      catch: (cause2) => new BadArgument({
        module: "FileSystem",
        method: "writeFileString",
        description: "could not encode string",
        cause: cause2
      })
    }), (_) => impl.writeFile(path2, _, options3))
  });
};
var stream = (file5, {
  bufferSize = 16,
  bytesToRead: bytesToRead_,
  chunkSize: chunkSize_ = Size(64 * 1024)
} = {}) => {
  const bytesToRead = bytesToRead_ !== void 0 ? Size(bytesToRead_) : void 0;
  const chunkSize = Size(chunkSize_);
  function loop2(totalBytesRead) {
    if (bytesToRead !== void 0 && bytesToRead <= totalBytesRead) {
      return void_6;
    }
    const toRead = bytesToRead !== void 0 && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
    return flatMap15(file5.readAlloc(toRead), match2({
      onNone: () => void_6,
      onSome: (buf) => flatMap15(write2(of2(buf)), (_) => loop2(totalBytesRead + BigInt(buf.length)))
    }));
  }
  return bufferChunks2(fromChannel4(loop2(BigInt(0))), {
    capacity: bufferSize
  });
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag;
var make54 = make53;
var FileTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/FileSystem/File");
var FileDescriptor = /* @__PURE__ */ nominal();
var WatchEventCreate = /* @__PURE__ */ tagged2("Create");
var WatchEventUpdate = /* @__PURE__ */ tagged2("Update");
var WatchEventRemove = /* @__PURE__ */ tagged2("Remove");
var WatchBackend = class extends (/* @__PURE__ */ Tag2("@effect/platform/FileSystem/WatchBackend")()) {
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Secret.js
var fromString2 = fromString;

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/terminal.js
var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/Terminal");

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Terminal.js
var QuitException = class extends (/* @__PURE__ */ TaggedError("QuitException")) {
};
var isQuitException = (u) => typeof u === "object" && u != null && "_tag" in u && u._tag === "QuitException";
var Terminal = tag2;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/action.js
var Action = /* @__PURE__ */ taggedEnum();

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt.js
var PromptSymbolKey = "@effect/cli/Prompt";
var PromptTypeId = /* @__PURE__ */ Symbol.for(PromptSymbolKey);
var proto18 = {
  ...CommitPrototype2,
  [PromptTypeId]: {
    _Output: (_) => _
  },
  commit() {
    return run5(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrompt = (u) => typeof u === "object" && u != null && PromptTypeId in u;
var custom2 = (initialState3, handlers) => {
  const op = Object.create(proto18);
  op._tag = "Loop";
  op.initialState = initialState3;
  op.render = handlers.render;
  op.process = handlers.process;
  op.clear = handlers.clear;
  return op;
};
var map28 = /* @__PURE__ */ dual(2, (self, f) => flatMap17(self, (a) => succeed15(f(a))));
var flatMap17 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto18);
  op._tag = "OnSuccess";
  op.prompt = self;
  op.onSuccess = f;
  return op;
});
var run5 = /* @__PURE__ */ fnUntraced2(function* (self) {
  const terminal = yield* Terminal;
  const input = yield* terminal.readInput;
  return yield* runWithInput(self, terminal, input);
}, /* @__PURE__ */ mapError2(() => new QuitException()), scoped2);
var runWithInput = (prompt3, terminal, input) => suspend4(() => {
  const op = prompt3;
  switch (op._tag) {
    case "Loop": {
      return runLoop(op, terminal, input);
    }
    case "OnSuccess": {
      return flatMap9(runWithInput(op.prompt, terminal, input), (a) => runWithInput(op.onSuccess(a), terminal, input));
    }
    case "Succeed": {
      return succeed7(op.value);
    }
  }
});
var runLoop = /* @__PURE__ */ fnUntraced2(function* (loop2, terminal, input) {
  let state = isEffect2(loop2.initialState) ? yield* loop2.initialState : loop2.initialState;
  let action = Action.NextFrame({
    state
  });
  while (true) {
    const msg = yield* loop2.render(state, action);
    yield* orDie2(terminal.display(msg));
    const event = yield* input.take;
    action = yield* loop2.process(event, state);
    switch (action._tag) {
      case "Beep":
        continue;
      case "NextFrame": {
        yield* orDie2(terminal.display(yield* loop2.clear(state, action)));
        state = action.state;
        continue;
      }
      case "Submit": {
        yield* orDie2(terminal.display(yield* loop2.clear(state, action)));
        const msg2 = yield* loop2.render(state, action);
        yield* orDie2(terminal.display(msg2));
        return action.value;
      }
    }
  }
}, (effect3, _, terminal) => ensuring2(effect3, orDie2(terminal.display(render3(cursorShow3, {
  style: "pretty"
})))));
var succeed15 = (value5) => {
  const op = Object.create(proto18);
  op._tag = "Succeed";
  op.value = value5;
  return op;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/matcher.js
var TypeId19 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId19]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId19]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value5) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value5;
  return matcher;
}
var makeWhen = (guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p3]) => [k, makePredicate(p3)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var value3 = (i) => makeValueMatcher(i, left2(i));
var when4 = (pattern2, f) => (self) => self.add(makeWhen(makePredicate(pattern2), f));
var orElse12 = (f) => (self) => {
  const result = either6(self);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var either6 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Match.js
var value4 = value3;
var when5 = when4;
var orElse13 = orElse12;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/ansi-utils.js
var defaultFigures = {
  arrowUp: /* @__PURE__ */ text3("\u2191"),
  arrowDown: /* @__PURE__ */ text3("\u2193"),
  arrowLeft: /* @__PURE__ */ text3("\u2190"),
  arrowRight: /* @__PURE__ */ text3("\u2192"),
  radioOn: /* @__PURE__ */ text3("\u25C9"),
  radioOff: /* @__PURE__ */ text3("\u25EF"),
  checkboxOn: /* @__PURE__ */ text3("\u2612"),
  checkboxOff: /* @__PURE__ */ text3("\u2610"),
  tick: /* @__PURE__ */ text3("\u2714"),
  cross: /* @__PURE__ */ text3("\u2716"),
  ellipsis: /* @__PURE__ */ text3("\u2026"),
  pointerSmall: /* @__PURE__ */ text3("\u203A"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3("\u276F")
};
var windowsFigures = {
  arrowUp: defaultFigures.arrowUp,
  arrowDown: defaultFigures.arrowDown,
  arrowLeft: defaultFigures.arrowLeft,
  arrowRight: defaultFigures.arrowRight,
  radioOn: /* @__PURE__ */ text3("(*)"),
  radioOff: /* @__PURE__ */ text3("( )"),
  checkboxOn: /* @__PURE__ */ text3("[*]"),
  checkboxOff: /* @__PURE__ */ text3("[ ]"),
  tick: /* @__PURE__ */ text3("\u221A"),
  cross: /* @__PURE__ */ text3("\xD7"),
  ellipsis: /* @__PURE__ */ text3("..."),
  pointerSmall: /* @__PURE__ */ text3("\xBB"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3(">")
};
var figures = /* @__PURE__ */ map17(/* @__PURE__ */ sync4(() => process.platform === "win32"), (isWindows2) => isWindows2 ? windowsFigures : defaultFigures);
function eraseText(text10, columns) {
  if (columns === 0) {
    return cat2(eraseLine3, cursorTo3(0));
  }
  let rows = 0;
  const lines3 = text10.split(/\r?\n/);
  for (const line4 of lines3) {
    rows += 1 + Math.floor(Math.max(line4.length - 1, 0) / columns);
  }
  return eraseLines3(rows);
}
function lines(prompt3, columns) {
  const lines3 = prompt3.split(/\r?\n/);
  return columns === 0 ? lines3.length : pipe(map4(lines3, (line4) => Math.ceil(line4.length / columns)), reduce(0, (left3, right3) => left3 + right3));
}

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/date.js
var renderBeep = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty32,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX = /\r?\n/;
function renderError(state, pointer) {
  return match2(state.error, {
    onNone: () => empty32,
    onSome: (error4) => {
      const errorLines = error4.split(NEWLINE_REGEX);
      if (isNonEmptyReadonlyArray(errorLines)) {
        const annotateLine = (line4) => annotate2(text3(line4), combine11(italicized2, red4));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines3 = map4(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
      return empty32;
    }
  });
}
function renderParts(state, submitted = false) {
  return reduce(state.dateParts, empty32, (doc, part, currentIndex) => {
    const partDoc = text3(part.toString());
    if (currentIndex === state.cursor && !submitted) {
      const annotation = combine11(underlined2, cyanBright2);
      return cat2(doc, annotate2(partDoc, annotation));
    }
    return cat2(doc, partDoc);
  });
}
function renderOutput(leadingSymbol, trailingSymbol, parts2, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, parts2]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(parts2));
    }
  });
}
function renderNextFrame(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const parts2 = renderParts(state);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    const errorMsg = renderError(state, figures4.pointerSmall);
    return cursorHide3.pipe(cat2(promptMsg), cat2(errorMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const parts2 = renderParts(state, true);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processUp(state) {
  state.dateParts[state.cursor].increment();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processDown(state) {
  state.dateParts[state.cursor].decrement();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processCursorLeft(state) {
  const previousPart = state.dateParts[state.cursor].previousPart();
  return match2(previousPart, {
    onNone: () => Action.Beep(),
    onSome: (previous) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(previous)
      }
    })
  });
}
function processCursorRight(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  return match2(nextPart, {
    onNone: () => Action.Beep(),
    onSome: (next) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(next)
      }
    })
  });
}
function processNext(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  const cursor = match2(nextPart, {
    onNone: () => state.dateParts.findIndex((part) => !part.isToken()),
    onSome: (next) => state.dateParts.indexOf(next)
  });
  return Action.NextFrame({
    state: {
      ...state,
      cursor
    }
  });
}
function defaultProcessor(value5, state) {
  if (/\d/.test(value5)) {
    const typed = state.typed + value5;
    state.dateParts[state.cursor].setValue(typed);
    return Action.NextFrame({
      state: {
        ...state,
        typed
      }
    });
  }
  return Action.Beep();
}
var defaultLocales = {
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
};
function handleRender(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep),
      NextFrame: ({
        state: state2
      }) => renderNextFrame(state2, options3),
      Submit: () => renderSubmission(state, options3)
    });
  };
}
function handleProcess(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "left": {
        return succeed7(processCursorLeft(state));
      }
      case "right": {
        return succeed7(processCursorRight(state));
      }
      case "k":
      case "up": {
        return succeed7(processUp(state));
      }
      case "j":
      case "down": {
        return succeed7(processDown(state));
      }
      case "tab": {
        return succeed7(processNext(state));
      }
      case "enter":
      case "return": {
        return match11(options3.validate(state.value), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              error: some2(error4)
            }
          }),
          onSuccess: (value5) => Action.Submit({
            value: value5
          })
        });
      }
      default: {
        const value5 = getOrElse2(input.input, () => "");
        return succeed7(defaultProcessor(value5, state));
      }
    }
  };
}
var date2 = (options3) => {
  const opts = {
    initial: /* @__PURE__ */ new Date(),
    dateMask: "YYYY-MM-DD HH:mm:ss",
    validate: succeed7,
    ...options3,
    locales: {
      ...defaultLocales,
      ...options3.locales
    }
  };
  const dateParts = makeDateParts(opts.dateMask, opts.initial, opts.locales);
  const initialCursorPosition = dateParts.findIndex((part) => !part.isToken());
  const initialState3 = {
    dateParts,
    typed: "",
    cursor: initialCursorPosition,
    value: opts.initial,
    error: none2()
  };
  return custom2(initialState3, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: handleClear(opts)
  });
};
var DATE_PART_REGEX = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
var regexGroups = {
  1: ({
    token,
    ...opts
  }) => new Token({
    token: token.replace(/\\(.)/g, "$1"),
    ...opts
  }),
  2: (opts) => new Day(opts),
  3: (opts) => new Month(opts),
  4: (opts) => new Year(opts),
  5: (opts) => new Meridiem(opts),
  6: (opts) => new Hours(opts),
  7: (opts) => new Minutes(opts),
  8: (opts) => new Seconds(opts),
  9: (opts) => new Milliseconds(opts)
};
var makeDateParts = (dateMask, date5, locales) => {
  const parts2 = [];
  let result = null;
  while (result = DATE_PART_REGEX.exec(dateMask)) {
    const match18 = result.shift();
    const index = result.findIndex((group4) => group4 !== void 0);
    if (index in regexGroups) {
      const token = result[index] || match18;
      parts2.push(regexGroups[index]({
        token,
        date: date5,
        parts: parts2,
        locales
      }));
    } else {
      parts2.push(new Token({
        token: result[index] || match18,
        date: date5,
        parts: parts2,
        locales
      }));
    }
  }
  const orderedParts = parts2.reduce((array7, element) => {
    const lastElement = array7[array7.length - 1];
    if (element.isToken() && lastElement !== void 0 && lastElement.isToken()) {
      lastElement.setValue(element.token);
    } else {
      array7.push(element);
    }
    return array7;
  }, empty2());
  parts2.splice(0, parts2.length, ...orderedParts);
  return parts2;
};
var DatePart = class {
  token;
  date;
  parts;
  locales;
  constructor(params) {
    this.token = params.token;
    this.locales = params.locales;
    this.date = params.date || /* @__PURE__ */ new Date();
    this.parts = params.parts || [this];
  }
  /**
   * Returns `true` if this `DatePart` is a `Token`, `false` otherwise.
   */
  isToken() {
    return false;
  }
  /**
   * Retrieves the next date part in the list of parts.
   */
  nextPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findFirst2(this.parts.slice(currentPartIndex + 1), (part) => !part.isToken())));
  }
  /**
   * Retrieves the previous date part in the list of parts.
   */
  previousPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findLast(this.parts.slice(0, currentPartIndex), (part) => !part.isToken())));
  }
  toString() {
    return String(this.date);
  }
};
var Token = class extends DatePart {
  increment() {
  }
  decrement() {
  }
  setValue(value5) {
    this.token = this.token + value5;
  }
  isToken() {
    return true;
  }
  toString() {
    return this.token;
  }
};
var Milliseconds = class extends DatePart {
  increment() {
    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
  }
  decrement() {
    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
  }
  setValue(value5) {
    this.date.setMilliseconds(Number.parseInt(value5.slice(-this.token.length)));
  }
  toString() {
    const millis2 = `${this.date.getMilliseconds()}`;
    return millis2.padStart(4, "0").substring(0, this.token.length);
  }
};
var Seconds = class extends DatePart {
  increment() {
    this.date.setSeconds(this.date.getSeconds() + 1);
  }
  decrement() {
    this.date.setSeconds(this.date.getSeconds() - 1);
  }
  setValue(value5) {
    this.date.setSeconds(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const seconds2 = `${this.date.getSeconds()}`;
    return this.token.length > 1 ? seconds2.padStart(2, "0") : seconds2;
  }
};
var Minutes = class extends DatePart {
  increment() {
    this.date.setMinutes(this.date.getMinutes() + 1);
  }
  decrement() {
    this.date.setMinutes(this.date.getMinutes() - 1);
  }
  setValue(value5) {
    this.date.setMinutes(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const minutes2 = `${this.date.getMinutes()}`;
    return this.token.length > 1 ? minutes2.padStart(2, "0") : minutes2;
  }
};
var Hours = class extends DatePart {
  increment() {
    this.date.setHours(this.date.getHours() + 1);
  }
  decrement() {
    this.date.setHours(this.date.getHours() - 1);
  }
  setValue(value5) {
    this.date.setHours(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const hours2 = /h/.test(this.token) ? this.date.getHours() % 12 || 12 : this.date.getHours();
    return this.token.length > 1 ? `${hours2}`.padStart(2, "0") : `${hours2}`;
  }
};
var Day = class extends DatePart {
  increment() {
    this.date.setDate(this.date.getDate() + 1);
  }
  decrement() {
    this.date.setDate(this.date.getDate() - 1);
  }
  setValue(value5) {
    this.date.setDate(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const date5 = this.date.getDate();
    const day = this.date.getDay();
    return value4(this.token).pipe(when5("DD", () => `${date5}`.padStart(2, "0")), when5("Do", () => `${date5}${this.ordinalIndicator(date5)}`), when5("d", () => `${day + 1}`), when5("ddd", () => this.locales.weekdaysShort[day]), when5("dddd", () => this.locales.weekdays[day]), orElse13(() => `${date5}`));
  }
  ordinalIndicator(day) {
    return value4(day % 10).pipe(when5(1, () => "st"), when5(2, () => "nd"), when5(3, () => "rd"), orElse13(() => "th"));
  }
};
var Month = class extends DatePart {
  increment() {
    this.date.setMonth(this.date.getMonth() + 1);
  }
  decrement() {
    this.date.setMonth(this.date.getMonth() - 1);
  }
  setValue(value5) {
    const month = Number.parseInt(value5.slice(-2)) - 1;
    this.date.setMonth(month < 0 ? 0 : month);
  }
  toString() {
    const month = this.date.getMonth();
    return value4(this.token.length).pipe(when5(2, () => `${month + 1}`.padStart(2, "0")), when5(3, () => this.locales.monthsShort[month]), when5(4, () => this.locales.months[month]), orElse13(() => `${month + 1}`));
  }
};
var Year = class extends DatePart {
  increment() {
    this.date.setFullYear(this.date.getFullYear() + 1);
  }
  decrement() {
    this.date.setFullYear(this.date.getFullYear() - 1);
  }
  setValue(value5) {
    this.date.setFullYear(Number.parseInt(value5.slice(-4)));
  }
  toString() {
    const year = `${this.date.getFullYear()}`.padStart(4, "0");
    return this.token.length === 2 ? year.substring(-2) : year;
  }
};
var Meridiem = class extends DatePart {
  increment() {
    this.date.setHours((this.date.getHours() + 12) % 24);
  }
  decrement() {
    this.increment();
  }
  setValue(_value) {
  }
  toString() {
    const meridiem = this.date.getHours() > 12 ? "pm" : "am";
    return /A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
  }
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/path.js
var TypeId20 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code2 = path2.charCodeAt(i);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path2.slice(lastSlash + 1, i);
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  const dir2 = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir2) {
    return base;
  }
  if (dir2 === pathObject.root) {
    return dir2 + base;
  }
  return dir2 + sep + base;
}
function fromFileUrl(url2) {
  if (url2.protocol !== "file:") {
    return fail7(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "URL must be of scheme file"
    }));
  } else if (url2.hostname !== "") {
    return fail7(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "Invalid file URL host"
    }));
  }
  const pathname = url2.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail7(new BadArgument({
          module: "Path",
          method: "fromFileUrl",
          description: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed7(decodeURIComponent(pathname));
}
var resolve = function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd = void 0;
  for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path2;
    if (i >= 0) {
      path2 = arguments[i];
    } else {
      const process3 = globalThis.process;
      if (cwd === void 0 && "process" in globalThis && typeof process3 === "object" && process3 !== null && typeof process3.cwd === "function") {
        cwd = process3.cwd();
      }
      path2 = cwd;
    }
    if (path2.length === 0) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
};
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed7(outURL);
}
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId20]: TypeId20,
  resolve,
  normalize(path2) {
    if (path2.length === 0) return ".";
    const isAbsolute = path2.charCodeAt(0) === 47;
    const trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = normalizeStringPosix(path2, !isAbsolute);
    if (path2.length === 0 && !isAbsolute) path2 = ".";
    if (path2.length > 0 && trailingSeparator) path2 += "/";
    if (isAbsolute) return "/" + path2;
    return path2;
  },
  isAbsolute(path2) {
    return path2.length > 0 && path2.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to) return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to) return "";
    let fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length3 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i <= length3; ++i) {
      if (i === length3) {
        if (toLen > length3) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length3) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode3 = to.charCodeAt(toStart + i);
      if (fromCode !== toCode3) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path2) {
    if (path2.length === 0) return ".";
    let code2 = path2.charCodeAt(0);
    const hasRoot = code2 === 47;
    let end5 = -1;
    let matchedSlash = true;
    for (let i = path2.length - 1; i >= 1; --i) {
      code2 = path2.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          end5 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end5 === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end5 === 1) return "//";
    return path2.slice(0, end5);
  },
  basename(path2, ext) {
    let start4 = 0;
    let end5 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2) return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            start4 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end5 = i;
              }
            } else {
              extIdx = -1;
              end5 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start4 === end5) end5 = firstNonSlashEnd;
      else if (end5 === -1) end5 = path2.length;
      return path2.slice(start4, end5);
    } else {
      for (i = path2.length - 1; i >= 0; --i) {
        if (path2.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start4 = i + 1;
            break;
          }
        } else if (end5 === -1) {
          matchedSlash = false;
          end5 = i + 1;
        }
      }
      if (end5 === -1) return "";
      return path2.slice(start4, end5);
    }
  },
  extname(path2) {
    let startDot = -1;
    let startPart = 0;
    let end5 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code2 = path2.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end5 === -1) {
        matchedSlash = false;
        end5 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end5 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end5 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end5);
  },
  format: function format5(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse(path2) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path2.length === 0) return ret;
    let code2 = path2.charCodeAt(0);
    const isAbsolute = code2 === 47;
    let start4;
    if (isAbsolute) {
      ret.root = "/";
      start4 = 1;
    } else {
      start4 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end5 = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start4; --i) {
      code2 = path2.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end5 === -1) {
        matchedSlash = false;
        end5 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1) startDot = i;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end5 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end5 - 1 && startDot === startPart + 1) {
      if (end5 !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end5);
        else ret.base = ret.name = path2.slice(startPart, end5);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end5);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end5);
      }
      ret.ext = path2.slice(startDot, end5);
    }
    if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Path.js
var TypeId21 = TypeId20;
var Path2 = Path;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/utils.js
var entriesToDisplay = (cursor, total, maxVisible) => {
  const max6 = maxVisible === void 0 ? total : maxVisible;
  let startIndex = Math.min(total - max6, cursor - Math.floor(max6 / 2));
  if (startIndex < 0) {
    startIndex = 0;
  }
  const endIndex = Math.min(startIndex + max6, total);
  return {
    startIndex,
    endIndex
  };
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/file.js
var CONFIRM_MESSAGE = "The selected directory contains files. Would you like to traverse the selected directory?";
var Confirm = /* @__PURE__ */ taggedEnum();
var showConfirmation = /* @__PURE__ */ Confirm.$is("Show");
var renderBeep2 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function resolveCurrentPath(path2, options3) {
  return match2(path2, {
    onNone: () => match2(options3.startingPath, {
      onNone: () => sync4(() => process.cwd()),
      onSome: (path3) => flatMap9(FileSystem, (fs) => (
        // Ensure the user provided starting path exists
        orDie2(fs.exists(path3)).pipe(filterOrDieMessage2(identity, `The provided starting path '${path3}' does not exist`), as4(path3))
      ))
    }),
    onSome: (path3) => succeed7(path3)
  });
}
function getFileList(directory3, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path2 = yield* Path2;
    const files = yield* orDie2(fs.readDirectory(directory3)).pipe(
      // Always prepend the `".."` option to the file list but allow it
      // to be filtered out if the user so desires
      map17((files2) => ["..", ...files2])
    );
    return yield* filter8(files, (file5) => {
      const result = options3.filter(file5);
      const userDefinedFilter = isEffect2(result) ? result : succeed7(result);
      const directoryFilter = options3.type === "directory" ? map17(orDie2(fs.stat(path2.join(directory3, file5))), (info2) => info2.type === "Directory") : succeed7(true);
      return zipWith4(userDefinedFilter, directoryFilter, (a, b) => a && b);
    }, {
      concurrency: files.length
    });
  });
}
function handleClear2(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const currentPath = yield* resolveCurrentPath(state.path, options3);
      const text10 = "\n".repeat(Math.min(state.files.length, options3.maxPerPage));
      const clearPath = eraseText(currentPath, columns);
      const message = showConfirmation(state.confirm) ? CONFIRM_MESSAGE : options3.message;
      const clearPrompt = eraseText(`
${message}`, columns);
      const clearOptions = eraseText(text10, columns);
      return clearOptions.pipe(cat2(clearPath), cat2(clearPrompt), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX2 = /\r?\n/;
function renderPrompt(confirm3, message, leadingSymbol, trailingSymbol) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(message.split(NEWLINE_REGEX2), {
    onEmpty: () => hsep2([prefix, trailingSymbol, confirm3]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(confirm3));
    }
  });
}
function renderPrefix(state, toDisplay, currentIndex, length3, figures4) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures4.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < length3) {
    prefix = figures4.arrowDown;
  }
  return state.cursor === currentIndex ? figures4.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderFileName(file5, isSelected) {
  return isSelected ? annotate2(text3(file5), combine11(underlined2, cyanBright2)) : text3(file5);
}
function renderFiles(state, files, figures4, options3) {
  const length3 = files.length;
  const toDisplay = entriesToDisplay(state.cursor, length3, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const isSelected = state.cursor === index;
    const prefix = renderPrefix(state, toDisplay, index, length3, figures4);
    const fileName = renderFileName(files[index], isSelected);
    documents.push(cat2(prefix, fileName));
  }
  return vsep2(documents);
}
function renderNextFrame2(state, options3) {
  return gen2(function* () {
    const path2 = yield* Path2;
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path2.resolve(currentPath, selectedPath);
    const resolvedPathMsg = figures4.pointerSmall.pipe(cat2(space2), cat2(text3(resolvedPath)), annotate2(blackBright2));
    if (showConfirmation(state.confirm)) {
      const leadingSymbol2 = annotate2(text3("?"), cyanBright2);
      const trailingSymbol2 = annotate2(figures4.pointerSmall, blackBright2);
      const confirm3 = annotate2(text3("(Y/n)"), blackBright2);
      const promptMsg2 = renderPrompt(confirm3, CONFIRM_MESSAGE, leadingSymbol2, trailingSymbol2);
      return cursorHide3.pipe(cat2(promptMsg2), cat2(hardLine2), cat2(resolvedPathMsg), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    }
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty32, options3.message, leadingSymbol, trailingSymbol);
    const files = renderFiles(state, state.files, figures4, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(resolvedPathMsg), cat2(hardLine2), cat2(files), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission2(value5, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty32, options3.message, leadingSymbol, trailingSymbol);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(text3(value5), white4)), cat2(hardLine2), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleRender2(options3) {
  return (_, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep2),
      NextFrame: ({
        state
      }) => renderNextFrame2(state, options3),
      Submit: ({
        value: value5
      }) => renderSubmission2(value5, options3)
    });
  };
}
function processCursorUp(state) {
  const cursor = state.cursor - 1;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor: cursor < 0 ? state.files.length - 1 : cursor
    }
  }));
}
function processCursorDown(state) {
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor: (state.cursor + 1) % state.files.length
    }
  }));
}
function processSelection(state, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path2 = yield* Path2;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path2.resolve(currentPath, selectedPath);
    const info2 = yield* orDie2(fs.stat(resolvedPath));
    if (info2.type === "Directory") {
      const files = yield* getFileList(resolvedPath, options3);
      const filesWithoutParent = files.filter((file5) => file5 !== "..");
      if (options3.type === "directory" || options3.type === "either") {
        return filesWithoutParent.length === 0 ? Action.Submit({
          value: resolvedPath
        }) : Action.NextFrame({
          state: {
            ...state,
            confirm: Confirm.Show()
          }
        });
      }
      return Action.NextFrame({
        state: {
          cursor: 0,
          files,
          path: some2(resolvedPath),
          confirm: Confirm.Hide()
        }
      });
    }
    return Action.Submit({
      value: resolvedPath
    });
  });
}
function handleProcess2(options3) {
  return (input, state) => gen2(function* () {
    switch (input.key.name) {
      case "k":
      case "up": {
        return yield* processCursorUp(state);
      }
      case "j":
      case "down":
      case "tab": {
        return yield* processCursorDown(state);
      }
      case "enter":
      case "return": {
        return yield* processSelection(state, options3);
      }
      case "y":
      case "t": {
        if (showConfirmation(state.confirm)) {
          const path2 = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path2.resolve(currentPath, selectedPath);
          const files = yield* getFileList(resolvedPath, options3);
          return Action.NextFrame({
            state: {
              cursor: 0,
              files,
              path: some2(resolvedPath),
              confirm: Confirm.Hide()
            }
          });
        }
        return Action.Beep();
      }
      case "n":
      case "f": {
        if (showConfirmation(state.confirm)) {
          const path2 = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path2.resolve(currentPath, selectedPath);
          return Action.Submit({
            value: resolvedPath
          });
        }
        return Action.Beep();
      }
      default: {
        return Action.Beep();
      }
    }
  });
}
var file = (options3 = {}) => {
  const opts = {
    type: options3.type ?? "file",
    message: options3.message ?? `Choose a file`,
    startingPath: fromNullable(options3.startingPath),
    maxPerPage: options3.maxPerPage ?? 10,
    filter: options3.filter ?? (() => succeed7(true))
  };
  const initialState3 = gen2(function* () {
    const path2 = none2();
    const currentPath = yield* resolveCurrentPath(path2, opts);
    const files = yield* getFileList(currentPath, opts);
    const confirm3 = Confirm.Hide();
    return {
      cursor: 0,
      files,
      path: path2,
      confirm: confirm3
    };
  });
  return custom2(initialState3, {
    render: handleRender2(opts),
    process: handleProcess2(opts),
    clear: handleClear2(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/number.js
var parseInt2 = /* @__PURE__ */ NumberFromString.pipe(/* @__PURE__ */ int(), decodeUnknown2);
var parseFloat2 = /* @__PURE__ */ decodeUnknown2(NumberFromString);
var renderBeep3 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear3(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty32,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
function renderInput(state, submitted) {
  const annotation = match2(state.error, {
    onNone: () => combine11(underlined2, cyanBright2),
    onSome: () => red4
  });
  const value5 = state.value === "" ? empty32 : text3(`${state.value}`);
  return submitted ? value5 : annotate2(value5, annotation);
}
var NEWLINE_REGEX3 = /\r?\n/;
function renderError2(state, pointer) {
  return match2(state.error, {
    onNone: () => empty32,
    onSome: (error4) => match3(error4.split(NEWLINE_REGEX3), {
      onEmpty: () => empty32,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => annotate2(text3(line4), combine11(italicized2, red4));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines3 = map4(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput2(state, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, renderInput(state, submitted)]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput(state, submitted)));
    }
  });
}
function renderNextFrame3(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const errorMsg = renderError2(state, figures4.pointerSmall);
    const promptMsg = renderOutput2(state, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(errorMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission3(nextState, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderOutput2(nextState, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace(state) {
  if (state.value.length <= 0) {
    return succeed7(Action.Beep());
  }
  const value5 = state.value.slice(0, state.value.length - 1);
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      value: value5,
      error: none2()
    }
  }));
}
function defaultIntProcessor(state, input) {
  if (state.value.length === 0 && input === "-") {
    return succeed7(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match11(parseInt2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value5) => Action.NextFrame({
      state: {
        ...state,
        value: `${value5}`,
        error: none2()
      }
    })
  });
}
function defaultFloatProcessor(state, input) {
  if (input === "." && state.value.includes(".")) {
    return succeed7(Action.Beep());
  }
  if (state.value.length === 0 && input === "-") {
    return succeed7(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match11(parseFloat2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value5) => Action.NextFrame({
      state: {
        ...state,
        value: input === "." ? `${value5}.` : `${value5}`,
        error: none2()
      }
    })
  });
}
var initialState = {
  cursor: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRenderInteger(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessInteger(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed7(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseInt(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed7(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseInt(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseInt2(state.value), {
          onFailure: () => succeed7(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide an integer value")
            }
          })),
          onSuccess: (n) => match11(options3.validate(n), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value5) => Action.Submit({
              value: value5
            })
          })
        });
      }
      default: {
        const value5 = getOrElse2(input.input, () => "");
        return defaultIntProcessor(state, value5);
      }
    }
  };
}
var integer2 = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    validate: (n) => {
      if (n < opts.min) {
        return fail7(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail7(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed7(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderInteger(opts),
    process: handleProcessInteger(opts),
    clear: handleClear3(opts)
  });
};
function handleRenderFloat(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessFloat(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed7(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseFloat(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed7(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseFloat(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseFloat2(state.value), {
          onFailure: () => succeed7(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide a floating point value")
            }
          })),
          onSuccess: (n) => flatMap9(sync4(() => round(n, options3.precision)), (rounded) => match11(options3.validate(rounded), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value5) => Action.Submit({
              value: value5
            })
          }))
        });
      }
      default: {
        const value5 = getOrElse2(input.input, () => "");
        return defaultFloatProcessor(state, value5);
      }
    }
  };
}
var float = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    precision: 2,
    validate: (n) => {
      if (n < opts.min) {
        return fail7(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail7(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed7(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderFloat(opts),
    process: handleProcessFloat(opts),
    clear: handleClear3(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/select.js
var renderBeep4 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
var NEWLINE_REGEX4 = /\r?\n/;
function renderOutput3(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX4), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2));
    }
  });
}
function renderChoicePrefix(state, choices, toDisplay, currentIndex, figures4) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures4.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < choices.length) {
    prefix = figures4.arrowDown;
  }
  if (choices[currentIndex].disabled) {
    const annotation = combine11(bold2, blackBright2);
    return state === currentIndex ? figures4.pointer.pipe(annotate2(annotation), cat2(prefix)) : prefix.pipe(cat2(space2));
  }
  return state === currentIndex ? figures4.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderChoiceTitle(choice4, isSelected) {
  const title = text3(choice4.title);
  if (isSelected) {
    return choice4.disabled ? annotate2(title, combine11(underlined2, blackBright2)) : annotate2(title, combine11(underlined2, cyanBright2));
  }
  return choice4.disabled ? annotate2(title, combine11(strikethrough2, blackBright2)) : title;
}
function renderChoiceDescription(choice4, isSelected) {
  if (!choice4.disabled && choice4.description && isSelected) {
    return char3("-").pipe(cat2(space2), cat2(text3(choice4.description)), annotate2(blackBright2));
  }
  return empty32;
}
function renderChoices(state, options3, figures4) {
  const choices = options3.choices;
  const toDisplay = entriesToDisplay(state, choices.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const choice4 = choices[index];
    const isSelected = state === index;
    const prefix = renderChoicePrefix(state, choices, toDisplay, index, figures4);
    const title = renderChoiceTitle(choice4, isSelected);
    const description = renderChoiceDescription(choice4, isSelected);
    documents.push(prefix.pipe(cat2(title), cat2(space2), cat2(description)));
  }
  return vsep2(documents);
}
function renderNextFrame4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const choices = renderChoices(state, options3, figures4);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(choices), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const selected = text3(options3.choices[state].title);
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(selected, white4)), cat2(hardLine2), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp2(state, choices) {
  if (state === 0) {
    return succeed7(Action.NextFrame({
      state: choices.length - 1
    }));
  }
  return succeed7(Action.NextFrame({
    state: state - 1
  }));
}
function processCursorDown2(state, choices) {
  if (state === choices.length - 1) {
    return succeed7(Action.NextFrame({
      state: 0
    }));
  }
  return succeed7(Action.NextFrame({
    state: state + 1
  }));
}
function processNext2(state, choices) {
  return succeed7(Action.NextFrame({
    state: (state + 1) % choices.length
  }));
}
function handleRender3(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep4),
      NextFrame: ({
        state: state2
      }) => renderNextFrame4(state2, options3),
      Submit: () => renderSubmission4(state, options3)
    });
  };
}
function handleClear4(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const text10 = "\n".repeat(Math.min(options3.choices.length, options3.maxPerPage)) + options3.message;
    const clearOutput = eraseText(text10, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess3(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp2(state, options3.choices);
      }
      case "j":
      case "down": {
        return processCursorDown2(state, options3.choices);
      }
      case "tab": {
        return processNext2(state, options3.choices);
      }
      case "enter":
      case "return": {
        const selected = options3.choices[state];
        if (selected.disabled) {
          return succeed7(Action.Beep());
        }
        return succeed7(Action.Submit({
          value: selected.value
        }));
      }
      default: {
        return succeed7(Action.Beep());
      }
    }
  };
}
var select = (options3) => {
  const opts = {
    maxPerPage: 10,
    ...options3
  };
  let initialIndex = 0;
  let seenSelected = -1;
  for (let i = 0; i < opts.choices.length; i++) {
    const choice4 = opts.choices[i];
    if (choice4.selected === true) {
      if (seenSelected !== -1) {
        throw new Error("InvalidArgumentException: only a single choice can be selected by default for Prompt.select");
      }
      seenSelected = i;
    }
  }
  if (seenSelected !== -1) {
    initialIndex = seenSelected;
  }
  return custom2(initialIndex, {
    render: handleRender3(opts),
    process: handleProcess3(opts),
    clear: () => handleClear4(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/text.js
function getValue(state, options3) {
  return state.value.length > 0 ? state.value : options3.default;
}
var renderBeep5 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function renderClearScreen(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
    const clearError = match2(state.error, {
      onNone: () => empty32,
      onSome: (error4) => (
        // If there was an error, move the cursor down to the final error line and
        // then clear all lines of error output
        cursorDown3(lines(error4, columns)).pipe(
          // Add a leading newline to the error message to ensure that the corrrect
          // number of error lines are erased
          cat2(eraseText(`
${error4}`, columns))
        )
      )
    });
    const clearOutput = eraseText(options3.message, columns);
    return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderInput2(nextState, options3, submitted) {
  const text10 = getValue(nextState, options3);
  const annotation = match2(nextState.error, {
    onNone: () => {
      if (submitted) {
        return white4;
      }
      if (nextState.value.length === 0) {
        return blackBright2;
      }
      return combine11(underlined2, cyanBright2);
    },
    onSome: () => red4
  });
  switch (options3.type) {
    case "hidden": {
      return empty32;
    }
    case "password": {
      return annotate2(text3("*".repeat(text10.length)), annotation);
    }
    case "text": {
      return annotate2(text3(text10), annotation);
    }
  }
}
function renderError3(nextState, pointer) {
  return match2(nextState.error, {
    onNone: () => empty32,
    onSome: (error4) => match3(error4.split(/\r?\n/), {
      onEmpty: () => empty32,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => text3(line4).pipe(annotate2(combine11(italicized2, red4)));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines3 = map4(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput4(nextState, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines3 = map4(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput2(nextState, options3, submitted)));
  }
  return hsep2([prefix, trailingSymbol, renderInput2(nextState, options3, submitted)]);
}
function renderNextFrame5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3);
    const errorMsg = renderError3(state, figures4.pointerSmall);
    const offset = state.cursor - state.value.length;
    return promptMsg.pipe(cat2(errorMsg), cat2(cursorMove3(offset)), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace2(state) {
  if (state.cursor <= 0) {
    return succeed7(Action.Beep());
  }
  const beforeCursor = state.value.slice(0, state.cursor - 1);
  const afterCursor = state.value.slice(state.cursor);
  const cursor = state.cursor - 1;
  const value5 = `${beforeCursor}${afterCursor}`;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value5,
      error: none2()
    }
  }));
}
function processCursorLeft2(state) {
  if (state.cursor <= 0) {
    return succeed7(Action.Beep());
  }
  const cursor = state.cursor - 1;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor,
      error: none2()
    }
  }));
}
function processCursorRight2(state) {
  if (state.cursor >= state.value.length) {
    return succeed7(Action.Beep());
  }
  const cursor = Math.min(state.cursor + 1, state.value.length);
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor,
      error: none2()
    }
  }));
}
function processTab(state, options3) {
  if (state.value === options3.default) {
    return succeed7(Action.Beep());
  }
  const value5 = getValue(state, options3);
  const cursor = value5.length;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      value: value5,
      cursor,
      error: none2()
    }
  }));
}
function defaultProcessor2(input, state) {
  const beforeCursor = state.value.slice(0, state.cursor);
  const afterCursor = state.value.slice(state.cursor);
  const value5 = `${beforeCursor}${input}${afterCursor}`;
  const cursor = state.cursor + input.length;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value5,
      error: none2()
    }
  }));
}
var initialState2 = {
  cursor: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRender4(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep5),
      NextFrame: ({
        state: state2
      }) => renderNextFrame5(state2, options3),
      Submit: () => renderSubmission5(state, options3)
    });
  };
}
function handleProcess4(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace2(state);
      }
      case "left": {
        return processCursorLeft2(state);
      }
      case "right": {
        return processCursorRight2(state);
      }
      case "enter":
      case "return": {
        const value5 = getValue(state, options3);
        return match11(options3.validate(value5), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              value: value5,
              error: some2(error4)
            }
          }),
          onSuccess: (value6) => Action.Submit({
            value: value6
          })
        });
      }
      case "tab": {
        return processTab(state, options3);
      }
      default: {
        const value5 = getOrElse2(input.input, () => "");
        return defaultProcessor2(value5, state);
      }
    }
  };
}
function handleClear5(options3) {
  return (state, _) => {
    return renderClearScreen(state, options3);
  };
}
function basePrompt(options3, type2) {
  const opts = {
    default: "",
    type: type2,
    validate: succeed7,
    ...options3
  };
  return custom2(initialState2, {
    render: handleRender4(opts),
    process: handleProcess4(opts),
    clear: handleClear5(opts)
  });
}
var hidden = (options3) => basePrompt(options3, "hidden").pipe(map28(make51));
var text5 = (options3) => basePrompt(options3, "text");

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/toggle.js
var renderBeep6 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear6(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const clearOutput = eraseText(options3.message, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderToggle(value5, options3, submitted = false) {
  const separator = annotate2(char3("/"), blackBright2);
  const selectedAnnotation = combine11(underlined2, submitted ? white4 : cyanBright2);
  const inactive = value5 ? text3(options3.inactive) : annotate2(text3(options3.inactive), selectedAnnotation);
  const active2 = value5 ? annotate2(text3(options3.active), selectedAnnotation) : text3(options3.active);
  return hsep2([active2, separator, inactive]);
}
function renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines3 = map4(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(toggle3));
  }
  return hsep2([prefix, trailingSymbol, toggle3]);
}
function renderNextFrame6(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures4 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const toggle3 = renderToggle(state, options3);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission6(value5, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures4 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const toggle3 = renderToggle(value5, options3, true);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
var activate = /* @__PURE__ */ succeed7(/* @__PURE__ */ Action.NextFrame({
  state: true
}));
var deactivate = /* @__PURE__ */ succeed7(/* @__PURE__ */ Action.NextFrame({
  state: false
}));
function handleRender5(options3) {
  return (state, action) => {
    switch (action._tag) {
      case "Beep": {
        return succeed7(renderBeep6);
      }
      case "NextFrame": {
        return renderNextFrame6(state, options3);
      }
      case "Submit": {
        return renderSubmission6(state, options3);
      }
    }
  };
}
function handleProcess5(input, state) {
  switch (input.key.name) {
    case "0":
    case "j":
    case "delete":
    case "right":
    case "down": {
      return deactivate;
    }
    case "1":
    case "k":
    case "left":
    case "up": {
      return activate;
    }
    case " ":
    case "tab": {
      return state ? deactivate : activate;
    }
    case "enter":
    case "return": {
      return succeed7(Action.Submit({
        value: state
      }));
    }
    default: {
      return succeed7(Action.Beep());
    }
  }
}
var toggle2 = (options3) => {
  const opts = {
    initial: false,
    active: "on",
    inactive: "off",
    ...options3
  };
  return custom2(opts.initial, {
    render: handleRender5(opts),
    process: handleProcess5,
    clear: () => handleClear6(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/primitive.js
var PrimitiveSymbolKey = "@effect/cli/Primitive";
var PrimitiveTypeId = /* @__PURE__ */ Symbol.for(PrimitiveSymbolKey);
var proto19 = {
  [PrimitiveTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrimitive = (u) => typeof u === "object" && u != null && PrimitiveTypeId in u;
var isBool = (self) => isPrimitive(self) && isBoolType(self);
var isBoolType = (self) => self._tag === "Bool";
var trueValues = /* @__PURE__ */ Literal2("true", "1", "y", "yes", "on");
var isTrueValue = /* @__PURE__ */ is(trueValues);
var falseValues = /* @__PURE__ */ Literal2("false", "0", "n", "no", "off");
var isFalseValue = /* @__PURE__ */ is(falseValues);
var boolean3 = (defaultValue) => {
  const op = Object.create(proto19);
  op._tag = "Bool";
  op.defaultValue = defaultValue;
  return op;
};
var choice = (alternatives) => {
  const op = Object.create(proto19);
  op._tag = "Choice";
  op.alternatives = alternatives;
  return op;
};
var integer3 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Integer";
  return op;
})();
var path = (pathType, pathExists) => {
  const op = Object.create(proto19);
  op._tag = "Path";
  op.pathType = pathType;
  op.pathExists = pathExists;
  return op;
};
var text6 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Text";
  return op;
})();
var getChoices = (self) => getChoicesInternal(self);
var getHelp = (self) => getHelpInternal(self);
var getTypeName = (self) => getTypeNameInternal(self);
var validate4 = /* @__PURE__ */ dual(3, (self, value5, config2) => validateInternal(self, value5, config2));
var wizard = /* @__PURE__ */ dual(2, (self, help) => wizardInternal(self, help));
var getChoicesInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return some2("true | false");
    }
    case "Choice": {
      const choices = pipe(map4(self.alternatives, ([choice4]) => choice4), join(" | "));
      return some2(choices);
    }
    case "DateTime": {
      return some2("date");
    }
    case "Float":
    case "Integer":
    case "Path":
    case "Redacted":
    case "Secret":
    case "Text": {
      return none2();
    }
  }
};
var getHelpInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return text4("A true or false value.");
    }
    case "Choice": {
      const choices = pipe(map4(self.alternatives, ([choice4]) => choice4), join(", "));
      return text4(`One of the following: ${choices}`);
    }
    case "DateTime": {
      return text4("A date without a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30.");
    }
    case "Float": {
      return text4("A floating point number.");
    }
    case "Integer": {
      return text4("An integer.");
    }
    case "Path": {
      if (self.pathType === "either" && self.pathExists === "yes") {
        return text4("An existing file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "yes") {
        return text4("An existing file.");
      }
      if (self.pathType === "directory" && self.pathExists === "yes") {
        return text4("An existing directory.");
      }
      if (self.pathType === "either" && self.pathExists === "no") {
        return text4("A file or directory that must not exist.");
      }
      if (self.pathType === "file" && self.pathExists === "no") {
        return text4("A file that must not exist.");
      }
      if (self.pathType === "directory" && self.pathExists === "no") {
        return text4("A directory that must not exist.");
      }
      if (self.pathType === "either" && self.pathExists === "either") {
        return text4("A file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "either") {
        return text4("A file.");
      }
      if (self.pathType === "directory" && self.pathExists === "either") {
        return text4("A directory.");
      }
      throw new Error(`[BUG]: Path.help - encountered invalid combination of path type ('${self.pathType}') and path existence ('${self.pathExists}')`);
    }
    case "Secret":
    case "Redacted": {
      return text4("A user-defined piece of text that is confidential.");
    }
    case "Text": {
      return text4("A user-defined piece of text.");
    }
  }
};
var getTypeNameInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "boolean";
    }
    case "Choice": {
      return "choice";
    }
    case "DateTime": {
      return "date";
    }
    case "Float": {
      return "float";
    }
    case "Integer": {
      return "integer";
    }
    case "Path": {
      if (self.pathType === "either") {
        return "path";
      }
      return self.pathType;
    }
    case "Redacted": {
      return "redacted";
    }
    case "Secret": {
      return "secret";
    }
    case "Text": {
      return "text";
    }
  }
};
var validateInternal = (self, value5, config2) => {
  switch (self._tag) {
    case "Bool": {
      return map2(value5, (str) => normalizeCase(config2, str)).pipe(match2({
        onNone: () => orElseFail2(self.defaultValue, () => `Missing default value for boolean parameter`),
        onSome: (value6) => isTrueValue(value6) ? succeed7(true) : isFalseValue(value6) ? succeed7(false) : fail7(`Unable to recognize '${value6}' as a valid boolean`)
      }));
    }
    case "Choice": {
      return orElseFail2(value5, () => `Choice options to not have a default value`).pipe(flatMap9((value6) => findFirst2(self.alternatives, ([choice4]) => choice4 === value6)), mapBoth4({
        onFailure: () => {
          const choices = pipe(map4(self.alternatives, ([choice4]) => choice4), join(", "));
          return `Expected one of the following cases: ${choices}`;
        },
        onSuccess: ([, value6]) => value6
      }));
    }
    case "DateTime": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(Date$));
    }
    case "Float": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(NumberFromString));
    }
    case "Integer": {
      const intFromString = compose3(NumberFromString, Int);
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(intFromString));
    }
    case "Path": {
      return flatMap9(FileSystem, (fileSystem) => {
        const errorMsg = "Path options do not have a default value";
        return orElseFail2(value5, () => errorMsg).pipe(tap2((path2) => orDie2(fileSystem.exists(path2)).pipe(tap2((pathExists) => validatePathExistence(path2, self.pathExists, pathExists).pipe(zipRight3(validatePathType(path2, self.pathType, fileSystem).pipe(when2(() => self.pathExists !== "no" && pathExists))))))));
      });
    }
    case "Redacted": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$)).pipe(map17((value6) => make51(value6)));
    }
    case "Secret": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$)).pipe(map17((value6) => fromString2(value6)));
    }
    case "Text": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$));
    }
  }
};
var attempt = (option6, typeName, parse6) => orElseFail2(option6, () => `${typeName} options do not have a default value`).pipe(flatMap9((value5) => orElseFail2(parse6(value5), () => `'${value5}' is not a ${typeName}`)));
var validatePathExistence = (path2, shouldPathExist, pathExists) => {
  if (shouldPathExist === "no" && pathExists) {
    return fail7(`Path '${path2}' must not exist`);
  }
  if (shouldPathExist === "yes" && !pathExists) {
    return fail7(`Path '${path2}' must exist`);
  }
  return _void;
};
var validatePathType = (path2, pathType, fileSystem) => {
  switch (pathType) {
    case "file": {
      const checkIsFile = fileSystem.stat(path2).pipe(map17((info2) => info2.type === "File"), orDie2);
      return fail7(`Expected path '${path2}' to be a regular file`).pipe(unlessEffect2(checkIsFile), asVoid2);
    }
    case "directory": {
      const checkIsDirectory = fileSystem.stat(path2).pipe(map17((info2) => info2.type === "Directory"), orDie2);
      return fail7(`Expected path '${path2}' to be a directory`).pipe(unlessEffect2(checkIsDirectory), asVoid2);
    }
    case "either": {
      return _void;
    }
  }
};
var wizardInternal = (self, help) => {
  switch (self._tag) {
    case "Bool": {
      const primitiveHelp = p("Select true or false");
      const message = sequence(help, primitiveHelp);
      const initial = getOrElse2(self.defaultValue, () => false);
      return toggle2({
        message: toAnsiText(message).trimEnd(),
        initial,
        active: "true",
        inactive: "false"
      }).pipe(map28((bool) => `${bool}`));
    }
    case "Choice": {
      const primitiveHelp = p("Select one of the following choices");
      const message = sequence(help, primitiveHelp);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: map4(self.alternatives, ([title]) => ({
          title,
          value: title
        }))
      });
    }
    case "DateTime": {
      const primitiveHelp = p("Enter a date");
      const message = sequence(help, primitiveHelp);
      return date2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map28((date5) => date5.toISOString()));
    }
    case "Float": {
      const primitiveHelp = p("Enter a floating point value");
      const message = sequence(help, primitiveHelp);
      return float({
        message: toAnsiText(message).trimEnd()
      }).pipe(map28((value5) => `${value5}`));
    }
    case "Integer": {
      const primitiveHelp = p("Enter an integer");
      const message = sequence(help, primitiveHelp);
      return integer2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map28((value5) => `${value5}`));
    }
    case "Path": {
      const primitiveHelp = p("Select a file system path");
      const message = sequence(help, primitiveHelp);
      return file({
        type: self.pathType,
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Redacted": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Secret": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Text": {
      const primitiveHelp = p("Enter some text");
      const message = sequence(help, primitiveHelp);
      return text5({
        message: toAnsiText(message).trimEnd()
      });
    }
  }
};
var getBashCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return '"${cur}"';
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Secret":
    case "Redacted":
    case "Text": {
      return '$(compgen -f "${cur}")';
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -d "${cur}")' : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
      }
    }
    case "Choice": {
      const choices = pipe(map4(self.alternatives, ([choice4]) => choice4), join(","));
      return `$(compgen -W "${choices}" -- "\${cur}")`;
    }
  }
};
var getFishCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return empty2();
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Redacted":
    case "Secret":
    case "Text": {
      return make4("-r", "-f");
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-f", "-a", `"(__fish_complete_directories (commandline -ct))"`) : make4("-r");
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
      }
    }
    case "Choice": {
      const choices = pipe(map4(self.alternatives, ([choice4]) => `${choice4}''`), join(","));
      return make4("-r", "-f", "-a", `"{${choices}}"`);
    }
  }
};
var getZshCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "";
    }
    case "Choice": {
      const choices = pipe(map4(self.alternatives, ([name]) => name), join(" "));
      return `:CHOICE:(${choices})`;
    }
    case "DateTime": {
      return "";
    }
    case "Float": {
      return "";
    }
    case "Integer": {
      return "";
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files -/" : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
      }
    }
    case "Redacted":
    case "Secret":
    case "Text": {
      return "";
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/list.js
var list3 = (options3) => text5(options3).pipe(map28((output) => output.split(options3.delimiter || ",")));

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/usage.js
var empty37 = {
  _tag: "Empty"
};
var mixed = {
  _tag: "Empty"
};
var named = (names, acceptedValues) => ({
  _tag: "Named",
  names,
  acceptedValues
});
var optional2 = (self) => ({
  _tag: "Optional",
  usage: self
});
var repeated2 = (self) => ({
  _tag: "Repeated",
  usage: self
});
var alternation = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Alternation",
  left: self,
  right: that
}));
var concat4 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Concat",
  left: self,
  right: that
}));
var getHelp2 = (self) => {
  const spans2 = enumerate(self, defaultConfig);
  if (isNonEmptyReadonlyArray(spans2)) {
    const head5 = headNonEmpty(spans2);
    const tail = tailNonEmpty(spans2);
    if (isNonEmptyReadonlyArray(tail)) {
      return pipe(map4(spans2, (span2) => p(span2)), reduceRight(empty34, (left3, right3) => sequence(left3, right3)));
    }
    return p(head5);
  }
  return empty34;
};
var enumerate = /* @__PURE__ */ dual(2, (self, config2) => render4(simplify(self, config2), config2));
var simplify = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Mixed": {
      return mixed;
    }
    case "Named": {
      if (isNone2(head(render4(self, config2)))) {
        return empty37;
      }
      return self;
    }
    case "Optional": {
      if (self.usage._tag === "Empty") {
        return empty37;
      }
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty37 : usage._tag === "Optional" ? usage : optional2(usage);
    }
    case "Repeated": {
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty37 : repeated2(usage);
    }
    case "Alternation": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : alternation(leftUsage, rightUsage);
    }
    case "Concat": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : concat4(leftUsage, rightUsage);
    }
  }
};
var render4 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return of(text4(""));
    }
    case "Mixed": {
      return of(text4("<command>"));
    }
    case "Named": {
      const typeInfo = config2.showTypes ? match2(self.acceptedValues, {
        onNone: () => empty33,
        onSome: (s) => concat2(space3, text4(s))
      }) : empty33;
      const namesToShow = config2.showAllNames ? self.names : self.names.length > 1 ? pipe(filter2(self.names, (name) => name.startsWith("--")), head, map2(of), getOrElse2(() => self.names)) : self.names;
      const nameInfo = text4(join(namesToShow, ", "));
      return config2.showAllNames && self.names.length > 1 ? of(spans([text4("("), nameInfo, typeInfo, text4(")")])) : of(concat2(nameInfo, typeInfo));
    }
    case "Optional": {
      return map4(render4(self.usage, config2), (span2) => spans([text4("["), span2, text4("]")]));
    }
    case "Repeated": {
      return map4(render4(self.usage, config2), (span2) => concat2(span2, text4("...")));
    }
    case "Alternation": {
      if (self.left._tag === "Repeated" || self.right._tag === "Repeated" || self.left._tag === "Concat" || self.right._tag === "Concat") {
        return appendAll(render4(self.left, config2), render4(self.right, config2));
      }
      return flatMap2(render4(self.left, config2), (left3) => map4(render4(self.right, config2), (right3) => spans([left3, text4("|"), right3])));
    }
    case "Concat": {
      const leftSpan = render4(self.left, config2);
      const rightSpan = render4(self.right, config2);
      const separator = isNonEmptyReadonlyArray(leftSpan) && isNonEmptyReadonlyArray(rightSpan) ? space3 : empty33;
      return flatMap2(leftSpan, (left3) => map4(rightSpan, (right3) => spans([left3, separator, right3])));
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/validationError.js
var ValidationErrorSymbolKey = "@effect/cli/ValidationError";
var ValidationErrorTypeId = /* @__PURE__ */ Symbol.for(ValidationErrorSymbolKey);
var proto20 = {
  [ValidationErrorTypeId]: ValidationErrorTypeId
};
var isValidationError = (u) => typeof u === "object" && u != null && ValidationErrorTypeId in u;
var isCommandMismatch = (self) => self._tag === "CommandMismatch";
var isHelpRequested = (self) => self._tag === "HelpRequested";
var isMultipleValuesDetected = (self) => self._tag === "MultipleValuesDetected";
var isMissingValue = (self) => self._tag === "MissingValue";
var commandMismatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CommandMismatch";
  op.error = error4;
  return op;
};
var correctedFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CorrectedFlag";
  op.error = error4;
  return op;
};
var invalidArgument = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidArgument";
  op.error = error4;
  return op;
};
var invalidValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidValue";
  op.error = error4;
  return op;
};
var missingFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingFlag";
  op.error = error4;
  return op;
};
var missingValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingValue";
  op.error = error4;
  return op;
};
var multipleValuesDetected = (error4, values4) => {
  const op = Object.create(proto20);
  op._tag = "MultipleValuesDetected";
  op.error = error4;
  op.values = values4;
  return op;
};
var noBuiltInMatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "NoBuiltInMatch";
  op.error = error4;
  return op;
};
var unclusteredFlag = (error4, unclustered, rest) => {
  const op = Object.create(proto20);
  op._tag = "UnclusteredFlag";
  op.error = error4;
  op.unclustered = unclustered;
  op.rest = rest;
  return op;
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/options.js
var OptionsSymbolKey = "@effect/cli/Options";
var OptionsTypeId = /* @__PURE__ */ Symbol.for(OptionsSymbolKey);
var proto21 = {
  [OptionsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isOptions = (u) => typeof u === "object" && u != null && OptionsTypeId in u;
var isEmpty15 = (self) => self._tag === "Empty";
var isSingle2 = (self) => self._tag === "Single";
var all6 = function() {
  if (arguments.length === 1) {
    if (isOptions(arguments[0])) {
      return map29(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries3 = Object.entries(arguments[0]);
      let result = map29(entries3[0][1], (value5) => ({
        [entries3[0][0]]: value5
      }));
      if (entries3.length === 1) {
        return result;
      }
      const rest = entries3.slice(1);
      for (const [key, options3] of rest) {
        result = map29(makeBoth(result, options3), ([record2, value5]) => ({
          ...record2,
          [key]: value5
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
var defaultBooleanOptions = {
  ifPresent: true,
  negationNames: [],
  aliases: []
};
var boolean4 = (name, options3) => {
  const {
    aliases,
    ifPresent,
    negationNames
  } = {
    ...defaultBooleanOptions,
    ...options3
  };
  const option6 = makeSingle(name, aliases, boolean3(some2(ifPresent)));
  if (isNonEmptyReadonlyArray(negationNames)) {
    const head5 = headNonEmpty(negationNames);
    const tail = tailNonEmpty(negationNames);
    const negationOption = makeSingle(head5, tail, boolean3(some2(!ifPresent)));
    return withDefault2(orElse14(option6, negationOption), !ifPresent);
  }
  return withDefault2(option6, !ifPresent);
};
var choice2 = (name, choices) => {
  const primitive2 = choice(map4(choices, (choice4) => [choice4, choice4]));
  return makeSingle(name, empty2(), primitive2);
};
var choiceWithValue = (name, choices) => makeSingle(name, empty2(), choice(choices));
var directory = (name, config2) => makeSingle(name, empty2(), path("directory", config2?.exists ?? "either"));
var file2 = (name, config2) => makeSingle(name, empty2(), path("file", config2?.exists ?? "either"));
var integer4 = (name) => makeSingle(name, empty2(), integer3);
var none10 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto21);
  op._tag = "Empty";
  return op;
})();
var text7 = (name) => makeSingle(name, empty2(), text6);
var getHelp3 = (self) => getHelpInternal2(self);
var getUsage = (self) => getUsageInternal(self);
var map29 = /* @__PURE__ */ dual(2, (self, f) => makeMap(self, (a) => right2(f(a))));
var mapEffect5 = /* @__PURE__ */ dual(2, (self, f) => makeMap(self, f));
var optional3 = (self) => withDefault2(map29(self, some2), none2());
var orElse14 = /* @__PURE__ */ dual(2, (self, that) => orElseEither4(self, that).pipe(map29(merge)));
var orElseEither4 = /* @__PURE__ */ dual(2, (self, that) => makeOrElse(self, that));
var processCommandLine = /* @__PURE__ */ dual(3, (self, args3, config2) => matchOptions(args3, toParseableInstruction(self), config2).pipe(flatMap9(([error4, commandArgs, matchedOptions]) => parseInternal(self, matchedOptions, config2).pipe(catchAll2((e) => match2(error4, {
  onNone: () => fail7(e),
  onSome: (err) => fail7(err)
})), map17((a) => [error4, commandArgs, a])))));
var repeated3 = (self) => makeVariadic(self, none2(), none2());
var withAlias = /* @__PURE__ */ dual(2, (self, alias) => modifySingle(self, (single) => {
  const aliases = append(single.aliases, alias);
  return makeSingle(single.name, aliases, single.primitiveType, single.description, single.pseudoName);
}));
var withDefault2 = /* @__PURE__ */ dual(2, (self, fallback) => makeWithDefault(self, fallback));
var withDescription2 = /* @__PURE__ */ dual(2, (self, desc) => modifySingle(self, (single) => {
  const description = sequence(single.description, p(desc));
  return makeSingle(single.name, single.aliases, single.primitiveType, description, single.pseudoName);
}));
var wizard2 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal2(self, config2));
var allTupled = (arg) => {
  if (arg.length === 0) {
    return none10;
  }
  if (arg.length === 1) {
    return map29(arg[0], (x) => [x]);
  }
  let result = map29(arg[0], (x) => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map29(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty34;
    }
    case "Single": {
      return descriptionList(of([getSpan(getHelp2(getUsageInternal(self))), sequence(p(getHelp(self.primitiveType)), self.description)]));
    }
    case "KeyValueMap": {
      const identifier2 = getOrThrow2(getIdentifierInternal(self.argumentOption));
      return mapDescriptionList(getHelpInternal2(self.argumentOption), (span2, oldBlock) => {
        const header = p("This setting is a property argument which:");
        const single = `${identifier2} key1=value key2=value2`;
        const multiple = `${identifier2} key1=value ${identifier2} key2=value2`;
        const description = enumeration([p(`May be specified a single time:  '${single}'`), p(`May be specified multiple times: '${multiple}'`)]);
        const newBlock = pipe(oldBlock, sequence(header), sequence(description));
        return [span2, newBlock];
      });
    }
    case "Map": {
      return getHelpInternal2(self.options);
    }
    case "Both":
    case "OrElse": {
      return sequence(getHelpInternal2(self.left), getHelpInternal2(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal2(self.argumentOption);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min4 = getMinSizeInternal(self);
        const max6 = getMaxSizeInternal(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min4} - ${max6}` : min4 === 0 ? "..." : ` ${min4}+`);
        const newBlock = p(isSome2(self.max) ? `This option must be repeated at least ${min4} times and may be repeated up to ${max6} times.` : min4 === 0 ? "This option may be repeated zero or more times." : `This option must be repeated at least ${min4} times.`);
        return [concat2(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal2(self.options), (span2, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span2, sequence(block, optionalDescription)];
      });
    }
    case "WithFallback": {
      const helpDoc = isConfig2(self.effect) ? p("This option can be set from environment variables.") : isPrompt(self.effect) ? p("Will prompt the user for input if this option is not provided.") : empty34;
      return mapDescriptionList(getHelpInternal2(self.options), (span2, block) => [span2, sequence(block, helpDoc)]);
    }
  }
};
var getIdentifierInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return none2();
    }
    case "Single": {
      return some2(self.fullName);
    }
    case "Both":
    case "OrElse": {
      const ids3 = getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
      return match3(ids3, {
        onEmpty: () => none2(),
        onNonEmpty: (ids4) => some2(join(ids4, ", "))
      });
    }
    case "KeyValueMap":
    case "Variadic": {
      return getIdentifierInternal(self.argumentOption);
    }
    case "Map":
    case "WithFallback":
    case "WithDefault": {
      return getIdentifierInternal(self.options);
    }
  }
};
var getMinSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallback": {
      return 0;
    }
    case "Single":
    case "KeyValueMap": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal(self.options);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return leftMinSize + rightMinSize;
    }
    case "OrElse": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return Math.min(leftMinSize, rightMinSize);
    }
    case "Variadic": {
      const selfMinSize = getOrElse2(self.min, () => 0);
      const argumentOptionMinSize = getMinSizeInternal(self.argumentOption);
      return selfMinSize * argumentOptionMinSize;
    }
  }
};
var getMaxSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "KeyValueMap": {
      return Number.MAX_SAFE_INTEGER;
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getMaxSizeInternal(self.options);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal(self.left);
      const rightMaxSize = getMaxSizeInternal(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "OrElse": {
      const leftMin = getMaxSizeInternal(self.left);
      const rightMin = getMaxSizeInternal(self.right);
      return Math.min(leftMin, rightMin);
    }
    case "Variadic": {
      const selfMaxSize = getOrElse2(self.max, () => Number.MAX_SAFE_INTEGER / 2);
      const optionsMaxSize = getMaxSizeInternal(self.argumentOption);
      return Math.floor(selfMaxSize * optionsMaxSize);
    }
  }
};
var getUsageInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Single": {
      const acceptedValues = isBool(self.primitiveType) ? none2() : orElse(getChoices(self.primitiveType), () => some2(self.placeholder));
      return named(getNames(self), acceptedValues);
    }
    case "KeyValueMap": {
      return getUsageInternal(self.argumentOption);
    }
    case "Map": {
      return getUsageInternal(self.options);
    }
    case "Both": {
      return concat4(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "OrElse": {
      return alternation(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal(self.argumentOption));
    }
    case "WithDefault":
    case "WithFallback": {
      return optional2(getUsageInternal(self.options));
    }
  }
};
var isBoolInternal = (self) => {
  switch (self._tag) {
    case "Single": {
      return isBool(self.primitiveType);
    }
    case "Map": {
      return isBoolInternal(self.options);
    }
    case "WithDefault": {
      return isBoolInternal(self.options);
    }
    default: {
      return false;
    }
  }
};
var makeBoth = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeFullName = (str) => str.length === 1 ? [true, `-${str}`] : [false, `--${str}`];
var makeKeyValueMap = (argumentOption) => {
  const op = Object.create(proto21);
  op._tag = "KeyValueMap";
  op.argumentOption = argumentOption;
  return op;
};
var makeMap = (options3, f) => {
  const op = Object.create(proto21);
  op._tag = "Map";
  op.options = options3;
  op.f = f;
  return op;
};
var makeOrElse = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "OrElse";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeSingle = (name, aliases, primitiveType, description = empty34, pseudoName = none2()) => {
  const op = Object.create(proto21);
  op._tag = "Single";
  op.name = name;
  op.fullName = makeFullName(name)[1];
  op.placeholder = `${getOrElse2(pseudoName, () => getTypeName(primitiveType))}`;
  op.aliases = aliases;
  op.primitiveType = primitiveType;
  op.description = description;
  op.pseudoName = pseudoName;
  return op;
};
var makeVariadic = (argumentOption, min4, max6) => {
  if (!isSingle2(argumentOption)) {
    throw new Error("InvalidArgumentException: only single options can be variadic");
  }
  const op = Object.create(proto21);
  op._tag = "Variadic";
  op.argumentOption = argumentOption;
  op.min = min4;
  op.max = max6;
  return op;
};
var makeWithDefault = (options3, fallback) => {
  const op = Object.create(proto21);
  op._tag = "WithDefault";
  op.options = options3;
  op.fallback = fallback;
  return op;
};
var makeWithFallback = (options3, effect3) => {
  const op = Object.create(proto21);
  op._tag = "WithFallback";
  op.options = options3;
  op.effect = effect3;
  return op;
};
var modifySingle = (self, f) => {
  switch (self._tag) {
    case "Empty": {
      return none10;
    }
    case "Single": {
      return f(self);
    }
    case "KeyValueMap": {
      return makeKeyValueMap(f(self.argumentOption));
    }
    case "Map": {
      return makeMap(modifySingle(self.options, f), self.f);
    }
    case "Both": {
      return makeBoth(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "OrElse": {
      return makeOrElse(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "Variadic": {
      return makeVariadic(f(self.argumentOption), self.min, self.max);
    }
    case "WithDefault": {
      return makeWithDefault(modifySingle(self.options, f), self.fallback);
    }
    case "WithFallback": {
      return makeWithFallback(modifySingle(self.options, f), self.effect);
    }
  }
};
var getNames = (self) => {
  const loop2 = (self2) => {
    switch (self2._tag) {
      case "Empty": {
        return empty2();
      }
      case "Single": {
        return prepend(self2.aliases, self2.name);
      }
      case "KeyValueMap":
      case "Variadic": {
        return loop2(self2.argumentOption);
      }
      case "Map":
      case "WithDefault":
      case "WithFallback": {
        return loop2(self2.options);
      }
      case "Both":
      case "OrElse": {
        const left3 = loop2(self2.left);
        const right3 = loop2(self2.right);
        return appendAll(left3, right3);
      }
    }
  };
  const order = mapInput2(boolean, (tuple3) => !tuple3[0]);
  return pipe(loop2(self), map4((str) => makeFullName(str)), sort(order), map4((tuple3) => tuple3[1]));
};
var toParseableInstruction = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single":
    case "KeyValueMap":
    case "Variadic": {
      return of(self);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return toParseableInstruction(self.options);
    }
    case "Both":
    case "OrElse": {
      return appendAll(toParseableInstruction(self.left), toParseableInstruction(self.right));
    }
  }
};
var keyValueSplitter = /=(.*)/;
var parseInternal = (self, args3, config2) => {
  switch (self._tag) {
    case "Empty": {
      return _void;
    }
    case "Single": {
      const singleNames = filterMap2(getNames(self), (name) => get7(args3, name));
      if (isNonEmptyReadonlyArray(singleNames)) {
        const head5 = headNonEmpty(singleNames);
        const tail = tailNonEmpty(singleNames);
        if (isEmptyReadonlyArray(tail)) {
          if (isEmptyReadonlyArray(head5)) {
            return validate4(self.primitiveType, none2(), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          if (isNonEmptyReadonlyArray(head5) && isEmptyReadonlyArray(tailNonEmpty(head5))) {
            const value5 = headNonEmpty(head5);
            return validate4(self.primitiveType, some2(value5), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          return fail7(multipleValuesDetected(empty34, head5));
        }
        const error5 = p(`More than one reference to option '${self.fullName}' detected`);
        return fail7(invalidValue(error5));
      }
      const error4 = p(`Expected to find option: '${self.fullName}'`);
      return fail7(missingValue(error4));
    }
    case "KeyValueMap": {
      const extractKeyValue = (value5) => {
        const split2 = value5.trim().split(keyValueSplitter, 2);
        if (isNonEmptyReadonlyArray(split2) && split2.length === 2 && split2[1] !== "") {
          return succeed7(split2);
        }
        const error4 = p(`Expected a key/value pair but received '${value5}'`);
        return fail7(invalidArgument(error4));
      };
      return parseInternal(self.argumentOption, args3, config2).pipe(matchEffect2({
        onFailure: (e) => isMultipleValuesDetected(e) ? forEach8(e.values, (kv) => extractKeyValue(kv)).pipe(map17(fromIterable6)) : fail7(e),
        onSuccess: (kv) => extractKeyValue(kv).pipe(map17(make16))
      }));
    }
    case "Map": {
      return parseInternal(self.options, args3, config2).pipe(flatMap9((a) => self.f(a)));
    }
    case "Both": {
      return parseInternal(self.left, args3, config2).pipe(catchAll2((err1) => parseInternal(self.right, args3, config2).pipe(matchEffect2({
        onFailure: (err2) => {
          const error4 = sequence(err1.error, err2.error);
          return fail7(missingValue(error4));
        },
        onSuccess: () => fail7(err1)
      }))), zip5(parseInternal(self.right, args3, config2)));
    }
    case "OrElse": {
      return parseInternal(self.left, args3, config2).pipe(matchEffect2({
        onFailure: (err1) => parseInternal(self.right, args3, config2).pipe(mapBoth4({
          onFailure: (err2) => (
            // orElse option is only missing in case neither option was given
            isMissingValue(err1) && isMissingValue(err2) ? missingValue(sequence(err1.error, err2.error)) : invalidValue(sequence(err1.error, err2.error))
          ),
          onSuccess: (b) => right2(b)
        })),
        onSuccess: (a) => parseInternal(self.right, args3, config2).pipe(matchEffect2({
          onFailure: () => succeed7(left2(a)),
          onSuccess: () => {
            const leftUid = getOrElse2(getIdentifierInternal(self.left), () => "???");
            const rightUid = getOrElse2(getIdentifierInternal(self.right), () => "???");
            const error4 = p(`Collision between two options detected - you can only specify one of either: ['${leftUid}', '${rightUid}']`);
            return fail7(invalidValue(error4));
          }
        }))
      }));
    }
    case "Variadic": {
      const min4 = getOrElse2(self.min, () => 0);
      const max6 = getOrElse2(self.max, () => Number.MAX_SAFE_INTEGER);
      const matchedArgument = filterMap2(getNames(self), (name) => get7(args3, name));
      const validateMinMax = (values4) => {
        if (values4.length < min4) {
          const name = self.argumentOption.fullName;
          const error4 = `Expected at least ${min4} value(s) for option: '${name}'`;
          return fail7(invalidValue(p(error4)));
        }
        if (values4.length > max6) {
          const name = self.argumentOption.fullName;
          const error4 = `Expected at most ${max6} value(s) for option: '${name}'`;
          return fail7(invalidValue(p(error4)));
        }
        const primitive2 = self.argumentOption.primitiveType;
        const validatePrimitive = (value5) => validate4(primitive2, some2(value5), config2).pipe(mapError2((e) => invalidValue(p(e))));
        return forEach8(values4, (value5) => validatePrimitive(value5));
      };
      if (every(matchedArgument, isEmptyReadonlyArray)) {
        return validateMinMax(empty2());
      }
      return parseInternal(self.argumentOption, args3, config2).pipe(matchEffect2({
        onFailure: (error4) => isMultipleValuesDetected(error4) ? validateMinMax(error4.values) : fail7(error4),
        onSuccess: (value5) => validateMinMax(of(value5))
      }));
    }
    case "WithDefault": {
      return parseInternal(self.options, args3, config2).pipe(catchTag2("MissingValue", () => succeed7(self.fallback)));
    }
    case "WithFallback": {
      return parseInternal(self.options, args3, config2).pipe(catchTag2("MissingValue", (e) => self.effect.pipe(catchAll2((e2) => {
        if (isTagged(e2, "QuitException")) {
          return die5(e2);
        }
        if (isConfigError2(e2) && !isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail7(error4);
        }
        return fail7(e);
      }))));
    }
  }
};
var wizardInternal2 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed7(empty2());
    }
    case "Single": {
      const help = getHelpInternal2(self);
      return wizard(self.primitiveType, help).pipe(flatMap9((input) => {
        const args3 = make4(getNames(self)[0], input);
        return parseCommandLine(self, args3, config2).pipe(as4(args3));
      }), zipLeft2(log3()));
    }
    case "KeyValueMap": {
      const message = p("Enter `key=value` pairs separated by spaces");
      return list3({
        message: toAnsiText(message).trim(),
        delimiter: " "
      }).pipe(flatMap9((args3) => {
        const identifier2 = getOrElse2(getIdentifierInternal(self), () => "");
        return parseInternal(self, make16([identifier2, args3]), config2).pipe(as4(prepend(args3, identifier2)));
      }), zipLeft2(log3()));
    }
    case "Map": {
      return wizardInternal2(self.options, config2);
    }
    case "Both": {
      return zipWith4(wizardInternal2(self.left, config2), wizardInternal2(self.right, config2), (left3, right3) => appendAll(left3, right3));
    }
    case "OrElse": {
      const alternativeHelp = p("Select which option you would like to use");
      const message = pipe(getHelpInternal2(self), sequence(alternativeHelp));
      const makeChoice = (title, value5) => ({
        title,
        value: value5
      });
      const choices = getSomes([map2(getIdentifierInternal(self.left), (title) => makeChoice(title, self.left)), map2(getIdentifierInternal(self.right), (title) => makeChoice(title, self.right))]);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices
      }).pipe(flatMap9((option6) => wizardInternal2(option6, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument be repeated?");
      const message = pipe(getHelpInternal2(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal(self),
        max: getMaxSizeInternal(self)
      }).pipe(flatMap9((n) => n <= 0 ? succeed7(empty2()) : make25(empty2()).pipe(flatMap9((ref) => wizardInternal2(self.argumentOption, config2).pipe(flatMap9((args3) => update3(ref, appendAll(args3))), repeatN2(n - 1), zipRight3(get11(ref)))))));
    }
    case "WithDefault": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`This option is optional - use the default?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: "Yes",
          value: true,
          description: `use the default ${isOption2(self.fallback) ? match2(self.fallback, {
            onNone: () => "",
            onSome: (a) => `(${JSON.stringify(a)})`
          }) : `(${JSON.stringify(self.fallback)})`}`
        }, {
          title: "No",
          value: false,
          description: "use a custom value"
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed7(empty2()) : wizardInternal2(self.options, config2)));
    }
    case "WithFallback": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      if (isPrompt(self.effect)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed7(empty2()) : wizardInternal2(self.options, config2)));
    }
  }
};
var matchOptions = (input, options3, config2) => {
  if (isNonEmptyReadonlyArray(options3)) {
    return findOptions(input, options3, config2).pipe(flatMap9(([otherArgs, otherOptions, map1]) => {
      if (isEmpty4(map1)) {
        return succeed7([none2(), input, map1]);
      }
      return matchOptions(otherArgs, otherOptions, config2).pipe(map17(([error4, otherArgs2, map210]) => [error4, otherArgs2, merge9(map1, fromIterable(map210))]));
    }), catchAll2((e) => succeed7([some2(e), input, empty10()])));
  }
  return isEmptyReadonlyArray(input) ? succeed7([none2(), empty2(), empty10()]) : succeed7([none2(), input, empty10()]);
};
var findOptions = (input, options3, config2) => matchLeft(options3, {
  onEmpty: () => succeed7([input, empty2(), empty10()]),
  onNonEmpty: (head5, tail) => parseCommandLine(head5, input, config2).pipe(flatMap9(({
    leftover: leftover2,
    parsed
  }) => match2(parsed, {
    onNone: () => findOptions(leftover2, tail, config2).pipe(map17(([nextArgs, nextOptions, map35]) => [nextArgs, prepend(nextOptions, head5), map35])),
    onSome: ({
      name,
      values: values4
    }) => succeed7([leftover2, tail, make16([name, values4])])
  })), catchTags2({
    CorrectedFlag: (e) => findOptions(input, tail, config2).pipe(catchSome2(() => some2(fail7(e))), flatMap9(([otherArgs, otherOptions, map35]) => fail7(e).pipe(when2(() => isEmpty4(map35)), as4([otherArgs, prepend(otherOptions, head5), map35])))),
    MissingFlag: () => findOptions(input, tail, config2).pipe(map17(([otherArgs, otherOptions, map35]) => [otherArgs, prepend(otherOptions, head5), map35])),
    UnclusteredFlag: (e) => matchUnclustered(e.unclustered, e.rest, options3, config2).pipe(catchAll2(() => fail7(e)))
  }))
});
var CLUSTERED_REGEX = /^-{1}([^-]{2,}$)/;
var FLAG_REGEX = /^(--[^=]+)(?:=(.+))?$/;
var processArgs = (args3) => matchLeft(args3, {
  onEmpty: () => succeed7(empty2()),
  onNonEmpty: (head5, tail) => {
    const value5 = head5.trim();
    if (CLUSTERED_REGEX.test(value5)) {
      const unclustered = value5.substring(1).split("").map((c) => `-${c}`);
      return fail7(unclusteredFlag(empty34, unclustered, tail));
    }
    if (FLAG_REGEX.test(value5)) {
      const result = FLAG_REGEX.exec(value5);
      if (result !== null && result[2] !== void 0) {
        return succeed7(appendAll([result[1], result[2]], tail));
      }
    }
    return succeed7(args3);
  }
});
var parseCommandLine = (self, args3, config2) => {
  switch (self._tag) {
    case "Single": {
      return processArgs(args3).pipe(flatMap9((args4) => matchLeft(args4, {
        onEmpty: () => {
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail7(missingFlag(error4));
        },
        onNonEmpty: (head5, tail) => {
          const normalize = (value5) => normalizeCase(config2, value5);
          const normalizedHead = normalize(head5);
          const normalizedNames = map4(getNames(self), (name) => normalize(name));
          if (contains2(normalizedNames, normalizedHead)) {
            if (isBool(self.primitiveType)) {
              return matchLeft(tail, {
                onEmpty: () => {
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed7({
                    parsed,
                    leftover: tail
                  });
                },
                onNonEmpty: (value5, leftover2) => {
                  if (isTrueValue(value5)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("true")
                    });
                    return succeed7({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  if (isFalseValue(value5)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("false")
                    });
                    return succeed7({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed7({
                    parsed,
                    leftover: tail
                  });
                }
              });
            }
            return matchLeft(tail, {
              onEmpty: () => {
                const error5 = p(`Expected a value following option: '${self.fullName}'`);
                return fail7(missingValue(error5));
              },
              onNonEmpty: (value5, leftover2) => {
                const parsed = some2({
                  name: head5,
                  values: of(value5)
                });
                return succeed7({
                  parsed,
                  leftover: leftover2
                });
              }
            });
          }
          if (self.name.length > config2.autoCorrectLimit + 1 && levensteinDistance(head5, self.fullName, config2) <= config2.autoCorrectLimit) {
            const error5 = p(`The flag '${head5}' is not recognized. Did you mean '${self.fullName}'?`);
            return fail7(correctedFlag(error5));
          }
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail7(missingFlag(error4));
        }
      })));
    }
    case "KeyValueMap": {
      const normalizedNames = map4(getNames(self.argumentOption), (name) => normalizeCase(config2, name));
      return matchLeft(args3, {
        onEmpty: () => succeed7({
          parsed: none2(),
          leftover: args3
        }),
        onNonEmpty: (head5, tail) => {
          const loop2 = (args4) => {
            let keyValues = empty2();
            let leftover2 = args4;
            while (isNonEmptyReadonlyArray(leftover2)) {
              const name = headNonEmpty(leftover2).trim();
              const normalizedName2 = normalizeCase(config2, name);
              if (leftover2.length >= 2 && contains2(normalizedNames, normalizedName2)) {
                const keyValue = leftover2[1].trim();
                const [key, value5] = keyValue.split("=");
                if (key !== void 0 && value5 !== void 0 && value5.length > 0) {
                  keyValues = append(keyValues, keyValue);
                  leftover2 = leftover2.slice(2);
                  continue;
                }
              }
              if (name.includes("=")) {
                const [key, value5] = name.split("=");
                if (key !== void 0 && value5 !== void 0 && value5.length > 0) {
                  keyValues = append(keyValues, name);
                  leftover2 = leftover2.slice(1);
                  continue;
                }
              }
              break;
            }
            return [keyValues, leftover2];
          };
          const normalizedName = normalizeCase(config2, head5);
          if (contains2(normalizedNames, normalizedName)) {
            const [values4, leftover2] = loop2(tail);
            return succeed7({
              parsed: some2({
                name: head5,
                values: values4
              }),
              leftover: leftover2
            });
          }
          return succeed7({
            parsed: none2(),
            leftover: args3
          });
        }
      });
    }
    case "Variadic": {
      const normalizedNames = map4(getNames(self.argumentOption), (name) => normalizeCase(config2, name));
      let optionName = void 0;
      let values4 = empty2();
      let unparsed = args3;
      let leftover2 = empty2();
      while (isNonEmptyReadonlyArray(unparsed)) {
        const name = headNonEmpty(unparsed);
        const normalizedName = normalizeCase(config2, name);
        if (contains2(normalizedNames, normalizedName)) {
          if (optionName === void 0) {
            optionName = name;
          }
          const value5 = unparsed[1];
          if (value5 !== void 0 && value5.length > 0) {
            values4 = append(values4, value5.trim());
          }
          unparsed = unparsed.slice(2);
        } else {
          leftover2 = append(leftover2, headNonEmpty(unparsed));
          unparsed = unparsed.slice(1);
        }
      }
      const parsed = fromNullable(optionName).pipe(orElse(() => some2(self.argumentOption.fullName)), map2((name) => ({
        name,
        values: values4
      })));
      return succeed7({
        parsed,
        leftover: leftover2
      });
    }
  }
};
var matchUnclustered = (input, tail, options3, config2) => {
  if (isNonEmptyReadonlyArray(input)) {
    const flag = headNonEmpty(input);
    const otherFlags = tailNonEmpty(input);
    return findOptions(of(flag), options3, config2).pipe(flatMap9(([_, opts1, map1]) => {
      if (isEmpty4(map1)) {
        return fail7(unclusteredFlag(empty34, empty2(), tail));
      }
      return matchUnclustered(otherFlags, tail, opts1, config2).pipe(map17(([_2, opts2, map210]) => [tail, opts2, merge9(map1, fromIterable(map210))]));
    }));
  }
  return succeed7([tail, options3, empty10()]);
};
var merge9 = (map1, map210) => {
  if (isNonEmptyReadonlyArray(map210)) {
    const head5 = headNonEmpty(map210);
    const tail = tailNonEmpty(map210);
    const newMap = match2(get7(map1, head5[0]), {
      onNone: () => set3(map1, head5[0], head5[1]),
      onSome: (elems) => set3(map1, head5[0], appendAll(elems, head5[1]))
    });
    return merge9(newMap, tail);
  }
  return map1;
};
var escape2 = (string7) => string7.replaceAll("\\", "\\\\").replaceAll("'", "'\\''").replaceAll("[", "\\[").replaceAll("]", "\\]").replaceAll(":", "\\:").replaceAll("$", "\\$").replaceAll("`", "\\`").replaceAll("(", "\\(").replaceAll(")", "\\)");
var getShortDescription = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both":
    case "OrElse": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "KeyValueMap":
    case "Variadic": {
      return getShortDescription(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getShortDescription(self.options);
    }
  }
};
var getBashCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const cases = join(names, "|");
      const compgen = getBashCompletions(self.primitiveType);
      return make4(`${cases})`, `    COMPREPLY=( ${compgen} )`, `    return 0`, `    ;;`);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getBashCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getBashCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      const left3 = getBashCompletions2(self.left);
      const right3 = getBashCompletions2(self.right);
      return appendAll(left3, right3);
    }
  }
};
var getFishCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription(self);
      const order = mapInput2(boolean, (tuple3) => !tuple3[0]);
      return pipe(prepend(self.aliases, self.name), map4((name) => [name.length === 1, name]), sort(order), flatMap2(([isShort, name]) => make4(isShort ? "-s" : "-l", name)), appendAll(getFishCompletions(self.primitiveType)), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getFishCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getFishCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      return pipe(getFishCompletions2(self.left), appendAll(getFishCompletions2(self.right)));
    }
  }
};
var getZshCompletions2 = (self, state = {
  conflicts: empty2(),
  multiple: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const description = getShortDescription(self);
      const possibleValues = getZshCompletions(self.primitiveType);
      const multiple = state.multiple ? "*" : "";
      const conflicts = isNonEmptyReadonlyArray(state.conflicts) ? `(${join(state.conflicts, " ")})` : "";
      return map4(names, (name) => `${conflicts}${multiple}${name}[${escape2(description)}]${possibleValues}`);
    }
    case "KeyValueMap": {
      return getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      });
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getZshCompletions2(self.options, state);
    }
    case "Both": {
      const left3 = getZshCompletions2(self.left, state);
      const right3 = getZshCompletions2(self.right, state);
      return appendAll(left3, right3);
    }
    case "OrElse": {
      const leftNames = getNames(self.left);
      const rightNames = getNames(self.right);
      const left3 = getZshCompletions2(self.left, {
        ...state,
        conflicts: appendAll(state.conflicts, rightNames)
      });
      const right3 = getZshCompletions2(self.right, {
        ...state,
        conflicts: appendAll(state.conflicts, leftNames)
      });
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      }) : getZshCompletions2(self.argumentOption, state);
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/Options.js
var all7 = all6;
var boolean5 = boolean4;
var choice3 = choice2;
var directory2 = directory;
var file3 = file2;
var integer5 = integer4;
var text8 = text7;
var mapEffect6 = mapEffect5;
var optional4 = optional3;
var repeated4 = repeated3;
var withDefault3 = withDefault2;
var withDescription3 = withDescription2;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/args.js
var ArgsSymbolKey = "@effect/cli/Args";
var ArgsTypeId = /* @__PURE__ */ Symbol.for(ArgsSymbolKey);
var proto22 = {
  [ArgsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isArgs = (u) => typeof u === "object" && u != null && ArgsTypeId in u;
var isEmpty16 = (self) => self._tag === "Empty";
var all8 = function() {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map30(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled2(arguments[0]);
    } else {
      const entries3 = Object.entries(arguments[0]);
      let result = map30(entries3[0][1], (value5) => ({
        [entries3[0][0]]: value5
      }));
      if (entries3.length === 1) {
        return result;
      }
      const rest = entries3.slice(1);
      for (const [key, options3] of rest) {
        result = map30(makeBoth2(result, options3), ([record2, value5]) => ({
          ...record2,
          [key]: value5
        }));
      }
      return result;
    }
  }
  return allTupled2(arguments[0]);
};
var none11 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto22);
  op._tag = "Empty";
  return op;
})();
var getHelp4 = (self) => getHelpInternal3(self);
var getUsage2 = (self) => getUsageInternal2(self);
var map30 = /* @__PURE__ */ dual(2, (self, f) => mapEffect7(self, (a) => succeed7(f(a))));
var mapEffect7 = /* @__PURE__ */ dual(2, (self, f) => makeMap2(self, f));
var validate5 = /* @__PURE__ */ dual(3, (self, args3, config2) => validateInternal2(self, args3, config2));
var wizard3 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal3(self, config2));
var allTupled2 = (arg) => {
  if (arg.length === 0) {
    return none11;
  }
  if (arg.length === 1) {
    return map30(arg[0], (x) => [x]);
  }
  let result = map30(arg[0], (x) => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map30(makeBoth2(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty34;
    }
    case "Single": {
      return descriptionList([[weak(self.name), sequence(p(getHelp(self.primitiveType)), self.description)]]);
    }
    case "Map": {
      return getHelpInternal3(self.args);
    }
    case "Both": {
      return sequence(getHelpInternal3(self.left), getHelpInternal3(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal3(self.args);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min4 = getMinSizeInternal2(self);
        const max6 = getMaxSizeInternal2(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min4} - ${max6}` : min4 === 0 ? "..." : ` ${min4}+`);
        const newBlock = p(isSome2(self.max) ? `This argument must be repeated at least ${min4} times and may be repeated up to ${max6} times.` : min4 === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min4} times.`);
        return [concat2(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal3(self.args), (span2, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span2, sequence(block, optionalDescription)];
      });
    }
    case "WithFallbackConfig": {
      return mapDescriptionList(getHelpInternal3(self.args), (span2, block) => [span2, sequence(block, p("This argument can be set from environment variables."))]);
    }
  }
};
var getMinSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal2(self.args);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal2(self.left);
      const rightMinSize = getMinSizeInternal2(self.right);
      return leftMinSize + rightMinSize;
    }
    case "Variadic": {
      const argsMinSize = getMinSizeInternal2(self.args);
      return Math.floor(getOrElse2(self.min, () => 0) * argsMinSize);
    }
  }
};
var getMaxSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getMaxSizeInternal2(self.args);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal2(self.left);
      const rightMaxSize = getMaxSizeInternal2(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "Variadic": {
      const argsMaxSize = getMaxSizeInternal2(self.args);
      return Math.floor(getOrElse2(self.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
    }
  }
};
var getUsageInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Single": {
      return named(of(self.name), getChoices(self.primitiveType));
    }
    case "Map": {
      return getUsageInternal2(self.args);
    }
    case "Both": {
      return concat4(getUsageInternal2(self.left), getUsageInternal2(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal2(self.args));
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return optional2(getUsageInternal2(self.args));
    }
  }
};
var makeMap2 = (self, f) => {
  const op = Object.create(proto22);
  op._tag = "Map";
  op.args = self;
  op.f = f;
  return op;
};
var makeBoth2 = (left3, right3) => {
  const op = Object.create(proto22);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var validateInternal2 = (self, args3, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed7([args3, void 0]);
    }
    case "Single": {
      return suspend4(() => {
        return matchLeft(args3, {
          onEmpty: () => {
            const choices = getChoices(self.primitiveType);
            if (isSome2(self.pseudoName) && isSome2(choices)) {
              return fail7(missingValue(p(`Missing argument <${self.pseudoName.value}> with choices ${choices.value}`)));
            }
            if (isSome2(self.pseudoName)) {
              return fail7(missingValue(p(`Missing argument <${self.pseudoName.value}>`)));
            }
            if (isSome2(choices)) {
              return fail7(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)} with choices ${choices.value}`)));
            }
            return fail7(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)}`)));
          },
          onNonEmpty: (head5, tail) => validate4(self.primitiveType, some2(head5), config2).pipe(mapBoth4({
            onFailure: (text10) => invalidArgument(p(text10)),
            onSuccess: (a) => [tail, a]
          }))
        });
      });
    }
    case "Map": {
      return validateInternal2(self.args, args3, config2).pipe(flatMap9(([leftover2, a]) => matchEffect2(self.f(a), {
        onFailure: (doc) => fail7(invalidArgument(doc)),
        onSuccess: (b) => succeed7([leftover2, b])
      })));
    }
    case "Both": {
      return validateInternal2(self.left, args3, config2).pipe(flatMap9(([args4, a]) => validateInternal2(self.right, args4, config2).pipe(map17(([args5, b]) => [args5, [a, b]]))));
    }
    case "Variadic": {
      const min1 = getOrElse2(self.min, () => 0);
      const max1 = getOrElse2(self.max, () => Number.MAX_SAFE_INTEGER);
      const loop2 = (args4, acc) => {
        if (acc.length >= max1) {
          return succeed7([args4, acc]);
        }
        return validateInternal2(self.args, args4, config2).pipe(matchEffect2({
          onFailure: (failure) => acc.length >= min1 && isEmptyReadonlyArray(args4) ? succeed7([args4, acc]) : fail7(failure),
          onSuccess: ([args5, a]) => loop2(args5, append(acc, a))
        }));
      };
      return loop2(args3, empty2()).pipe(map17(([args4, acc]) => [args4, acc]));
    }
    case "WithDefault": {
      return validateInternal2(self.args, args3, config2).pipe(catchTag2("MissingValue", () => succeed7([args3, self.fallback])));
    }
    case "WithFallbackConfig": {
      return validateInternal2(self.args, args3, config2).pipe(catchTag2("MissingValue", (e) => map17(catchAll2(self.config, (e2) => {
        if (isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail7(error4);
        }
        return fail7(e);
      }), (value5) => [args3, value5])));
    }
  }
};
var wizardInternal3 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed7(empty2());
    }
    case "Single": {
      const help = getHelpInternal3(self);
      return wizard(self.primitiveType, help).pipe(zipLeft2(log3()), flatMap9((input) => {
        const args3 = of(input);
        return validateInternal2(self, args3, config2).pipe(as4(args3));
      }));
    }
    case "Map": {
      return wizardInternal3(self.args, config2).pipe(tap2((args3) => validateInternal2(self.args, args3, config2)));
    }
    case "Both": {
      return zipWith4(wizardInternal3(self.left, config2), wizardInternal3(self.right, config2), (left3, right3) => appendAll(left3, right3)).pipe(tap2((args3) => validateInternal2(self, args3, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument should be repeated?");
      const message = pipe(getHelpInternal3(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal2(self),
        max: getMaxSizeInternal2(self)
      }).pipe(zipLeft2(log3()), flatMap9((n) => n <= 0 ? succeed7(empty2()) : make25(empty2()).pipe(flatMap9((ref) => wizardInternal3(self.args, config2).pipe(flatMap9((args3) => update3(ref, appendAll(args3))), repeatN2(n - 1), zipRight3(get11(ref)), tap2((args3) => validateInternal2(self, args3, config2)))))));
    }
    case "WithDefault": {
      const defaultHelp = p(`This argument is optional - use the default?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Default ['${JSON.stringify(self.fallback)}']`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed7(empty2()) : wizardInternal3(self.args, config2)));
    }
    case "WithFallbackConfig": {
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed7(empty2()) : wizardInternal3(self.args, config2)));
    }
  }
};
var getShortDescription2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getShortDescription2(self.args);
    }
  }
};
var getFishCompletions3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription2(self);
      return pipe(getFishCompletions(self.primitiveType), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "Both": {
      return pipe(getFishCompletions3(self.left), appendAll(getFishCompletions3(self.right)));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getFishCompletions3(self.args);
    }
  }
};
var getZshCompletions3 = (self, state = {
  multiple: false,
  optional: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const multiple = state.multiple ? "*" : "";
      const optional5 = state.optional ? "::" : ":";
      const shortDescription = getShortDescription2(self);
      const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
      const possibleValues = getZshCompletions(self.primitiveType);
      return possibleValues.length === 0 ? empty2() : of(`${multiple}${optional5}${self.name}${description}${possibleValues}`);
    }
    case "Map": {
      return getZshCompletions3(self.args, state);
    }
    case "Both": {
      const left3 = getZshCompletions3(self.left, state);
      const right3 = getZshCompletions3(self.right, state);
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions3(self.args, {
        ...state,
        multiple: true
      }) : getZshCompletions3(self.args, state);
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return getZshCompletions3(self.args, {
        ...state,
        optional: true
      });
    }
  }
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/builtInOptions.js
var setLogLevel = (level) => ({
  _tag: "SetLogLevel",
  level
});
var showCompletions = (shellType) => ({
  _tag: "ShowCompletions",
  shellType
});
var showHelp = (usage, helpDoc) => ({
  _tag: "ShowHelp",
  usage,
  helpDoc
});
var showWizard = (command) => ({
  _tag: "ShowWizard",
  command
});
var showVersion = {
  _tag: "ShowVersion"
};
var isShowHelp = (self) => self._tag === "ShowHelp";
var isShowWizard = (self) => self._tag === "ShowWizard";
var completionsOptions = /* @__PURE__ */ choiceWithValue("completions", [["sh", "bash"], ["bash", "bash"], ["fish", "fish"], ["zsh", "zsh"]]).pipe(optional3, /* @__PURE__ */ withDescription2("Generate a completion script for a specific shell."));
var logLevelOptions = /* @__PURE__ */ choiceWithValue("log-level", allLevels.map((level) => [level._tag.toLowerCase(), level])).pipe(optional3, /* @__PURE__ */ withDescription2("Sets the minimum log level for a command."));
var helpOptions = /* @__PURE__ */ boolean4("help").pipe(/* @__PURE__ */ withAlias("h"), /* @__PURE__ */ withDescription2("Show the help documentation for a command."));
var versionOptions = /* @__PURE__ */ boolean4("version").pipe(/* @__PURE__ */ withDescription2("Show the version of the application."));
var wizardOptions = /* @__PURE__ */ boolean4("wizard").pipe(/* @__PURE__ */ withDescription2("Start wizard mode for a command."));
var builtIns = /* @__PURE__ */ all6({
  completions: completionsOptions,
  logLevel: logLevelOptions,
  help: helpOptions,
  wizard: wizardOptions,
  version: versionOptions
});
var builtInOptions = (command, usage, helpDoc) => map29(builtIns, (builtIn2) => {
  if (isSome2(builtIn2.completions)) {
    return some2(showCompletions(builtIn2.completions.value));
  }
  if (isSome2(builtIn2.logLevel)) {
    return some2(setLogLevel(builtIn2.logLevel.value));
  }
  if (builtIn2.help) {
    return some2(showHelp(usage, helpDoc));
  }
  if (builtIn2.wizard) {
    return some2(showWizard(command));
  }
  if (builtIn2.version) {
    return some2(showVersion);
  }
  return none2();
});

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/commandDirective.js
var builtIn = (option6) => ({
  _tag: "BuiltIn",
  option: option6
});
var userDefined = (leftover2, value5) => ({
  _tag: "UserDefined",
  leftover: leftover2,
  value: value5
});
var isBuiltIn = (self) => self._tag === "BuiltIn";
var isUserDefined = (self) => self._tag === "UserDefined";
var map31 = /* @__PURE__ */ dual(2, (self, f) => isUserDefined(self) ? userDefined(self.leftover, f(self.value)) : self);

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/commandDescriptor.js
var CommandDescriptorSymbolKey = "@effect/cli/CommandDescriptor";
var TypeId22 = /* @__PURE__ */ Symbol.for(CommandDescriptorSymbolKey);
var proto23 = {
  [TypeId22]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCommand = (u) => typeof u === "object" && u != null && TypeId22 in u;
var isStandard = (self) => self._tag === "Standard";
var make55 = (name, options3 = none10, args3 = none11) => {
  const op = Object.create(proto23);
  op._tag = "Standard";
  op.name = name;
  op.description = empty34;
  op.options = options3;
  op.args = args3;
  return op;
};
var getHelp5 = (self, config2) => getHelpInternal4(self, config2);
var getNames2 = (self) => fromIterable5(getNamesInternal(self));
var getBashCompletions3 = (self, executable) => getBashCompletionsInternal(self, executable);
var getFishCompletions4 = (self, executable) => getFishCompletionsInternal(self, executable);
var getZshCompletions4 = (self, executable) => getZshCompletionsInternal(self, executable);
var getSubcommands = (self) => fromIterable6(getSubcommandsInternal(self));
var getUsage3 = (self) => getUsageInternal3(self);
var map32 = /* @__PURE__ */ dual(2, (self, f) => mapEffect8(self, (a) => right2(f(a))));
var mapEffect8 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto23);
  op._tag = "Map";
  op.command = self;
  op.f = f;
  return op;
});
var parse3 = /* @__PURE__ */ dual(3, (self, args3, config2) => parseInternal2(self, args3, config2));
var withDescription4 = /* @__PURE__ */ dual(2, (self, help) => withDescriptionInternal(self, help));
var withSubcommands = /* @__PURE__ */ dual(2, (self, subcommands) => {
  const op = Object.create(proto23);
  op._tag = "Subcommands";
  op.parent = self;
  op.children = map4(subcommands, ([id2, command]) => map32(command, (a) => [id2, a]));
  return op;
});
var wizard4 = /* @__PURE__ */ dual(3, (self, prefix, config2) => wizardInternal4(self, prefix, config2));
var getHelpInternal4 = (self, config2) => {
  switch (self._tag) {
    case "Standard": {
      const header = isEmpty13(self.description) ? empty34 : sequence(h1("DESCRIPTION"), self.description);
      const argsHelp = getHelp4(self.args);
      const argsSection = isEmpty13(argsHelp) ? empty34 : sequence(h1("ARGUMENTS"), argsHelp);
      const options3 = config2.showBuiltIns ? all7([self.options, builtIns]) : self.options;
      const optionsHelp = getHelp3(options3);
      const optionsSection = isEmpty13(optionsHelp) ? empty34 : sequence(h1("OPTIONS"), optionsHelp);
      return sequence(header, sequence(argsSection, optionsSection));
    }
    case "GetUserInput": {
      return isEmpty13(self.description) ? empty34 : sequence(h1("DESCRIPTION"), self.description);
    }
    case "Map": {
      return getHelpInternal4(self.command, config2);
    }
    case "Subcommands": {
      const getUsage5 = (command, preceding) => {
        switch (command._tag) {
          case "Standard":
          case "GetUserInput": {
            const usage = getSpan(getHelp2(getUsageInternal3(command)));
            const usages = append(preceding, usage);
            const finalUsage = reduce(usages, empty33, (acc, next) => isText3(acc) && acc.value === "" ? next : isText3(next) && next.value === "" ? acc : spans([acc, space3, next]));
            const description = getSpan(command.description);
            return of([finalUsage, description]);
          }
          case "Map": {
            return getUsage5(command.command, preceding);
          }
          case "Subcommands": {
            const parentUsage = getUsage5(command.parent, preceding);
            return match2(head(parentUsage), {
              onNone: () => flatMap2(command.children, (child) => getUsage5(child, preceding)),
              onSome: ([usage]) => {
                const childrenUsage = flatMap2(command.children, (child) => getUsage5(child, append(preceding, usage)));
                return appendAll(parentUsage, childrenUsage);
              }
            });
          }
        }
      };
      const printSubcommands = (subcommands) => {
        const maxUsageLength = reduceRight(subcommands, 0, (max6, [usage]) => Math.max(size10(usage), max6));
        const documents = map4(subcommands, ([usage, desc]) => p(spans([usage, text4(" ".repeat(maxUsageLength - size10(usage) + 2)), desc])));
        if (isNonEmptyReadonlyArray(documents)) {
          return enumeration(documents);
        }
        throw new Error("[BUG]: Subcommands.usage - received empty list of subcommands to print");
      };
      return sequence(getHelpInternal4(self.parent, config2), sequence(h1("COMMANDS"), printSubcommands(flatMap2(self.children, (child) => getUsage5(child, empty2())))));
    }
  }
};
var getNamesInternal = (self) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      return of(self.name);
    }
    case "Map": {
      return getNamesInternal(self.command);
    }
    case "Subcommands": {
      return getNamesInternal(self.parent);
    }
  }
};
var getSubcommandsInternal = (self) => {
  const loop2 = (self2, isSubcommand) => {
    switch (self2._tag) {
      case "Standard":
      case "GetUserInput": {
        return of([self2.name, self2]);
      }
      case "Map": {
        return loop2(self2.command, isSubcommand);
      }
      case "Subcommands": {
        return isSubcommand ? loop2(self2.parent, false) : flatMap2(self2.children, (child) => loop2(child, true));
      }
    }
  };
  return loop2(self, false);
};
var getUsageInternal3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return concat4(named(of(self.name), none2()), concat4(getUsage(self.options), getUsage2(self.args)));
    }
    case "GetUserInput": {
      return named(of(self.name), none2());
    }
    case "Map": {
      return getUsageInternal3(self.command);
    }
    case "Subcommands": {
      return concat4(getUsageInternal3(self.parent), mixed);
    }
  }
};
var parseInternal2 = (self, args3, config2) => {
  const parseCommandLine2 = (self2, args4) => matchLeft(args4, {
    onEmpty: () => {
      const error4 = p(`Missing command name: '${self2.name}'`);
      return fail7(commandMismatch(error4));
    },
    onNonEmpty: (head5, tail) => {
      const normalizedArgv0 = normalizeCase(config2, head5);
      const normalizedCommandName = normalizeCase(config2, self2.name);
      return succeed7(tail).pipe(when2(() => normalizedArgv0 === normalizedCommandName), flatten5, catchTag2("NoSuchElementException", () => {
        const error4 = p(`Missing command name: '${self2.name}'`);
        return fail7(commandMismatch(error4));
      }));
    }
  });
  switch (self._tag) {
    case "Standard": {
      const parseBuiltInArgs = (args4) => matchLeft(args4, {
        onEmpty: () => {
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail7(commandMismatch(error4));
        },
        onNonEmpty: (argv0) => {
          const normalizedArgv0 = normalizeCase(config2, argv0);
          const normalizedCommandName = normalizeCase(config2, self.name);
          if (normalizedArgv0 === normalizedCommandName) {
            const help = getHelpInternal4(self, config2);
            const usage = getUsageInternal3(self);
            const options3 = builtInOptions(self, usage, help);
            const argsWithoutCommand = drop(args4, 1);
            return processCommandLine(options3, argsWithoutCommand, config2).pipe(flatMap9((tuple3) => tuple3[2]), catchTag2("NoSuchElementException", () => {
              const error5 = p("No built-in option was matched");
              return fail7(noBuiltInMatch(error5));
            }), map17(builtIn));
          }
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail7(commandMismatch(error4));
        }
      });
      const parseUserDefinedArgs = (args4) => parseCommandLine2(self, args4).pipe(flatMap9((commandOptionsAndArgs) => {
        const [optionsAndArgs, forcedCommandArgs] = splitForcedArgs(commandOptionsAndArgs);
        return processCommandLine(self.options, optionsAndArgs, config2).pipe(flatMap9(([error4, commandArgs, optionsType]) => validate5(self.args, appendAll(commandArgs, forcedCommandArgs), config2).pipe(catchAll2((e) => match2(error4, {
          onNone: () => fail7(e),
          onSome: (err) => fail7(err)
        })), map17(([argsLeftover, argsType]) => userDefined(argsLeftover, {
          name: self.name,
          options: optionsType,
          args: argsType
        })))));
      }));
      const exhaustiveSearch = (args4) => {
        if (contains2(args4, "--help") || contains2(args4, "-h")) {
          return parseBuiltInArgs(make4(self.name, "--help"));
        }
        if (contains2(args4, "--wizard")) {
          return parseBuiltInArgs(make4(self.name, "--wizard"));
        }
        if (contains2(args4, "--version")) {
          return parseBuiltInArgs(make4(self.name, "--version"));
        }
        const error4 = p(`Missing command name: '${self.name}'`);
        return fail7(commandMismatch(error4));
      };
      return parseBuiltInArgs(args3).pipe(orElse4(() => parseUserDefinedArgs(args3)), catchSome2((e) => {
        if (isValidationError(e)) {
          if (config2.finalCheckBuiltIn) {
            return some2(exhaustiveSearch(args3).pipe(catchSome2((_) => isValidationError(_) ? some2(fail7(e)) : none2())));
          }
          return some2(fail7(e));
        }
        return none2();
      }));
    }
    case "GetUserInput": {
      return parseCommandLine2(self, args3).pipe(zipRight3(run5(self.prompt)), catchTag2("QuitException", (e) => die5(e)), map17((value5) => userDefined(drop(args3, 1), {
        name: self.name,
        value: value5
      })));
    }
    case "Map": {
      return parseInternal2(self.command, args3, config2).pipe(flatMap9((directive) => {
        if (isUserDefined(directive)) {
          return self.f(directive.value).pipe(map17((value5) => userDefined(directive.leftover, value5)));
        }
        return succeed7(directive);
      }));
    }
    case "Subcommands": {
      const names = getNamesInternal(self);
      const subcommands = getSubcommandsInternal(self);
      const [parentArgs, childArgs] = span(args3, (arg) => !some3(subcommands, ([name]) => name === arg));
      const parseChildren = suspend4(() => {
        const iterator = self.children[Symbol.iterator]();
        const loop2 = (next) => {
          return parseInternal2(next, childArgs, config2).pipe(catchIf2(isCommandMismatch, (e) => {
            const next2 = iterator.next();
            return next2.done ? fail7(e) : loop2(next2.value);
          }));
        };
        return loop2(iterator.next().value);
      });
      const helpDirectiveForParent = sync4(() => {
        return builtIn(showHelp(getUsageInternal3(self), getHelpInternal4(self, config2)));
      });
      const helpDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowHelp(directive.option)) {
          const parentName = getOrElse2(head(names), () => "");
          const newDirective = builtIn(showHelp(concat4(named(of(parentName), none2()), directive.option.usage), directive.option.helpDoc));
          return succeed7(newDirective);
        }
        return fail7(invalidArgument(empty34));
      }));
      const wizardDirectiveForParent = sync4(() => builtIn(showWizard(self)));
      const wizardDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowWizard(directive.option)) {
          return succeed7(directive);
        }
        return fail7(invalidArgument(empty34));
      }));
      return suspend4(() => parseInternal2(self.parent, parentArgs, config2).pipe(flatMap9((directive) => {
        switch (directive._tag) {
          case "BuiltIn": {
            if (isShowHelp(directive.option)) {
              return isNonEmptyReadonlyArray(childArgs) ? orElse4(helpDirectiveForChild, () => helpDirectiveForParent) : helpDirectiveForParent;
            }
            if (isShowWizard(directive.option)) {
              return orElse4(wizardDirectiveForChild, () => wizardDirectiveForParent);
            }
            return succeed7(directive);
          }
          case "UserDefined": {
            const args4 = appendAll(directive.leftover, childArgs);
            if (isNonEmptyReadonlyArray(args4)) {
              return parseChildren.pipe(mapBoth4({
                onFailure: (err) => {
                  if (isCommandMismatch(err)) {
                    const parentName = getOrElse2(head(names), () => "");
                    const childNames = map4(subcommands, ([name]) => `'${name}'`);
                    const oneOf = childNames.length === 1 ? "" : " one of";
                    const error4 = p(`Invalid subcommand for ${parentName} - use${oneOf} ${join(childNames, ", ")}`);
                    return commandMismatch(error4);
                  }
                  return err;
                },
                onSuccess: map31((subcommand) => ({
                  ...directive.value,
                  subcommand: some2(subcommand)
                }))
              }));
            }
            return succeed7(userDefined(directive.leftover, {
              ...directive.value,
              subcommand: none2()
            }));
          }
        }
      }), catchSome2(() => isEmptyReadonlyArray(args3) ? some2(helpDirectiveForParent) : none2())));
    }
  }
};
var splitForcedArgs = (args3) => {
  const [remainingArgs, forcedArgs] = span(args3, (str) => str !== "--");
  return [remainingArgs, drop(forcedArgs, 1)];
};
var withDescriptionInternal = (self, description) => {
  switch (self._tag) {
    case "Standard": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "Standard";
      op.name = self.name;
      op.description = helpDoc;
      op.options = self.options;
      op.args = self.args;
      return op;
    }
    case "GetUserInput": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "GetUserInput";
      op.name = self.name;
      op.description = helpDoc;
      op.prompt = self.prompt;
      return op;
    }
    case "Map": {
      return mapEffect8(withDescriptionInternal(self.command, description), self.f);
    }
    case "Subcommands": {
      const op = Object.create(proto23);
      op._tag = "Subcommands";
      op.parent = withDescriptionInternal(self.parent, description);
      op.children = self.children.slice();
      return op;
    }
  }
};
var argsWizardHeader = /* @__PURE__ */ code("Args Wizard - ");
var optionsWizardHeader = /* @__PURE__ */ code("Options Wizard - ");
var wizardInternal4 = (self, prefix, config2) => {
  const loop2 = (self2, commandLineRef) => {
    switch (self2._tag) {
      case "GetUserInput":
      case "Standard": {
        return gen2(function* () {
          const logCurrentCommand = get11(commandLineRef).pipe(flatMap9((commandLine) => {
            const currentCommand = p(pipe(strong(highlight("COMMAND:", cyan2)), concat2(space3), concat2(highlight(join(commandLine, " "), magenta2))));
            return log3(toAnsiText(currentCommand));
          }));
          if (isStandard(self2)) {
            yield* logCurrentCommand;
            const commandName = highlight(self2.name, magenta2);
            if (!isEmpty15(self2.options)) {
              const message = p(concat2(optionsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard2(self2.options, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
            if (!isEmpty16(self2.args)) {
              const message = p(concat2(argsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard3(self2.args, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
          }
          return yield* get11(commandLineRef);
        });
      }
      case "Map": {
        return loop2(self2.command, commandLineRef);
      }
      case "Subcommands": {
        const description = p("Select which command you would like to execute");
        const message = toAnsiText(description).trimEnd();
        const makeChoice = (title, index) => ({
          title,
          value: [title, index]
        });
        const choices = pipe(getSubcommandsInternal(self2), map4(([name], index) => makeChoice(name, index)));
        return loop2(self2.parent, commandLineRef).pipe(zipRight3(select({
          message,
          choices
        }).pipe(tap2(([name]) => update3(commandLineRef, append(name))), zipLeft2(log3()), flatMap9(([, nextIndex]) => loop2(self2.children[nextIndex], commandLineRef)))));
      }
    }
  };
  return make25(prefix).pipe(flatMap9((commandLineRef) => loop2(self, commandLineRef).pipe(zipRight3(get11(commandLineRef)))));
};
var getShortDescription3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return getText(getSpan(self.description));
    }
    case "GetUserInput": {
      return getText(getSpan(self.description));
    }
    case "Map": {
      return getShortDescription3(self.command);
    }
    case "Subcommands": {
      return "";
    }
  }
};
var traverseCommand = (self, initialState3, f) => make40(initialState3).pipe(flatMap9((ref) => {
  const loop2 = (self2, parentCommands, subcommands, level) => {
    switch (self2._tag) {
      case "Standard": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "GetUserInput": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "Map": {
        return loop2(self2.command, parentCommands, subcommands, level);
      }
      case "Subcommands": {
        const parentNames = getNamesInternal(self2.parent);
        const nextSubcommands = getSubcommandsInternal(self2);
        const nextParentCommands = appendAll(parentCommands, parentNames);
        return loop2(self2.parent, parentCommands, nextSubcommands, level).pipe(zipRight3(forEach8(self2.children, (child) => (
          // Traverse the child command using next parent names and old subcommands
          loop2(child, nextParentCommands, subcommands, level + 1)
        ))));
      }
    }
  };
  return suspend4(() => loop2(self, empty2(), empty2(), 0)).pipe(zipRight3(get13(ref)));
}));
var indentAll = /* @__PURE__ */ dual(2, (self, indent3) => {
  const indentation = allocate(indent3 + 1).join(" ");
  return map4(self, (line4) => `${indentation}${line4}`);
});
var getBashCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const options3 = isStandard(info2.command) ? all7([info2.command.options, builtIns]) : builtIns;
  const optionNames = getNames(options3);
  const optionCases = isStandard(info2.command) ? getBashCompletions2(info2.command.options) : empty2();
  const subcommandNames = pipe(info2.subcommands, map4(([name]) => name), sort(string2));
  const wordList = appendAll(optionNames, subcommandNames);
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map4((command) => command.replace("-", "__")));
  const caseName = join(preformatted, ",");
  const funcName = join(preformatted, "__");
  const funcLines = isEmptyReadonlyArray(info2.parentCommands) ? empty2() : [`${caseName})`, `    cmd="${funcName}"`, "    ;;"];
  const cmdLines = [`${funcName})`, `    opts="${join(wordList, " ")}"`, `    if [[ \${cur} == -* || \${COMP_CWORD} -eq ${info2.level + 1} ]] ; then`, '        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "        return 0", "    fi", '    case "${prev}" in', ...indentAll(optionCases, 8), "    *)", "        COMPREPLY=()", "        ;;", "    esac", '    COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "    return 0", "    ;;"];
  const lines3 = append(state, [funcLines, cmdLines]);
  return succeed7(lines3);
}).pipe(map17((lines3) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const scriptName = `_${rootCommand}_bash_completions`;
  const funcCases = flatMap2(lines3, ([funcLines]) => funcLines);
  const cmdCases = flatMap2(lines3, ([, cmdLines]) => cmdLines);
  return [`function ${scriptName}() {`, "    local i cur prev opts cmd", "    COMPREPLY=()", '    cur="${COMP_WORDS[COMP_CWORD]}"', '    prev="${COMP_WORDS[COMP_CWORD-1]}"', '    cmd=""', '    opts=""', '    for i in "${COMP_WORDS[@]}"; do', '        case "${cmd},${i}" in', '            ",$1")', `                cmd="${executable}"`, "                ;;", ...indentAll(funcCases, 12), "            *)", "                ;;", "        esac", "    done", '    case "${cmd}" in', ...indentAll(cmdCases, 8), "    esac", "}", `complete -F ${scriptName} -o nosort -o bashdefault -o default ${rootCommand}`];
}));
var getFishCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const baseTemplate = make4("complete", "-c", executable);
  const options3 = isStandard(info2.command) ? all6([builtIns, info2.command.options]) : builtIns;
  const optionsCompletions = getFishCompletions2(options3);
  const argsCompletions = isStandard(info2.command) ? getFishCompletions3(info2.command.args) : empty2();
  const rootCompletions = (conditionals2) => pipe(map4(optionsCompletions, (option6) => pipe(baseTemplate, appendAll(conditionals2), append(option6), join(" "))), appendAll(map4(argsCompletions, (option6) => pipe(baseTemplate, appendAll(conditionals2), append(option6), join(" ")))));
  const subcommandCompletions = (conditionals2) => map4(info2.subcommands, ([name, subcommand]) => {
    const description = getShortDescription3(subcommand);
    return pipe(baseTemplate, appendAll(conditionals2), appendAll(make4("-f", "-a", `"${name}"`)), appendAll(description.length === 0 ? empty2() : make4("-d", `'${description}'`)), join(" "));
  });
  if (isEmptyReadonlyArray(info2.parentCommands)) {
    const conditionals2 = make4("-n", '"__fish_use_subcommand"');
    return succeed7(pipe(state, appendAll(rootCompletions(conditionals2)), appendAll(subcommandCompletions(conditionals2))));
  }
  const parentConditionals = pipe(
    info2.parentCommands,
    // Drop the root command name from the subcommand conditionals
    drop(1),
    append(info2.command.name),
    map4((command) => `__fish_seen_subcommand_from ${command}`)
  );
  const subcommandConditionals = map4(info2.subcommands, ([name]) => `not __fish_seen_subcommand_from ${name}`);
  const baseConditionals = pipe(appendAll(parentConditionals, subcommandConditionals), join("; and "));
  const conditionals = make4("-n", `"${baseConditionals}"`);
  return succeed7(pipe(state, appendAll(rootCompletions(conditionals)), appendAll(subcommandCompletions(conditionals))));
});
var getZshCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map4((command) => command.replace("-", "__")));
  const underscoreName = join(preformatted, "__");
  const spaceName = join(preformatted, " ");
  const subcommands = pipe(info2.subcommands, map4(([name, subcommand]) => {
    const desc = getShortDescription3(subcommand);
    return `'${name}:${desc}' \\`;
  }));
  const commands = isEmptyReadonlyArray(subcommands) ? `commands=()` : `commands=(
${join(indentAll(subcommands, 8), "\n")}
    )`;
  const handlerLines = [`(( $+functions[_${underscoreName}_commands] )) ||`, `_${underscoreName}_commands() {`, `    local commands; ${commands}`, `    _describe -t commands '${spaceName} commands' commands "$@"`, "}"];
  return succeed7(appendAll(state, handlerLines));
}).pipe(map17((handlers) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const cases = getZshSubcommandCases(self, empty2(), empty2());
  const scriptName = `_${rootCommand}_zsh_completions`;
  return [`#compdef ${executable}`, "", "autoload -U is-at-least", "", `function ${scriptName}() {`, "    typeset -A opt_args", "    typeset -a _arguments_options", "    local ret=1", "", "    if is-at-least 5.2; then", "        _arguments_options=(-s -S -C)", "    else", "        _arguments_options=(-s -C)", "    fi", "", '    local context curcontext="$curcontext" state line', ...indentAll(cases, 4), "}", "", ...handlers, "", `if [ "$funcstack[1]" = "${scriptName}" ]; then`, `    ${scriptName} "$@"`, "else", `    compdef ${scriptName} ${rootCommand}`, "fi"];
}));
var getZshSubcommandCases = (self, parentCommands, subcommands) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      const options3 = isStandard(self) ? all6([builtIns, self.options]) : builtIns;
      const args3 = isStandard(self) ? self.args : none11;
      const optionCompletions = pipe(getZshCompletions2(options3), map4((completion) => `'${completion}' \\`));
      const argCompletions = pipe(getZshCompletions3(args3), map4((completion) => `'${completion}' \\`));
      if (isEmptyReadonlyArray(parentCommands)) {
        return ['_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${self.name}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
      }
      if (isEmptyReadonlyArray(subcommands)) {
        return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), "    && ret=0", ";;"];
      }
      return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${append(parentCommands, self.name).join("__")}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
    }
    case "Map": {
      return getZshSubcommandCases(self.command, parentCommands, subcommands);
    }
    case "Subcommands": {
      const nextSubcommands = getSubcommandsInternal(self);
      const parentNames = getNamesInternal(self.parent);
      const parentLines = getZshSubcommandCases(self.parent, parentCommands, appendAll(subcommands, nextSubcommands));
      const childCases = pipe(self.children, flatMap2((child) => getZshSubcommandCases(child, appendAll(parentCommands, parentNames), subcommands)));
      const hyphenName = pipe(appendAll(parentCommands, parentNames), join("-"));
      const childLines = pipe(parentNames, flatMap2((parentName) => ["case $state in", `    (${parentName})`, `    words=($line[1] "\${words[@]}")`, "    (( CURRENT += 1 ))", `    curcontext="\${curcontext%:*:*}:${hyphenName}-command-$line[1]:"`, `    case $line[1] in`, ...indentAll(childCases, 8), "    esac", "    ;;", "esac"]), appendAll(isEmptyReadonlyArray(parentCommands) ? empty2() : of(";;")));
      return appendAll(parentLines, childLines);
    }
  }
};
var helpRequestedError = (command) => {
  const op = Object.create(proto20);
  op._tag = "HelpRequested";
  op.error = empty34;
  op.command = command;
  return op;
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/ValidationError.js
var helpRequested = helpRequestedError;
var invalidValue2 = invalidValue;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Logger.js
var withMinimumLogLevel2 = withMinimumLogLevel;
var defaultLogger2 = defaultLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Unify.js
var unify2 = identity;

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/cliApp.js
var proto24 = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make56 = (config2) => {
  const op = Object.create(proto24);
  op.name = config2.name;
  op.version = config2.version;
  op.executable = config2.executable;
  op.command = config2.command;
  op.summary = config2.summary || empty33;
  op.footer = config2.footer || empty34;
  return op;
};
var run6 = /* @__PURE__ */ dual(3, (self, args3, execute2) => contextWithEffect2((context7) => {
  const config2 = getOrElse2(getOption2(context7, Tag3), () => defaultConfig);
  const [executable, filteredArgs] = splitExecutable(self, args3);
  const prefixedArgs = appendAll(prefixCommand(self.command), filteredArgs);
  return matchEffect2(parse3(self.command, prefixedArgs, config2), {
    onFailure: (e) => zipRight3(printDocs(e.error), fail7(e)),
    onSuccess: unify2((directive) => {
      switch (directive._tag) {
        case "UserDefined": {
          return matchLeft(directive.leftover, {
            onEmpty: () => execute2(directive.value).pipe(catchSome2((e) => isValidationError(e) && isHelpRequested(e) ? some2(handleBuiltInOption(self, executable, filteredArgs, showHelp(getUsage3(e.command), getHelp5(e.command, config2)), execute2, config2, args3)) : none2())),
            onNonEmpty: (head5) => {
              const error4 = p(`Received unknown argument: '${head5}'`);
              return zipRight3(printDocs(error4), fail7(invalidValue(error4)));
            }
          });
        }
        case "BuiltIn": {
          return handleBuiltInOption(self, executable, filteredArgs, directive.option, execute2, config2, args3).pipe(catchSome2((e) => isValidationError(e) ? some2(zipRight3(printDocs(e.error), fail7(e))) : none2()));
        }
      }
    })
  });
}));
var splitExecutable = (self, args3) => {
  if (self.executable !== void 0) {
    return [self.executable, drop(args3, 2)];
  }
  const [[runtime5, script], optionsAndArgs] = splitAt(args3, 2);
  return [`${runtime5} ${script}`, optionsAndArgs];
};
var printDocs = (error4) => error2(toAnsiText(error4));
var handleBuiltInOption = (self, executable, args3, builtIn2, execute2, config2, originalArgs) => {
  switch (builtIn2._tag) {
    case "SetLogLevel": {
      const baseArgs = take(originalArgs, 2);
      const filteredArgs = [];
      for (let i = 0; i < args3.length; i++) {
        if (isLogLevelArg(args3[i]) || isLogLevelArg(args3[i - 1])) {
          continue;
        }
        filteredArgs.push(args3[i]);
      }
      const nextArgs = appendAll(baseArgs, filteredArgs);
      return run6(self, nextArgs, execute2).pipe(withMinimumLogLevel2(builtIn2.level));
    }
    case "ShowHelp": {
      const banner = h1(code(self.name));
      const header = p(spans([text4(`${self.name} ${self.version}`), isEmpty12(self.summary) ? empty33 : spans([space3, text4("--"), space3, self.summary])]));
      const usage = sequence(h1("USAGE"), pipe(enumerate(builtIn2.usage, config2), map4((span2) => p(concat2(text4("$ "), span2))), reduceRight(empty34, (left3, right3) => sequence(left3, right3))));
      const helpDoc = pipe(banner, sequence(header), sequence(usage), sequence(builtIn2.helpDoc), sequence(self.footer));
      return log3(toAnsiText(helpDoc));
    }
    case "ShowCompletions": {
      const command = fromIterable(getNames2(self.command))[0];
      switch (builtIn2.shellType) {
        case "bash": {
          return getBashCompletions3(self.command, command).pipe(flatMap9((completions) => log3(join(completions, "\n"))));
        }
        case "fish": {
          return getFishCompletions4(self.command, command).pipe(flatMap9((completions) => log3(join(completions, "\n"))));
        }
        case "zsh":
          return getZshCompletions4(self.command, command).pipe(flatMap9((completions) => log3(join(completions, "\n"))));
      }
    }
    case "ShowWizard": {
      const summary5 = isEmpty12(self.summary) ? empty33 : spans([space3, text4("--"), space3, self.summary]);
      const instructions = sequence(p(spans([text4("The wizard mode will assist you with constructing commands for"), space3, code(`${self.name} (${self.version})`), text4(".")])), p("Please answer all prompts provided by the wizard."));
      const description = descriptionList([[text4("Instructions"), instructions]]);
      const header = h1(spans([code("Wizard Mode for CLI Application:"), space3, code(self.name), space3, code(`(${self.version})`), summary5]));
      const help = sequence(header, description);
      const text10 = toAnsiText(help);
      const command = fromIterable(getNames2(self.command))[0];
      const wizardPrefix = getWizardPrefix(builtIn2, command, args3);
      return log3(text10).pipe(zipRight3(wizard4(builtIn2.command, wizardPrefix, config2)), tap2((args4) => log3(toAnsiText(renderWizardArgs(args4)))), flatMap9((args4) => toggle2({
        message: "Would you like to run the command?",
        initial: true,
        active: "yes",
        inactive: "no"
      }).pipe(flatMap9((shouldRunCommand) => {
        const baseArgs = take(originalArgs, 2);
        const wizardArgs = drop(args4, 1);
        const finalArgs = appendAll(baseArgs, wizardArgs);
        return shouldRunCommand ? log3().pipe(zipRight3(run6(self, finalArgs, execute2))) : _void;
      }))), catchAll2((e) => {
        if (isQuitException(e)) {
          const message = p(error3("\n\nQuitting wizard mode..."));
          return log3(toAnsiText(message));
        }
        return fail7(e);
      }));
    }
    case "ShowVersion": {
      const help = p(self.version);
      return log3(toAnsiText(help));
    }
  }
};
var prefixCommand = (self) => {
  let command = self;
  let prefix = empty2();
  while (command !== void 0) {
    switch (command._tag) {
      case "Standard": {
        prefix = of(command.name);
        command = void 0;
        break;
      }
      case "GetUserInput": {
        prefix = of(command.name);
        command = void 0;
        break;
      }
      case "Map": {
        command = command.command;
        break;
      }
      case "Subcommands": {
        command = command.parent;
        break;
      }
    }
  }
  return prefix;
};
var getWizardPrefix = (builtIn2, rootCommand, commandLineArgs) => {
  const subcommands = getSubcommands(builtIn2.command);
  const [parentArgs, childArgs] = span(commandLineArgs, (name) => !has4(subcommands, name));
  const args3 = matchLeft(childArgs, {
    onEmpty: () => filter2(parentArgs, (arg) => arg !== "--wizard"),
    onNonEmpty: (head5) => append(parentArgs, head5)
  });
  return appendAll(rootCommand.split(/\s+/), args3);
};
var renderWizardArgs = (args3) => {
  const params = pipe(filter2(args3, (param) => param.length > 0), join(" "));
  const executeMsg = text4("You may now execute your command directly with the following options and arguments:");
  return blocks([p(strong(code("Wizard Mode Complete!"))), p(executeMsg), p(concat2(text4("    "), highlight(params, cyan2)))]);
};
var isLogLevelArg = (arg) => {
  return arg && (arg === "--log-level" || arg.startsWith("--log-level="));
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/command.js
var CommandSymbolKey = "@effect/cli/Command";
var TypeId23 = /* @__PURE__ */ Symbol.for(CommandSymbolKey);
var parseConfig = (config2) => {
  const args3 = [];
  let argsIndex = 0;
  const options3 = [];
  let optionsIndex = 0;
  function parse6(config3) {
    const tree = {};
    for (const key in config3) {
      tree[key] = parseValue(config3[key]);
    }
    return tree;
  }
  function parseValue(value5) {
    if (isArray(value5)) {
      return {
        _tag: "Array",
        children: map4(value5, parseValue)
      };
    } else if (isArgs(value5)) {
      args3.push(value5);
      return {
        _tag: "Args",
        index: argsIndex++
      };
    } else if (isOptions(value5)) {
      options3.push(value5);
      return {
        _tag: "Options",
        index: optionsIndex++
      };
    } else {
      return {
        _tag: "ParsedConfig",
        tree: parse6(value5)
      };
    }
  }
  return {
    args: args3,
    options: options3,
    tree: parse6(config2)
  };
};
var reconstructConfigTree = (tree, args3, options3) => {
  const output = {};
  for (const key in tree) {
    output[key] = nodeValue(tree[key]);
  }
  return output;
  function nodeValue(node) {
    if (node._tag === "Args") {
      return args3[node.index];
    } else if (node._tag === "Options") {
      return options3[node.index];
    } else if (node._tag === "Array") {
      return map4(node.children, nodeValue);
    } else {
      return reconstructConfigTree(node.tree, args3, options3);
    }
  }
};
var Prototype = {
  ...CommitPrototype2,
  [TypeId23]: TypeId23,
  commit() {
    return this.tag;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var registeredDescriptors = /* @__PURE__ */ globalValue("@effect/cli/Command/registeredDescriptors", () => /* @__PURE__ */ new WeakMap());
var getDescriptor = (self) => registeredDescriptors.get(self.tag) ?? self.descriptor;
var makeProto = (descriptor2, handler, tag4, transform3 = identity) => {
  const self = Object.create(Prototype);
  self.descriptor = descriptor2;
  self.handler = handler;
  self.transform = transform3;
  self.tag = tag4;
  return self;
};
var makeDerive = (self, options3) => {
  const command = Object.create(Prototype);
  command.descriptor = options3.descriptor ?? self.descriptor;
  command.handler = options3.handler ?? self.handler;
  command.transform = options3.transform ? (effect3, opts) => options3.transform(self.transform(effect3, opts), opts) : self.transform;
  command.tag = self.tag;
  return command;
};
var fromDescriptor = /* @__PURE__ */ dual((args3) => isCommand(args3[0]), (descriptor2, handler) => {
  const self = makeProto(descriptor2, handler ?? ((_) => failSync2(() => helpRequested(getDescriptor(self)))), GenericTag(`@effect/cli/Command/(${fromIterable(getNames2(descriptor2)).join("|")})`));
  return self;
});
var makeDescriptor = (name, config2) => {
  const {
    args: args3,
    options: options3,
    tree
  } = parseConfig(config2);
  return map32(make55(name, all6(options3), all8(args3)), ({
    args: args4,
    options: options4
  }) => reconstructConfigTree(tree, args4, options4));
};
var make57 = (name, config2 = {}, handler) => fromDescriptor(makeDescriptor(name, config2), handler);
var mapDescriptor = /* @__PURE__ */ dual(2, (self, f) => makeDerive(self, {
  descriptor: f(self.descriptor)
}));
var withDescription5 = /* @__PURE__ */ dual(2, (self, help) => mapDescriptor(self, withDescription4(help)));
var withSubcommands2 = /* @__PURE__ */ dual(2, (self, subcommands) => {
  const command = withSubcommands(self.descriptor, map4(subcommands, (_) => [_.tag, _.descriptor]));
  const subcommandMap = reduce(subcommands, /* @__PURE__ */ new Map(), (handlers, subcommand) => {
    handlers.set(subcommand.tag, subcommand);
    registeredDescriptors.set(subcommand.tag, subcommand.descriptor);
    return handlers;
  });
  function handler(args3) {
    if (args3.subcommand._tag === "Some") {
      const [tag4, value5] = args3.subcommand.value;
      const subcommand = subcommandMap.get(tag4);
      const subcommandEffect = subcommand.transform(subcommand.handler(value5), value5);
      return provideService2(subcommandEffect, self.tag, args3);
    }
    return self.handler(args3);
  }
  return makeDerive(self, {
    descriptor: command,
    handler
  });
});
var run7 = /* @__PURE__ */ dual(2, (self, config2) => {
  const app = make56({
    ...config2,
    command: self.descriptor
  });
  registeredDescriptors.set(self.tag, self.descriptor);
  const handler = (args3) => self.transform(self.handler(args3), args3);
  return (args3) => run6(app, args3, handler);
});

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/Command.js
var make58 = make57;
var withDescription6 = withDescription5;
var withSubcommands3 = withSubcommands2;
var run8 = run7;

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
var TypeId24 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
var ExitCode = /* @__PURE__ */ nominal();
var ProcessId = /* @__PURE__ */ nominal();
var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
var makeExecutor = (start4) => {
  const stream3 = (command) => unwrapScoped6(map17(start4(command), (process3) => process3.stdout));
  const streamLines2 = (command, encoding) => {
    const decoder2 = new TextDecoder(encoding);
    return splitLines3(mapChunks2(stream3(command), map5((bytes) => decoder2.decode(bytes))));
  };
  return {
    [TypeId24]: TypeId24,
    start: start4,
    exitCode: (command) => scoped2(flatMap9(start4(command), (process3) => process3.exitCode)),
    stream: stream3,
    string: (command, encoding = "utf-8") => {
      const decoder2 = new TextDecoder(encoding);
      return pipe(start4(command), flatMap9((process3) => run4(process3.stdout, collectUint8Array)), map17((bytes) => decoder2.decode(bytes)), scoped2);
    },
    lines: (command, encoding = "utf-8") => {
      return pipe(streamLines2(command, encoding), runCollect3, map17(toArray2));
    },
    streamLines: streamLines2
  };
};
var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array(), (bytes, chunk4) => reduce2(chunk4, bytes, (acc, curr) => {
  const newArray = new Uint8Array(acc.length + curr.length);
  newArray.set(acc);
  newArray.set(curr, acc.length);
  return newArray;
}));

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/command.js
var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
var flatten13 = (self) => Array.from(flattenLoop(self));
var flattenLoop = (self) => {
  switch (self._tag) {
    case "StandardCommand": {
      return of2(self);
    }
    case "PipedCommand": {
      return appendAll2(flattenLoop(self.left), flattenLoop(self.right));
    }
  }
};
var Proto2 = {
  [CommandTypeId]: CommandTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto
};
var StandardProto = {
  ...Proto2,
  _tag: "StandardCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      command: this.command,
      args: this.args,
      env: Object.fromEntries(this.env),
      cwd: this.cwd.toJSON(),
      shell: this.shell,
      gid: this.gid.toJSON(),
      uid: this.uid.toJSON()
    };
  }
};
var makeStandard = (options3) => Object.assign(Object.create(StandardProto), options3);
var PipedProto = {
  ...Proto2,
  _tag: "PipedCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      left: this.left.toJSON(),
      right: this.right.toJSON()
    };
  }
};
var makePiped = (options3) => Object.assign(Object.create(PipedProto), options3);
var stdin = /* @__PURE__ */ dual(2, (self, input) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stdin: input
      });
    }
    // For piped commands it only makes sense to provide `stdin` for the
    // left-most command as the rest will be piped in.
    case "PipedCommand": {
      return makePiped({
        ...self,
        left: stdin(self.left, input)
      });
    }
  }
});

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Command.js
var flatten14 = flatten13;
var stdin2 = stdin;

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/CommandExecutor.js
var CommandExecutor2 = CommandExecutor;
var ProcessTypeId2 = ProcessTypeId;
var ExitCode2 = ExitCode;
var ProcessId2 = ProcessId;
var makeExecutor2 = makeExecutor;

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
var ChildProcess = __toESM(require("child_process"), 1);

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
var handleErrnoException = (module2, method) => (err, [path2]) => {
  let reason = "Unknown";
  switch (err.code) {
    case "ENOENT":
      reason = "NotFound";
      break;
    case "EACCES":
      reason = "PermissionDenied";
      break;
    case "EEXIST":
      reason = "AlreadyExists";
      break;
    case "EISDIR":
      reason = "BadResource";
      break;
    case "ENOTDIR":
      reason = "BadResource";
      break;
    case "EBUSY":
      reason = "Busy";
      break;
    case "ELOOP":
      reason = "BadResource";
      break;
  }
  return new SystemError({
    reason,
    module: module2,
    method,
    pathOrDescriptor: path2,
    syscall: err.syscall,
    description: err.message,
    cause: err
  });
};

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/stream.js
var import_node_stream = require("stream");
var fromReadable = (evaluate3, onError4, options3) => fromChannel4(fromReadableChannel(evaluate3, onError4, options3));
var fromReadableChannel = (evaluate3, onError4, options3) => suspend9(() => unsafeReadableRead(evaluate3(), onError4, make13(void 0), options3));
var writeInput = (writable, onFailure, {
  encoding,
  endOnDone = true
} = {}, onDone2 = _void) => {
  const write4 = writeEffect(writable, encoding);
  const close3 = endOnDone ? async2((resume2) => {
    if ("closed" in writable && writable.closed) {
      resume2(_void);
    } else {
      writable.once("finish", () => resume2(_void));
      writable.end();
    }
  }) : _void;
  return {
    awaitRead: () => _void,
    emit: write4,
    error: (cause2) => zipRight3(close3, onFailure(cause2)),
    done: (_) => zipRight3(close3, onDone2)
  };
};
var writeEffect = (writable, encoding) => (chunk4) => chunk4.length === 0 ? _void : async2((resume2) => {
  const iterator = chunk4[Symbol.iterator]();
  let next = iterator.next();
  function loop2() {
    const item = next;
    next = iterator.next();
    const success = writable.write(item.value, encoding);
    if (next.done) {
      resume2(_void);
    } else if (success) {
      loop2();
    } else {
      writable.once("drain", loop2);
    }
  }
  loop2();
});
var unsafeReadableRead = (readable, onError4, exit4, options3) => {
  if (!readable.readable) {
    return void_6;
  }
  const latch = unsafeMakeLatch2(false);
  function onReadable() {
    latch.unsafeOpen();
  }
  function onErr(err) {
    exit4.current = fail3(onError4(err));
    latch.unsafeOpen();
  }
  function onEnd2() {
    exit4.current = void_3;
    latch.unsafeOpen();
  }
  readable.on("readable", onReadable);
  readable.on("error", onErr);
  readable.on("end", onEnd2);
  const chunkSize = options3?.chunkSize ? Number(options3.chunkSize) : void 0;
  const read3 = suspend9(function loop2() {
    let item = readable.read(chunkSize);
    if (item === null) {
      if (exit4.current) {
        return fromEffect8(exit4.current);
      }
      latch.unsafeClose();
      return flatMap15(latch.await, loop2);
    }
    const arr = [item];
    while (true) {
      item = readable.read(chunkSize);
      if (item === null) {
        return flatMap15(write2(unsafeFromArray(arr)), loop2);
      }
      arr.push(item);
    }
  });
  return ensuring5(read3, sync4(() => {
    readable.off("readable", onReadable);
    readable.off("error", onErr);
    readable.off("end", onEnd2);
    if (options3?.closeOnDone !== false && "closed" in readable && !readable.closed) {
      readable.destroy();
    }
  }));
};

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
var fromWritable = (evaluate3, onError4, options3) => fromChannel3(fromWritableChannel(evaluate3, onError4, options3));
var fromWritableChannel = (writable, onError4, options3) => flatMap15(zip5(sync4(() => writable()), make38()), ([writable2, deferred]) => embedInput2(writableOutput(writable2, deferred, onError4), writeInput(writable2, (cause2) => failCause5(deferred, cause2), options3, complete2(deferred, _void))));
var writableOutput = (writable, deferred, onError4) => suspend4(() => {
  function handleError(err) {
    unsafeDone(deferred, fail7(onError4(err)));
  }
  writable.on("error", handleError);
  return ensuring2(_await3(deferred), sync4(() => {
    writable.removeListener("error", handleError);
  }));
});

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
var inputToStdioOption = (stdin3) => typeof stdin3 === "string" ? stdin3 : "pipe";
var outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
var toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
var toPlatformError = (method, error4, command) => {
  const flattened2 = flatten14(command).reduce((acc, curr) => {
    const command2 = `${curr.command} ${curr.args.join(" ")}`;
    return acc.length === 0 ? command2 : `${acc} | ${command2}`;
  }, "");
  return handleErrnoException("Command", method)(error4, [flattened2]);
};
var ProcessProto = {
  [ProcessTypeId2]: ProcessTypeId2,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/CommandExecutor/Process",
      pid: this.pid
    };
  }
};
var runCommand = (fileSystem) => (command) => {
  switch (command._tag) {
    case "StandardCommand": {
      const spawn2 = flatMap9(make38(), (exitCode2) => async2((resume2) => {
        const handle = ChildProcess.spawn(command.command, command.args, {
          stdio: [inputToStdioOption(command.stdin), outputToStdioOption(command.stdout), outputToStdioOption(command.stderr)],
          cwd: getOrElse2(command.cwd, constUndefined),
          shell: command.shell,
          env: {
            ...process.env,
            ...Object.fromEntries(command.env)
          },
          detached: process.platform !== "win32"
        });
        handle.on("error", (err) => {
          resume2(fail7(toPlatformError("spawn", err, command)));
        });
        handle.on("exit", (...args3) => {
          unsafeDone(exitCode2, succeed7(args3));
        });
        handle.on("spawn", () => {
          resume2(succeed7([handle, exitCode2]));
        });
        return sync4(() => {
          handle.kill("SIGTERM");
        });
      }));
      const killProcessGroup = process.platform === "win32" ? (handle, _) => async2((resume2) => {
        ChildProcess.exec(`taskkill /pid ${handle.pid} /T /F`, (error4) => {
          if (error4) {
            resume2(fail7(toPlatformError("kill", toError(error4), command)));
          } else {
            resume2(_void);
          }
        });
      }) : (handle, signal) => try_3({
        try: () => process.kill(-handle.pid, signal),
        catch: (error4) => toPlatformError("kill", toError(error4), command)
      });
      const killProcess = (handle, signal) => suspend4(() => handle.kill(signal) ? _void : fail7(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command)));
      return pipe(
        // Validate that the directory is accessible
        match2(command.cwd, {
          onNone: () => _void,
          onSome: (dir2) => fileSystem.access(dir2)
        }),
        zipRight3(acquireRelease2(spawn2, ([handle, exitCode2]) => flatMap9(isDone5(exitCode2), (done8) => {
          if (!done8) {
            return killProcessGroup(handle, "SIGTERM").pipe(orElse4(() => killProcess(handle, "SIGTERM")), zipRight3(_await3(exitCode2)), ignore2);
          }
          return flatMap9(_await3(exitCode2), ([code2]) => {
            if (code2 !== 0 && code2 !== null) {
              return killProcessGroup(handle, "SIGTERM").pipe(ignore2);
            }
            return _void;
          });
        }))),
        map17(([handle, exitCodeDeferred]) => {
          let stdin3 = drain3;
          if (handle.stdin !== null) {
            stdin3 = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command));
          }
          const exitCode2 = flatMap9(_await3(exitCodeDeferred), ([code2, signal]) => {
            if (code2 !== null) {
              return succeed7(ExitCode2(code2));
            }
            return fail7(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command));
          });
          const isRunning2 = negate2(isDone5(exitCodeDeferred));
          const kill = (signal = "SIGTERM") => killProcessGroup(handle, signal).pipe(orElse4(() => killProcess(handle, signal)), zipRight3(asVoid2(_await3(exitCodeDeferred))));
          const pid = ProcessId2(handle.pid);
          const stderr2 = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command));
          let stdout2 = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command));
          if (typeof command.stdout !== "string") {
            stdout2 = transduce2(stdout2, command.stdout);
          }
          return Object.assign(Object.create(ProcessProto), {
            pid,
            exitCode: exitCode2,
            isRunning: isRunning2,
            kill,
            stdin: stdin3,
            stderr: stderr2,
            stdout: stdout2
          });
        }),
        typeof command.stdin === "string" ? identity : tap2((process3) => forkDaemon2(run4(command.stdin, process3.stdin)))
      );
    }
    case "PipedCommand": {
      const flattened2 = flatten14(command);
      if (flattened2.length === 1) {
        return pipe(flattened2[0], runCommand(fileSystem));
      }
      const head5 = flattened2[0];
      const tail = flattened2.slice(1);
      const initial = tail.slice(0, tail.length - 1);
      const last5 = tail[tail.length - 1];
      const stream3 = initial.reduce((stdin3, command2) => pipe(stdin2(command2, stdin3), runCommand(fileSystem), map17((process3) => process3.stdout), unwrapScoped6), pipe(runCommand(fileSystem)(head5), map17((process3) => process3.stdout), unwrapScoped6));
      return pipe(stdin2(last5, stream3), runCommand(fileSystem));
    }
  }
};
var layer2 = /* @__PURE__ */ effect(CommandExecutor2, /* @__PURE__ */ pipe(FileSystem, /* @__PURE__ */ map17((fileSystem) => makeExecutor2(runCommand(fileSystem)))));

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
var layer3 = layer2;

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/effectify.js
var effectify = (fn3, onError4, onSyncError) => (...args3) => async2((resume2) => {
  try {
    fn3(...args3, (err, result) => {
      if (err) {
        resume2(fail7(onError4 ? onError4(err, args3) : err));
      } else {
        resume2(succeed7(result));
      }
    });
  } catch (err) {
    resume2(onSyncError ? fail7(onSyncError(err, args3)) : die5(err));
  }
});

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Effectify.js
var effectify2 = effectify;

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
var Crypto = __toESM(require("crypto"), 1);
var NFS = __toESM(require("fs"), 1);
var OS = __toESM(require("os"), 1);
var Path3 = __toESM(require("path"), 1);
var handleBadArgument = (method) => (cause2) => new BadArgument({
  module: "FileSystem",
  method,
  cause: cause2
});
var access2 = /* @__PURE__ */ (() => {
  const nodeAccess = /* @__PURE__ */ effectify2(NFS.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
  return (path2, options3) => {
    let mode = NFS.constants.F_OK;
    if (options3?.readable) {
      mode |= NFS.constants.R_OK;
    }
    if (options3?.writable) {
      mode |= NFS.constants.W_OK;
    }
    return nodeAccess(path2, mode);
  };
})();
var copy3 = /* @__PURE__ */ (() => {
  const nodeCp = /* @__PURE__ */ effectify2(NFS.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
  return (fromPath, toPath, options3) => nodeCp(fromPath, toPath, {
    force: options3?.overwrite ?? false,
    preserveTimestamps: options3?.preserveTimestamps ?? false,
    recursive: true
  });
})();
var copyFile2 = /* @__PURE__ */ (() => {
  const nodeCopyFile = /* @__PURE__ */ effectify2(NFS.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
  return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
})();
var chmod2 = /* @__PURE__ */ (() => {
  const nodeChmod = /* @__PURE__ */ effectify2(NFS.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
  return (path2, mode) => nodeChmod(path2, mode);
})();
var chown2 = /* @__PURE__ */ (() => {
  const nodeChown = /* @__PURE__ */ effectify2(NFS.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
  return (path2, uid, gid) => nodeChown(path2, uid, gid);
})();
var link2 = /* @__PURE__ */ (() => {
  const nodeLink = /* @__PURE__ */ effectify2(NFS.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
  return (existingPath, newPath) => nodeLink(existingPath, newPath);
})();
var makeDirectory = /* @__PURE__ */ (() => {
  const nodeMkdir = /* @__PURE__ */ effectify2(NFS.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
  return (path2, options3) => nodeMkdir(path2, {
    recursive: options3?.recursive ?? false,
    mode: options3?.mode
  });
})();
var makeTempDirectoryFactory = (method) => {
  const nodeMkdtemp = effectify2(NFS.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (options3) => suspend4(() => {
    const prefix = options3?.prefix ?? "";
    const directory3 = typeof options3?.directory === "string" ? Path3.join(options3.directory, ".") : OS.tmpdir();
    return nodeMkdtemp(prefix ? Path3.join(directory3, prefix) : directory3 + "/");
  });
};
var makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
var removeFactory = (method) => {
  const nodeRm = effectify2(NFS.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => nodeRm(path2, {
    recursive: options3?.recursive ?? false,
    force: options3?.force ?? false
  });
};
var remove7 = /* @__PURE__ */ removeFactory("remove");
var makeTempDirectoryScoped = /* @__PURE__ */ (() => {
  const makeDirectory2 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
  return (options3) => acquireRelease2(makeDirectory2(options3), (directory3) => orDie2(removeDirectory(directory3, {
    recursive: true
  })));
})();
var openFactory = (method) => {
  const nodeOpen = effectify2(NFS.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeClose = effectify2(NFS.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => pipe(acquireRelease2(nodeOpen(path2, options3?.flag ?? "r", options3?.mode), (fd) => orDie2(nodeClose(fd))), map17((fd) => makeFile(FileDescriptor(fd), options3?.flag?.startsWith("a") ?? false)));
};
var open2 = /* @__PURE__ */ openFactory("open");
var makeFile = /* @__PURE__ */ (() => {
  const nodeReadFactory = (method) => effectify2(NFS.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
  const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
  const nodeStat = /* @__PURE__ */ effectify2(NFS.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  const nodeSync = /* @__PURE__ */ effectify2(NFS.fsync, /* @__PURE__ */ handleErrnoException("FileSystem", "sync"), /* @__PURE__ */ handleBadArgument("sync"));
  const nodeWriteFactory = (method) => effectify2(NFS.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
  const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");
  class FileImpl {
    fd;
    append;
    [FileTypeId];
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore2(1);
    position = 0n;
    constructor(fd, append4) {
      this.fd = fd;
      this.append = append4;
      this[FileTypeId] = FileTypeId;
    }
    get stat() {
      return map17(nodeStat(this.fd), makeFileInfo);
    }
    get sync() {
      return nodeSync(this.fd);
    }
    seek(offset, from) {
      const offsetSize = Size2(offset);
      return this.semaphore.withPermits(1)(sync4(() => {
        if (from === "start") {
          this.position = offsetSize;
        } else if (from === "current") {
          this.position = this.position + offsetSize;
        }
        return this.position;
      }));
    }
    read(buffer3) {
      return this.semaphore.withPermits(1)(map17(suspend4(() => nodeRead(this.fd, {
        buffer: buffer3,
        position: this.position
      })), (bytesRead) => {
        const sizeRead = Size2(bytesRead);
        this.position = this.position + sizeRead;
        return sizeRead;
      }));
    }
    readAlloc(size13) {
      const sizeNumber = Number(size13);
      return this.semaphore.withPermits(1)(flatMap9(sync4(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer3) => map17(nodeReadAlloc(this.fd, {
        buffer: buffer3,
        position: this.position
      }), (bytesRead) => {
        if (bytesRead === 0) {
          return none2();
        }
        this.position = this.position + BigInt(bytesRead);
        if (bytesRead === sizeNumber) {
          return some2(buffer3);
        }
        const dst = Buffer.allocUnsafeSlow(bytesRead);
        buffer3.copy(dst, 0, 0, bytesRead);
        return some2(dst);
      })));
    }
    truncate(length3) {
      return this.semaphore.withPermits(1)(map17(nodeTruncate(this.fd, length3 ? Number(length3) : void 0), () => {
        if (!this.append) {
          const len = BigInt(length3 ?? 0);
          if (this.position > len) {
            this.position = len;
          }
        }
      }));
    }
    write(buffer3) {
      return this.semaphore.withPermits(1)(map17(suspend4(() => nodeWrite(this.fd, buffer3, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
        const sizeWritten = Size2(bytesWritten);
        if (!this.append) {
          this.position = this.position + sizeWritten;
        }
        return sizeWritten;
      }));
    }
    writeAllChunk(buffer3) {
      return flatMap9(suspend4(() => nodeWriteAll(this.fd, buffer3, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
        if (bytesWritten === 0) {
          return fail7(new SystemError({
            module: "FileSystem",
            method: "writeAll",
            reason: "WriteZero",
            pathOrDescriptor: this.fd,
            description: "write returned 0 bytes written"
          }));
        }
        if (!this.append) {
          this.position = this.position + BigInt(bytesWritten);
        }
        return bytesWritten < buffer3.length ? this.writeAllChunk(buffer3.subarray(bytesWritten)) : _void;
      });
    }
    writeAll(buffer3) {
      return this.semaphore.withPermits(1)(this.writeAllChunk(buffer3));
    }
  }
  return (fd, append4) => new FileImpl(fd, append4);
})();
var makeTempFileFactory = (method) => {
  const makeDirectory2 = makeTempDirectoryFactory(method);
  const open3 = openFactory(method);
  const randomHexString2 = (bytes) => sync4(() => Crypto.randomBytes(bytes).toString("hex"));
  return (options3) => pipe(zip5(makeDirectory2(options3), randomHexString2(6)), map17(([directory3, random3]) => Path3.join(directory3, random3 + (options3?.suffix ?? ""))), tap2((path2) => scoped2(open3(path2, {
    flag: "w+"
  }))));
};
var makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
var makeTempFileScoped = /* @__PURE__ */ (() => {
  const makeFile2 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
  return (options3) => acquireRelease2(makeFile2(options3), (file5) => orDie2(removeDirectory(Path3.dirname(file5), {
    recursive: true
  })));
})();
var readDirectory = (path2, options3) => tryPromise2({
  try: () => NFS.promises.readdir(path2, options3),
  catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path2])
});
var readFile2 = (path2) => async2((resume2, signal) => {
  try {
    NFS.readFile(path2, {
      signal
    }, (err, data) => {
      if (err) {
        resume2(fail7(handleErrnoException("FileSystem", "readFile")(err, [path2])));
      } else {
        resume2(succeed7(data));
      }
    });
  } catch (err) {
    resume2(fail7(handleBadArgument("readFile")(err)));
  }
});
var readLink = /* @__PURE__ */ (() => {
  const nodeReadLink = /* @__PURE__ */ effectify2(NFS.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
  return (path2) => nodeReadLink(path2);
})();
var realPath = /* @__PURE__ */ (() => {
  const nodeRealPath = /* @__PURE__ */ effectify2(NFS.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
  return (path2) => nodeRealPath(path2);
})();
var rename3 = /* @__PURE__ */ (() => {
  const nodeRename = /* @__PURE__ */ effectify2(NFS.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
  return (oldPath, newPath) => nodeRename(oldPath, newPath);
})();
var makeFileInfo = (stat3) => ({
  type: stat3.isFile() ? "File" : stat3.isDirectory() ? "Directory" : stat3.isSymbolicLink() ? "SymbolicLink" : stat3.isBlockDevice() ? "BlockDevice" : stat3.isCharacterDevice() ? "CharacterDevice" : stat3.isFIFO() ? "FIFO" : stat3.isSocket() ? "Socket" : "Unknown",
  mtime: fromNullable(stat3.mtime),
  atime: fromNullable(stat3.atime),
  birthtime: fromNullable(stat3.birthtime),
  dev: stat3.dev,
  rdev: fromNullable(stat3.rdev),
  ino: fromNullable(stat3.ino),
  mode: stat3.mode,
  nlink: fromNullable(stat3.nlink),
  uid: fromNullable(stat3.uid),
  gid: fromNullable(stat3.gid),
  size: Size2(stat3.size),
  blksize: map2(fromNullable(stat3.blksize), Size2),
  blocks: fromNullable(stat3.blocks)
});
var stat2 = /* @__PURE__ */ (() => {
  const nodeStat = /* @__PURE__ */ effectify2(NFS.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  return (path2) => map17(nodeStat(path2), makeFileInfo);
})();
var symlink2 = /* @__PURE__ */ (() => {
  const nodeSymlink = /* @__PURE__ */ effectify2(NFS.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
  return (target, path2) => nodeSymlink(target, path2);
})();
var truncate2 = /* @__PURE__ */ (() => {
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  return (path2, length3) => nodeTruncate(path2, length3 !== void 0 ? Number(length3) : void 0);
})();
var utimes2 = /* @__PURE__ */ (() => {
  const nodeUtimes = /* @__PURE__ */ effectify2(NFS.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
  return (path2, atime, mtime) => nodeUtimes(path2, atime, mtime);
})();
var watchNode = (path2, options3) => asyncScoped2((emit) => acquireRelease2(sync4(() => {
  const watcher = NFS.watch(path2, {
    recursive: options3?.recursive
  }, (event, path3) => {
    if (!path3) return;
    switch (event) {
      case "rename": {
        emit.fromEffect(matchEffect2(stat2(path3), {
          onSuccess: (_) => succeed7(WatchEventCreate({
            path: path3
          })),
          onFailure: (err) => err._tag === "SystemError" && err.reason === "NotFound" ? succeed7(WatchEventRemove({
            path: path3
          })) : fail7(err)
        }));
        return;
      }
      case "change": {
        emit.single(WatchEventUpdate({
          path: path3
        }));
        return;
      }
    }
  });
  watcher.on("error", (error4) => {
    emit.fail(new SystemError({
      module: "FileSystem",
      reason: "Unknown",
      method: "watch",
      pathOrDescriptor: path2,
      cause: error4
    }));
  });
  watcher.on("close", () => {
    emit.end();
  });
  return watcher;
}), (watcher) => sync4(() => watcher.close())));
var watch2 = (backend, path2, options3) => stat2(path2).pipe(map17((stat3) => backend.pipe(flatMap((_) => _.register(path2, stat3, options3)), getOrElse2(() => watchNode(path2, options3)))), unwrap5);
var writeFile2 = (path2, data, options3) => async2((resume2, signal) => {
  try {
    NFS.writeFile(path2, data, {
      signal,
      flag: options3?.flag,
      mode: options3?.mode
    }, (err) => {
      if (err) {
        resume2(fail7(handleErrnoException("FileSystem", "writeFile")(err, [path2])));
      } else {
        resume2(_void);
      }
    });
  } catch (err) {
    resume2(fail7(handleBadArgument("writeFile")(err)));
  }
});
var makeFileSystem = /* @__PURE__ */ map17(/* @__PURE__ */ serviceOption2(WatchBackend), (backend) => make54({
  access: access2,
  chmod: chmod2,
  chown: chown2,
  copy: copy3,
  copyFile: copyFile2,
  link: link2,
  makeDirectory,
  makeTempDirectory,
  makeTempDirectoryScoped,
  makeTempFile,
  makeTempFileScoped,
  open: open2,
  readDirectory,
  readFile: readFile2,
  readLink,
  realPath,
  remove: remove7,
  rename: rename3,
  stat: stat2,
  symlink: symlink2,
  truncate: truncate2,
  utimes: utimes2,
  watch(path2, options3) {
    return watch2(backend, path2, options3);
  },
  writeFile: writeFile2
}));
var layer4 = /* @__PURE__ */ effect(FileSystem, makeFileSystem);

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
var layer5 = layer4;

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/path.js
var NodePath = __toESM(require("path"), 1);
var NodeUrl = __toESM(require("url"), 1);
var fromFileUrl2 = (url2) => try_3({
  try: () => NodeUrl.fileURLToPath(url2),
  catch: (error4) => new BadArgument({
    module: "Path",
    method: "fromFileUrl",
    description: `Invalid file URL: ${url2}`,
    cause: error4
  })
});
var toFileUrl2 = (path2) => try_3({
  try: () => NodeUrl.pathToFileURL(path2),
  catch: (error4) => new BadArgument({
    module: "Path",
    method: "toFileUrl",
    description: `Invalid path: ${path2}`,
    cause: error4
  })
});
var layerPosix = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId21]: TypeId21,
  ...NodePath.posix,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layerWin32 = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId21]: TypeId21,
  ...NodePath.win32,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layer6 = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId21]: TypeId21,
  ...NodePath,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
var layer7 = layer6;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/mailbox.js
var TypeId25 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty38 = /* @__PURE__ */ empty5();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty38);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty38, true];
var MailboxImpl = class extends Class2 {
  scheduler;
  capacity;
  strategy;
  [TypeId25] = TypeId25;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty5();
  constructor(scheduler, capacity3, strategy) {
    super();
    this.scheduler = scheduler;
    this.capacity = capacity3;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause2) {
    return this.done(exitFailCause(cause2));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty38;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty38);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty38, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size13 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size13);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    for (const taker of this.state.takers) {
      this.state.takers.delete(taker);
      taker(exitVoid);
      if (this.messages.length + this.messagesChunk.length === 0) {
        break;
      }
    }
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty38;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty38;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make60 = (capacity3) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity3 === "number" ? capacity3 : capacity3?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity3 === "number" ? "suspend" : capacity3?.strategy ?? "suspend")));
var toChannel3 = (self) => {
  const loop2 = flatMap12(self.takeAll, ([messages, done8]) => done8 ? messages.length === 0 ? void_5 : write(messages) : zipRight4(write(messages), loop2));
  return loop2;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Mailbox.js
var TypeId26 = TypeId25;
var isMailbox = (u) => hasProperty(u, TypeId26);
var make61 = make60;
var toChannel4 = toChannel3;

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/terminal.js
var readline = __toESM(require("readline"), 1);
var defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
var make62 = /* @__PURE__ */ fnUntraced2(function* (shouldQuit = defaultShouldQuit) {
  const stdin3 = process.stdin;
  const stdout2 = process.stdout;
  const rlRef = yield* make48({
    acquire: acquireRelease2(sync4(() => {
      const rl = readline.createInterface({
        input: stdin3,
        escapeCodeTimeout: 50
      });
      readline.emitKeypressEvents(stdin3, rl);
      if (stdin3.isTTY) {
        stdin3.setRawMode(true);
      }
      return rl;
    }), (rl) => sync4(() => {
      if (stdin3.isTTY) {
        stdin3.setRawMode(false);
      }
      rl.close();
    }))
  });
  const columns = sync4(() => stdout2.columns ?? 0);
  const readInput = gen2(function* () {
    yield* get15(rlRef);
    const mailbox = yield* make61();
    const handleKeypress = (s, k) => {
      const userInput = {
        input: fromNullable(s),
        key: {
          name: k.name ?? "",
          ctrl: !!k.ctrl,
          meta: !!k.meta,
          shift: !!k.shift
        }
      };
      mailbox.unsafeOffer(userInput);
      if (shouldQuit(userInput)) {
        mailbox.unsafeDone(void_3);
      }
    };
    yield* addFinalizer3(() => sync4(() => stdin3.off("keypress", handleKeypress)));
    stdin3.on("keypress", handleKeypress);
    return mailbox;
  });
  const readLine = get15(rlRef).pipe(flatMap9((readlineInterface) => async2((resume2) => {
    const onLine = (line4) => resume2(succeed7(line4));
    readlineInterface.once("line", onLine);
    return sync4(() => readlineInterface.off("line", onLine));
  })), scoped2);
  const display = (prompt3) => uninterruptible2(async2((resume2) => {
    stdout2.write(prompt3, (err) => err ? resume2(fail7(new BadArgument({
      module: "Terminal",
      method: "display",
      description: "Failed to write prompt to stdout",
      cause: err
    }))) : resume2(_void));
  }));
  return Terminal.of({
    columns,
    readInput,
    readLine,
    display
  });
});
var layer8 = /* @__PURE__ */ scoped3(Terminal, /* @__PURE__ */ make62(defaultShouldQuit));

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
var layer9 = layer8;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/FiberSet.js
var TypeId27 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId27);
var Proto3 = {
  [TypeId27]: TypeId27,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake8 = (backing, deferred) => {
  const self = Object.create(Proto3);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make63 = () => acquireRelease2(map17(make38(), (deferred) => unsafeMake8(/* @__PURE__ */ new Set(), deferred)), (set7) => withFiberRuntime2((parent) => {
  const state = set7.state;
  if (state._tag === "Closed") return _void;
  set7.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return interruptAllAs2(fibers, combine4(parent.id(), internalFiberId)).pipe(intoDeferred2(set7.deferred));
}));
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make15(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId2) => has3(ids2(fiberId2), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = /* @__PURE__ */ dual((args3) => isFiberSet(args3[0]), (self, fiber, options3) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine4(options3?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure(exit4) && (options3?.propagateInterruption === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var join5 = (self) => _await3(self.deferred);

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Transferable.js
var Collector = class extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
};
var unsafeMakeCollector = () => {
  let tranferables = [];
  const unsafeAddAll = (transfers) => {
    tranferables.push(...transfers);
  };
  const unsafeRead = () => tranferables;
  const unsafeClear = () => {
    const prev = tranferables;
    tranferables = [];
    return prev;
  };
  return Collector.of({
    unsafeAddAll,
    addAll: (transferables) => sync4(() => unsafeAddAll(transferables)),
    unsafeRead,
    read: sync4(unsafeRead),
    unsafeClear,
    clear: sync4(unsafeClear)
  });
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/workerError.js
var WorkerErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/WorkerError.js
var WorkerErrorTypeId2 = WorkerErrorTypeId;
var WorkerError = class extends (/* @__PURE__ */ TaggedError2()("WorkerError", {
  reason: /* @__PURE__ */ Literal2("spawn", "decode", "send", "unknown", "encode"),
  cause: Defect
})) {
  /**
   * @since 1.0.0
   */
  [WorkerErrorTypeId2] = WorkerErrorTypeId2;
  /**
   * @since 1.0.0
   */
  static Cause = /* @__PURE__ */ Cause({
    error: this,
    defect: Defect
  });
  /**
   * @since 1.0.0
   */
  static encodeCause = /* @__PURE__ */ encodeSync(this.Cause);
  /**
   * @since 1.0.0
   */
  static decodeCause = /* @__PURE__ */ decodeSync(this.Cause);
  /**
   * @since 1.0.0
   */
  get message() {
    switch (this.reason) {
      case "send":
        return "An error occurred calling .postMessage";
      case "spawn":
        return "An error occurred while spawning a worker";
      case "decode":
        return "An error occurred during decoding";
      case "encode":
        return "An error occurred during encoding";
      case "unknown":
        return "An unexpected error occurred";
    }
  }
};

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/internal/worker.js
var PlatformWorkerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/PlatformWorker");
var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");
var WorkerManagerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/WorkerManager");
var WorkerManager = /* @__PURE__ */ GenericTag("@effect/platform/Worker/WorkerManager");
var Spawner = /* @__PURE__ */ GenericTag("@effect/platform/Worker/Spawner");
var makeManager = /* @__PURE__ */ gen2(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode: encode3,
      initialMessage
    }) {
      return gen2(function* () {
        const id2 = idCounter++;
        let requestIdCounter = 0;
        const requestMap = /* @__PURE__ */ new Map();
        const collector = unsafeMakeCollector();
        const wrappedEncode = encode3 ? (message) => zipRight3(collector.clear, provideService2(encode3(message), Collector, collector)) : succeed7;
        const readyLatch = yield* make38();
        const backing = yield* platform.spawn(id2);
        yield* backing.run((message) => {
          if (message[0] === 0) {
            return complete2(readyLatch, _void);
          }
          return handleMessage(message[1]);
        }).pipe(onError2((cause2) => forEach8(requestMap.values(), (mailbox) => DeferredTypeId2 in mailbox ? failCause5(mailbox, cause2) : mailbox.failCause(cause2))), tapErrorCause2(logWarning2), retry(spaced2(1e3)), annotateLogs2({
          package: "@effect/platform",
          module: "Worker"
        }), interruptible4, forkScoped2);
        yield* addFinalizer3(() => zipRight3(forEach8(requestMap.values(), (mailbox) => DeferredTypeId2 in mailbox ? interrupt5(mailbox) : mailbox.end, {
          discard: true
        }), sync4(() => requestMap.clear())));
        const handleMessage = (response) => suspend4(() => {
          const mailbox = requestMap.get(response[0]);
          if (!mailbox) return _void;
          switch (response[1]) {
            // data
            case 0: {
              return DeferredTypeId2 in mailbox ? succeed6(mailbox, response[2][0]) : mailbox.offerAll(response[2]);
            }
            // end
            case 1: {
              if (response.length === 2) {
                return DeferredTypeId2 in mailbox ? interrupt5(mailbox) : mailbox.end;
              }
              return DeferredTypeId2 in mailbox ? succeed6(mailbox, response[2][0]) : zipRight3(mailbox.offerAll(response[2]), mailbox.end);
            }
            // error / defect
            case 2:
            case 3: {
              if (response[1] === 2) {
                return DeferredTypeId2 in mailbox ? fail6(mailbox, response[2]) : mailbox.fail(response[2]);
              }
              const cause2 = WorkerError.decodeCause(response[2]);
              return DeferredTypeId2 in mailbox ? failCause5(mailbox, cause2) : mailbox.failCause(cause2);
            }
          }
        });
        const executeAcquire = (request, makeMailbox) => withFiberRuntime2((fiber) => {
          const context7 = fiber.getFiberRef(currentContext2);
          const span2 = getOption2(context7, ParentSpan).pipe(filter((span3) => span3._tag === "Span"));
          const id3 = requestIdCounter++;
          return makeMailbox.pipe(tap2((mailbox) => {
            requestMap.set(id3, mailbox);
            return wrappedEncode(request).pipe(tap2((payload) => backing.send([id3, 0, payload, span2._tag === "Some" ? [span2.value.traceId, span2.value.spanId, span2.value.sampled] : void 0], collector.unsafeRead())), catchAllCause2((cause2) => isMailbox(mailbox) ? mailbox.failCause(cause2) : failCause5(mailbox, cause2)));
          }), map17((mailbox) => ({
            id: id3,
            mailbox
          })));
        });
        const executeRelease = ({
          id: id3
        }, exit4) => {
          const release = sync4(() => requestMap.delete(id3));
          return isFailure(exit4) ? zipRight3(orDie2(backing.send([id3, 1])), release) : release;
        };
        const execute2 = (request) => fromChannel4(acquireUseRelease4(executeAcquire(request, make61()), ({
          mailbox
        }) => toChannel4(mailbox), executeRelease));
        const executeEffect = (request) => acquireUseRelease2(executeAcquire(request, make38()), ({
          mailbox
        }) => _await3(mailbox), executeRelease);
        yield* _await3(readyLatch);
        if (initialMessage) {
          yield* sync4(initialMessage).pipe(flatMap9(executeEffect), mapError2((cause2) => new WorkerError({
            reason: "spawn",
            cause: cause2
          })));
        }
        return {
          id: id2,
          execute: execute2,
          executeEffect
        };
      });
    }
  });
});
var layerManager = /* @__PURE__ */ effect(WorkerManager, makeManager);
var makePlatform = () => (options3) => PlatformWorker.of({
  [PlatformWorkerTypeId]: PlatformWorkerTypeId,
  spawn(id2) {
    return gen2(function* () {
      const spawn2 = yield* Spawner;
      let currentPort;
      const buffer3 = [];
      const run10 = (handler) => uninterruptibleMask3((restore) => gen2(function* () {
        const scope4 = yield* scope2;
        const port2 = yield* options3.setup({
          worker: spawn2(id2),
          scope: scope4
        });
        currentPort = port2;
        yield* addFinalizer2(scope4, sync4(() => {
          currentPort = void 0;
        }));
        const runtime5 = (yield* runtime4()).pipe(updateContext3(omit2(Scope)));
        const fiberSet = yield* make63();
        const runFork4 = runFork3(runtime5);
        yield* options3.listen({
          port: port2,
          scope: scope4,
          emit(data) {
            unsafeAdd(fiberSet, runFork4(handler(data)));
          },
          deferred: fiberSet.deferred
        });
        if (buffer3.length > 0) {
          for (const [message, transfers] of buffer3) {
            port2.postMessage([0, message], transfers);
          }
          buffer3.length = 0;
        }
        return yield* restore(join5(fiberSet));
      }).pipe(scoped2));
      const send = (message, transfers) => try_3({
        try: () => {
          if (currentPort === void 0) {
            buffer3.push([message, transfers]);
          } else {
            currentPort.postMessage([0, message], transfers);
          }
        },
        catch: (cause2) => new WorkerError({
          reason: "send",
          cause: cause2
        })
      });
      return {
        run: run10,
        send
      };
    });
  }
});

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Worker.js
var makePlatform2 = makePlatform;
var PlatformWorker2 = PlatformWorker;
var layerManager2 = layerManager;

// ../../node_modules/.pnpm/@effect+platform-node@0.104.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rpc@0.73_mtv4yqlrbvngrnrgy7kff3c24u/node_modules/@effect/platform-node/dist/esm/internal/worker.js
var platformWorkerImpl = /* @__PURE__ */ makePlatform2()({
  setup({
    scope: scope4,
    worker
  }) {
    return flatMap9(make38(), (exitDeferred) => {
      const thing = "postMessage" in worker ? {
        postMessage(msg, t) {
          worker.postMessage(msg, t);
        },
        kill: () => worker.terminate(),
        worker
      } : {
        postMessage(msg, _) {
          worker.send(msg);
        },
        kill: () => worker.kill("SIGKILL"),
        worker
      };
      worker.on("exit", () => {
        unsafeDone(exitDeferred, void_3);
      });
      return as4(addFinalizer2(scope4, suspend4(() => {
        thing.postMessage([1]);
        return _await3(exitDeferred);
      }).pipe(interruptible4, timeout2(5e3), catchAllCause2(() => sync4(() => thing.kill())))), thing);
    });
  },
  listen({
    deferred,
    emit,
    port: port2
  }) {
    port2.worker.on("message", (message) => {
      emit(message);
    });
    port2.worker.on("messageerror", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "decode",
        cause: cause2
      }));
    });
    port2.worker.on("error", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: cause2
      }));
    });
    port2.worker.on("exit", (code2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: new Error(`exited with code ${code2}`)
      }));
    });
    return _void;
  }
});
var layerWorker = /* @__PURE__ */ succeed10(PlatformWorker2, platformWorkerImpl);
var layerManager3 = /* @__PURE__ */ provide3(layerManager2, layerWorker);

// ../../node_modules/.pnpm/@effect+platform-node@0.104.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rpc@0.73_mtv4yqlrbvngrnrgy7kff3c24u/node_modules/@effect/platform-node/dist/esm/NodeWorker.js
var layerManager4 = layerManager3;

// ../../node_modules/.pnpm/@effect+platform-node@0.104.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rpc@0.73_mtv4yqlrbvngrnrgy7kff3c24u/node_modules/@effect/platform-node/dist/esm/NodeContext.js
var layer11 = /* @__PURE__ */ pipe(/* @__PURE__ */ mergeAll5(layer7, layer3, layer9, layerManager4), /* @__PURE__ */ provideMerge2(layer5));

// ../../node_modules/.pnpm/@effect+platform@0.94.1_effect@3.19.14/node_modules/@effect/platform/dist/esm/Runtime.js
var defaultTeardown = (exit4, onExit3) => {
  onExit3(isFailure(exit4) && !isInterruptedOnly2(exit4.cause) ? 1 : 0);
};
var addPrettyLogger = (refs, fiberId2) => {
  const loggers = getOrDefault2(refs, currentLoggers2);
  if (!has3(loggers, defaultLogger2)) {
    return refs;
  }
  return updateAs2(refs, {
    fiberId: fiberId2,
    fiberRef: currentLoggers2,
    value: loggers.pipe(remove4(defaultLogger2), add4(prettyLoggerDefault2))
  });
};
var makeRunMain = (f) => dual((args3) => isEffect2(args3[0]), (effect3, options3) => {
  const fiber = options3?.disableErrorReporting === true ? runFork2(effect3, {
    updateRefs: options3?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  }) : runFork2(tapErrorCause2(effect3, (cause2) => {
    if (isInterruptedOnly2(cause2)) {
      return _void;
    }
    return logError2(cause2);
  }), {
    updateRefs: options3?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  });
  const teardown = options3?.teardown ?? defaultTeardown;
  return f({
    fiber,
    teardown
  });
});

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
var runMain = /* @__PURE__ */ makeRunMain(({
  fiber,
  teardown
}) => {
  const keepAlive = setInterval(constVoid, 2 ** 31 - 1);
  let receivedSignal = false;
  fiber.addObserver((exit4) => {
    if (!receivedSignal) {
      process.removeListener("SIGINT", onSigint);
      process.removeListener("SIGTERM", onSigint);
    }
    clearInterval(keepAlive);
    teardown(exit4, (code2) => {
      if (receivedSignal || code2 !== 0) {
        process.exit(code2);
      }
    });
  });
  function onSigint() {
    receivedSignal = true;
    process.removeListener("SIGINT", onSigint);
    process.removeListener("SIGTERM", onSigint);
    fiber.unsafeInterruptAsFork(fiber.id());
  }
  process.on("SIGINT", onSigint);
  process.on("SIGTERM", onSigint);
});

// ../../node_modules/.pnpm/@effect+platform-node-shared@0.57.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rp_chuwlmyxrvttdq5xa6zvwf7phu/node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
var runMain2 = runMain;

// ../../node_modules/.pnpm/@effect+platform-node@0.104.0_@effect+cluster@0.56.1_@effect+platform@0.94.1_@effect+rpc@0.73_mtv4yqlrbvngrnrgy7kff3c24u/node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
var runMain3 = runMain2;

// package.json
var package_default = {
  name: "@effect/language-service",
  version: "0.72.0",
  publishConfig: {
    access: "public",
    directory: "dist"
  },
  author: "Michael Arnaldi <ma@matechs.com>",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/Effect-TS/language-service.git"
  },
  bugs: {
    url: "https://github.com/Effect-TS/language-service/issues"
  },
  homepage: "https://github.com/Effect-TS/language-service",
  description: "A Language-Service Plugin to Refactor and Diagnostic effect-ts projects",
  tags: [
    "typescript",
    "algebraic-data-types",
    "functional-programming"
  ],
  keywords: [
    "typescript",
    "algebraic-data-types",
    "functional-programming"
  ],
  scripts: {
    build: "tsup",
    dev: "tsup --watch",
    clean: "rimraf dist build .tsbuildinfo",
    lint: "eslint src test",
    "lint-fix": "eslint src test --fix",
    check: "tsc -b tsconfig.json",
    circular: "madge --extensions ts --circular --no-color --no-spinner --warning src",
    test: "vitest",
    "test-update": "vitest --update",
    "test-patch": "pnpm clean && pnpm build && pnpm effect-language-service unpatch && pnpm effect-language-service patch && pnpm check",
    coverage: "vitest run --coverage",
    perf: "tsx test/perf.ts"
  },
  devDependencies: {
    "@effect/cli": "^0.73.0",
    "@effect/eslint-plugin": "^0.3.2",
    "@effect/experimental": "^0.58.0",
    "@effect/language-service": "link:dist",
    "@effect/platform": "0.94.1",
    "@effect/platform-node": "0.104.0",
    "@effect/printer-ansi": "^0.47.0",
    "@effect/rpc": "^0.73.0",
    "@effect/sql": "^0.49.0",
    "@eslint/compat": "^2.0.1",
    "@eslint/eslintrc": "^3.3.3",
    "@eslint/js": "^9.39.2",
    "@rollup/pluginutils": "^5.3.0",
    "@types/node": "^25.0.6",
    "@types/pako": "^2.0.4",
    "@typescript-eslint/eslint-plugin": "^8.52.0",
    "@typescript-eslint/parser": "^8.52.0",
    "@typescript-eslint/project-service": "^8.52.0",
    "@vitest/coverage-v8": "^4.0.17",
    effect: "^3.19.14",
    eslint: "^9.39.2",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-codegen": "^0.34.1",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "eslint-plugin-sort-destructure-keys": "^2.0.0",
    madge: "^8.0.0",
    pako: "^2.1.0",
    rimraf: "^6.1.2",
    "ts-patch": "^3.3.0",
    tsup: "^8.5.1",
    tsx: "^4.21.0",
    typescript: "^5.9.3",
    vite: "^7.3.1",
    vitest: "^4.0.17"
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Graph.js
var TypeId28 = "~effect/Graph";
var Edge = class extends Class3 {
};
var ProtoGraph = {
  [TypeId28]: TypeId28,
  [Symbol.iterator]() {
    return this.nodes[Symbol.iterator]();
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    if (isGraph(that)) {
      if (this.nodes.size !== that.nodes.size || this.edges.size !== that.edges.size || this.type !== that.type) {
        return false;
      }
      for (const [nodeIndex, nodeData] of this.nodes) {
        if (!that.nodes.has(nodeIndex)) {
          return false;
        }
        const otherNodeData = that.nodes.get(nodeIndex);
        if (!equals(nodeData, otherNodeData)) {
          return false;
        }
      }
      for (const [edgeIndex, edgeData] of this.edges) {
        if (!that.edges.has(edgeIndex)) {
          return false;
        }
        const otherEdge = that.edges.get(edgeIndex);
        if (!equals(edgeData, otherEdge)) {
          return false;
        }
      }
      return true;
    }
    return false;
  },
  [symbol]() {
    let hash2 = string("Graph");
    hash2 = hash2 ^ string(this.type);
    hash2 = hash2 ^ number2(this.nodes.size);
    hash2 = hash2 ^ number2(this.edges.size);
    for (const [nodeIndex, nodeData] of this.nodes) {
      hash2 = hash2 ^ hash(nodeIndex) + hash(nodeData);
    }
    for (const [edgeIndex, edgeData] of this.edges) {
      hash2 = hash2 ^ hash(edgeIndex) + hash(edgeData);
    }
    return hash2;
  },
  toJSON() {
    return {
      _id: "Graph",
      nodeCount: this.nodes.size,
      edgeCount: this.edges.size,
      type: this.type
    };
  },
  toString() {
    return format(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GraphError = class extends (/* @__PURE__ */ TaggedError("GraphError")) {
};
var missingNode = (node) => new GraphError({
  message: `Node ${node} does not exist`
});
var isGraph = (u) => typeof u === "object" && u !== null && TypeId28 in u;
var directed = (mutate4) => {
  const graph = Object.create(ProtoGraph);
  graph.type = "directed";
  graph.nodes = /* @__PURE__ */ new Map();
  graph.edges = /* @__PURE__ */ new Map();
  graph.adjacency = /* @__PURE__ */ new Map();
  graph.reverseAdjacency = /* @__PURE__ */ new Map();
  graph.nextNodeIndex = 0;
  graph.nextEdgeIndex = 0;
  graph.isAcyclic = some2(true);
  graph.mutable = false;
  if (mutate4) {
    const mutable2 = beginMutation3(graph);
    mutate4(mutable2);
    return endMutation3(mutable2);
  }
  return graph;
};
var beginMutation3 = (graph) => {
  const adjacency = /* @__PURE__ */ new Map();
  const reverseAdjacency = /* @__PURE__ */ new Map();
  for (const [nodeIndex, edges2] of graph.adjacency) {
    adjacency.set(nodeIndex, [...edges2]);
  }
  for (const [nodeIndex, edges2] of graph.reverseAdjacency) {
    reverseAdjacency.set(nodeIndex, [...edges2]);
  }
  const mutable2 = Object.create(ProtoGraph);
  mutable2.type = graph.type;
  mutable2.nodes = new Map(graph.nodes);
  mutable2.edges = new Map(graph.edges);
  mutable2.adjacency = adjacency;
  mutable2.reverseAdjacency = reverseAdjacency;
  mutable2.nextNodeIndex = graph.nextNodeIndex;
  mutable2.nextEdgeIndex = graph.nextEdgeIndex;
  mutable2.isAcyclic = graph.isAcyclic;
  mutable2.mutable = true;
  return mutable2;
};
var endMutation3 = (mutable2) => {
  const graph = Object.create(ProtoGraph);
  graph.type = mutable2.type;
  graph.nodes = new Map(mutable2.nodes);
  graph.edges = new Map(mutable2.edges);
  graph.adjacency = mutable2.adjacency;
  graph.reverseAdjacency = mutable2.reverseAdjacency;
  graph.nextNodeIndex = mutable2.nextNodeIndex;
  graph.nextEdgeIndex = mutable2.nextEdgeIndex;
  graph.isAcyclic = mutable2.isAcyclic;
  graph.mutable = false;
  return graph;
};
var mutate3 = /* @__PURE__ */ dual(2, (graph, f) => {
  const mutable2 = beginMutation3(graph);
  f(mutable2);
  return endMutation3(mutable2);
});
var addNode = (mutable2, data) => {
  const nodeIndex = mutable2.nextNodeIndex;
  mutable2.nodes.set(nodeIndex, data);
  mutable2.adjacency.set(nodeIndex, []);
  mutable2.reverseAdjacency.set(nodeIndex, []);
  mutable2.nextNodeIndex = mutable2.nextNodeIndex + 1;
  return nodeIndex;
};
var getNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex) ? some2(graph.nodes.get(nodeIndex)) : none2();
var hasNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex);
var reverse6 = (mutable2) => {
  for (const [index, edgeData] of mutable2.edges) {
    mutable2.edges.set(index, {
      source: edgeData.target,
      target: edgeData.source,
      data: edgeData.data
    });
  }
  mutable2.adjacency.clear();
  mutable2.reverseAdjacency.clear();
  for (const [edgeIndex, edgeData] of mutable2.edges) {
    const sourceEdges = mutable2.adjacency.get(edgeData.source) || [];
    sourceEdges.push(edgeIndex);
    mutable2.adjacency.set(edgeData.source, sourceEdges);
    const targetEdges = mutable2.reverseAdjacency.get(edgeData.target) || [];
    targetEdges.push(edgeIndex);
    mutable2.reverseAdjacency.set(edgeData.target, targetEdges);
  }
  mutable2.isAcyclic = none2();
};
var invalidateCycleFlagOnRemoval = (mutable2) => {
  if (isSome2(mutable2.isAcyclic) && mutable2.isAcyclic.value === false) {
    mutable2.isAcyclic = none2();
  }
};
var invalidateCycleFlagOnAddition = (mutable2) => {
  if (isSome2(mutable2.isAcyclic) && mutable2.isAcyclic.value === true) {
    mutable2.isAcyclic = none2();
  }
};
var addEdge = (mutable2, source, target, data) => {
  if (!mutable2.nodes.has(source)) {
    throw missingNode(source);
  }
  if (!mutable2.nodes.has(target)) {
    throw missingNode(target);
  }
  const edgeIndex = mutable2.nextEdgeIndex;
  const edgeData = new Edge({
    source,
    target,
    data
  });
  mutable2.edges.set(edgeIndex, edgeData);
  const sourceAdjacency = mutable2.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    sourceAdjacency.push(edgeIndex);
  }
  const targetReverseAdjacency = mutable2.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    targetReverseAdjacency.push(edgeIndex);
  }
  if (mutable2.type === "undirected") {
    const targetAdjacency = mutable2.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      targetAdjacency.push(edgeIndex);
    }
    const sourceReverseAdjacency = mutable2.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      sourceReverseAdjacency.push(edgeIndex);
    }
  }
  mutable2.nextEdgeIndex = mutable2.nextEdgeIndex + 1;
  invalidateCycleFlagOnAddition(mutable2);
  return edgeIndex;
};
var removeNode = (mutable2, nodeIndex) => {
  if (!mutable2.nodes.has(nodeIndex)) {
    return;
  }
  const edgesToRemove = [];
  const outgoingEdges = mutable2.adjacency.get(nodeIndex);
  if (outgoingEdges !== void 0) {
    for (const edge of outgoingEdges) {
      edgesToRemove.push(edge);
    }
  }
  const incomingEdges = mutable2.reverseAdjacency.get(nodeIndex);
  if (incomingEdges !== void 0) {
    for (const edge of incomingEdges) {
      edgesToRemove.push(edge);
    }
  }
  for (const edgeIndex of edgesToRemove) {
    removeEdgeInternal(mutable2, edgeIndex);
  }
  mutable2.nodes.delete(nodeIndex);
  mutable2.adjacency.delete(nodeIndex);
  mutable2.reverseAdjacency.delete(nodeIndex);
  invalidateCycleFlagOnRemoval(mutable2);
};
var removeEdgeInternal = (mutable2, edgeIndex) => {
  const edge = mutable2.edges.get(edgeIndex);
  if (edge === void 0) {
    return false;
  }
  const {
    source,
    target
  } = edge;
  const sourceAdjacency = mutable2.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    const index = sourceAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      sourceAdjacency.splice(index, 1);
    }
  }
  const targetReverseAdjacency = mutable2.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    const index = targetReverseAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      targetReverseAdjacency.splice(index, 1);
    }
  }
  if (mutable2.type === "undirected") {
    const targetAdjacency = mutable2.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      const index = targetAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        targetAdjacency.splice(index, 1);
      }
    }
    const sourceReverseAdjacency = mutable2.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      const index = sourceReverseAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        sourceReverseAdjacency.splice(index, 1);
      }
    }
  }
  mutable2.edges.delete(edgeIndex);
  return true;
};
var hasEdge = (graph, source, target) => {
  const adjacencyList = graph.adjacency.get(source);
  if (adjacencyList === void 0) {
    return false;
  }
  for (const edgeIndex of adjacencyList) {
    const edge = graph.edges.get(edgeIndex);
    if (edge !== void 0 && edge.target === target) {
      return true;
    }
  }
  return false;
};
var neighborsDirected = (graph, nodeIndex, direction) => {
  const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
  const adjacencyList = adjacencyMap.get(nodeIndex);
  if (adjacencyList === void 0) {
    return [];
  }
  const result = [];
  for (const edgeIndex of adjacencyList) {
    const edge = graph.edges.get(edgeIndex);
    if (edge !== void 0) {
      const neighborNode = direction === "incoming" ? edge.source : edge.target;
      result.push(neighborNode);
    }
  }
  return result;
};
var escapeMermaidLabel = (label) => {
  return label.replace(/#/g, "#35;").replace(/"/g, "#quot;").replace(/</g, "#lt;").replace(/>/g, "#gt;").replace(/&/g, "#amp;").replace(/\[/g, "#91;").replace(/\]/g, "#93;").replace(/\{/g, "#123;").replace(/\}/g, "#125;").replace(/\(/g, "#40;").replace(/\)/g, "#41;").replace(/\|/g, "#124;").replace(/\\/g, "#92;").replace(/\n/g, "<br/>");
};
var formatMermaidNode = (nodeId, label, shape) => {
  switch (shape) {
    case "rectangle":
      return `${nodeId}["${label}"]`;
    case "rounded":
      return `${nodeId}("${label}")`;
    case "circle":
      return `${nodeId}(("${label}"))`;
    case "diamond":
      return `${nodeId}{"${label}"}`;
    case "hexagon":
      return `${nodeId}{{"${label}"}}`;
    case "stadium":
      return `${nodeId}(["${label}"])`;
    case "subroutine":
      return `${nodeId}[["${label}"]]`;
    case "cylindrical":
      return `${nodeId}[("${label}")]`;
  }
};
var toMermaid = (graph, options3) => {
  const {
    diagramType,
    direction = "TD",
    edgeLabel = (data) => String(data),
    nodeLabel = (data) => String(data),
    nodeShape = () => "rectangle"
  } = options3 ?? {};
  const finalDiagramType = diagramType ?? (graph.type === "directed" ? "flowchart" : "graph");
  const lines3 = [];
  lines3.push(`${finalDiagramType} ${direction}`);
  for (const [nodeIndex, nodeData] of graph.nodes) {
    const nodeId = String(nodeIndex);
    const label = escapeMermaidLabel(nodeLabel(nodeData));
    const shape = nodeShape(nodeData);
    const formattedNode = formatMermaidNode(nodeId, label, shape);
    lines3.push(`  ${formattedNode}`);
  }
  const edgeOperator = finalDiagramType === "flowchart" ? "-->" : "---";
  for (const [, edgeData] of graph.edges) {
    const sourceId = String(edgeData.source);
    const targetId = String(edgeData.target);
    const label = escapeMermaidLabel(edgeLabel(edgeData.data));
    if (label) {
      lines3.push(`  ${sourceId} ${edgeOperator}|"${label}"| ${targetId}`);
    } else {
      lines3.push(`  ${sourceId} ${edgeOperator} ${targetId}`);
    }
  }
  return lines3.join("\n");
};
var Walker = class {
  // @ts-ignore
  [Symbol.iterator];
  /**
   * Visits each element and maps it to a value using the provided function.
   *
   * Takes a function that receives the index and data,
   * and returns an iterable of the mapped values. Skips elements that
   * no longer exist in the graph.
   *
   * @example
   * ```ts
   * import { Graph } from "effect"
   *
   * const graph = Graph.directed<string, number>((mutable) => {
   *   const a = Graph.addNode(mutable, "A")
   *   const b = Graph.addNode(mutable, "B")
   *   Graph.addEdge(mutable, a, b, 1)
   * })
   *
   * const dfs = Graph.dfs(graph, { start: [0] })
   *
   * // Map to just the node data
   * const values = Array.from(dfs.visit((index, data) => data))
   * console.log(values) // ["A", "B"]
   *
   * // Map to custom objects
   * const custom = Array.from(dfs.visit((index, data) => ({ id: index, name: data })))
   * console.log(custom) // [{ id: 0, name: "A" }, { id: 1, name: "B" }]
   * ```
   *
   * @since 3.18.0
   * @category iterators
   */
  visit;
  constructor(visit) {
    this.visit = visit;
    this[Symbol.iterator] = visit((index, data) => [index, data])[Symbol.iterator];
  }
};
var indices = (walker) => walker.visit((index, _) => index);
var values3 = (walker) => walker.visit((_, data) => data);
var entries2 = (walker) => walker.visit((index, data) => [index, data]);
var nodes = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const nodeMap = graph.nodes;
    const iterator = nodeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [nodeIndex, nodeData] = result.value;
        return {
          done: false,
          value: f(nodeIndex, nodeData)
        };
      }
    };
  }
}));
var edges = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const edgeMap = graph.edges;
    const iterator = edgeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [edgeIndex, edgeData] = result.value;
        return {
          done: false,
          value: f(edgeIndex, edgeData)
        };
      }
    };
  }
}));
var externals = (graph, config2 = {}) => {
  const direction = config2.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const nodeMap = graph.nodes;
      const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
      const nodeIterator = nodeMap.entries();
      const nextMapped = () => {
        let current = nodeIterator.next();
        while (!current.done) {
          const [nodeIndex, nodeData] = current.value;
          const adjacencyList = adjacencyMap.get(nodeIndex);
          if (adjacencyList === void 0 || adjacencyList.length === 0) {
            return {
              done: false,
              value: f(nodeIndex, nodeData)
            };
          }
          current = nodeIterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      };
      return {
        next: nextMapped
      };
    }
  }));
};

// src/core/Nano.ts
var NanoTag = class {
  constructor(key) {
    this.key = key;
  }
};
var Tag4 = (identifier2) => new NanoTag(identifier2);
var SingleShotGen3 = class _SingleShotGen {
  called = false;
  self;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var evaluate2 = /* @__PURE__ */ Symbol.for("Nano.evaluate");
var contA = /* @__PURE__ */ Symbol.for("Nano.contA");
var contE = /* @__PURE__ */ Symbol.for("Nano.contE");
var contAll = /* @__PURE__ */ Symbol.for("Nano.contAll");
var NanoYield = /* @__PURE__ */ Symbol.for("Nano.yield");
var args2 = /* @__PURE__ */ Symbol.for("Nano.args");
var NanoDefectException = class {
  constructor(message, lastSpan) {
    this.message = message;
    this.lastSpan = lastSpan;
  }
  _tag = "@effect/language-service/NanoDefectException";
};
var PrimitiveProto = {
  [Symbol.iterator]() {
    return new SingleShotGen3(this);
  }
};
var SucceedProto = {
  ...PrimitiveProto,
  _tag: "Success",
  get value() {
    return this[args2];
  },
  [evaluate2](fiber) {
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](this[args2], fiber) : fiber.yieldWith(this);
  }
};
var succeed17 = (value5) => {
  const nano = Object.create(SucceedProto);
  nano[args2] = value5;
  return nano;
};
var FailureProto = {
  ...PrimitiveProto,
  _tag: "Failure",
  get value() {
    return this[args2];
  },
  [evaluate2](fiber) {
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](this[args2], fiber) : fiber.yieldWith(this);
  }
};
var fail18 = (error4) => {
  const nano = Object.create(FailureProto);
  nano[args2] = error4;
  return nano;
};
var SuspendProto = {
  ...PrimitiveProto,
  [evaluate2]() {
    return this[args2]();
  }
};
var suspend11 = (fn3) => {
  const nano = Object.create(SuspendProto);
  nano[args2] = fn3;
  return nano;
};
var NanoFiber = class {
  _stack = [];
  _yielded = void 0;
  _services = {};
  _cache = {};
  _perf = false;
  _lastSpan = "";
  runLoop(nano) {
    let current = nano;
    while (true) {
      current = current[evaluate2](this);
      if (current === NanoYield) {
        return this._yielded;
      }
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[contAll] && op[contAll](this);
      if (cont) return { [symbol3]: cont };
      if (op[symbol3]) return op;
    }
  }
  yieldWith(value5) {
    this._yielded = value5;
    return NanoYield;
  }
};
var timings = {};
var timingsCount = {};
var WithSpanProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    const [fa, name] = this[args2];
    if (!fiber._perf) return fa;
    const previousSpan = fiber._lastSpan;
    fiber._lastSpan = name;
    const start4 = performance.now();
    timingsCount[name] = (timingsCount[name] || 0) + 1;
    return match17(fa, {
      onSuccess: (_) => {
        const end5 = performance.now();
        timings[name] = (timings[name] || 0) + (end5 - start4);
        fiber._lastSpan = previousSpan;
        return succeed17(_);
      },
      onFailure: (_) => {
        const end5 = performance.now();
        timings[name] = (timings[name] || 0) + (end5 - start4);
        fiber._lastSpan = previousSpan;
        return fail18(_);
      }
    });
  }
};
var withSpan6 = (name) => (fa) => {
  const nano = Object.create(WithSpanProto);
  nano[args2] = [fa, name];
  return nano;
};
var run9 = (nano) => {
  const fiber = new NanoFiber();
  try {
    const result = fiber.runLoop(nano);
    if (result._tag === "Success") {
      return right2(result.value);
    }
    return left2(result.value);
  } catch (e) {
    return left2(new NanoDefectException(e, fiber._lastSpan));
  }
};
var OnSuccessProto2 = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
};
var flatMap18 = dual(2, (fa, f) => {
  const nano = Object.create(OnSuccessProto2);
  nano[args2] = fa;
  nano[contA] = f;
  return nano;
});
var map34 = dual(2, (fa, f) => flatMap18(fa, (_) => succeed17(f(_))));
var SyncProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    const value5 = this[args2]();
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](value5, fiber) : fiber.yieldWith(succeed17(value5));
  }
};
var sync11 = (f) => {
  const nano = Object.create(SyncProto);
  nano[args2] = f;
  return nano;
};
var void_8 = succeed17(void 0);
var FromIteratorProto = {
  ...PrimitiveProto,
  [contA](value5, fiber) {
    const state = this[args2][0].next(value5);
    if (state.done) return succeed17(state.value);
    fiber._stack.push(this);
    return state.value;
  },
  [evaluate2](fiber) {
    return this[contA](this[args2][1], fiber);
  }
};
var unsafeFromIterator = (iterator, initial) => {
  const nano = Object.create(FromIteratorProto);
  nano[args2] = [iterator, initial];
  return nano;
};
var gen3 = (...args3) => suspend11(() => unsafeFromIterator(args3[0]()));
var fn2 = (_) => (body) => (...args3) => withSpan6(_)(suspend11(() => unsafeFromIterator(body(...args3))));
var MatchProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
};
var match17 = (fa, opts) => {
  const nano = Object.create(MatchProto);
  nano[args2] = fa;
  nano[contA] = opts.onSuccess;
  nano[contE] = opts.onFailure;
  return nano;
};
var orElse15 = (f) => (fa) => {
  const nano = Object.create(MatchProto);
  nano[args2] = fa;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail18(_) : f(_);
  return nano;
};
var firstSuccessOf2 = (arr) => arr.slice(1).reduce((arr2, fa) => orElse15(() => fa)(arr2), arr[0]);
var ProvideServiceProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    const prevServices = fiber._services;
    const [fa, tag4, value5] = this[args2];
    fiber._services = {
      ...fiber._services,
      [tag4.key]: value5
    };
    return match17(fa, {
      onSuccess: (_) => {
        fiber._services = prevServices;
        return succeed17(_);
      },
      onFailure: (_) => {
        fiber._services = prevServices;
        return fail18(_);
      }
    });
  }
};
var provideService7 = (tag4, value5) => (fa) => {
  const nano = Object.create(ProvideServiceProto);
  nano[args2] = [fa, tag4, value5];
  return nano;
};
var ServiceProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    const tag4 = this[args2];
    if (tag4.key in fiber._services) {
      const value5 = fiber._services[tag4.key];
      const cont2 = fiber.getCont(contA);
      return cont2 ? cont2[contA](value5, fiber) : fiber.yieldWith(succeed17(value5));
    }
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](tag4, fiber) : fiber.yieldWith(fail18(new NanoDefectException(`Service ${tag4.key} not found`, fiber._lastSpan)));
  }
};
var service2 = (tag4) => {
  const nano = Object.create(ServiceProto);
  nano[args2] = tag4;
  return nano;
};
var CachedProto = {
  ...PrimitiveProto,
  [evaluate2](fiber) {
    const [fa, type2, key] = this[args2];
    const cache = fiber._cache[type2] || /* @__PURE__ */ new WeakMap();
    fiber._cache[type2] = cache;
    const cached3 = cache.get(key);
    if (cached3) return cached3;
    return match17(fa, {
      onSuccess: (_) => {
        cache.set(key, succeed17(_));
        return succeed17(_);
      },
      onFailure: (_) => {
        cache.set(key, fail18(_));
        return fail18(_);
      }
    });
  }
};
function cachedBy(fa, type2, lookupKey) {
  return (...p3) => {
    const nano = Object.create(CachedProto);
    nano[args2] = [fa(...p3), type2, lookupKey(...p3)];
    return nano;
  };
}
var option5 = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args2] = fa;
  nano[contA] = (_) => succeed17(some2(_));
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail18(_) : succeed17(none2());
  return nano;
};
var ignore3 = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args2] = fa;
  nano[contA] = (_) => void_8;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail18(_) : void_8;
  return nano;
};
var all9 = fn2("all")(
  function* (...args3) {
    const results = [];
    for (const fa of args3) {
      const result = yield* fa;
      results.push(result);
    }
    return results;
  }
);

// src/core/TypeScriptApi.ts
var TypeScriptApi = Tag4("TypeScriptApi");
var TypeScriptProgram = Tag4("TypeScriptProgram");
var ChangeTracker = Tag4("ChangeTracker");
function getPackageJsonInfoCache(program) {
  try {
    if (hasProperty(program, "getModuleResolutionCache") && isFunction2(program.getModuleResolutionCache)) {
      const moduleResolutionCache = program.getModuleResolutionCache();
      if (hasProperty(moduleResolutionCache, "getPackageJsonInfoCache") && isFunction2(moduleResolutionCache.getPackageJsonInfoCache)) {
        return moduleResolutionCache.getPackageJsonInfoCache();
      }
    }
  } catch (_) {
    return void 0;
  }
  return void 0;
}
function getDirectoryPath(ts, path2) {
  try {
    if (hasProperty(ts, "getDirectoryPath") && isFunction2(ts.getDirectoryPath)) {
      return ts.getDirectoryPath(path2);
    }
    return path2;
  } catch (_) {
    return path2;
  }
}
function makeGetModuleSpecifier(ts) {
  if (!(hasProperty(ts, "moduleSpecifiers") && hasProperty(ts.moduleSpecifiers, "getModuleSpecifier") && isFunction2(ts.moduleSpecifiers.getModuleSpecifier))) return;
  const _internal = ts.moduleSpecifiers.getModuleSpecifier;
  return (compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options3) => {
    return _internal(
      compilerOptions,
      importingSourceFile,
      importingSourceFileName,
      toFileName,
      host,
      options3
    );
  };
}
function makeGetTemporaryModuleResolutionState(ts) {
  if (hasProperty(ts, "getTemporaryModuleResolutionState") && isFunction2(ts.getTemporaryModuleResolutionState)) {
    const _internal = ts.getTemporaryModuleResolutionState;
    return (cache, program, compilerOptions) => _internal(cache, program, compilerOptions);
  }
  return void 0;
}
function makeGetPackageScopeForPath(ts) {
  if (hasProperty(ts, "getPackageScopeForPath") && isFunction2(ts.getPackageScopeForPath)) {
    const _internal = ts.getPackageScopeForPath;
    return (path2, state) => _internal(path2, state);
  }
}

// src/core/TypeScriptUtils.ts
var TypeScriptUtils = Tag4("TypeScriptUtils");
var nanoLayer = (fa) => pipe(
  service2(TypeScriptApi),
  flatMap18((ts) => pipe(fa, provideService7(TypeScriptUtils, makeTypeScriptUtils(ts))))
);
function makeTypeScriptUtils(ts) {
  const getTemporaryModuleResolutionState = makeGetTemporaryModuleResolutionState(ts);
  const getPackageScopeForPath = makeGetPackageScopeForPath(ts);
  function parsePackageContentNameAndVersionFromScope(v) {
    if (!isObject(v)) return;
    if (!hasProperty(v, "packageJsonScope")) return;
    if (!v.packageJsonScope) return;
    const packageJsonScope = v.packageJsonScope;
    if (!hasProperty(packageJsonScope, "contents")) return;
    if (!hasProperty(packageJsonScope.contents, "packageJsonContent")) return;
    const packageJsonContent = packageJsonScope.contents.packageJsonContent;
    if (!hasProperty(packageJsonContent, "name")) return;
    if (!hasProperty(packageJsonScope, "packageDirectory")) return;
    if (!isString(packageJsonScope.packageDirectory)) return;
    const { name } = packageJsonContent;
    const version = hasProperty(packageJsonScope, "version") ? packageJsonScope.version : "";
    if (!isString(name)) return;
    if (!isString(version)) return;
    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) && hasProperty(packageJsonContent.peerDependencies, "effect");
    const referencedPackages = Object.keys({
      ...hasProperty(packageJsonContent, "dependencies") && isObject(packageJsonContent.dependencies) ? packageJsonContent.dependencies : {},
      ...hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) ? packageJsonContent.peerDependencies : {},
      ...hasProperty(packageJsonContent, "devDependencies") && isObject(packageJsonContent.devDependencies) ? packageJsonContent.devDependencies : {}
    });
    const exportsKeys = Object.keys(
      hasProperty(packageJsonContent, "exports") && isObject(packageJsonContent.exports) ? packageJsonContent.exports : {}
    );
    return {
      name: name.toLowerCase(),
      version: version.toLowerCase(),
      hasEffectInPeerDependencies,
      contents: packageJsonContent,
      packageDirectory: packageJsonScope.packageDirectory,
      referencedPackages,
      exportsKeys
    };
  }
  function resolveModuleWithPackageInfoFromSourceFile(program, sourceFile) {
    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile);
    if (!packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState) {
      const packageJsonInfoCache = getPackageJsonInfoCache(program);
      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(
        packageJsonInfoCache,
        program,
        program.getCompilerOptions()
      );
      const directoryPath = getDirectoryPath(ts, sourceFile.fileName);
      packageJsonScope = parsePackageContentNameAndVersionFromScope({
        ...sourceFile,
        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)
      });
    }
    return packageJsonScope;
  }
  function resolveModulePattern(program, sourceFile, pattern2) {
    if (pattern2.indexOf("*") === -1) return [pattern2.toLowerCase()];
    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    const referencedPackages = [];
    for (const statement of sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {
        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase();
        const packageName = moduleSpecifier.startsWith("@") ? moduleSpecifier.split("/", 2).join("/") : moduleSpecifier.split("/", 1).join("/");
        referencedPackages.push(packageName);
      }
    }
    return pipe(
      referencedPackages.concat(packageJsonScope?.referencedPackages || []),
      dedupe,
      map4((packageName) => packageName.toLowerCase()),
      filter2(
        (packageName) => pattern2.endsWith("*") && packageName.startsWith(pattern2.toLowerCase().substring(0, pattern2.length - 1))
      )
    );
  }
  function findNodeWithLeadingCommentAtPosition(sourceFile, position) {
    const sourceText = sourceFile.text;
    let result;
    function find3(node) {
      const leading = ts.getLeadingCommentRanges(sourceText, node.pos);
      if (leading) {
        for (const commentRange of leading) {
          if (commentRange.pos <= position && position < commentRange.end) {
            result = { node, commentRange };
            return;
          }
        }
      }
      if (node.pos <= position && position < node.end) {
        ts.forEachChild(node, find3);
      }
    }
    find3(sourceFile);
    return result;
  }
  function collectSelfAndAncestorNodesInRange(node, textRange) {
    let result = empty2();
    let parent = node;
    while (parent) {
      if (parent.end >= textRange.end) {
        result = pipe(result, append(parent));
      }
      parent = parent.parent;
    }
    return result;
  }
  function findNodeAtPosition(sourceFile, position) {
    function find3(node) {
      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {
        return ts.forEachChild(node, find3) || node;
      }
      return void 0;
    }
    return find3(sourceFile);
  }
  function findNodeAtPositionIncludingTrivia(sourceFile, position) {
    function find3(node) {
      if (position >= node.pos && position < node.end) {
        return ts.forEachChild(node, find3) || node;
      }
      return void 0;
    }
    return find3(sourceFile);
  }
  function getAncestorNodesInRange(sourceFile, textRange) {
    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos);
    if (!nodeAtPosition) return empty2();
    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange);
  }
  function getCommentAtPosition(sourceFile, pos) {
    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos);
    if (token === void 0 || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || "").length) {
      return;
    }
    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || "").length : token.pos;
    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos);
    return result;
  }
  function isCommentInRange(pos, end5, kind, _nl, at) {
    return at >= pos && at < end5 ? { pos, end: end5, kind } : void 0;
  }
  function toTextRange(positionOrRange) {
    return typeof positionOrRange === "number" ? { end: positionOrRange, pos: positionOrRange } : positionOrRange;
  }
  function isNodeInRange(textRange) {
    return (node) => node.pos <= textRange.pos && node.end >= textRange.end;
  }
  function transformAsyncAwaitToEffectGeneratorBody(body, onAwait) {
    function visitor(_) {
      if (ts.isAwaitExpression(_)) {
        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext);
        return ts.factory.createYieldExpression(
          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
          onAwait(expression)
        );
      }
      return ts.visitEachChild(_, visitor, ts.nullTransformationContext);
    }
    return visitor(body);
  }
  function transformAsyncAwaitToEffectFn(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const fnName = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node ? node.parent.name : void 0;
    let fnCall = ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectModuleName),
      "fn"
    );
    if (fnName) {
      fnCall = ts.factory.createCallExpression(
        fnCall,
        void 0,
        [ts.factory.createStringLiteral(ts.idText(fnName))]
      );
    }
    return tryPreserveDeclarationSemantics(
      node,
      ts.factory.createCallExpression(
        fnCall,
        void 0,
        [
          ts.factory.createFunctionExpression(
            void 0,
            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
            void 0,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.isBlock(generatorBody) ? generatorBody : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])
          )
        ]
      ),
      true
    );
  }
  function transformAsyncAwaitToEffectGen(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody);
    let currentFlags = ts.getCombinedModifierFlags(node);
    currentFlags &= ~ts.ModifierFlags.Async;
    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags);
    if (ts.isArrowFunction(node)) {
      return ts.factory.createArrowFunction(
        newModifiers,
        node.typeParameters,
        node.parameters,
        void 0,
        node.equalsGreaterThanToken,
        effectGenCallExp
      );
    }
    const newBody = ts.factory.createBlock([
      ts.factory.createReturnStatement(effectGenCallExp)
    ]);
    if (ts.isFunctionDeclaration(node)) {
      return ts.factory.createFunctionDeclaration(
        newModifiers,
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        void 0,
        newBody
      );
    }
    return ts.factory.createFunctionExpression(
      newModifiers,
      node.asteriskToken,
      node.name,
      node.typeParameters,
      node.parameters,
      void 0,
      newBody
    );
  }
  function findImportedModuleIdentifier(sourceFile, test) {
    for (const statement of sourceFile.statements) {
      if (!ts.isImportDeclaration(statement)) continue;
      const importClause = statement.importClause;
      if (!importClause) continue;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) continue;
      if (ts.isNamespaceImport(namedBindings)) {
        if (test(namedBindings.name, statement.moduleSpecifier, none2())) {
          return ts.idText(namedBindings.name);
        }
      } else if (ts.isNamedImports(namedBindings)) {
        for (const importSpecifier of namedBindings.elements) {
          const importProperty = fromNullable(importSpecifier.propertyName).pipe(
            orElse(() => some2(importSpecifier.name))
          );
          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {
            return ts.idText(importSpecifier.name);
          }
        }
      }
    }
  }
  function findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, packageName, moduleName) {
    return findImportedModuleIdentifier(
      sourceFile,
      (_, fromModule, importProperty) => {
        if (isNone2(importProperty) && ts.isStringLiteral(fromModule) && fromModule.text === packageName + "/" + moduleName) {
          return true;
        }
        if (isSome2(importProperty) && ts.isIdentifier(importProperty.value) && ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) && fromModule.text === packageName) {
          return true;
        }
        return false;
      }
    );
  }
  function simplifyTypeNode(typeNode) {
    function collectCallable(typeNode2) {
      if (ts.isParenthesizedTypeNode(typeNode2)) return collectCallable(typeNode2.type);
      if (ts.isFunctionTypeNode(typeNode2)) {
        return some2([
          ts.factory.createCallSignature(typeNode2.typeParameters, typeNode2.parameters, typeNode2.type)
        ]);
      }
      if (ts.isTypeLiteralNode(typeNode2)) {
        const allCallSignatures = typeNode2.members.every(ts.isCallSignatureDeclaration);
        if (allCallSignatures) {
          return some2(typeNode2.members);
        }
      }
      if (ts.isIntersectionTypeNode(typeNode2)) {
        const members = typeNode2.types.map((node) => collectCallable(node));
        if (members.every(isSome2)) {
          return some2(members.map((_) => isSome2(_) ? _.value : []).flat());
        }
      }
      return none2();
    }
    const callSignatures = collectCallable(typeNode);
    if (isSome2(callSignatures) && callSignatures.value.length > 1) {
      return ts.factory.createTypeLiteralNode(callSignatures.value);
    }
    return typeNode;
  }
  function tryPreserveDeclarationSemantics(nodeToReplace, node, dropAsync) {
    if (!ts.isExpression(node)) return node;
    if (ts.isFunctionDeclaration(nodeToReplace)) {
      if (!nodeToReplace.name) return node;
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createVariableStatement(
        newModifiers,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            nodeToReplace.name,
            void 0,
            void 0,
            node
          )],
          ts.NodeFlags.Const
        )
      );
    } else if (ts.isMethodDeclaration(nodeToReplace)) {
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createPropertyDeclaration(
        newModifiers,
        nodeToReplace.name,
        void 0,
        void 0,
        node
      );
    }
    return node;
  }
  function parseAccessedExpressionForCompletion(sourceFile, position) {
    const precedingToken = ts.findPrecedingToken(position, sourceFile, void 0, true);
    if (!precedingToken) return;
    let accessedObject = precedingToken;
    let replacementSpan = ts.createTextSpan(position, 0);
    let outerNode = precedingToken;
    if (ts.isIdentifier(precedingToken) && precedingToken.parent && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        spanStart,
        precedingToken.end - spanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken;
      outerNode = precedingToken;
    } else {
      return;
    }
    const importDeclaration = ts.findAncestor(accessedObject, ts.isImportDeclaration);
    if (importDeclaration) return;
    return { accessedObject, outerNode, replacementSpan, insideImportDeclaration: !!importDeclaration };
  }
  function parseDataForExtendsClassCompletion(sourceFile, position) {
    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return;
    const { accessedObject, outerNode, replacementSpan } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return;
    let classDeclaration = outerNode.parent;
    while (ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)) {
      if (!classDeclaration.parent) break;
      classDeclaration = classDeclaration.parent;
    }
    if (!ts.isClassDeclaration(classDeclaration)) return;
    if (!classDeclaration.name) return;
    return {
      accessedObject,
      classDeclaration,
      className: classDeclaration.name,
      replacementSpan
    };
  }
  function createEffectGenCallExpression(effectModuleIdentifierName, node) {
    const generator = ts.factory.createFunctionExpression(
      void 0,
      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
      void 0,
      [],
      [],
      void 0,
      node
      // NOTE(mattia): intended, to use same routine for both ConciseBody and Body
    );
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifierName),
        "gen"
      ),
      void 0,
      [generator]
    );
  }
  function createEffectGenCallExpressionWithBlock(effectModuleIdentifierName, statement) {
    return createEffectGenCallExpression(
      effectModuleIdentifierName,
      ts.factory.createBlock(isArray(statement) ? statement : [statement], false)
    );
  }
  function createReturnYieldStarStatement(expr) {
    return ts.factory.createReturnStatement(
      ts.factory.createYieldExpression(
        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
        expr
      )
    );
  }
  function createDataTaggedErrorDeclaration(dataModuleIdentifier, name, fields) {
    const invokeTaggedError = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(dataModuleIdentifier),
        "TaggedError"
      ),
      void 0,
      [
        ts.factory.createStringLiteral(name)
      ]
    );
    const withTypeFields = ts.factory.createExpressionWithTypeArguments(
      invokeTaggedError,
      [
        ts.factory.createTypeLiteralNode(fields)
      ]
    );
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      void 0,
      [
        ts.factory.createHeritageClause(
          ts.SyntaxKind.ExtendsKeyword,
          [
            withTypeFields
          ]
        )
      ],
      []
    );
  }
  function getSourceFileOfNode(current) {
    let node = current;
    while (node && node.kind !== ts.SyntaxKind.SourceFile) {
      node = node.parent;
    }
    return node;
  }
  function isOuterExpression(node, kinds = ts.OuterExpressionKinds.All) {
    switch (node.kind) {
      case ts.SyntaxKind.ParenthesizedExpression:
        return (kinds & ts.OuterExpressionKinds.Parentheses) !== 0;
      case ts.SyntaxKind.TypeAssertionExpression:
      case ts.SyntaxKind.AsExpression:
        return (kinds & ts.OuterExpressionKinds.TypeAssertions) !== 0;
      case ts.SyntaxKind.SatisfiesExpression:
        return (kinds & (ts.OuterExpressionKinds.TypeAssertions | ts.OuterExpressionKinds.Satisfies)) !== 0;
      case ts.SyntaxKind.ExpressionWithTypeArguments:
        return (kinds & ts.OuterExpressionKinds.ExpressionsWithTypeArguments) !== 0;
      case ts.SyntaxKind.NonNullExpression:
        return (kinds & ts.OuterExpressionKinds.NonNullAssertions) !== 0;
      case ts.SyntaxKind.PartiallyEmittedExpression:
        return (kinds & ts.OuterExpressionKinds.PartiallyEmittedExpressions) !== 0;
    }
    return false;
  }
  function skipOuterExpressions(node, kinds = ts.OuterExpressionKinds.All) {
    while (isOuterExpression(node, kinds)) {
      node = node.expression;
    }
    return node;
  }
  function isDeclarationKind(kind) {
    return kind === ts.SyntaxKind.ArrowFunction || kind === ts.SyntaxKind.BindingElement || kind === ts.SyntaxKind.ClassDeclaration || kind === ts.SyntaxKind.ClassExpression || kind === ts.SyntaxKind.ClassStaticBlockDeclaration || kind === ts.SyntaxKind.Constructor || kind === ts.SyntaxKind.EnumDeclaration || kind === ts.SyntaxKind.EnumMember || kind === ts.SyntaxKind.ExportSpecifier || kind === ts.SyntaxKind.FunctionDeclaration || kind === ts.SyntaxKind.FunctionExpression || kind === ts.SyntaxKind.GetAccessor || kind === ts.SyntaxKind.ImportClause || kind === ts.SyntaxKind.ImportEqualsDeclaration || kind === ts.SyntaxKind.ImportSpecifier || kind === ts.SyntaxKind.InterfaceDeclaration || kind === ts.SyntaxKind.JsxAttribute || kind === ts.SyntaxKind.MethodDeclaration || kind === ts.SyntaxKind.MethodSignature || kind === ts.SyntaxKind.ModuleDeclaration || kind === ts.SyntaxKind.NamespaceExportDeclaration || kind === ts.SyntaxKind.NamespaceImport || kind === ts.SyntaxKind.NamespaceExport || kind === ts.SyntaxKind.Parameter || kind === ts.SyntaxKind.PropertyAssignment || kind === ts.SyntaxKind.PropertyDeclaration || kind === ts.SyntaxKind.PropertySignature || kind === ts.SyntaxKind.SetAccessor || kind === ts.SyntaxKind.ShorthandPropertyAssignment || kind === ts.SyntaxKind.TypeAliasDeclaration || kind === ts.SyntaxKind.TypeParameter || kind === ts.SyntaxKind.VariableDeclaration || kind === ts.SyntaxKind.JSDocTypedefTag || kind === ts.SyntaxKind.JSDocCallbackTag || kind === ts.SyntaxKind.JSDocPropertyTag || kind === ts.SyntaxKind.NamedTupleMember;
  }
  function isVoidExpression(node) {
    const unwrapped = ts.isExpression(node) ? skipOuterExpressions(node) : node;
    if (ts.isVoidExpression(unwrapped) && ts.isNumericLiteral(unwrapped.expression) && unwrapped.expression.text === "0") {
      return true;
    }
    if (ts.isIdentifier(unwrapped) && ts.idText(unwrapped) === "undefined") {
      return true;
    }
    return false;
  }
  return {
    findNodeAtPositionIncludingTrivia,
    parsePackageContentNameAndVersionFromScope,
    resolveModulePattern,
    resolveModuleWithPackageInfoFromSourceFile,
    findNodeWithLeadingCommentAtPosition,
    getCommentAtPosition,
    getAncestorNodesInRange,
    toTextRange,
    isNodeInRange,
    transformAsyncAwaitToEffectFn,
    transformAsyncAwaitToEffectGen,
    createDataTaggedErrorDeclaration,
    findImportedModuleIdentifierByPackageAndNameOrBarrel,
    simplifyTypeNode,
    tryPreserveDeclarationSemantics,
    parseDataForExtendsClassCompletion,
    createEffectGenCallExpressionWithBlock,
    createReturnYieldStarStatement,
    parseAccessedExpressionForCompletion,
    getSourceFileOfNode,
    isOuterExpression,
    skipOuterExpressions,
    isDeclarationKind,
    isVoidExpression
  };
}

// src/cli/utils.ts
var PackageJsonSchema = Struct({
  name: String$,
  version: String$,
  scripts: optional(Record({
    key: String$,
    value: String$
  }))
});
var UnableToFindPackageJsonError = class extends TaggedError("UnableToFindPackageError") {
  get message() {
    return `Unable to find and read typescript package.json at ${this.packageJsonPath}`;
  }
};
var MalformedPackageJsonError = class extends TaggedError("MalformedPackageJsonError") {
  get message() {
    return `Malformed typescript package.json at ${this.packageJsonPath}`;
  }
};
var CorruptedPatchedSourceFileError = class extends TaggedError("CorruptedPatchedSourceFileError") {
  get message() {
    return `Patched source file ${this.filePath} has corrupted patches`;
  }
};
var UnableToFindInstalledTypeScriptPackage = class extends TaggedError("UnableToFindInstalledTypeScriptPackage") {
  get message() {
    return `Unable to find an installed typescript package`;
  }
};
var TypeScriptContext = class _TypeScriptContext extends Tag2("TypeScriptContext")() {
  static live = (cwd) => effect(
    _TypeScriptContext,
    try_3({
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      try: () => require(require.resolve("typescript", { paths: [cwd] })),
      catch: (cause2) => new UnableToFindInstalledTypeScriptPackage({ cause: cause2 })
    }).pipe(
      orElse4(
        () => try_3({
          // eslint-disable-next-line @typescript-eslint/no-require-imports
          try: () => require("typescript"),
          catch: (cause2) => new UnableToFindInstalledTypeScriptPackage({ cause: cause2 })
        })
      )
    )
  );
};
var getPackageJsonData = fn("getPackageJsonData")(function* (packageDir) {
  const path2 = yield* Path2;
  const fs = yield* FileSystem;
  const packageJsonPath = path2.resolve(packageDir, "package.json");
  const packageJsonContent = yield* fs.readFileString(packageJsonPath).pipe(
    mapError2((cause2) => new UnableToFindPackageJsonError({ packageJsonPath, cause: cause2 }))
  );
  const packageJsonData = yield* decode3(parseJson(PackageJsonSchema))(packageJsonContent).pipe(
    mapError2((cause2) => new MalformedPackageJsonError({ packageJsonPath, cause: cause2 }))
  );
  return { ...packageJsonData };
});
var getModuleFilePath = fn("getModuleFilePath")(
  function* (dirPath4, moduleName) {
    const path2 = yield* Path2;
    const filePath = path2.resolve(dirPath4, "lib", moduleName === "tsc" ? "_tsc.js" : "typescript.js");
    return filePath;
  }
);
var getTypeScriptApisUtils = fn("getTypeScriptApisFile")(
  function* (dirPath4) {
    const filePath = yield* getModuleFilePath(dirPath4, "typescript");
    const sourceText = yield* getSourceFileText(filePath);
    const sourceFile = yield* getUnpatchedSourceFile(filePath, sourceText);
    const bodyWithoutBundlerComment = yield* omitBundlerSourceFileComment(
      sourceFile.text.split("\n").map((line4) => `    ${line4}`).join("\n")
    );
    const patchWithWrappingFunction = `
var _effectLspTypeScriptApis = undefined;
function effectLspTypeScriptApis(){
  if(!_effectLspTypeScriptApis){
    _effectLspTypeScriptApis = (function(module){
${bodyWithoutBundlerComment}
return ts
})(effectLspTypeScriptApis);
  }
  return _effectLspTypeScriptApis;
}`;
    return patchWithWrappingFunction;
  }
);
var getEffectLspPatchUtils = fn("getEffectLspPatchUtils")(function* () {
  const path2 = yield* Path2;
  const fs = yield* FileSystem;
  const effectLspPatchUtilsPath = path2.resolve(__dirname, "effect-lsp-patch-utils.js");
  const effectLspPatchUtilsContent = yield* fs.readFileString(effectLspPatchUtilsPath);
  const bodyWithoutBundlerComment = yield* omitBundlerSourceFileComment(
    effectLspPatchUtilsContent.split("\n").map((line4) => `    ${line4}`).join("\n")
  );
  const patchWithWrappingFunction = `
var _effectLspPatchUtils = undefined;
function effectLspPatchUtils(){
  if(!_effectLspPatchUtils){
    _effectLspPatchUtils = (function(module){
${bodyWithoutBundlerComment}
return module
})({});
  }
  return _effectLspPatchUtils.exports;
}`;
  return patchWithWrappingFunction;
});
var AppliedPatchMetadata = compose3(
  StringFromBase64,
  parseJson(Struct({
    version: String$,
    replacedText: String$,
    insertedPrefixLength: Int,
    insertedTextLength: Int
  }))
);
var makeEffectLspPatchChange = fn("makeEffectLspPatchChange")(
  function* (sourceText, pos, end5, insertedText, insertedPrefix, version) {
    const replacedText = sourceText.slice(pos, end5);
    const metadata = {
      version,
      replacedText,
      insertedPrefixLength: insertedPrefix.length,
      insertedTextLength: insertedText.length
    };
    const encodedMetadata = yield* encode2(AppliedPatchMetadata)(metadata);
    const textChange = {
      span: { start: pos, length: end5 - pos },
      newText: insertedPrefix + "/* @effect-lsp-patch " + encodedMetadata + " */ " + insertedText
    };
    return textChange;
  }
);
var extractAppliedEffectLspPatches = fn("extractAppliedEffectLspPatches")(
  function* (sourceFile) {
    const ts = yield* TypeScriptContext;
    const tsUtils = makeTypeScriptUtils(ts);
    const regex = /@effect-lsp-patch(?:\s+)([a-zA-Z0-9+=/]+)/gm;
    let match18;
    const patches = [];
    const revertChanges = [];
    while ((match18 = regex.exec(sourceFile.text)) !== null) {
      const commentTextMetadata = match18[1];
      const commentRange = tsUtils.getCommentAtPosition(sourceFile, match18.index);
      if (!commentRange) continue;
      const metadata = yield* decode3(AppliedPatchMetadata)(commentTextMetadata).pipe(
        mapError2((cause2) => new CorruptedPatchedSourceFileError({ filePath: sourceFile.fileName, cause: cause2 }))
      );
      patches.push(metadata);
      revertChanges.push({
        span: {
          start: commentRange.pos - metadata.insertedPrefixLength,
          length: metadata.insertedPrefixLength + metadata.insertedTextLength + 1 + commentRange.end - commentRange.pos
        },
        newText: metadata.replacedText
      });
    }
    return { patches, revertChanges };
  }
);
var applyTextChanges = fn("applyTextChanges")(
  function* (sourceText, patches) {
    const changes2 = patches.map((patch10) => ({
      newText: patch10.newText,
      span: { start: patch10.span.start, length: patch10.span.length }
    }));
    changes2.sort((a, b) => a.span.start - b.span.start);
    let newSourceText = sourceText;
    for (let i = 0; i < changes2.length; i++) {
      const change = changes2[i];
      newSourceText = newSourceText.slice(0, change.span.start) + change.newText + newSourceText.slice(change.span.start + change.span.length);
      const changeDelta = change.newText.length - change.span.length;
      for (let j = i + 1; j < changes2.length; j++) {
        if (changes2[j].span.start >= change.span.start) {
          changes2[j].span.start += changeDelta;
        }
      }
    }
    return newSourceText;
  }
);
var getSourceFileText = fn("getSourceFileText")(function* (filePath) {
  const fs = yield* FileSystem;
  return yield* fs.readFileString(filePath);
});
var getUnpatchedSourceFile = fn("getUnpatchedSourceFile")(
  function* (filePath, sourceText) {
    const ts = yield* TypeScriptContext;
    const sourceFile = ts.createSourceFile(
      filePath,
      sourceText,
      ts.ScriptTarget.ES2022,
      true
    );
    const { revertChanges } = yield* extractAppliedEffectLspPatches(sourceFile);
    if (revertChanges.length === 0) return sourceFile;
    const newSourceText = yield* applyTextChanges(sourceText, revertChanges);
    const newSourceFile = ts.createSourceFile(
      filePath,
      newSourceText,
      ts.ScriptTarget.ES2022,
      true
    );
    return newSourceFile;
  }
);
var omitBundlerSourceFileComment = fn("omitBundlerSourceFileComment")(
  function* (originalSourceText) {
    const ts = yield* TypeScriptContext;
    const deleteChanges = [];
    const sourceFile = ts.createSourceFile(
      "file.ts",
      originalSourceText,
      ts.ScriptTarget.ES2022,
      true
    );
    const lineStarts = sourceFile.getLineStarts();
    const regex = /^\s*\/\/\s*src\//gmid;
    for (let i = 0; i < lineStarts.length; i++) {
      const pos = lineStarts[i];
      const end5 = i >= lineStarts.length ? sourceFile.text.length : lineStarts[i + 1];
      if (sourceFile.text.substring(pos, end5).match(regex)) {
        deleteChanges.push({
          span: { start: pos, length: end5 - 1 - pos },
          newText: ""
        });
      }
    }
    return yield* applyTextChanges(sourceFile.text, deleteChanges);
  }
);
var extractEffectLspOptions = (compilerOptions) => {
  return (hasProperty(compilerOptions, "plugins") && Array.isArray(compilerOptions.plugins) ? compilerOptions.plugins : []).find((_) => hasProperty(_, "name") && _.name === "@effect/language-service");
};
var getFileNamesInTsConfig = fn("getFileNamesInTsConfig")(function* (tsconfigPath) {
  const path2 = yield* Path2;
  const tsInstance = yield* TypeScriptContext;
  const filesToCheck = /* @__PURE__ */ new Set();
  let tsconfigToHandle = [tsconfigPath];
  while (tsconfigToHandle.length > 0) {
    const tsconfigPath2 = tsconfigToHandle.shift();
    const tsconfigAbsolutePath = path2.resolve(tsconfigPath2);
    const configFile = tsInstance.readConfigFile(tsconfigAbsolutePath, tsInstance.sys.readFile);
    if (configFile.error) {
      if (!tsconfigAbsolutePath.endsWith("tsconfig.json")) {
        tsconfigToHandle = [...tsconfigToHandle, path2.resolve(tsconfigPath2, "tsconfig.json")];
      }
      continue;
    }
    const parsedConfig = tsInstance.parseJsonConfigFileContent(
      configFile.config,
      tsInstance.sys,
      path2.dirname(tsconfigAbsolutePath)
    );
    tsconfigToHandle = [...tsconfigToHandle, ...parsedConfig.projectReferences?.map((_) => _.path) ?? []];
    parsedConfig.fileNames.forEach((_) => filesToCheck.add(_));
  }
  return filesToCheck;
});

// src/cli/check.ts
var LOCAL_TYPESCRIPT_DIR = "./node_modules/typescript";
var dirPath = directory2("dir").pipe(
  withDefault3(LOCAL_TYPESCRIPT_DIR),
  withDescription3("The directory of the typescript package to patch.")
);
var check2 = make58(
  "check",
  { dirPath },
  fn("check")(function* ({ dirPath: dirPath4 }) {
    const fs = yield* FileSystem;
    const ts = yield* TypeScriptContext;
    const { version: effectLspVersion } = yield* getPackageJsonData(__dirname);
    yield* logDebug2(`Found @effect/language-service version ${effectLspVersion}!`);
    yield* logDebug2(`Searching for typescript in ${dirPath4}...`);
    const { version: typescriptVersion } = yield* getPackageJsonData(dirPath4);
    yield* logDebug2(`Found typescript version ${typescriptVersion}!`);
    for (const moduleName of ["typescript", "tsc"]) {
      yield* logDebug2(`Searching ${moduleName}...`);
      const filePath = yield* getModuleFilePath(dirPath4, moduleName);
      yield* logDebug2(`Reading ${moduleName} from ${filePath}...`);
      const sourceText = yield* fs.readFileString(filePath);
      const sourceFile = ts.createSourceFile(filePath, sourceText, ts.ScriptTarget.ES2022, true);
      yield* logDebug2(`Collecting patches for ${moduleName}...`);
      const { patches } = yield* extractAppliedEffectLspPatches(sourceFile);
      const patchesVersion = pipe(patches, map4((patch10) => patch10.version), dedupe);
      if (patchesVersion.length === 0) {
        yield* logInfo2(`${filePath} is not patched.`);
      } else {
        yield* logInfo2(`${filePath} patched with version ${patchesVersion.join(", ")}`);
      }
    }
  })
).pipe(
  withDescription6("Check if the typescript package is patched with the effect-language-service.")
);

// src/cli/codegen.ts
var import_project_service = __toESM(require_dist2());

// src/core/LanguageServicePluginOptions.ts
var LanguageServicePluginOptions = Tag4("PluginOptions");
function isValidSeverityLevel(value5) {
  return value5 === "off" || value5 === "error" || value5 === "warning" || value5 === "message" || value5 === "suggestion";
}
function parseDiagnosticSeverity(config2) {
  if (!isRecord(config2)) return {};
  return Object.fromEntries(
    pipe(
      Object.entries(config2),
      filter2(([key, value5]) => isString(key) && isString(value5)),
      map4(([key, value5]) => [String(key).toLowerCase(), String(value5).toLowerCase()]),
      filter2(([_, value5]) => isValidSeverityLevel(value5))
    )
  );
}
var defaults = {
  refactors: true,
  diagnostics: true,
  diagnosticSeverity: {},
  diagnosticsName: true,
  missingDiagnosticNextLine: "warning",
  includeSuggestionsInTsc: true,
  quickinfo: true,
  quickinfoEffectParameters: "whentruncated",
  quickinfoMaximumLength: -1,
  completions: true,
  goto: true,
  inlays: true,
  allowedDuplicatedPackages: [],
  namespaceImportPackages: [],
  topLevelNamedReexports: "ignore",
  barrelImportPackages: [],
  importAliases: {},
  renames: true,
  noExternal: false,
  keyPatterns: [{
    target: "service",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }, {
    target: "custom",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }],
  extendedKeyDetection: false,
  ignoreEffectWarningsInTscExitCode: false,
  ignoreEffectSuggestionsInTscExitCode: true,
  pipeableMinArgCount: 2,
  effectFn: ["span"],
  layerGraphFollowDepth: 0,
  mermaidProvider: "mermaid.live"
};
function parseKeyPatterns(patterns) {
  const result = [];
  for (const entry of patterns) {
    if (!isObject(entry)) continue;
    result.push({
      target: hasProperty(entry, "target") && isString(entry.target) && ["service", "error", "custom"].includes(entry.target.toLowerCase()) ? entry.target.toLowerCase() : "service",
      pattern: hasProperty(entry, "pattern") && isString(entry.pattern) && ["package-identifier", "default", "default-hashed"].includes(entry.pattern.toLowerCase()) ? entry.pattern.toLowerCase() : "default",
      skipLeadingPath: hasProperty(entry, "skipLeadingPath") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString) ? entry.skipLeadingPath : ["src/"]
    });
  }
  return result;
}
function parse4(config2) {
  return {
    refactors: isObject(config2) && hasProperty(config2, "refactors") && isBoolean(config2.refactors) ? config2.refactors : defaults.refactors,
    diagnostics: isObject(config2) && hasProperty(config2, "diagnostics") && isBoolean(config2.diagnostics) ? config2.diagnostics : defaults.diagnostics,
    diagnosticSeverity: isObject(config2) && hasProperty(config2, "diagnosticSeverity") && isRecord(config2.diagnosticSeverity) ? parseDiagnosticSeverity(config2.diagnosticSeverity) : defaults.diagnosticSeverity,
    diagnosticsName: isObject(config2) && hasProperty(config2, "diagnosticsName") && isBoolean(config2.diagnosticsName) ? config2.diagnosticsName : defaults.diagnosticsName,
    missingDiagnosticNextLine: isObject(config2) && hasProperty(config2, "missingDiagnosticNextLine") && isString(config2.missingDiagnosticNextLine) && isValidSeverityLevel(config2.missingDiagnosticNextLine) ? config2.missingDiagnosticNextLine : defaults.missingDiagnosticNextLine,
    includeSuggestionsInTsc: isObject(config2) && hasProperty(config2, "includeSuggestionsInTsc") && isBoolean(config2.includeSuggestionsInTsc) ? config2.includeSuggestionsInTsc : defaults.includeSuggestionsInTsc,
    ignoreEffectWarningsInTscExitCode: isObject(config2) && hasProperty(config2, "ignoreEffectWarningsInTscExitCode") && isBoolean(config2.ignoreEffectWarningsInTscExitCode) ? config2.ignoreEffectWarningsInTscExitCode : defaults.ignoreEffectWarningsInTscExitCode,
    ignoreEffectSuggestionsInTscExitCode: isObject(config2) && hasProperty(config2, "ignoreEffectSuggestionsInTscExitCode") && isBoolean(config2.ignoreEffectSuggestionsInTscExitCode) ? config2.ignoreEffectSuggestionsInTscExitCode : defaults.ignoreEffectSuggestionsInTscExitCode,
    quickinfo: isObject(config2) && hasProperty(config2, "quickinfo") && isBoolean(config2.quickinfo) ? config2.quickinfo : defaults.quickinfo,
    quickinfoEffectParameters: isObject(config2) && hasProperty(config2, "quickinfoEffectParameters") && isString(config2.quickinfoEffectParameters) && ["always", "never", "whentruncated"].includes(config2.quickinfoEffectParameters.toLowerCase()) ? config2.quickinfoEffectParameters.toLowerCase() : defaults.quickinfoEffectParameters,
    quickinfoMaximumLength: isObject(config2) && hasProperty(config2, "quickinfoMaximumLength") && isNumber(config2.quickinfoMaximumLength) ? config2.quickinfoMaximumLength : defaults.quickinfoMaximumLength,
    completions: isObject(config2) && hasProperty(config2, "completions") && isBoolean(config2.completions) ? config2.completions : defaults.completions,
    goto: isObject(config2) && hasProperty(config2, "goto") && isBoolean(config2.goto) ? config2.goto : defaults.goto,
    inlays: isObject(config2) && hasProperty(config2, "inlays") && isBoolean(config2.inlays) ? config2.inlays : defaults.inlays,
    allowedDuplicatedPackages: isObject(config2) && hasProperty(config2, "allowedDuplicatedPackages") && isArray(config2.allowedDuplicatedPackages) && config2.allowedDuplicatedPackages.every(isString) ? config2.allowedDuplicatedPackages.map((_) => _.toLowerCase()) : defaults.allowedDuplicatedPackages,
    namespaceImportPackages: isObject(config2) && hasProperty(config2, "namespaceImportPackages") && isArray(config2.namespaceImportPackages) && config2.namespaceImportPackages.every(isString) ? config2.namespaceImportPackages.map((_) => _.toLowerCase()) : defaults.namespaceImportPackages,
    barrelImportPackages: isObject(config2) && hasProperty(config2, "barrelImportPackages") && isArray(config2.barrelImportPackages) && config2.barrelImportPackages.every(isString) ? config2.barrelImportPackages.map((_) => _.toLowerCase()) : defaults.barrelImportPackages,
    importAliases: isObject(config2) && hasProperty(config2, "importAliases") && isRecord(config2.importAliases) ? map3(config2.importAliases, (value5) => String(value5)) : defaults.importAliases,
    topLevelNamedReexports: isObject(config2) && hasProperty(config2, "topLevelNamedReexports") && isString(config2.topLevelNamedReexports) && ["ignore", "follow"].includes(config2.topLevelNamedReexports.toLowerCase()) ? config2.topLevelNamedReexports.toLowerCase() : defaults.topLevelNamedReexports,
    renames: isObject(config2) && hasProperty(config2, "renames") && isBoolean(config2.renames) ? config2.renames : defaults.renames,
    noExternal: isObject(config2) && hasProperty(config2, "noExternal") && isBoolean(config2.noExternal) ? config2.noExternal : defaults.noExternal,
    keyPatterns: isObject(config2) && hasProperty(config2, "keyPatterns") && isArray(config2.keyPatterns) ? parseKeyPatterns(config2.keyPatterns) : defaults.keyPatterns,
    extendedKeyDetection: isObject(config2) && hasProperty(config2, "extendedKeyDetection") && isBoolean(config2.extendedKeyDetection) ? config2.extendedKeyDetection : defaults.extendedKeyDetection,
    pipeableMinArgCount: isObject(config2) && hasProperty(config2, "pipeableMinArgCount") && isNumber(config2.pipeableMinArgCount) ? config2.pipeableMinArgCount : defaults.pipeableMinArgCount,
    effectFn: isObject(config2) && hasProperty(config2, "effectFn") && isArray(config2.effectFn) && config2.effectFn.every(isString) ? config2.effectFn.map((_) => _.toLowerCase()) : defaults.effectFn,
    layerGraphFollowDepth: isObject(config2) && hasProperty(config2, "layerGraphFollowDepth") && isNumber(config2.layerGraphFollowDepth) ? config2.layerGraphFollowDepth : defaults.layerGraphFollowDepth,
    mermaidProvider: isObject(config2) && hasProperty(config2, "mermaidProvider") && isString(config2.mermaidProvider) ? config2.mermaidProvider : defaults.mermaidProvider
  };
}

// src/core/LSP.ts
var RefactorNotApplicableError = class {
  _tag = "@effect/language-service/RefactorNotApplicableError";
};
function createRefactor(definition) {
  return definition;
}
function createDiagnostic(definition) {
  return definition;
}
var getSemanticDiagnosticsWithCodeFixes = fn2(
  "LSP.getSemanticDiagnosticsWithCodeFixes"
)(function* (rules, sourceFile) {
  let effectDiagnostics = [];
  let effectCodeFixes = [];
  const executor = yield* createDiagnosticExecutor(sourceFile);
  for (const rule of rules) {
    const { codeFixes, diagnostics: diagnostics3 } = yield* executor.execute(rule);
    effectDiagnostics = effectDiagnostics.concat(diagnostics3);
    effectCodeFixes = effectCodeFixes.concat(codeFixes);
  }
  return {
    diagnostics: effectDiagnostics,
    codeFixes: effectCodeFixes
  };
});
function refactorNameToFullyQualifiedName(name) {
  return `@effect/language-service/refactors/${name}`;
}
var getApplicableRefactors = fn2("LSP.getApplicableRefactors")(function* (refactors, sourceFile, positionOrRange) {
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  const effectRefactors = [];
  for (const refactor of refactors) {
    yield* pipe(
      refactor.apply(sourceFile, textRange),
      map34(
        (result) => effectRefactors.push({
          name: refactorNameToFullyQualifiedName(refactor.name),
          description: refactor.description,
          actions: [{
            name: refactorNameToFullyQualifiedName(refactor.name),
            description: result.description,
            kind: result.kind
          }]
        })
      ),
      ignore3
    );
  }
  return effectRefactors;
});
var getEditsForRefactor = fn2("LSP.getEditsForRefactor")(function* (refactors, sourceFile, positionOrRange, refactorName) {
  const refactor = refactors.find((refactor2) => refactorNameToFullyQualifiedName(refactor2.name) === refactorName);
  if (!refactor) {
    return yield* fail18(new RefactorNotApplicableError());
  }
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  return yield* refactor.apply(sourceFile, textRange);
});
var getCompletionsAtPosition = fn2("LSP.getCompletionsAtPosition")(function* (completions, sourceFile, position, options3, formatCodeSettings) {
  let effectCompletions = [];
  for (const completion of completions) {
    const result = yield* completion.apply(sourceFile, position, options3, formatCodeSettings);
    effectCompletions = effectCompletions.concat(
      result.map((_) => ({ sortText: "11", ..._ }))
    );
  }
  return effectCompletions;
});
var createDiagnosticExecutor = fn2("LSP.createCommentDirectivesProcessor")(
  function* (sourceFile) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const pluginOptions = yield* service2(LanguageServicePluginOptions);
    function findParentStatementForDisableNextLine(node) {
      let result;
      function find3(node2) {
        if (ts.isStatement(node2)) {
          result = node2;
          return;
        }
        if (ts.isPropertyAssignment(node2)) {
          const realStart = ts.getTokenPosOfNode(node2, sourceFile);
          const starts = sourceFile.getLineStarts().filter((start4) => start4 >= node2.pos && start4 <= realStart);
          if (starts.length > 0) {
            result = node2;
            return;
          }
        }
        if (result) return;
        if (node2.parent) find3(node2.parent);
      }
      find3(node);
      return result || node;
    }
    const lineOverrides = {};
    const sectionOverrides = {};
    const skippedRules = [];
    const regex = /@effect-diagnostics(-next-line)?((?:\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm;
    let match18;
    while ((match18 = regex.exec(sourceFile.text)) !== null) {
      const nextLineCaptureGroup = match18[1];
      const rulesCaptureGroup = match18[2];
      if (rulesCaptureGroup) {
        const trimmedRuleString = rulesCaptureGroup.trim();
        if (trimmedRuleString) {
          const individualRules = trimmedRuleString.split(/\s+/);
          for (const rulePair of individualRules) {
            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(":");
            const ruleName = rawRuleName.startsWith("effect/") ? rawRuleName.substring("effect/".length) : rawRuleName;
            if (ruleName && ruleLevel) {
              if (ruleLevel === "skip-file") skippedRules.push(ruleName);
              const isOverrideNextLine = nextLineCaptureGroup && nextLineCaptureGroup.trim().toLowerCase() === "-next-line";
              if (isOverrideNextLine) {
                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match18.index);
                if (foundNode) {
                  lineOverrides[ruleName] = lineOverrides[ruleName] || [];
                  lineOverrides[ruleName].unshift({
                    pos: foundNode.node.pos,
                    end: foundNode.node.end,
                    level: ruleLevel,
                    commentRange: foundNode.commentRange
                  });
                }
              } else {
                sectionOverrides[ruleName] = sectionOverrides[ruleName] || [];
                sectionOverrides[ruleName].unshift({
                  pos: match18.index,
                  level: ruleLevel
                });
              }
            }
          }
        }
      }
    }
    const levelToDiagnosticCategory = {
      error: ts.DiagnosticCategory.Error,
      warning: ts.DiagnosticCategory.Warning,
      message: ts.DiagnosticCategory.Message,
      suggestion: ts.DiagnosticCategory.Suggestion
    };
    const execute2 = (rule) => gen3(function* () {
      const diagnostics3 = [];
      const codeFixes = [];
      const ruleNameLowered = rule.name.toLowerCase();
      const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity;
      if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics: diagnostics3, codeFixes };
      if (defaultLevel === "off" && (lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0) {
        return { diagnostics: diagnostics3, codeFixes };
      }
      const fixByDisableNextLine = (node) => ({
        fixName: rule.name + "_skipNextLine",
        description: "Disable " + rule.name + " for this line",
        apply: flatMap18(
          service2(ChangeTracker),
          (changeTracker) => gen3(function* () {
            const disableAtNode = findParentStatementForDisableNextLine(node);
            const start4 = ts.getTokenPosOfNode(disableAtNode, sourceFile);
            const { line: line4 } = ts.getLineAndCharacterOfPosition(sourceFile, start4);
            changeTracker.insertCommentBeforeLine(
              sourceFile,
              line4,
              start4,
              ` @effect-diagnostics-next-line ${rule.name}:off`
            );
          })
        )
      });
      const fixByDisableEntireFile = {
        fixName: rule.name + "_skipFile",
        description: "Disable " + rule.name + " for this entire file",
        apply: flatMap18(
          service2(ChangeTracker),
          (changeTracker) => sync11(
            () => changeTracker.insertText(
              sourceFile,
              0,
              `/** @effect-diagnostics ${rule.name}:skip-file */
`
            )
          )
        )
      };
      const applicableDiagnostics = [];
      yield* rule.apply(sourceFile, (entry) => {
        const range3 = "kind" in entry.location ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end } : entry.location;
        const node = "kind" in entry.location ? entry.location : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos);
        applicableDiagnostics.push({
          range: range3,
          messageText: pluginOptions.diagnosticsName ? `${entry.messageText}    effect(${rule.name})` : entry.messageText,
          fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])
        });
      });
      const unusedLineOverrides = new Set(lineOverrides[ruleNameLowered] || []);
      for (const emitted of applicableDiagnostics.slice(0)) {
        let newLevel = defaultLevel;
        const lineOverride = (lineOverrides[ruleNameLowered] || []).find(
          (_) => _.pos < emitted.range.pos && _.end >= emitted.range.end
        );
        if (lineOverride) {
          newLevel = lineOverride.level;
          unusedLineOverrides.delete(lineOverride);
        } else {
          const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos);
          if (sectionOverride) newLevel = sectionOverride.level;
        }
        if (!(newLevel in levelToDiagnosticCategory)) continue;
        diagnostics3.push({
          file: sourceFile,
          start: emitted.range.pos,
          length: emitted.range.end - emitted.range.pos,
          messageText: emitted.messageText,
          category: levelToDiagnosticCategory[newLevel],
          code: rule.code,
          source: "effect"
        });
        for (const fix of emitted.fixes) {
          codeFixes.push({
            ...fix,
            code: rule.code,
            start: emitted.range.pos,
            end: emitted.range.end
          });
        }
      }
      if (pluginOptions.missingDiagnosticNextLine !== "off" && unusedLineOverrides.size > 0) {
        for (const unusedLineOverride of unusedLineOverrides) {
          diagnostics3.push({
            file: sourceFile,
            start: unusedLineOverride.commentRange.pos,
            length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,
            messageText: `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,
            category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],
            code: -1,
            source: "effect"
          });
        }
      }
      return { diagnostics: diagnostics3, codeFixes };
    });
    return { execute: execute2 };
  }
);
var cyrb53 = (str, seed = 0) => {
  let h12 = 3735928559 ^ seed, h22 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h22 = Math.imul(h22 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507);
  h12 ^= Math.imul(h22 ^ h22 >>> 13, 3266489909);
  h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507);
  h22 ^= Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return (h22 >>> 0).toString(16).padStart(8, "0") + (h12 >>> 0).toString(16).padStart(8, "0");
};
var CodegenNotApplicableError = class {
  constructor(cause2) {
    this.cause = cause2;
  }
  _tag = "@effect/language-service/CodegenNotApplicableError";
};
function createCodegen(definition) {
  return definition;
}
var getCodegensForSourceFile = fn2("LSP.getApplicableCodegens")(function* (codegens2, sourceFile) {
  const tsUtils = yield* service2(TypeScriptUtils);
  const result = [];
  const regex = /@effect-codegens((?:\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid;
  let match18;
  while ((match18 = regex.exec(sourceFile.text)) !== null) {
    const pos = match18.indices?.[0]?.[0];
    if (!pos) continue;
    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos);
    if (!commentRange) continue;
    const commentText = sourceFile.text.slice(pos, commentRange.end);
    const codegenRegex = /(\s+)(\w+)(?::(\w+))?/gmi;
    let codegenMatch;
    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {
      const whitespace = codegenMatch[1] || "";
      const codegenName = codegenMatch[2] || "";
      const codegenHash = codegenMatch[3] || "";
      const range3 = {
        pos: codegenMatch.index + pos + whitespace.length,
        end: codegenMatch.index + pos + codegenMatch[0].length
      };
      const codegen2 = codegens2.find((codegen3) => codegen3.name === codegenName);
      if (!codegen2) continue;
      result.push({ codegen: codegen2, hash: codegenHash, range: range3 });
    }
  }
  return result;
});
var getEditsForCodegen = fn2("LSP.getEditsForCodegen")(function* (codegens2, sourceFile, textRange) {
  const applicableCodegens = yield* getCodegensForSourceFile(codegens2, sourceFile);
  const inRangeCodegens = applicableCodegens.filter(
    (codegen3) => codegen3.range.pos <= textRange.pos && codegen3.range.end >= textRange.end
  );
  if (inRangeCodegens.length !== 1) {
    return yield* fail18(new CodegenNotApplicableError("zero or multiple codegens in range"));
  }
  const { codegen: codegen2, range: range3 } = inRangeCodegens[0];
  const edit = yield* codegen2.apply(sourceFile, range3);
  const updateHashComment = pipe(
    service2(ChangeTracker),
    map34((changeTracker) => {
      changeTracker.deleteRange(sourceFile, range3);
      changeTracker.insertText(
        sourceFile,
        range3.pos,
        edit.hash.length > 0 ? `${codegen2.name}:${edit.hash}` : codegen2.name
      );
    })
  );
  return {
    ...edit,
    apply: pipe(
      edit.apply,
      flatMap18(() => updateHashComment)
    ),
    ignore: updateHashComment
  };
});
var getEffectLspPatchSourceFileMetadata = (sourceFile) => {
  return sourceFile["@effect-lsp-patch/metadata"];
};

// src/core/TypeCheckerApi.ts
var TypeCheckerApi = Tag4("TypeChecker");
function makeResolveExternalModuleName(typeChecker) {
  if (!(hasProperty(typeChecker, "resolveExternalModuleName") && isFunction(typeChecker.resolveExternalModuleName))) {
    return;
  }
  const _internal = typeChecker.resolveExternalModuleName;
  return (moduleSpecifier) => {
    return _internal(moduleSpecifier);
  };
}

// src/core/TypeCheckerUtils.ts
var TypeCheckerUtils = Tag4("TypeCheckerUtils");
var nanoLayer2 = (fa) => pipe(
  service2(TypeScriptApi),
  flatMap18(
    (ts) => flatMap18(service2(TypeCheckerApi), (typeChecker) => flatMap18(service2(TypeScriptUtils), (typeScriptUtils) => pipe(fa, provideService7(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))
  )
);
function makeTypeCheckerUtils(ts, typeChecker, tsUtils) {
  const readonlyArraySymbol = typeChecker.resolveName("ReadonlyArray", void 0, ts.SymbolFlags.Type, false);
  const globalReadonlyArrayType = readonlyArraySymbol ? typeChecker.getDeclaredTypeOfSymbol(readonlyArraySymbol) : void 0;
  const errorSymbol = typeChecker.resolveName("Error", void 0, ts.SymbolFlags.Type, false);
  const globalErrorType = errorSymbol ? typeChecker.getDeclaredTypeOfSymbol(errorSymbol) : void 0;
  function isUnion4(type2) {
    return !!(type2.flags & ts.TypeFlags.Union);
  }
  function isIndexType(type2) {
    return !!(type2.flags & ts.TypeFlags.Index);
  }
  function isThisTypeParameter(type2) {
    return !!(type2.flags & ts.TypeFlags.TypeParameter && type2.isThisType);
  }
  function isReadonlyArrayType(type2) {
    return type2 && "target" in type2 && type2.target === globalReadonlyArrayType;
  }
  function isMissingIntrinsicType(type2) {
    return (type2.flags & ts.TypeFlags.Undefined) !== 0 && "debugIntrinsicName" in type2 && type2.debugIntrinsicName === "missing";
  }
  function getTypeParameterAtPosition(signature, pos) {
    const type2 = typeChecker.getParameterType(signature, pos);
    if (isIndexType(type2) && isThisTypeParameter(type2.type)) {
      const constraint = typeChecker.getBaseConstraintOfType(type2.type);
      if (constraint) {
        return typeChecker.getIndexType(constraint);
      }
    }
    return type2;
  }
  const unrollUnionMembers = (type2) => {
    const result = [];
    let toTest = [type2];
    while (toTest.length > 0) {
      const type3 = toTest.pop();
      if (isUnion4(type3)) {
        toTest = toTest.concat(type3.types);
      } else {
        result.push(type3);
      }
    }
    return result;
  };
  const getMissingTypeEntriesInTargetType = function(realType, expectedType) {
    if (realType === expectedType) return [];
    const result = [];
    let toTest = [realType];
    while (toTest.length > 0) {
      const type2 = toTest.pop();
      if (!type2) return result;
      if (isUnion4(type2)) {
        toTest = toTest.concat(type2.types);
      } else {
        const assignable = typeChecker.isTypeAssignableTo(type2, expectedType);
        if (!assignable) {
          result.push(type2);
        }
      }
    }
    return result;
  };
  const appendToUniqueTypesMap = fn2(
    "TypeCheckerUtils.appendToUniqueTypesMap"
  )(
    function* (memory, initialType, shouldExclude) {
      const newIndexes = /* @__PURE__ */ new Set();
      const knownIndexes = /* @__PURE__ */ new Set();
      let toTest = [initialType];
      while (toTest.length > 0) {
        const type2 = toTest.pop();
        if (!type2) break;
        if (yield* shouldExclude(type2)) {
          continue;
        }
        if (isUnion4(type2)) {
          toTest = toTest.concat(type2.types);
        } else {
          const foundMatch = [];
          for (const [typeId, knownType] of memory.entries()) {
            const areSame = typeChecker.isTypeAssignableTo(knownType, type2) && typeChecker.isTypeAssignableTo(type2, knownType);
            if (areSame) {
              foundMatch.push(typeId);
              break;
            }
          }
          if (foundMatch.length === 0) {
            const newId = "t" + (memory.size + 1);
            memory.set(newId, type2);
            newIndexes.add(newId);
          } else {
            knownIndexes.add(foundMatch[0]);
          }
        }
      }
      return {
        newIndexes,
        knownIndexes,
        allIndexes: pipe(
          fromIterable(newIndexes),
          appendAll(fromIterable(knownIndexes))
        )
      };
    }
  );
  const deterministicTypeOrder = make2((a, b) => {
    const aName = typeChecker.typeToString(a);
    const bName = typeChecker.typeToString(b);
    if (aName < bName) return -1;
    if (aName > bName) return 1;
    return 0;
  });
  const getAncestorConvertibleDeclaration = (node) => {
    let current = node;
    while (current) {
      if (ts.isFunctionDeclaration(current) || ts.isFunctionExpression(current) || ts.isArrowFunction(current) || ts.isMethodDeclaration(current)) {
        return current;
      }
      current = current.parent;
    }
  };
  const getInferredReturnType = (declaration) => {
    if (!declaration.body) {
      return;
    }
    let returnType;
    if (typeChecker.isImplementationOfOverload(declaration)) {
      const signatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(declaration),
        ts.SignatureKind.Call
      );
      if (signatures.length > 1) {
        returnType = typeChecker.getUnionType(
          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)
        );
      }
    }
    if (!returnType) {
      const signature = typeChecker.getSignatureFromDeclaration(declaration);
      if (signature) {
        const typePredicate = typeChecker.getTypePredicateOfSignature(signature);
        if (typePredicate && typePredicate.type) {
          return typePredicate.type;
        } else {
          returnType = typeChecker.getReturnTypeOfSignature(signature);
        }
      }
    }
    return returnType;
  };
  const expectedAndRealTypeCache = /* @__PURE__ */ new WeakMap();
  const expectedAndRealType = (sourceFile) => {
    const cached3 = expectedAndRealTypeCache.get(sourceFile);
    if (cached3) return cached3;
    const result = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isVariableDeclaration(node) && node.initializer) {
        const expectedType = typeChecker.getTypeAtLocation(node.name);
        const realType = typeChecker.getTypeAtLocation(node.initializer);
        result.push([node.name, expectedType, node.initializer, realType]);
        appendNodeToVisit(node.initializer);
        continue;
      } else if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          resolvedSignature.parameters.map((parameter, index) => {
            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node);
            const realType = typeChecker.getTypeAtLocation(node.arguments[index]);
            result.push([
              node.arguments[index],
              expectedType,
              node.arguments[index],
              realType
            ]);
          });
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {
        const parent = node.parent;
        if (ts.isObjectLiteralElement(parent)) {
          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
            const type2 = typeChecker.getContextualType(parent.parent);
            if (type2) {
              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : void 0;
              if (name) {
                const symbol3 = typeChecker.getPropertyOfType(type2, name);
                if (symbol3) {
                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol3, node);
                  const realType = typeChecker.getTypeAtLocation(node);
                  result.push([node, expectedType, node, realType]);
                }
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const expectedType = typeChecker.getTypeAtLocation(node.left);
        const realType = typeChecker.getTypeAtLocation(node.right);
        result.push([node.left, expectedType, node.right, realType]);
        appendNodeToVisit(node.right);
        continue;
      } else if (ts.isReturnStatement(node) && node.expression) {
        const parentDeclaration = getAncestorConvertibleDeclaration(node);
        if (parentDeclaration) {
          const expectedType = getInferredReturnType(parentDeclaration);
          const realType = typeChecker.getTypeAtLocation(node.expression);
          if (expectedType) {
            result.push([node, expectedType, node, realType]);
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = typeChecker.getContextualType(body);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = getInferredReturnType(node);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isSatisfiesExpression(node)) {
        const expectedType = typeChecker.getTypeAtLocation(node.type);
        const realType = typeChecker.getTypeAtLocation(node.expression);
        result.push([node.expression, expectedType, node.expression, realType]);
        appendNodeToVisit(node.expression);
        continue;
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
    expectedAndRealTypeCache.set(sourceFile, result);
    return result;
  };
  function typeToSimplifiedTypeNode(type2, enclosingNode, flags) {
    return typeToSimplifiedTypeNodeWorker(type2, enclosingNode, flags, 0);
  }
  function isGlobalErrorType(type2) {
    if (!globalErrorType) return false;
    return typeChecker.isTypeAssignableTo(type2, globalErrorType) && typeChecker.isTypeAssignableTo(globalErrorType, type2);
  }
  function typeToSimplifiedTypeNodeWorker(type2, enclosingNode, flags, depth) {
    const fallbackStandard = () => {
      const typeNode = typeChecker.typeToTypeNode(type2, enclosingNode, flags);
      if (!typeNode) return void 0;
      return tsUtils.simplifyTypeNode(typeNode);
    };
    if (depth > 20) return fallbackStandard();
    const members = unrollUnionMembers(type2);
    if (members.length > 1 && !(type2.flags & ts.TypeFlags.Boolean)) {
      const typeNodes = [];
      members.sort(deterministicTypeOrder);
      for (const member of members) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes));
    }
    if (type2.flags & ts.TypeFlags.Intersection) {
      const intersectionType = type2;
      const typeNodes = [];
      for (const member of intersectionType.types) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes));
    }
    if (type2.flags & ts.TypeFlags.Object && type2.objectFlags & ts.ObjectFlags.Reference) {
      const typeReference = type2;
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isTypeReferenceNode(standard2)) return standard2;
      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard2;
      if (standard2.typeArguments?.length !== typeReference.typeArguments?.length) return standard2;
      const typeParametersCount = (typeReference.target.typeParameters || []).length;
      for (let i = typeParametersCount - 1; i >= 0; i--) {
        const typeParameter = typeReference.target.typeParameters[i];
        const typeArgument = typeReference.typeArguments[i];
        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter);
        if (defaultType !== typeArgument || i === 0) {
          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(
            standard2,
            standard2.typeName,
            ts.factory.createNodeArray((standard2.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))
          ));
        }
      }
      return standard2;
    }
    if (type2.flags & ts.TypeFlags.Object) {
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isFunctionTypeNode(standard2)) return standard2;
      const signatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
      if (signatures.length !== 1) return standard2;
      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
      if (!returnType) return standard2;
      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1);
      if (!returnTypeNode) return standard2;
      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(
        standard2,
        standard2.typeParameters,
        standard2.parameters,
        returnTypeNode
      ));
    }
    return fallbackStandard();
  }
  function getTypeAtLocation(node) {
    if (node.parent && ts.isJsxSelfClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxAttribute(node.parent) && node.parent.name === node) return;
    if (ts.isExpression(node) || ts.isTypeNode(node)) {
      return typeChecker.getTypeAtLocation(node);
    }
  }
  return {
    isUnion: isUnion4,
    isReadonlyArrayType,
    isMissingIntrinsicType,
    getTypeParameterAtPosition,
    getMissingTypeEntriesInTargetType,
    unrollUnionMembers,
    appendToUniqueTypesMap,
    deterministicTypeOrder,
    getInferredReturnType,
    expectedAndRealType,
    typeToSimplifiedTypeNode,
    isGlobalErrorType,
    getTypeAtLocation
  };
}

// src/core/TypeParser.ts
var TypeParser = Tag4("@effect/language-service/TypeParser");
var nanoLayer3 = (fa) => gen3(function* () {
  const ts = yield* service2(TypeScriptApi);
  const tsUtils = yield* service2(TypeScriptUtils);
  const typeChecker = yield* service2(TypeCheckerApi);
  const typeCheckerUtils = yield* service2(TypeCheckerUtils);
  const program = yield* service2(TypeScriptProgram);
  return yield* pipe(
    fa,
    provideService7(TypeParser, make64(ts, tsUtils, typeChecker, typeCheckerUtils, program))
  );
});
var TypeParserIssue = class _TypeParserIssue {
  _tag = "@effect/language-service/TypeParserIssue";
  static issue = fail18(new _TypeParserIssue());
};
function typeParserIssue(_message, _type, _node) {
  return TypeParserIssue.issue;
}
function make64(ts, tsUtils, typeChecker, typeCheckerUtils, program) {
  const getSourceFilePackageInfo = cachedBy(
    fn2("TypeParser.getSourceFilePackageInfo")(function* (sourceFile) {
      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    }),
    `TypeParser.getSourceFilePackageInfo`,
    (sourceFile) => sourceFile
  );
  const getSourceFilesDeclaringSymbolModule = (packageName) => cachedBy(
    fn2("TypeParser.getSourceFilesDeclaringSymbolModule")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const sourceFile of symbol3.declarations) {
        if (!ts.isSourceFile(sourceFile)) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push(sourceFile);
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no source file declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,
    (symbol3) => symbol3
  );
  const isSymbolReferenceToPackageModule = (givenSymbol, packageName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolModule(packageName)(symbol3),
      flatMap18(
        (sourceFiles) => firstSuccessOf2(
          sourceFiles.map((_) => checkSourceFile(_))
        )
      )
    );
  };
  const isNodeReferenceToPackageModule = (givenNode, packageName, isCorrectSourceFile) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolReferenceToPackageModule(symbol3, packageName, isCorrectSourceFile);
  };
  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (packageName, memberName) => cachedBy(
    fn2("TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const declaration of symbol3.declarations) {
        const sourceFile = tsUtils.getSourceFileOfNode(declaration);
        if (!sourceFile) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (memberSymbol) {
          if (memberSymbol === symbol3) {
            result.push({ memberSymbol, moduleSymbol, sourceFile });
          } else if (memberSymbol.flags & ts.SymbolFlags.Alias) {
            const aliased = typeChecker.getAliasedSymbol(memberSymbol);
            if (aliased === symbol3) {
              result.push({ memberSymbol, moduleSymbol, sourceFile });
            }
          }
        }
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,
    (sym) => sym
  );
  const isSymbolExportOfPackageModule = (givenSymbol, packageName, memberName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol3),
      flatMap18(
        (sourceFiles) => firstSuccessOf2(
          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))
        )
      )
    );
  };
  const isNodeReferenceToExportOfPackageModule = (givenNode, packageName, isCorrectSourceFile, memberName) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolExportOfPackageModule(symbol3, packageName, memberName, isCorrectSourceFile);
  };
  const findSymbolsMatchingPackageAndExportedName = (packageName, exportedSymbolName) => cachedBy(
    fn2("TypeParser.findSymbolsMatchingPackageAndExportedName")(function* () {
      const result = [];
      for (const sourceFile of program.getSourceFiles()) {
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const symbol3 = typeChecker.tryGetMemberInModuleExports(exportedSymbolName, moduleSymbol);
        if (!symbol3) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push([symbol3, sourceFile]);
      }
      return result;
    }),
    `TypeParser.findSymbolsMatchingPackageAndExportedName(${packageName}, ${exportedSymbolName})`,
    () => program
  );
  const isCauseTypeSourceFile = cachedBy(
    fn2("TypeParser.isCauseTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const causeTypeSymbol = typeChecker.tryGetMemberInModuleExports("Cause", moduleSymbol);
      if (!causeTypeSymbol) return yield* typeParserIssue("Cause type not found", void 0, sourceFile);
      const type2 = typeChecker.getDeclaredTypeOfSymbol(causeTypeSymbol);
      yield* pipeableType(type2, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isCauseTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const extendsCauseYieldableError = cachedBy(
    fn2("TypeParser.extendsCauseYieldableError")(function* (givenType) {
      if (givenType.flags & ts.TypeFlags.Never) {
        return yield* typeParserIssue("Type is never", givenType);
      }
      if (givenType.flags & ts.TypeFlags.Any) {
        return yield* typeParserIssue("Type is any", givenType);
      }
      const symbols = yield* findSymbolsMatchingPackageAndExportedName("effect", "YieldableError")();
      for (const [symbol3, sourceFile] of symbols) {
        const causeFile = yield* pipe(isCauseTypeSourceFile(sourceFile), orElse15(() => void_8));
        if (!causeFile) continue;
        const type2 = typeChecker.getDeclaredTypeOfSymbol(symbol3);
        if (!type2) continue;
        if (typeChecker.isTypeAssignableTo(givenType, type2)) {
          return type2;
        }
      }
      return yield* typeParserIssue("Type does not extend Cause.YieldableError", givenType);
    }),
    "TypeParser.extendsCauseYieldableError",
    (type2) => type2
  );
  function covariantTypeArgument(type2) {
    const signatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Covariant type has no call signature", type2);
    }
    return succeed17(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  function contravariantTypeArgument(type2) {
    const signatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Contravariant type has no call signature", type2);
    }
    return succeed17(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0));
  }
  function invariantTypeArgument(type2) {
    const signatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Invariant type has no call signature", type2);
    }
    return succeed17(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  const pipeableType = cachedBy(
    function(type2, atLocation) {
      const pipeSymbol = typeChecker.getPropertyOfType(type2, "pipe");
      if (!pipeSymbol) {
        return typeParserIssue("Type has no 'pipe' property", type2, atLocation);
      }
      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation);
      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call);
      if (signatures.length === 0) {
        return typeParserIssue("'pipe' property is not callable", type2, atLocation);
      }
      return succeed17(type2);
    },
    "TypeParser.pipeableType",
    (type2) => type2
  );
  const varianceStructCovariantType = (type2, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type2, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type2, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return covariantTypeArgument(propertyType);
  };
  const varianceStructContravariantType = (type2, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type2, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type2, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return contravariantTypeArgument(propertyType);
  };
  const varianceStructInvariantType = (type2, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type2, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type2, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return invariantTypeArgument(propertyType);
  };
  const effectVarianceStruct = (type2, atLocation) => map34(
    all9(
      varianceStructCovariantType(type2, atLocation, "_A"),
      varianceStructCovariantType(type2, atLocation, "_E"),
      varianceStructCovariantType(type2, atLocation, "_R")
    ),
    ([A, E, R]) => ({ A, E, R })
  );
  const layerVarianceStruct = (type2, atLocation) => map34(
    all9(
      varianceStructContravariantType(type2, atLocation, "_ROut"),
      varianceStructCovariantType(type2, atLocation, "_E"),
      varianceStructCovariantType(type2, atLocation, "_RIn")
    ),
    ([ROut, E, RIn]) => ({ ROut, E, RIn })
  );
  const effectType = cachedBy(
    fn2("TypeParser.effectType")(function* (type2, atLocation) {
      const propertiesSymbols = typeChecker.getPropertiesOfType(type2).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no effect variance struct", type2, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("EffectTypeId") - ts.symbolName(a).indexOf("EffectTypeId")
      );
      return yield* firstSuccessOf2(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectType",
    (type2) => type2
  );
  const strictEffectType = cachedBy(
    fn2("TypeParser.strictEffectType")(function* (type2, atLocation) {
      if (!(type2.symbol && ts.symbolName(type2.symbol) === "Effect" && !type2.aliasSymbol)) {
        return yield* typeParserIssue("Type name should be Effect with no alias symbol", type2, atLocation);
      }
      return yield* effectType(type2, atLocation);
    }),
    "TypeParser.strictEffectType",
    (type2) => type2
  );
  const isEffectTypeSourceFile = cachedBy(
    fn2("TypeParser.isEffectTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports("Effect", moduleSymbol);
      if (!effectTypeSymbol) return yield* typeParserIssue("Effect type not found", void 0, sourceFile);
      const type2 = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol);
      yield* effectType(type2, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,
    (node) => node
  );
  const layerType = cachedBy(
    fn2("TypeParser.layerType")(function* (type2, atLocation) {
      yield* pipeableType(type2, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type2).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no layer variance struct", type2, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("LayerTypeId") - ts.symbolName(a).indexOf("LayerTypeId")
      );
      return yield* firstSuccessOf2(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return layerVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.layerType",
    (type2) => type2
  );
  const fiberType = cachedBy(
    fn2("TypeParser.fiberType")(function* (type2, atLocation) {
      const awaitSymbol = typeChecker.getPropertyOfType(type2, "await");
      const pollSymbol = typeChecker.getPropertyOfType(type2, "poll");
      if (!awaitSymbol || !pollSymbol) {
        return yield* typeParserIssue(
          "Type is not a fiber because it does not have 'await' or 'poll' property",
          type2,
          atLocation
        );
      }
      return yield* effectType(type2, atLocation);
    }),
    "TypeParser.fiberType",
    (type2) => type2
  );
  const effectSubtype = cachedBy(
    fn2("TypeParser.effectSubtype")(function* (type2, atLocation) {
      const tagSymbol = typeChecker.getPropertyOfType(type2, "_tag");
      const getSymbol = typeChecker.getPropertyOfType(type2, "get");
      if (!(tagSymbol || getSymbol)) {
        return yield* typeParserIssue(
          "Type is not a subtype of effect because it does not have '_tag' or 'get' property",
          type2,
          atLocation
        );
      }
      return yield* effectType(type2, atLocation);
    }),
    "TypeParser.effectSubtype",
    (type2) => type2
  );
  const isEffectContextSourceFile = cachedBy(
    fn2("TypeParser.isEffectContextSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const contextSymbol = typeChecker.tryGetMemberInModuleExports("Context", moduleSymbol);
      if (!contextSymbol) return yield* typeParserIssue("Context not found", void 0, sourceFile);
      const tagSymbol = typeChecker.tryGetMemberInModuleExports("Tag", moduleSymbol);
      if (!tagSymbol) return yield* typeParserIssue("Tag not found", void 0, sourceFile);
      const tagType = typeChecker.getDeclaredTypeOfSymbol(tagSymbol);
      yield* contextTag(tagType, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectContextSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectContextModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectContextModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectContextSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectContextModuleApi(${memberName})`,
    (node) => node
  );
  const importedContextModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectContextSourceFile),
      map34(() => node)
    ),
    "TypeParser.importedContextModule",
    (node) => node
  );
  const importedEffectModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectTypeSourceFile),
      map34(() => node)
    ),
    "TypeParser.importedEffectModule",
    (node) => node
  );
  const isEffectDataSourceFile = cachedBy(
    fn2("TypeParser.isEffectDataSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const taggedEnumSymbol = typeChecker.tryGetMemberInModuleExports("TaggedEnum", moduleSymbol);
      if (!taggedEnumSymbol) return yield* typeParserIssue("TaggedEnum not found", void 0, sourceFile);
      const taggedErrorSymbol = typeChecker.tryGetMemberInModuleExports("TaggedError", moduleSymbol);
      if (!taggedErrorSymbol) return yield* typeParserIssue("TaggedError not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectDataSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectDataModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectDataModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectDataSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectDataModuleApi(${memberName})`,
    (node) => node
  );
  const importedDataModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectDataSourceFile),
      map34(() => node)
    ),
    "TypeParser.importedDataModule",
    (node) => node
  );
  const effectGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue("Node is not a generator function", void 0, node);
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("gen")(propertyAccess),
        map34(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectGen",
    (node) => node
  );
  const effectFnUntracedGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = node.expression;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fnUntraced")(propertyAccess),
        map34(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2
        }))
      );
    },
    "TypeParser.effectFnUntracedGen",
    (node) => node
  );
  const effectFnGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue(
          "Node is not a function expression",
          void 0,
          node
        );
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map34(() => ({
          node,
          generatorFunction,
          effectModule: propertyAccess.expression,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFnGen",
    (node) => node
  );
  const findEnclosingScopes = fn2("TypeParser.findEnclosingScopes")(function* (startNode) {
    let currentParent = startNode.parent;
    let scopeNode = void 0;
    let effectGenResult = void 0;
    while (currentParent) {
      const nodeToCheck = currentParent;
      if (!scopeNode) {
        if (ts.isFunctionExpression(nodeToCheck) || ts.isFunctionDeclaration(nodeToCheck) || ts.isMethodDeclaration(nodeToCheck) || ts.isArrowFunction(nodeToCheck) || ts.isGetAccessorDeclaration(nodeToCheck) || ts.isSetAccessorDeclaration(nodeToCheck)) {
          scopeNode = nodeToCheck;
        }
      }
      if (!effectGenResult) {
        const isEffectGen = yield* pipe(
          effectGen(nodeToCheck),
          map34((result) => ({
            node: result.node,
            effectModule: result.effectModule,
            generatorFunction: result.generatorFunction,
            body: result.body
          })),
          orElse15(
            () => pipe(
              effectFnUntracedGen(nodeToCheck),
              map34((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          orElse15(
            () => pipe(
              effectFnGen(nodeToCheck),
              map34((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          option5
        );
        if (isSome2(isEffectGen)) {
          effectGenResult = isEffectGen.value;
        }
      }
      if (scopeNode && effectGenResult) {
        break;
      }
      currentParent = nodeToCheck.parent;
    }
    return { scopeNode, effectGen: effectGenResult };
  });
  const effectFn = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const regularFunction = node.arguments[0];
      if (!ts.isFunctionExpression(regularFunction) && !ts.isArrowFunction(regularFunction)) {
        return typeParserIssue("Node is not a function expression or arrow function", void 0, node);
      }
      if (ts.isFunctionExpression(regularFunction) && regularFunction.asteriskToken !== void 0) {
        return typeParserIssue("Node is a generator function, not a regular function", void 0, node);
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map34(() => ({
          node,
          effectModule: propertyAccess.expression,
          regularFunction,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFn",
    (node) => node
  );
  const unnecessaryEffectGen2 = cachedBy(
    fn2("TypeParser.unnecessaryEffectGen")(function* (node) {
      const { body } = yield* effectGen(node);
      if (body.statements.length !== 1) {
        return yield* typeParserIssue(
          "Generator body should have a single statement",
          void 0,
          node
        );
      }
      let explicitReturn = false;
      let nodeToCheck = body.statements[0];
      while (nodeToCheck) {
        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {
          nodeToCheck = nodeToCheck.expression;
          explicitReturn = true;
          continue;
        }
        if (ts.isExpressionStatement(nodeToCheck)) {
          nodeToCheck = nodeToCheck.expression;
          continue;
        }
        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {
          const yieldedExpression = nodeToCheck.expression;
          const type2 = typeCheckerUtils.getTypeAtLocation(yieldedExpression);
          if (!type2) continue;
          const { A: successType } = yield* effectType(type2, yieldedExpression);
          let replacementNode = succeed17(yieldedExpression);
          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {
            replacementNode = pipe(
              gen3(function* () {
                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
                  node.getSourceFile(),
                  "effect",
                  "Effect"
                ) || "Effect";
                return ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(effectIdentifier),
                    "asVoid"
                  ),
                  void 0,
                  [
                    yieldedExpression
                  ]
                );
              }),
              provideService7(TypeScriptApi, ts)
            );
          }
          return { node, body, yieldedExpression, replacementNode };
        }
        break;
      }
      return yield* typeParserIssue(
        "Not an handled node",
        void 0,
        node
      );
    }),
    "TypeParser.unnecessaryEffectGen",
    (node) => node
  );
  const effectSchemaVarianceStruct = (type2, atLocation) => map34(
    all9(
      varianceStructInvariantType(type2, atLocation, "_A"),
      varianceStructInvariantType(type2, atLocation, "_I"),
      varianceStructCovariantType(type2, atLocation, "_R")
    ),
    ([A, I, R]) => ({ A, I, R })
  );
  const effectSchemaType = cachedBy(
    fn2("TypeParser.effectSchemaType")(function* (type2, atLocation) {
      yield* pipeableType(type2, atLocation);
      const ast = typeChecker.getPropertyOfType(type2, "ast");
      if (!ast) return yield* typeParserIssue("Has no 'ast' property", type2, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type2).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no schema variance struct", type2, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf2(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectSchemaVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectSchemaType",
    (type2) => type2
  );
  const isEffectSchemaTypeSourceFile = cachedBy(
    fn2("TypeParser.isEffectSchemaTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const typeSymbol = typeChecker.tryGetMemberInModuleExports("Schema", moduleSymbol);
      if (!typeSymbol) return yield* typeParserIssue("Schema type not found", void 0, sourceFile);
      const type2 = typeChecker.getDeclaredTypeOfSymbol(typeSymbol);
      yield* effectSchemaType(type2, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectSchemaTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSchemaModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectSchemaModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectSchemaTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,
    (node) => node
  );
  const isEffectParseResultSourceFile = cachedBy(
    fn2("TypeParser.isEffectParseResultSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const parseIssueSymbol = typeChecker.tryGetMemberInModuleExports("ParseIssue", moduleSymbol);
      if (!parseIssueSymbol) return yield* typeParserIssue("ParseIssue type not found", void 0, sourceFile);
      const decodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("decodeSync", moduleSymbol);
      if (!decodeSyncSymbol) return yield* typeParserIssue("decodeSync not found", void 0, sourceFile);
      const encodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("encodeSync", moduleSymbol);
      if (!encodeSyncSymbol) return yield* typeParserIssue("encodeSync not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectParseResultSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectParseResultModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectParseResultModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectParseResultSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectParseResultModuleApi(${memberName})`,
    (node) => node
  );
  const contextTagVarianceStruct = (type2, atLocation) => map34(
    all9(
      varianceStructInvariantType(type2, atLocation, "_Identifier"),
      varianceStructInvariantType(type2, atLocation, "_Service")
    ),
    ([Identifier, Service]) => ({ Identifier, Service })
  );
  const contextTag = cachedBy(
    fn2("TypeParser.contextTag")(function* (type2, atLocation) {
      yield* pipeableType(type2, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type2).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no tag variance struct", type2, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf2(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return contextTagVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.contextTag",
    (type2) => type2
  );
  const effectFunctionImportedName = cachedBy(
    fn2("TypeParser.effectFunctionImportedName")(function* (sourceFile) {
      return tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Function");
    }),
    "TypeParser.effectFunctionImportedName",
    (node) => node
  );
  const pipeCall = cachedBy(
    function(node) {
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "pipe") {
        const baseExpression = node.expression.expression;
        return pipe(
          effectFunctionImportedName(tsUtils.getSourceFileOfNode(node)),
          flatMap18((functionIdentifier) => {
            if (functionIdentifier && ts.isIdentifier(baseExpression) && ts.idText(baseExpression) === functionIdentifier) {
              if (node.arguments.length === 0) {
                return typeParserIssue("Node is not a pipe call", void 0, node);
              }
              const [subject, ...args3] = node.arguments;
              return succeed17({
                node,
                subject,
                args: args3,
                kind: "pipe"
              });
            }
            return succeed17({
              node,
              subject: baseExpression,
              args: Array.from(node.arguments),
              kind: "pipeable"
            });
          })
        );
      }
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === "pipe" && node.arguments.length > 0) {
        const [subject, ...args3] = node.arguments;
        return succeed17({ node, subject, args: args3, kind: "pipe" });
      }
      return typeParserIssue("Node is not a pipe call", void 0, node);
    },
    "TypeParser.pipeCall",
    (node) => node
  );
  const singleArgCall = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length !== 1) {
        return typeParserIssue("Node must have exactly one argument", void 0, node);
      }
      return succeed17({
        node,
        callee: node.expression,
        subject: node.arguments[0]
      });
    },
    "TypeParser.singleArgCall",
    (node) => node
  );
  const scopeType = cachedBy(
    fn2("TypeParser.scopeType")(function* (type2, atLocation) {
      yield* pipeableType(type2, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type2).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.some((s) => ts.symbolName(s).indexOf("ScopeTypeId") !== -1)) {
        return type2;
      }
      return yield* typeParserIssue("Type has no scope type id", type2, atLocation);
    }),
    "TypeParser.scopeType",
    (type2) => type2
  );
  const promiseLike = cachedBy(
    function(type2, atLocation) {
      const thenProperty = type2.getProperty("then");
      if (!thenProperty) return typeParserIssue("not a promise - missing then property", type2, atLocation);
      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation);
      if (!thenType) return typeParserIssue("not a promise - missing then property", type2, atLocation);
      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {
        const parameter = callSignature.parameters[0];
        if (!parameter) continue;
        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0);
        if (!parameterType) continue;
        let callbackCallSignatures = [];
        let toTest = [parameterType];
        while (toTest.length > 0) {
          const type3 = toTest.shift();
          if (!type3) continue;
          const callSignatures = typeChecker.getSignaturesOfType(type3, ts.SignatureKind.Call);
          callbackCallSignatures = callbackCallSignatures.concat(callSignatures);
          if (typeCheckerUtils.isUnion(type3)) {
            toTest = toTest.concat(type3.types);
          }
        }
        for (const callableType of callbackCallSignatures) {
          const callbackParameter = callableType.parameters[0];
          if (!callbackParameter) {
            continue;
          }
          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0);
          if (!callbackParameterType) {
            continue;
          }
          return succeed17({
            type: callbackParameterType
          });
        }
      }
      return typeParserIssue("not a promise", type2, atLocation);
    },
    "TypeParser.promiseLike",
    (type2) => type2
  );
  const extendsSchemaClass = cachedBy(
    fn2("TypeParser.extendsSchemaClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("Class")(schemaCall.expression),
                  option5
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.Class", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedClass = cachedBy(
    fn2("TypeParser.extendsSchemaTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {
              const schemaTaggedClassTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments && schemaTaggedClassTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(schemaTaggedClassTCall.expression),
                  option5
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedClassTCall.arguments[0]) ? schemaTaggedClassTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedError = cachedBy(
    fn2("TypeParser.extendsSchemaTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedErrorTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments && schemaTaggedErrorTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedError")(schemaTaggedErrorTCall.expression),
                  option5
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0]) ? schemaTaggedErrorTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedError",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedRequest = cachedBy(
    fn2("TypeParser.extendsSchemaTaggedRequest")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedRequestTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedRequestTCall) && schemaTaggedRequestTCall.typeArguments && schemaTaggedRequestTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(schemaTaggedRequestTCall.expression),
                  option5
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0,
                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0]) ? schemaTaggedRequestTCall.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedRequest", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedRequest",
    (atLocation) => atLocation
  );
  const extendsDataTaggedError = cachedBy(
    fn2("TypeParser.extendsDataTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedErrorCall = expression;
              const dataIdentifier = dataTaggedErrorCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedError") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option5
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedErrorCall.arguments[0]) ? dataTaggedErrorCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedError",
    (atLocation) => atLocation
  );
  const extendsDataTaggedClass = cachedBy(
    fn2("TypeParser.extendsDataTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedClassCall = expression;
              const dataIdentifier = dataTaggedClassCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedClass") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option5
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedClassCall.arguments[0]) ? dataTaggedClassCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedClass",
    (atLocation) => atLocation
  );
  const extendsContextTag = cachedBy(
    fn2("TypeParser.extendsContextTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const contextTagCall = wholeCall.expression;
              if (ts.isCallExpression(contextTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const contextTagIdentifier = contextTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                if (ts.isPropertyAccessExpression(contextTagIdentifier) && ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === "Tag") {
                  const parsedContextModule = yield* pipe(
                    importedContextModule(contextTagIdentifier.expression),
                    option5
                  );
                  if (isSome2(parsedContextModule)) {
                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                    if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                    const type2 = typeChecker.getTypeOfSymbol(classSym);
                    const tagType = yield* contextTag(type2, atLocation);
                    return {
                      className: atLocation.name,
                      selfTypeNode,
                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0]) ? contextTagCall.arguments[0] : void 0,
                      args: contextTagCall.arguments,
                      Identifier: tagType.Identifier,
                      Tag: parsedContextModule.value
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Context.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsContextTag",
    (atLocation) => atLocation
  );
  const extendsEffectTag = cachedBy(
    fn2("TypeParser.extendsEffectTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
      if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
      const type2 = typeChecker.getTypeOfSymbol(classSym);
      const tagType = yield* contextTag(type2, atLocation);
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectTagCall = wholeCall.expression;
              if (ts.isCallExpression(effectTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const effectTagIdentifier = effectTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                const isEffectTag = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Tag")(effectTagIdentifier),
                  option5
                );
                if (isSome2(isEffectTag)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0]) ? effectTagCall.arguments[0] : void 0,
                    args: effectTagCall.arguments,
                    Identifier: tagType.Identifier,
                    Service: tagType.Service
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsEffectTag",
    (atLocation) => atLocation
  );
  const extendsEffectService = cachedBy(
    fn2("TypeParser.extendsEffectService")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectServiceCall = wholeCall.expression;
              if (ts.isCallExpression(effectServiceCall) && effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0) {
                const effectServiceIdentifier = effectServiceCall.expression;
                const selfTypeNode = effectServiceCall.typeArguments[0];
                const isEffectService = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Service")(effectServiceIdentifier),
                  option5
                );
                if (isSome2(isEffectService)) {
                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                  if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                  const type2 = typeChecker.getTypeOfSymbol(classSym);
                  const parsedContextTag = yield* pipe(
                    contextTag(type2, atLocation),
                    option5
                  );
                  if (isSome2(parsedContextTag)) {
                    let accessors2 = void 0;
                    let dependencies = void 0;
                    if (wholeCall.arguments.length >= 2) {
                      const args3 = wholeCall.arguments[1];
                      if (ts.isObjectLiteralExpression(args3)) {
                        for (const property of args3.properties) {
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "accessors" && property.initializer && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                            accessors2 = true;
                          }
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "dependencies" && property.initializer && ts.isArrayLiteralExpression(property.initializer)) {
                            dependencies = property.initializer.elements;
                          }
                        }
                      }
                    }
                    return {
                      ...parsedContextTag.value,
                      className: atLocation.name,
                      selfTypeNode,
                      args: wholeCall.arguments,
                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0]) ? wholeCall.arguments[0] : void 0,
                      options: wholeCall.arguments[1],
                      accessors: accessors2,
                      dependencies
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Service", void 0, atLocation);
    }),
    "TypeParser.extendsEffectService",
    (atLocation) => atLocation
  );
  const isEffectSqlModelTypeSourceFile = cachedBy(
    fn2("TypeParser.isEffectSqlModelTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const classSymbol = typeChecker.tryGetMemberInModuleExports("Class", moduleSymbol);
      if (!classSymbol) return yield* typeParserIssue("Model's Class type not found", void 0, sourceFile);
      const makeRepositorySymbol = typeChecker.tryGetMemberInModuleExports("makeRepository", moduleSymbol);
      if (!makeRepositorySymbol) {
        return yield* typeParserIssue("Model's makeRepository type not found", void 0, sourceFile);
      }
      const makeDataLoadersSymbol = typeChecker.tryGetMemberInModuleExports("makeDataLoaders", moduleSymbol);
      if (!makeDataLoadersSymbol) {
        return yield* typeParserIssue("Model's makeDataLoaders type not found", void 0, sourceFile);
      }
      return sourceFile;
    }),
    "TypeParser.isEffectSqlModelTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSqlModelModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectSqlModelModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "@effect/sql",
        isEffectSqlModelTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectSqlModelModuleApi(${memberName})`,
    (node) => node
  );
  const extendsEffectSqlModelClass = cachedBy(
    fn2("TypeParser.extendsEffectSqlModelClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSqlModelModuleApi("Class")(schemaCall.expression),
                  option5
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend @effect/sql's Model.Class", void 0, atLocation);
    }),
    "TypeParser.extendsEffectSqlModelClass",
    (atLocation) => atLocation
  );
  const isEffectLayerTypeSourceFile = cachedBy(
    fn2("TypeParser.isEffectLayerTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const layerTypeSymbol = typeChecker.tryGetMemberInModuleExports("Layer", moduleSymbol);
      if (!layerTypeSymbol) return yield* typeParserIssue("Layer type not found", void 0, sourceFile);
      const type2 = typeChecker.getDeclaredTypeOfSymbol(layerTypeSymbol);
      yield* layerType(type2, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectLayerTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectLayerModuleApi = (memberName) => cachedBy(
    fn2("TypeParser.isNodeReferenceToEffectLayerModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "effect",
        isEffectLayerTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectLayerModuleApi(${memberName})`,
    (node) => node
  );
  const lazyExpression = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      if (node.parameters.length !== 0) {
        return typeParserIssue("Function must have zero parameters", void 0, node);
      }
      if (node.typeParameters && node.typeParameters.length > 0) {
        return typeParserIssue("Function must have no type parameters", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (ts.isArrowFunction(node) && !ts.isBlock(body)) {
        return succeed17({
          node,
          body,
          expression: body,
          returnType
        });
      }
      if (ts.isBlock(body)) {
        if (body.statements.length !== 1) {
          return typeParserIssue("Block must have exactly one statement", void 0, node);
        }
        const stmt = body.statements[0];
        if (!ts.isReturnStatement(stmt)) {
          return typeParserIssue("Statement must be a return statement", void 0, node);
        }
        if (!stmt.expression) {
          return typeParserIssue("Return statement must have an expression", void 0, node);
        }
        return succeed17({
          node,
          body,
          expression: stmt.expression,
          returnType
        });
      }
      return typeParserIssue("Invalid function body", void 0, node);
    },
    "TypeParser.lazyExpression",
    (node) => node
  );
  const emptyFunction = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (!ts.isBlock(body)) {
        return typeParserIssue("Body must be a block", void 0, node);
      }
      if (body.statements.length !== 0) {
        return typeParserIssue("Block must have zero statements", void 0, node);
      }
      return succeed17({
        node,
        body,
        returnType
      });
    },
    "TypeParser.emptyFunction",
    (node) => node
  );
  const pipingFlows = (includeEffectFn) => cachedBy(
    fn2("TypeParser.pipingFlows")(function* (sourceFile) {
      const result = [];
      const workQueue = [[sourceFile, void 0]];
      while (workQueue.length > 0) {
        const [node, parentFlow] = workQueue.pop();
        if (ts.isCallExpression(node)) {
          const parsed = yield* pipe(
            pipeCall(node),
            map34((p3) => ({ _tag: "pipe", ...p3 })),
            orElse15(
              () => pipe(
                singleArgCall(node),
                map34((s) => ({ _tag: "call", ...s }))
              )
            ),
            option5
          );
          if (isSome2(parsed)) {
            const result2 = parsed.value;
            let transformations;
            let flowNode;
            let childrenToTraverse = [];
            if (result2._tag === "pipe") {
              const signature = typeChecker.getResolvedSignature(result2.node);
              const typeArguments = signature ? typeChecker.getTypeArgumentsForResolvedSignature(signature) : void 0;
              transformations = [];
              for (let i = 0; i < result2.args.length; i++) {
                const arg = result2.args[i];
                const outType = typeArguments?.[i + 1];
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    // e.g., Effect.map
                    args: Array.from(arg.arguments),
                    // e.g., [(x) => x + 1]
                    outType,
                    kind: result2.kind
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    // e.g., Effect.asVoid
                    args: void 0,
                    outType,
                    kind: result2.kind
                  });
                }
              }
              flowNode = result2.node;
              childrenToTraverse = result2.args;
            } else {
              const callSignature = typeChecker.getResolvedSignature(node);
              const outType = callSignature ? typeChecker.getReturnTypeOfSignature(callSignature) : void 0;
              transformations = [{
                callee: result2.callee,
                args: void 0,
                outType,
                kind: "call"
              }];
              flowNode = node;
            }
            if (parentFlow) {
              parentFlow.transformations.unshift(...transformations);
              parentFlow.subject = {
                node: result2.subject,
                outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
              };
              workQueue.push([result2.subject, parentFlow]);
            } else {
              const newFlow = {
                node: flowNode,
                subject: {
                  node: result2.subject,
                  outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
                },
                transformations
              };
              workQueue.push([result2.subject, newFlow]);
            }
            for (const child of childrenToTraverse) {
              ts.forEachChild(child, (c) => {
                workQueue.push([c, void 0]);
              });
            }
            continue;
          }
          if (includeEffectFn) {
            const effectFnGenParsed = yield* pipe(effectFnGen(node), option5);
            const effectFnUntracedGenParsed = isNone2(effectFnGenParsed) ? yield* pipe(effectFnUntracedGen(node), option5) : none2();
            const effectFnNonGenParsed = isNone2(effectFnGenParsed) && isNone2(effectFnUntracedGenParsed) ? yield* pipe(effectFn(node), option5) : none2();
            const isEffectFnGen = isSome2(effectFnGenParsed);
            const isEffectFnUntracedGen = isSome2(effectFnUntracedGenParsed);
            const isEffectFnNonGen = isSome2(effectFnNonGenParsed);
            const transformationKind = isEffectFnUntracedGen ? "effectFnUntraced" : "effectFn";
            if (isEffectFnGen || isEffectFnUntracedGen) {
              const effectFnParsed = isEffectFnGen ? effectFnGenParsed : effectFnUntracedGenParsed;
              if (isSome2(effectFnParsed) && effectFnParsed.value.pipeArguments.length > 0) {
                const fnResult = effectFnParsed.value;
                const pipeArgs = fnResult.pipeArguments;
                const transformations = [];
                let subjectType;
                for (let i = 0; i < pipeArgs.length; i++) {
                  const arg = pipeArgs[i];
                  const contextualType = typeChecker.getContextualType(arg);
                  const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                  const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                  if (i === 0 && callSigs.length > 0) {
                    const params = callSigs[0].parameters;
                    if (params.length > 0) {
                      subjectType = typeChecker.getTypeOfSymbol(params[0]);
                    }
                  }
                  if (ts.isCallExpression(arg)) {
                    transformations.push({
                      callee: arg.expression,
                      args: Array.from(arg.arguments),
                      outType,
                      kind: transformationKind
                    });
                  } else {
                    transformations.push({
                      callee: arg,
                      args: void 0,
                      outType,
                      kind: transformationKind
                    });
                  }
                }
                const newFlow = {
                  node,
                  subject: {
                    node,
                    outType: subjectType
                  },
                  transformations
                };
                result.push(newFlow);
                workQueue.push([fnResult.body, void 0]);
                for (const arg of pipeArgs) {
                  ts.forEachChild(arg, (c) => {
                    workQueue.push([c, void 0]);
                  });
                }
                continue;
              }
            }
            if (isEffectFnNonGen && isSome2(effectFnNonGenParsed) && effectFnNonGenParsed.value.pipeArguments.length > 0) {
              const fnResult = effectFnNonGenParsed.value;
              const pipeArgs = fnResult.pipeArguments;
              const transformations = [];
              let subjectType;
              for (let i = 0; i < pipeArgs.length; i++) {
                const arg = pipeArgs[i];
                const contextualType = typeChecker.getContextualType(arg);
                const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                if (i === 0 && callSigs.length > 0) {
                  const params = callSigs[0].parameters;
                  if (params.length > 0) {
                    subjectType = typeChecker.getTypeOfSymbol(params[0]);
                  }
                }
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    args: Array.from(arg.arguments),
                    outType,
                    kind: "effectFn"
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    args: void 0,
                    outType,
                    kind: "effectFn"
                  });
                }
              }
              const newFlow = {
                node,
                subject: {
                  node,
                  outType: subjectType
                },
                transformations
              };
              result.push(newFlow);
              const regularFn = fnResult.regularFunction;
              if (ts.isArrowFunction(regularFn)) {
                if (ts.isBlock(regularFn.body)) {
                  workQueue.push([regularFn.body, void 0]);
                } else {
                  workQueue.push([regularFn.body, void 0]);
                }
              } else if (regularFn.body) {
                workQueue.push([regularFn.body, void 0]);
              }
              for (const arg of pipeArgs) {
                ts.forEachChild(arg, (c) => {
                  workQueue.push([c, void 0]);
                });
              }
              continue;
            }
          }
        }
        if (parentFlow && parentFlow.transformations.length > 0) {
          result.push(parentFlow);
        }
        ts.forEachChild(node, (child) => {
          workQueue.push([child, void 0]);
        });
      }
      result.sort((a, b) => a.node.pos - b.node.pos);
      return result;
    }),
    `TypeParser.pipingFlows(${includeEffectFn})`,
    (sourceFile) => sourceFile
  );
  const reconstructPipingFlow = (flow2) => {
    if (flow2.transformations.length > 0 && flow2.transformations.every((t) => t.kind === "effectFn" || t.kind === "effectFnUntraced")) {
      return flow2.subject.node;
    }
    let result = flow2.subject.node;
    for (const t of flow2.transformations) {
      if (t.kind === "call") {
        result = ts.factory.createCallExpression(
          t.callee,
          void 0,
          [result]
        );
      } else if (t.kind === "effectFn" || t.kind === "effectFnUntraced") {
        continue;
      } else {
        if (t.args) {
          const transformCall = ts.factory.createCallExpression(
            t.callee,
            void 0,
            t.args
          );
          result = ts.factory.createCallExpression(
            transformCall,
            void 0,
            [result]
          );
        } else {
          result = ts.factory.createCallExpression(
            t.callee,
            void 0,
            [result]
          );
        }
      }
    }
    return result;
  };
  return {
    isNodeReferenceToEffectModuleApi,
    isNodeReferenceToEffectSchemaModuleApi,
    isNodeReferenceToEffectParseResultModuleApi,
    isNodeReferenceToEffectDataModuleApi,
    isNodeReferenceToEffectContextModuleApi,
    isNodeReferenceToEffectSqlModelModuleApi,
    isNodeReferenceToEffectLayerModuleApi,
    effectType,
    strictEffectType,
    layerType,
    fiberType,
    effectSubtype,
    importedEffectModule,
    effectGen,
    effectFnUntracedGen,
    effectFnGen,
    findEnclosingScopes,
    effectFn,
    extendsCauseYieldableError,
    unnecessaryEffectGen: unnecessaryEffectGen2,
    effectSchemaType,
    contextTag,
    pipeableType,
    pipeCall,
    singleArgCall,
    scopeType,
    promiseLike,
    extendsEffectTag,
    extendsEffectService,
    extendsContextTag,
    extendsSchemaClass,
    extendsSchemaTaggedClass,
    extendsSchemaTaggedError,
    extendsDataTaggedError,
    extendsDataTaggedClass,
    extendsSchemaTaggedRequest,
    extendsEffectSqlModelClass,
    lazyExpression,
    emptyFunction,
    pipingFlows,
    reconstructPipingFlow
  };
}

// src/refactors/writeTagClassAccessors.ts
var generate = fn2("writeTagClassAccessors.generate")(function* (sourceFile, service3, className, atLocation, involvedMembers) {
  const ts = yield* service2(TypeScriptApi);
  const tsUtils = yield* service2(TypeScriptUtils);
  const typeChecker = yield* service2(TypeCheckerApi);
  const typeParser = yield* service2(TypeParser);
  const changeTracker = yield* service2(ChangeTracker);
  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1;
  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Effect"
  ) || "Effect";
  const createFunctionProperty = (className2, propertyName, type2, forceAny) => {
    const arrowBody = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectIdentifier),
        "andThen"
      ),
      void 0,
      [
        ts.factory.createIdentifier(ts.idText(className2)),
        ts.factory.createArrowFunction(
          void 0,
          void 0,
          [ts.factory.createParameterDeclaration(
            void 0,
            void 0,
            "_",
            void 0,
            forceAny ? ts.factory.createTypeReferenceNode("any") : void 0
          )],
          void 0,
          void 0,
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createIdentifier("_"),
              propertyName
            ),
            void 0,
            [
              ts.factory.createSpreadElement(ts.factory.createIdentifier("args"))
            ]
          )
        )
      ]
    );
    return ts.factory.createPropertyDeclaration(
      [
        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),
        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)
      ],
      propertyName,
      void 0,
      type2,
      ts.factory.createArrowFunction(
        void 0,
        void 0,
        [ts.factory.createParameterDeclaration(
          void 0,
          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),
          "args",
          void 0,
          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode("any")) : void 0
        )],
        void 0,
        void 0,
        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode("any")) : arrowBody
      )
    );
  };
  const generateReturnType = (type2, atLocation2, className2) => pipe(
    typeParser.effectType(type2, atLocation2),
    flatMap18((returnedEffect) => {
      const contextType = returnedEffect.R.flags & ts.TypeFlags.Never ? ts.factory.createTypeReferenceNode(ts.idText(className2)) : ts.factory.createUnionTypeNode(
        [
          ts.factory.createTypeReferenceNode(ts.idText(className2)),
          typeChecker.typeToTypeNode(returnedEffect.R, atLocation2, ts.NodeBuilderFlags.NoTruncation)
        ]
      );
      const successType = typeChecker.typeToTypeNode(
        returnedEffect.A,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!successType) return fail18("error generating success type");
      const failureType = typeChecker.typeToTypeNode(
        returnedEffect.E,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!failureType) return fail18("error generating failure type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [successType, failureType, contextType]
      );
      return succeed17(typeNode);
    }),
    orElse15(
      () => pipe(
        typeParser.promiseLike(type2, atLocation2),
        flatMap18(({ type: type3 }) => {
          const successType = typeChecker.typeToTypeNode(
            type3,
            atLocation2,
            ts.NodeBuilderFlags.NoTruncation
          );
          if (!successType) return fail18("error generating success type");
          return succeed17(ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectIdentifier),
              ts.factory.createIdentifier("Effect")
            ),
            [
              successType,
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier("Cause"),
                  ts.factory.createIdentifier("UnknownException")
                )
              ),
              ts.factory.createTypeReferenceNode(ts.idText(className2))
            ]
          ));
        })
      )
    ),
    orElse15(() => {
      const successType = typeChecker.typeToTypeNode(type2, atLocation2, ts.NodeBuilderFlags.NoTruncation);
      if (!successType) return fail18("error generating success type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [
          successType,
          ts.factory.createTypeReferenceNode("never"),
          ts.factory.createTypeReferenceNode(ts.idText(className2))
        ]
      );
      return succeed17(typeNode);
    })
  );
  const proxySignature = (signature, atLocation2, className2) => gen3(function* () {
    const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(
      signature,
      ts.SyntaxKind.FunctionType,
      atLocation2,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!signatureDeclaration) return yield* fail18("error generating signature");
    const returnType = yield* generateReturnType(
      typeChecker.getReturnTypeOfSignature(signature),
      atLocation2,
      className2
    );
    return ts.factory.createFunctionTypeNode(
      signatureDeclaration.typeParameters,
      signatureDeclaration.parameters,
      returnType
    );
  });
  for (const { property, propertyType } of involvedMembers) {
    const callSignatures = [];
    let propertyDeclaration = void 0;
    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {
      yield* pipe(
        proxySignature(signature, atLocation, className),
        map34((sig) => {
          callSignatures.push(sig);
        }),
        ignore3
      );
    }
    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures);
    const type2 = tsUtils.simplifyTypeNode(allSignatures);
    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type2, callSignatures.length > 1);
    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p3) => {
      const symbol3 = typeChecker.getSymbolAtLocation(p3.name);
      return symbol3 && ts.symbolName(symbol3) === ts.symbolName(property);
    });
    if (oldProperty) {
      const start4 = ts.getTokenPosOfNode(oldProperty, sourceFile);
      changeTracker.deleteRange(sourceFile, {
        pos: start4,
        end: oldProperty.end
      });
      changeTracker.insertNodeAt(sourceFile, start4, propertyDeclaration);
    } else {
      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: "\n" });
    }
  }
});
var parse5 = fn2("writeTagClassAccessors.parse")(function* (node) {
  const ts = yield* service2(TypeScriptApi);
  const typeChecker = yield* service2(TypeCheckerApi);
  const typeParser = yield* service2(TypeParser);
  const typeCheckerUtils = yield* service2(TypeCheckerUtils);
  if (!ts.isClassDeclaration(node)) return yield* fail18("not a class declaration");
  const { Service, accessors: accessors2, className, kind } = yield* pipe(
    map34(typeParser.extendsEffectService(node), (_) => ({ kind: "effectService", ..._ })),
    orElse15(
      () => map34(typeParser.extendsEffectTag(node), (_) => ({ kind: "effectTag", accessors: true, ..._ }))
    ),
    orElse15(() => fail18("not a class extending Effect.Service call"))
  );
  if (accessors2 !== true) return yield* fail18("accessors are not enabled in the Effect.Service call");
  const involvedMembers = [];
  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter(
    (_) => !(_.flags & ts.TypeFlags.Number || _.flags & ts.TypeFlags.String || _.flags & ts.TypeFlags.Boolean || _.flags & ts.TypeFlags.Literal)
  );
  if (nonPrimitiveServices.length === 0) return yield* fail18("Service type is a primitive type");
  for (const serviceShape of nonPrimitiveServices) {
    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {
      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node);
      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call);
      if (callSignatures.length > 0) {
        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0);
        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType });
      }
    }
  }
  const hash2 = involvedMembers.map(({ property, propertyType }) => {
    return ts.symbolName(property) + ": " + typeChecker.typeToString(propertyType);
  }).concat([ts.idText(className)]).join("\n");
  return { Service, className, atLocation: node, hash: cyrb53(hash2), involvedMembers, kind };
});
var writeTagClassAccessors = createRefactor({
  name: "writeTagClassAccessors",
  description: "Implement accessors methods with generics or multiple signatures",
  apply: fn2("writeTagClassAccessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const parseNode = (node) => pipe(
      parse5(node),
      map34(({ Service, atLocation, className, involvedMembers }) => ({
        kind: "refactor.rewrite.effect.writeTagClassAccessors",
        description: "Implement Service accessors",
        apply: pipe(
          generate(sourceFile, Service, className, atLocation, involvedMembers),
          provideService7(TypeScriptUtils, tsUtils),
          provideService7(TypeParser, typeParser),
          provideService7(TypeCheckerApi, typeChecker),
          provideService7(TypeScriptApi, ts)
        )
      }))
    );
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf2(parentNodes.map(parseNode)),
      orElse15(() => fail18(new RefactorNotApplicableError()))
    );
  })
});

// src/codegens/accessors.ts
var accessors = createCodegen({
  name: "accessors",
  apply: fn2("accessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail18(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse5(nodeAndCommentRange.node),
      map34(
        (_) => ({
          hash: _.hash,
          description: "Generate accessors for the service",
          apply: pipe(
            generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),
            provideService7(TypeScriptApi, ts),
            provideService7(TypeScriptUtils, tsUtils),
            provideService7(TypeCheckerApi, typeChecker),
            provideService7(TypeParser, typeParser),
            provideService7(TypeCheckerUtils, typeCheckerUtils)
          )
        })
      ),
      orElse15((cause2) => fail18(new CodegenNotApplicableError(cause2)))
    );
  })
});

// src/codegens/annotate.ts
var annotate3 = createCodegen({
  name: "annotate",
  apply: fn2("annotate.apply")(function* (sourceFile, textRange) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const parse6 = (node) => gen3(function* () {
      let variableDeclarations = [];
      const result = [];
      if (ts.isVariableStatement(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarationList.declarations];
      } else if (ts.isVariableDeclarationList(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarations];
      } else if (ts.isVariableDeclaration(node)) {
        variableDeclarations = [...variableDeclarations, node];
      }
      if (variableDeclarations.length === 0) {
        return yield* fail18(new CodegenNotApplicableError("not a variable declaration"));
      }
      for (const variableDeclaration of variableDeclarations) {
        if (!variableDeclaration.initializer) continue;
        const initializerType = typeCheckerUtils.getTypeAtLocation(variableDeclaration.initializer);
        if (!initializerType) continue;
        const enclosingNode = ts.findAncestor(variableDeclaration, (_) => tsUtils.isDeclarationKind(_.kind)) || sourceFile;
        const initializerTypeNode = fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
          initializerType,
          enclosingNode,
          ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.IgnoreErrors
        )).pipe(
          getOrUndefined
        );
        if (!initializerTypeNode) continue;
        const typeNodeString = typeChecker.typeToString(initializerType, void 0, ts.TypeFormatFlags.NoTruncation);
        const hash3 = cyrb53(typeNodeString);
        result.push({ variableDeclaration, initializerTypeNode, hash: hash3 });
      }
      if (result.length === 0) {
        return yield* fail18(new CodegenNotApplicableError("no variable declarations with initializers"));
      }
      const hash2 = cyrb53(result.map((_) => _.hash).join("/"));
      return {
        hash: hash2,
        result
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail18(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse6(nodeAndCommentRange.node),
      map34(
        (_) => ({
          hash: _.hash,
          description: "Annotate with type",
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            for (const { initializerTypeNode, variableDeclaration } of _.result) {
              if (variableDeclaration.type) {
                changeTracker.deleteRange(sourceFile, {
                  pos: variableDeclaration.name.end,
                  end: variableDeclaration.type.end
                });
              }
              changeTracker.insertNodeAt(
                sourceFile,
                variableDeclaration.name.end,
                initializerTypeNode,
                {
                  prefix: ": "
                }
              );
            }
          })
        })
      )
    );
  })
});

// src/utils/StructuralSchemaGen.ts
var UnsupportedTypeError = class {
  constructor(type2, reason) {
    this.type = type2;
    this.reason = reason;
  }
  _tag = "@effect/language-service/UnsupportedTypeError";
  toString() {
    return `Unsupported type: ${this.reason}`;
  }
};
var StructuralSchemaGenContext = Tag4("StructuralSchemaGenContext");
var makeStructuralSchemaGenContext = fn2("StructuralSchemaGen.makeContext")(
  function* (sourceFile, schemaIdentifier) {
    const ts = yield* service2(TypeScriptApi);
    const program = yield* service2(TypeScriptProgram);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const effectSchemaIdentifier = schemaIdentifier || "Schema";
    return identity({
      ts,
      program,
      typeChecker,
      typeCheckerUtils,
      sourceFile,
      createApiPropertyAccess: (apiName) => ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaIdentifier),
        apiName
      ),
      createApiCall: (apiName, args3) => ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          ts.factory.createIdentifier(effectSchemaIdentifier),
          apiName
        ),
        [],
        args3
      ),
      hoistedSchemas: /* @__PURE__ */ new Map(),
      typeToStatementIndex: /* @__PURE__ */ new Map(),
      nameToType: /* @__PURE__ */ new Map(),
      usedGlobalIdentifiers: /* @__PURE__ */ new Map(),
      schemaStatements: [],
      rangesToDelete: []
    });
  }
);
var pushHoistedStatement = fn2("StructuralSchemaGen.pushHoistedStatement")(
  function* (ctx, name, type2, statement, createReference) {
    ctx.usedGlobalIdentifiers.set(name, (ctx.usedGlobalIdentifiers.get(name) || 0) + 1);
    ctx.schemaStatements.push(statement);
    ctx.typeToStatementIndex.set(type2, ctx.schemaStatements.length - 1);
    ctx.hoistedSchemas.set(type2, createReference);
  }
);
var pushHoistedVariableStatement = fn2("StructuralSchemaGen.pushHoistedVariableStatement")(
  function* (ts, ctx, name, type2, result) {
    return yield* pushHoistedStatement(
      ctx,
      name,
      type2,
      ts.factory.createVariableStatement(
        void 0,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(ts.factory.createIdentifier(name), void 0, void 0, result)],
          ts.NodeFlags.Const
        )
      ),
      () => ts.factory.createIdentifier(name)
    );
  }
);
var createProcessingContext = (maxDepth = 200) => ({
  depth: 0,
  maxDepth,
  hoistName: void 0
});
var processType = fn2(
  "StructuralSchemaGen.processType"
)(
  function* (type2, context7) {
    const processingContext = context7 || createProcessingContext();
    const { hoistedSchemas, nameToType, ts, typeChecker, usedGlobalIdentifiers } = yield* service2(
      StructuralSchemaGenContext
    );
    if (processingContext.depth >= processingContext.maxDepth) {
      return yield* fail18(new UnsupportedTypeError(type2, "Maximum depth exceeded"));
    }
    let hoistName = fromIterable(nameToType.entries()).find(([_, existingType]) => existingType === type2)?.[0];
    if (!hoistName && type2 && type2.symbol && type2.symbol.declarations && type2.symbol.declarations.length === 1) {
      const declaration = type2.symbol.declarations[0];
      if (ts.isInterfaceDeclaration(declaration)) {
        hoistName = ts.idText(declaration.name);
      } else if (declaration.parent && ts.isTypeAliasDeclaration(declaration.parent)) {
        hoistName = ts.idText(declaration.parent.name);
      }
      if (hoistName) {
        const existingType = nameToType.get(hoistName);
        const isSame = existingType && typeChecker.isTypeAssignableTo(type2, existingType) && typeChecker.isTypeAssignableTo(existingType, type2);
        if (!isSame) {
          const usedCount = usedGlobalIdentifiers.get(hoistName) || 0;
          usedGlobalIdentifiers.set(hoistName, usedCount + 1);
          hoistName = usedCount > 0 ? hoistName + "_" + usedCount : hoistName;
        }
      }
    }
    const nestedContext = {
      ...processingContext,
      depth: processingContext.depth + 1,
      hoistName
    };
    for (const [hoistedType, hoistedSchema] of hoistedSchemas.entries()) {
      if (hoistedType === type2 || typeChecker.isTypeAssignableTo(type2, hoistedType) && typeChecker.isTypeAssignableTo(hoistedType, type2)) {
        return hoistedSchema();
      }
    }
    const [schemaExpr, skipHoisting] = yield* processTypeImpl(type2, nestedContext);
    if (!skipHoisting && hoistName) {
      const ctx = yield* service2(StructuralSchemaGenContext);
      yield* pushHoistedVariableStatement(ts, ctx, hoistName, type2, schemaExpr);
      return ctx.hoistedSchemas.get(type2)();
    }
    return schemaExpr;
  }
);
var processTypeImpl = fn2(
  "StructuralSchemaGen.processTypeImpl"
)(
  function* (type2, context7) {
    const { createApiCall, createApiPropertyAccess, ts, typeChecker, typeCheckerUtils } = yield* service2(
      StructuralSchemaGenContext
    );
    if (type2.flags & ts.TypeFlags.String) {
      return [createApiPropertyAccess("String"), true];
    }
    if (type2.flags & ts.TypeFlags.Number) {
      return [createApiPropertyAccess("Number"), true];
    }
    if (type2.flags & ts.TypeFlags.Boolean) {
      return [createApiPropertyAccess("Boolean"), true];
    }
    if (type2.flags & ts.TypeFlags.BigInt) {
      return [createApiPropertyAccess("BigInt"), true];
    }
    if (type2.flags & ts.TypeFlags.Void) {
      return [createApiPropertyAccess("Void"), true];
    }
    if (type2.flags & ts.TypeFlags.Undefined) {
      return [createApiPropertyAccess("Undefined"), true];
    }
    if (type2.flags & ts.TypeFlags.Null) {
      return [createApiPropertyAccess("Null"), true];
    }
    if (type2.flags & ts.TypeFlags.Never) {
      return [createApiPropertyAccess("Never"), true];
    }
    if (type2.flags & ts.TypeFlags.Any) {
      return [createApiPropertyAccess("Any"), true];
    }
    if (type2.flags & ts.TypeFlags.Unknown) {
      return [createApiPropertyAccess("Unknown"), true];
    }
    if (type2.flags & ts.TypeFlags.StringLiteral) {
      const literalType = type2;
      return [createApiCall("Literal", [ts.factory.createStringLiteral(literalType.value)]), true];
    }
    if (type2.flags & ts.TypeFlags.NumberLiteral) {
      const literalType = type2;
      return [createApiCall("Literal", [ts.factory.createNumericLiteral(literalType.value)]), true];
    }
    if (type2.flags & ts.TypeFlags.BooleanLiteral) {
      const value5 = type2.intrinsicName === "true";
      return [createApiCall("Literal", [value5 ? ts.factory.createTrue() : ts.factory.createFalse()]), true];
    }
    if (typeCheckerUtils.isUnion(type2)) {
      return yield* processUnionType(type2.types, context7);
    }
    if (type2.flags & ts.TypeFlags.Intersection) {
      return yield* processIntersectionType(type2, context7);
    }
    if (typeChecker.isArrayType(type2)) {
      return yield* processArrayType(type2, context7);
    }
    if (typeChecker.isTupleType(type2)) {
      return yield* processTupleType(type2, context7);
    }
    if (type2.flags & ts.TypeFlags.Object) {
      const symbol3 = type2.symbol || type2.aliasSymbol;
      if (symbol3) {
        const typeName = typeChecker.symbolToString(symbol3);
        if (typeName === "Date") {
          return [createApiPropertyAccess("Date"), false];
        }
        if (typeName === "ReadonlyArray" || typeName === "Array") {
          return yield* processArrayType(type2, context7);
        }
      }
      const objectType = type2;
      return yield* processObjectType(objectType, context7);
    }
    return yield* fail18(
      new UnsupportedTypeError(
        type2,
        `Type with flags ${type2.flags} is not supported`
      )
    );
  }
);
var processUnionType = fn2(
  "StructuralSchemaGen.processUnionType"
)(
  function* (types, context7) {
    const { createApiCall, ts } = yield* service2(StructuralSchemaGenContext);
    const allLiterals = types.every(
      (t) => t.flags & ts.TypeFlags.StringLiteral || t.flags & ts.TypeFlags.NumberLiteral || t.flags & ts.TypeFlags.BooleanLiteral
    );
    if (allLiterals) {
      const literals = yield* all9(
        ...types.map((t) => processType(t, context7))
      );
      const literalValues = literals.map((expr) => {
        if (ts.isCallExpression(expr) && expr.arguments.length > 0) {
          return expr.arguments[0];
        }
        return expr;
      }).filter((arg) => arg !== void 0);
      return [createApiCall("Literal", literalValues), false];
    }
    const members = yield* all9(
      ...types.map((t) => processType(t, context7))
    );
    if (members.length === 1) {
      return [members[0], false];
    }
    return [createApiCall("Union", members), false];
  }
);
var processIntersectionType = fn2(
  "StructuralSchemaGen.processIntersectionType"
)(
  function* (type2, context7) {
    const { createApiCall, ts } = yield* service2(StructuralSchemaGenContext);
    const [firstSchema, ...otherSchemas] = yield* all9(
      ...type2.types.map((t) => processType(t, context7))
    );
    if (otherSchemas.length === 0) {
      return [firstSchema, false];
    }
    return [
      ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          firstSchema,
          "pipe"
        ),
        [],
        otherSchemas.map((schema) => createApiCall("extend", [schema]))
      ),
      false
    ];
  }
);
var processArrayType = fn2(
  "StructuralSchemaGen.processArrayType"
)(
  function* (type2, context7) {
    const { createApiCall, typeChecker, typeCheckerUtils } = yield* service2(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type2);
    if (typeArgs.length === 0) {
      return yield* fail18(new UnsupportedTypeError(type2, "Array type has no type arguments"));
    }
    const elementSchema = yield* processType(typeArgs[0], context7);
    const expr = createApiCall("Array", [elementSchema]);
    if (typeCheckerUtils.isReadonlyArrayType(type2)) return [expr, false];
    return [createApiCall("mutable", [expr]), false];
  }
);
var processTupleType = fn2(
  "StructuralSchemaGen.processTupleType"
)(
  function* (type2, context7) {
    const { createApiCall, typeChecker } = yield* service2(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type2);
    const elementSchemas = yield* all9(
      ...typeArgs.map((t) => processType(t, context7))
    );
    return [createApiCall("Tuple", elementSchemas), false];
  }
);
var processObjectType = fn2(
  "StructuralSchemaGen.processObjectType"
)(
  function* (type2, context7) {
    const {
      createApiCall,
      createApiPropertyAccess,
      program,
      ts,
      typeChecker,
      typeCheckerUtils
    } = yield* service2(
      StructuralSchemaGenContext
    );
    let hasRecords = false;
    const properties = typeChecker.getPropertiesOfType(type2);
    const propertyAssignments = [];
    for (const property of properties) {
      const propertyName = typeChecker.symbolToString(property);
      const propertyType = typeChecker.getTypeOfSymbol(property);
      const isOptional = (property.flags & ts.SymbolFlags.Optional) !== 0;
      let schemaExpr;
      if (isOptional) {
        if (program.getCompilerOptions().exactOptionalPropertyTypes) {
          if (typeCheckerUtils.isUnion(propertyType)) {
            const typeWithoutMissing = propertyType.types.filter((t) => !typeCheckerUtils.isMissingIntrinsicType(t));
            const [result, _] = yield* processUnionType(typeWithoutMissing, context7);
            schemaExpr = createApiCall("optionalWith", [
              result,
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("exact", ts.factory.createTrue())
              ])
            ]);
          }
        } else {
          schemaExpr = yield* processType(propertyType, context7);
          schemaExpr = createApiCall("optional", [schemaExpr]);
        }
      }
      if (!schemaExpr) {
        schemaExpr = yield* processType(propertyType, context7);
      }
      const propertyNameNode = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName) ? ts.factory.createIdentifier(propertyName) : ts.factory.createStringLiteral(propertyName);
      propertyAssignments.push(
        ts.factory.createPropertyAssignment(
          propertyNameNode,
          schemaExpr
        )
      );
    }
    const indexInfos = typeChecker.getIndexInfosOfType(type2);
    const args3 = [
      ts.factory.createObjectLiteralExpression(propertyAssignments, propertyAssignments.length > 0)
    ];
    for (const indexInfo of indexInfos) {
      hasRecords = true;
      const keyType = indexInfo.keyType;
      const valueType = indexInfo.type;
      const keySchema = yield* processType(keyType, context7);
      const valueSchema = yield* processType(valueType, context7);
      args3.push(
        ts.factory.createObjectLiteralExpression([
          ts.factory.createPropertyAssignment("key", keySchema),
          ts.factory.createPropertyAssignment("value", valueSchema)
        ])
      );
    }
    if (!hasRecords && context7.hoistName) {
      const ctx = yield* service2(StructuralSchemaGenContext);
      yield* pushHoistedStatement(
        ctx,
        context7.hoistName,
        type2,
        ts.factory.createClassDeclaration(
          void 0,
          ts.factory.createIdentifier(context7.hoistName),
          [],
          [ts.factory.createHeritageClause(
            ts.SyntaxKind.ExtendsKeyword,
            [
              ts.factory.createExpressionWithTypeArguments(
                ts.factory.createCallExpression(
                  ts.factory.createCallExpression(
                    createApiPropertyAccess("Class"),
                    [ts.factory.createTypeReferenceNode(
                      context7.hoistName
                    )],
                    [ts.factory.createStringLiteral(context7.hoistName)]
                  ),
                  [],
                  args3
                ),
                []
              )
            ]
          )],
          []
        ),
        () => ts.factory.createIdentifier(context7.hoistName)
      );
      return [ctx.hoistedSchemas.get(type2)(), true];
    }
    return [createApiCall("Struct", args3), propertyAssignments.length === 0];
  }
);
var findNodeToProcess = fn2("StructuralSchemaGen.findNodeToProcess")(
  function* (sourceFile, textRange) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter2((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),
      filter2((node) => tsUtils.isNodeInRange(textRange)(node.name)),
      filter2((node) => (node.typeParameters || []).length === 0),
      map4((node) => ({
        node,
        identifier: node.name,
        type: typeCheckerUtils.getTypeAtLocation(node.name),
        isExported: node.modifiers ? (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 : false
      })),
      filter2(({ type: type2 }) => !!type2),
      head
    );
  }
);
var process2 = fn2("StructuralSchemaGen.process")(
  function* (sourceFile, scope4, typeMap, isExported, handleCodegeneratedComments) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Schema") || "Schema";
    const ctx = yield* makeStructuralSchemaGenContext(sourceFile, schemaIdentifier);
    for (const [name, type2] of typeMap.entries()) {
      ctx.nameToType.set(name, type2);
    }
    if (handleCodegeneratedComments) {
      for (const declaration of sourceFile.statements) {
        const nodeText = sourceFile.text.slice(declaration.pos, declaration.end);
        if (!nodeText.toLowerCase().includes("@effect-schema-codegenerated")) continue;
        const interleavingRange = ctx.rangesToDelete.find(
          (range3) => range3.pos < declaration.end && range3.end > declaration.pos
        );
        if (interleavingRange) {
          interleavingRange.pos = Math.min(interleavingRange.pos, declaration.pos);
          interleavingRange.end = Math.max(interleavingRange.end, declaration.end);
        } else {
          ctx.rangesToDelete.push({
            pos: declaration.pos,
            end: declaration.end
          });
        }
      }
    }
    for (const symbol3 of typeChecker.getSymbolsInScope(scope4, ts.SymbolFlags.Value)) {
      const name = typeChecker.symbolToString(symbol3);
      ctx.usedGlobalIdentifiers.set(name, 1);
      const type2 = typeChecker.getTypeOfSymbolAtLocation(symbol3, sourceFile);
      if (type2) {
        const schemaType = yield* pipe(
          typeParser.effectSchemaType(type2, scope4),
          orElse15(() => void_8)
        );
        if (schemaType) {
          ctx.hoistedSchemas.set(
            schemaType.A,
            () => {
              const expression = typeChecker.symbolToExpression(
                symbol3,
                ts.SymbolFlags.Value,
                scope4,
                ts.NodeBuilderFlags.NoTruncation
              );
              if (expression) {
                return expression;
              }
              return ts.factory.createIdentifier(name);
            }
          );
        }
      }
    }
    const results = yield* pipe(
      all9(
        ...fromIterable(ctx.nameToType.entries()).map(
          ([name, type2]) => pipe(
            processType(type2),
            orElse15(
              (error4) => succeed17(ts.addSyntheticLeadingComment(
                ts.factory.createIdentifier(""),
                ts.SyntaxKind.MultiLineCommentTrivia,
                " " + String(error4) + " ",
                true
              ))
            ),
            map34((_) => ({ requestedName: name, type: type2, result: _ }))
          )
        )
      ),
      provideService7(StructuralSchemaGenContext, ctx)
    );
    for (const { requestedName, result, type: type2 } of results) {
      const statementIndex = ctx.typeToStatementIndex.get(type2);
      if (statementIndex !== void 0) continue;
      ctx.schemaStatements.push(ts.factory.createVariableStatement(
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            ts.factory.createIdentifier(requestedName),
            void 0,
            void 0,
            result
          )],
          ts.NodeFlags.Const
        )
      ));
      ctx.typeToStatementIndex.set(type2, ctx.schemaStatements.length - 1);
    }
    if (isExported) {
      const statementsToExport = pipe(
        fromIterable(ctx.nameToType),
        map4(([_, type2]) => ctx.typeToStatementIndex.get(type2)),
        filter2((index) => index !== void 0),
        dedupe
      );
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        if (!statementsToExport.includes(i)) continue;
        const statement = ctx.schemaStatements[i];
        if (ts.isVariableStatement(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateVariableStatement(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.declarationList
          );
        } else if (ts.isClassDeclaration(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateClassDeclaration(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.name,
            statement.typeParameters,
            statement.heritageClauses,
            statement.members
          );
        }
      }
    }
    if (handleCodegeneratedComments) {
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        const statement = ctx.schemaStatements[i];
        ctx.schemaStatements[i] = ts.addSyntheticLeadingComment(
          statement,
          ts.SyntaxKind.SingleLineCommentTrivia,
          " @effect-schema-codegenerated: This schema will be re-generated by the effect-schema-codegens command, remove this comment to disable re-generation.",
          true
        );
      }
    }
    return ctx;
  }
);
var applyAtNode = fn2("StructuralSchemaGen.applyAtNode")(
  function* (sourceFile, node, identifier2, type2, isExported) {
    const changeTracker = yield* service2(ChangeTracker);
    const ts = yield* service2(TypeScriptApi);
    const ctx = yield* process2(sourceFile, node, /* @__PURE__ */ new Map([[ts.idText(identifier2), type2]]), isExported, false);
    for (const statement of ctx.schemaStatements) {
      changeTracker.insertNodeAt(sourceFile, node.pos, statement, { prefix: "\n", suffix: "\n" });
    }
  }
);

// src/codegens/typeToSchema.ts
var typeToSchema = createCodegen({
  name: "typeToSchema",
  apply: fn2("typeToSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const program = yield* service2(TypeScriptProgram);
    const inThisFile = yield* getCodegensForSourceFile([typeToSchema], sourceFile);
    if (inThisFile.length > 1) {
      return yield* fail18(
        new CodegenNotApplicableError("the typeToSchema codegen can be used only once per file")
      );
    }
    const parse6 = (node) => gen3(function* () {
      if (!ts.isTypeAliasDeclaration(node)) {
        return yield* fail18(
          new CodegenNotApplicableError(
            "this codegen is applicable only to a type alias where each object member is a schema to generate. e.g. `type ToGenerate = { UserSchema: User, TodoSchema: Todo}`"
          )
        );
      }
      const type2 = typeCheckerUtils.getTypeAtLocation(node.name);
      if (!type2) {
        return yield* fail18(
          new CodegenNotApplicableError(
            "error getting the type to process"
          )
        );
      }
      const nameToType = /* @__PURE__ */ new Map();
      const typeProperties = typeChecker.getPropertiesOfType(type2);
      for (const symProp of typeProperties) {
        const symName = ts.symbolName(symProp);
        const propType = typeChecker.getTypeOfSymbolAtLocation(symProp, node);
        if (propType) nameToType.set(symName, propType);
      }
      const hash2 = pipe(
        fromIterable(nameToType),
        map4(([name, type3]) => {
          const typeString = typeChecker.typeToString(
            type3,
            node,
            ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.UseStructuralFallback
          );
          return name + ": " + typeString;
        }),
        join("\n"),
        cyrb53
      );
      return {
        hash: hash2,
        nameToType
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) {
      return yield* fail18(new CodegenNotApplicableError("no node and comment range affected"));
    }
    return yield* pipe(
      parse6(nodeAndCommentRange.node),
      map34(
        (_) => ({
          hash: _.hash,
          description: "Generate Schemas from types",
          apply: pipe(
            gen3(function* () {
              const changeTracker = yield* service2(ChangeTracker);
              const ctx = yield* process2(
                sourceFile,
                nodeAndCommentRange.node,
                _.nameToType,
                true,
                true
              );
              const pos = sourceFile.end;
              for (const range3 of ctx.rangesToDelete) {
                changeTracker.deleteRange(sourceFile, range3);
              }
              for (const statement of ctx.schemaStatements) {
                changeTracker.insertNodeAt(sourceFile, pos, statement, { prefix: "\n", suffix: "\n" });
              }
            }),
            provideService7(TypeScriptApi, ts),
            provideService7(TypeScriptUtils, tsUtils),
            provideService7(TypeCheckerApi, typeChecker),
            provideService7(TypeCheckerUtils, typeCheckerUtils),
            provideService7(TypeParser, typeParser),
            provideService7(TypeScriptProgram, program)
          )
        })
      )
    );
  })
});

// src/codegens.ts
var codegens = [accessors, annotate3, typeToSchema];

// src/cli/codegen.ts
var NoFilesToCodegenError = class extends TaggedError("NoFilesToCodegenError") {
  get message() {
    return "No files to codegen. Please provide an existing .ts file or a project tsconfig.json";
  }
};
var file4 = file3("file").pipe(
  optional4,
  withDescription3("The full path of the file to codegen.")
);
var project2 = file3("project").pipe(
  optional4,
  withDescription3("The full path of the project tsconfig.json file to codegen.")
);
var verbose = boolean5("verbose").pipe(
  withDefault3(false),
  withDescription3("Verbose output.")
);
var force = boolean5("force").pipe(
  withDefault3(false),
  withDescription3("Force codegen even if no changes are needed.")
);
var BATCH_SIZE = 50;
var codegen = make58(
  "codegen",
  { file: file4, project: project2, verbose, force },
  fn("codegen")(function* ({ file: file5, force: force3, project: project3, verbose: verbose2 }) {
    const path2 = yield* Path2;
    const fs = yield* FileSystem;
    const tsInstance = yield* TypeScriptContext;
    let filesToCodegen = /* @__PURE__ */ new Set();
    let checkedFilesCount = 0;
    let updatedFilesCount = 0;
    if (isSome2(project3)) {
      filesToCodegen = yield* getFileNamesInTsConfig(project3.value);
    }
    if (isSome2(file5)) {
      filesToCodegen.add(path2.resolve(file5.value));
    }
    if (filesToCodegen.size === 0) {
      return yield* new NoFilesToCodegenError();
    }
    const filesWithCodegenDirective = /* @__PURE__ */ new Set();
    for (const filePath of filesToCodegen) {
      const sourceText = yield* fs.readFileString(filePath);
      if (sourceText.toLowerCase().indexOf("@effect-codegens") !== -1) {
        filesWithCodegenDirective.add(filePath);
      }
    }
    if (filesWithCodegenDirective.size === 0) {
      return yield* new NoFilesToCodegenError();
    }
    const filesToCodegenArray = fromIterable(filesWithCodegenDirective);
    const batches = chunksOf(filesToCodegenArray, BATCH_SIZE);
    let lastLanguageService;
    const disposeIfLanguageServiceChanged = (languageService) => {
      if (lastLanguageService !== languageService) {
        lastLanguageService?.dispose();
        lastLanguageService = languageService;
      }
    };
    for (const batch of batches) {
      const { service: service3 } = (0, import_project_service.createProjectService)({ options: { loadTypeScriptPlugins: false } });
      for (const filePath of batch) {
        service3.openClientFile(filePath);
        try {
          const scriptInfo = service3.getScriptInfo(filePath);
          if (!scriptInfo) continue;
          const project4 = scriptInfo.getDefaultProject();
          const languageService = project4.getLanguageService(true);
          disposeIfLanguageServiceChanged(languageService);
          const program = languageService.getProgram();
          if (!program) continue;
          const sourceFile = program.getSourceFile(filePath);
          if (!sourceFile) continue;
          const pluginConfig = extractEffectLspOptions(program.getCompilerOptions());
          if (!pluginConfig) continue;
          const formatContext = tsInstance.formatting.getFormatContext(
            tsInstance.getDefaultFormatCodeSettings(project4.getNewLine()),
            project4
          );
          const allFileChanges = pipe(
            gen3(function* () {
              let allChanges = [];
              const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
              for (const { codegen: codegen2, hash: hash2, range: range3 } of codegensWithRanges) {
                const applicable = yield* pipe(
                  getEditsForCodegen([codegen2], sourceFile, range3),
                  orElse15(() => void_8)
                );
                if (applicable && (applicable.hash !== hash2 || force3)) {
                  const changes2 = tsInstance.textChanges.ChangeTracker.with(
                    {
                      formatContext,
                      host: project4,
                      preferences: {}
                    },
                    (changeTracker) => pipe(
                      applicable.apply,
                      provideService7(ChangeTracker, changeTracker),
                      run9
                    )
                  );
                  allChanges = [...allChanges, ...changes2];
                }
              }
              return allChanges;
            }),
            nanoLayer3,
            nanoLayer2,
            nanoLayer,
            provideService7(TypeCheckerApi, program.getTypeChecker()),
            provideService7(TypeScriptProgram, program),
            provideService7(TypeScriptApi, tsInstance),
            provideService7(
              LanguageServicePluginOptions,
              { ...parse4(pluginConfig), diagnosticsName: false }
            ),
            run9,
            getOrElse(() => [])
          );
          checkedFilesCount++;
          const thisFileChanges = allFileChanges.filter((change) => change.fileName === sourceFile.fileName);
          const flattenedChanges = flatten(thisFileChanges.map((change) => change.textChanges));
          if (verbose2) {
            if (flattenedChanges.length > 0) {
              console.log(`${filePath}: with ${flattenedChanges.length} changes`);
            } else {
              console.log(`${filePath}: no changes`);
            }
          }
          if (flattenedChanges.length === 0) continue;
          const sourceText = yield* fs.readFileString(filePath);
          const newSourceText = yield* applyTextChanges(sourceText, flattenedChanges);
          yield* fs.writeFileString(filePath, newSourceText);
          updatedFilesCount++;
        } finally {
          service3.closeClientFile(filePath);
        }
      }
      yield* yieldNow4();
    }
    disposeIfLanguageServiceChanged(void 0);
    console.log(
      `${filesToCodegen.size} involved files, of which ${filesWithCodegenDirective.size} with codegens.
${checkedFilesCount} checked and ${updatedFilesCount} updated.`
    );
  })
).pipe(
  withDescription6("Regenarate the outdated effect-codegens provided by the effect-language-service.")
);

// src/cli/diagnostics.ts
var import_project_service2 = __toESM(require_dist2());

// src/diagnostics/anyUnknownInErrorContext.ts
var anyUnknownInErrorContext = createDiagnostic({
  name: "anyUnknownInErrorContext",
  code: 28,
  description: "Detects 'any' or 'unknown' types in Effect error or requirements channels",
  severity: "off",
  apply: fn2("anyUnknownInErrorContext.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const isAnyOrUnknown = (type2) => (type2.flags & ts.TypeFlags.Any) > 0 || (type2.flags & ts.TypeFlags.Unknown) > 0;
    const matchingNodes = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.pop();
      if (ts.isTypeNode(node)) continue;
      if (ts.isTypeAliasDeclaration(node)) continue;
      if (ts.isInterfaceDeclaration(node)) continue;
      if (ts.isAsExpression(node) && node.type && node.type.kind === ts.SyntaxKind.AnyKeyword) {
        continue;
      }
      if (ts.isParameter(node) || ts.isPropertyDeclaration(node) || ts.isVariableDeclaration(node)) {
        if (node.type) {
          const typeNode = node.type;
          const type3 = typeCheckerUtils.getTypeAtLocation(node.type);
          if (!type3) continue;
          const expectedEffect = yield* pipe(
            typeParser.strictEffectType(type3, node.type),
            orElse15(() => typeParser.layerType(type3, typeNode)),
            orElse15(() => void_8)
          );
          if (expectedEffect) continue;
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isExpression(node)) continue;
      let type2 = typeCheckerUtils.getTypeAtLocation(node);
      if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          type2 = typeChecker.getReturnTypeOfSignature(resolvedSignature);
        }
      }
      if (!type2) continue;
      yield* pipe(
        typeParser.strictEffectType(type2, node),
        orElse15(() => pipe(typeParser.layerType(type2, node), map34(({ E, RIn }) => ({ E, R: RIn })))),
        map34((effectOrLayer) => {
          const { E, R } = effectOrLayer;
          const hasAnyUnknownR = isAnyOrUnknown(R);
          const hasAnyUnknownE = isAnyOrUnknown(E);
          if (hasAnyUnknownR || hasAnyUnknownE) {
            const channels = [];
            if (hasAnyUnknownR) {
              const typeName = R.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the requirements channel`);
            }
            if (hasAnyUnknownE) {
              const typeName = E.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the error channel`);
            }
            const nodeStart = ts.getTokenPosOfNode(node, sourceFile);
            const nodeEnd = node.end;
            for (let i = matchingNodes.length - 1; i >= 0; i--) {
              const existing = matchingNodes[i];
              const existingStart = ts.getTokenPosOfNode(existing.node, sourceFile);
              const existingEnd = existing.node.end;
              if (existingStart <= nodeStart && existingEnd >= nodeEnd) {
                matchingNodes.splice(i, 1);
              }
            }
            const suggestions = [`This has ${channels.join(" and ")} which is not recommended.`];
            if (hasAnyUnknownR) {
              suggestions.push(`Only service identifiers should appear in the requirements channel.`);
            }
            if (hasAnyUnknownE) {
              suggestions.push(
                `Having an unknown or any error type is not useful. Consider instead using specific error types baked by Data.TaggedError for example.`
              );
            }
            channels.push(`If you plan to later on manually cast the type, you can safely disable this diagnostic.`);
            const messageText = suggestions.join("\n");
            matchingNodes.push({ messageText, node, type: type2 });
          }
        }),
        ignore3
      );
    }
    for (const { messageText, node } of matchingNodes) {
      report({
        location: node,
        messageText,
        fixes: []
      });
    }
  })
});

// src/diagnostics/catchAllToMapError.ts
var catchAllToMapError = createDiagnostic({
  name: "catchAllToMapError",
  code: 39,
  description: "Suggests using Effect.mapError instead of Effect.catchAll when the callback only wraps the error with Effect.fail",
  severity: "suggestion",
  apply: fn2("catchAllToMapError.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const getFunctionBody = (node) => {
      if (ts.isArrowFunction(node)) {
        return node.body;
      }
      if (ts.isFunctionExpression(node)) {
        return node.body;
      }
      return void 0;
    };
    const getEffectFailCallInfo = (body) => {
      return gen3(function* () {
        if (ts.isCallExpression(body)) {
          const isFailCall = yield* pipe(
            typeParser.isNodeReferenceToEffectModuleApi("fail")(body.expression),
            option5
          );
          if (isSome2(isFailCall) && body.arguments.length >= 1) {
            return some2({ failCall: body, failArg: body.arguments[0] });
          }
        }
        if (ts.isBlock(body)) {
          const statements = body.statements;
          if (statements.length === 1) {
            const stmt = statements[0];
            if (ts.isReturnStatement(stmt) && stmt.expression && ts.isCallExpression(stmt.expression)) {
              const isFailCall = yield* pipe(
                typeParser.isNodeReferenceToEffectModuleApi("fail")(stmt.expression.expression),
                option5
              );
              if (isSome2(isFailCall) && stmt.expression.arguments.length >= 1) {
                return some2({ failCall: stmt.expression, failArg: stmt.expression.arguments[0] });
              }
            }
          }
        }
        return none2();
      });
    };
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchAllCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("catchAll")(transformation.callee),
          option5
        );
        if (isNone2(isCatchAllCall)) {
          continue;
        }
        const callback = transformation.args[0];
        if (!callback) continue;
        const functionBody = getFunctionBody(callback);
        if (!functionBody) continue;
        const failCallInfo = yield* getEffectFailCallInfo(functionBody);
        if (isNone2(failCallInfo)) continue;
        const { failArg, failCall } = failCallInfo.value;
        report({
          location: transformation.callee,
          messageText: `You can use Effect.mapError instead of Effect.catchAll + Effect.fail to transform the error type.`,
          fixes: [{
            fixName: "catchAllToMapError_fix",
            description: "Replace with Effect.mapError",
            apply: gen3(function* () {
              const changeTracker = yield* service2(ChangeTracker);
              if (ts.isPropertyAccessExpression(transformation.callee)) {
                changeTracker.replaceNode(
                  sourceFile,
                  transformation.callee.name,
                  ts.factory.createIdentifier("mapError")
                );
              }
              changeTracker.replaceNode(sourceFile, failCall, failArg);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/catchUnfailableEffect.ts
var catchUnfailableEffect = createDiagnostic({
  name: "catchUnfailableEffect",
  code: 2,
  description: "Warns when using error handling on Effects that never fail (error type is 'never')",
  severity: "suggestion",
  apply: fn2("catchUnfailableEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const catchFunctions = ["catchAll", "catch", "catchIf", "catchSome", "catchTag", "catchTags"];
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (let i = 0; i < flow2.transformations.length; i++) {
        const transformation = flow2.transformations[i];
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchCall = yield* pipe(
          firstSuccessOf2(
            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(transformation.callee))
          ),
          option5
        );
        if (isNone2(isCatchCall)) {
          continue;
        }
        const inputType = i === 0 ? flow2.subject.outType : flow2.transformations[i - 1].outType;
        if (!inputType) {
          continue;
        }
        const effectType = yield* pipe(
          typeParser.effectType(inputType, transformation.callee),
          option5
        );
        if (isSome2(effectType)) {
          const { E } = effectType.value;
          if (E.flags & ts.TypeFlags.Never) {
            report({
              location: transformation.callee,
              messageText: `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,
              fixes: []
            });
          }
        }
      }
    }
  })
});

// src/diagnostics/classSelfMismatch.ts
var classSelfMismatch = createDiagnostic({
  name: "classSelfMismatch",
  code: 20,
  description: "Ensures Self type parameter matches the class name in Service/Tag/Schema classes",
  severity: "error",
  apply: fn2("classSelfMismatch.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse15(() => typeParser.extendsContextTag(node)),
          orElse15(() => typeParser.extendsEffectTag(node)),
          orElse15(() => typeParser.extendsSchemaClass(node)),
          orElse15(() => typeParser.extendsSchemaTaggedClass(node)),
          orElse15(() => typeParser.extendsSchemaTaggedError(node)),
          orElse15(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse15(() => typeParser.extendsEffectSqlModelClass(node)),
          orElse15(() => void_8)
        );
        if (result) {
          const { className, selfTypeNode } = result;
          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end);
          if (ts.isTypeReferenceNode(selfTypeNode)) {
            if (ts.isIdentifier(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName);
            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName.right);
            }
          }
          const expectedName = ts.idText(className);
          if (actualName !== expectedName) {
            report({
              location: selfTypeNode,
              messageText: `Self type parameter should be '${expectedName}'`,
              fixes: [{
                fixName: "classSelfMismatch_fix",
                description: `Replace '${actualName}' with '${expectedName}'`,
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : void 0;
                  const newTypeReference = ts.factory.createTypeReferenceNode(
                    ts.factory.createIdentifier(expectedName),
                    typeArgs
                  );
                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/core/KeyBuilder.ts
var makeKeyBuilder = fn2("KeyBuilder")(
  function* (sourceFile) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const program = yield* service2(TypeScriptProgram);
    const options3 = yield* service2(LanguageServicePluginOptions);
    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    function createString2(classNameText, kind) {
      if (!packageInfo) return;
      for (const keyPattern of options3.keyPatterns) {
        if (keyPattern.target !== kind) continue;
        const lastIndex = sourceFile.fileName.lastIndexOf("/");
        let onlyFileName = lastIndex === -1 ? "" : sourceFile.fileName.slice(lastIndex + 1);
        const lastExtensionIndex = onlyFileName.lastIndexOf(".");
        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex);
        if (onlyFileName.toLowerCase().endsWith("/index")) onlyFileName = onlyFileName.slice(0, -6);
        if (onlyFileName.startsWith("/")) onlyFileName = onlyFileName.slice(1);
        let subDirectory = getDirectoryPath(ts, sourceFile.fileName);
        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue;
        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length);
        if (!subDirectory.endsWith("/")) subDirectory = subDirectory + "/";
        if (subDirectory.startsWith("/")) subDirectory = subDirectory.slice(1);
        for (const prefix of keyPattern.skipLeadingPath) {
          if (subDirectory.startsWith(prefix)) {
            subDirectory = subDirectory.slice(prefix.length);
            break;
          }
        }
        let parts2 = [packageInfo.name, subDirectory, onlyFileName].concat(
          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
        );
        if (keyPattern.pattern === "package-identifier") {
          parts2 = [packageInfo.name, onlyFileName].concat(
            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
          );
        }
        parts2 = parts2.map((part) => part.startsWith("/") ? part.slice(1) : part).map(
          (part) => part.endsWith("/") ? part.slice(0, -1) : part
        );
        const fullKey = parts2.filter((_) => String(_).trim().length > 0).join("/");
        return keyPattern.pattern === "default-hashed" ? cyrb53(fullKey) : fullKey;
      }
    }
    return {
      createString: createString2
    };
  }
);
var keyBuilderCache = /* @__PURE__ */ new Map();
var getOrMakeKeyBuilder = fn2("getOrMakeKeyBuilder")(function* (sourceFile) {
  while (keyBuilderCache.size > 5) {
    const oldest = keyBuilderCache.keys().next().value;
    if (oldest) keyBuilderCache.delete(oldest);
  }
  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) || (yield* makeKeyBuilder(sourceFile));
  keyBuilderCache.set(sourceFile.fileName, keyBuilder);
  return keyBuilder;
});
function createString(sourceFile, identifier2, kind) {
  return map34(
    getOrMakeKeyBuilder(sourceFile),
    (identifierBuilder) => identifierBuilder.createString(identifier2, kind)
  );
}

// src/diagnostics/deterministicKeys.ts
var deterministicKeys = createDiagnostic({
  name: "deterministicKeys",
  code: 25,
  description: "Enforces deterministic naming for service/tag/error identifiers based on class names",
  severity: "off",
  apply: fn2("deterministicKeys.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeScriptUtils = yield* service2(TypeScriptUtils);
    const options3 = yield* service2(LanguageServicePluginOptions);
    const parseExtendsCustom = cachedBy(
      fn2("parseExtendsCustom")(function* (classDeclaration) {
        if (!options3.extendedKeyDetection) {
          return yield* typeParserIssue("Extended key detection is disabled", void 0, classDeclaration);
        }
        if (!classDeclaration.name) {
          return yield* typeParserIssue("Class has no name", void 0, classDeclaration);
        }
        if (!ts.isIdentifier(classDeclaration.name)) {
          return yield* typeParserIssue("Class name is not an identifier", void 0, classDeclaration);
        }
        const heritageClauses = classDeclaration.heritageClauses;
        if (!heritageClauses) {
          return yield* typeParserIssue("Class has no heritage clauses", void 0, classDeclaration);
        }
        const nodeToVisit2 = [...classDeclaration.heritageClauses];
        const appendNodeToVisit2 = (node) => {
          nodeToVisit2.push(node);
          return void 0;
        };
        while (nodeToVisit2.length > 0) {
          const node = nodeToVisit2.shift();
          if (ts.isCallExpression(node)) {
            for (let i = 0; i < node.arguments.length; i++) {
              const arg = node.arguments[i];
              if (!ts.isStringLiteral(arg)) continue;
              const resolvedSignature = typeChecker.getResolvedSignature(node);
              if (resolvedSignature) {
                const parameter = resolvedSignature.parameters[i];
                if (!parameter) continue;
                if (parameter.declarations) {
                  for (const declaration of parameter.declarations) {
                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration);
                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end);
                    if (paramText.toLowerCase().includes("@effect-identifier")) {
                      return { className: classDeclaration.name, keyStringLiteral: arg, target: "custom" };
                    }
                  }
                }
              }
            }
          }
          ts.forEachChild(node, appendNodeToVisit2);
        }
        return yield* typeParserIssue(
          "Class does not extend any custom pattern",
          void 0,
          classDeclaration
        );
      }),
      "deterministicKeys.parseExtendsCustom",
      (classDeclaration) => classDeclaration
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          pipe(
            typeParser.extendsEffectService(node),
            orElse15(() => typeParser.extendsContextTag(node)),
            orElse15(() => typeParser.extendsEffectTag(node)),
            map34(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "service" }))
          ),
          orElse15(
            () => pipe(
              typeParser.extendsDataTaggedError(node),
              orElse15(() => typeParser.extendsSchemaTaggedError(node)),
              map34(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "error" }))
            )
          ),
          orElse15(() => parseExtendsCustom(node)),
          orElse15(() => void_8)
        );
        if (result && result.keyStringLiteral) {
          const { className, keyStringLiteral, target } = result;
          const classNameText = ts.idText(className);
          const expectedKey = yield* createString(sourceFile, classNameText, target);
          if (!expectedKey) continue;
          const actualIdentifier = keyStringLiteral.text;
          if (actualIdentifier !== expectedKey) {
            report({
              location: keyStringLiteral,
              messageText: `Key should be '${expectedKey}'`,
              fixes: [{
                fixName: "deterministicKeys_fix",
                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey);
                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/duplicatePackage.ts
var checkedPackagesCache = /* @__PURE__ */ new Map();
var programResolvedCacheSize = /* @__PURE__ */ new Map();
var duplicatePackage = createDiagnostic({
  name: "duplicatePackage",
  code: 6,
  description: "Detects when multiple versions of the same Effect package are loaded",
  severity: "warning",
  apply: fn2("duplicatePackage.apply")(function* (sourceFile, report) {
    const program = yield* service2(TypeScriptProgram);
    const tsUtils = yield* service2(TypeScriptUtils);
    const options3 = yield* service2(LanguageServicePluginOptions);
    if (sourceFile.statements.length < 1) return;
    let resolvedPackages = checkedPackagesCache.get(sourceFile.fileName) || {};
    const newResolvedModuleSize = hasProperty(program, "resolvedModules") && hasProperty(program.resolvedModules, "size") && isNumber(program.resolvedModules.size) ? program.resolvedModules.size : 0;
    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1;
    if (newResolvedModuleSize !== oldResolvedSize) {
      const seenPackages = /* @__PURE__ */ new Set();
      resolvedPackages = {};
      program.getSourceFiles().map((_) => {
        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_);
        if (!packageInfo) return;
        const packageNameAndVersion = packageInfo.name + "@" + packageInfo.version;
        if (seenPackages.has(packageNameAndVersion)) return;
        seenPackages.add(packageNameAndVersion);
        if (!(packageInfo.name === "effect" || packageInfo.hasEffectInPeerDependencies)) return;
        if (options3.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return;
        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {};
        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory;
      });
      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages);
      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize);
    }
    for (const packageName of Object.keys(resolvedPackages)) {
      if (Object.keys(resolvedPackages[packageName]).length > 1) {
        const versions = Object.keys(resolvedPackages[packageName]);
        report({
          location: sourceFile.statements[0],
          messageText: `Package ${packageName} is referenced multiple times with different versions (${versions.join(", ")}) and may cause unexpected type errors.
Cleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.
If this is intended set the LSP config "allowedDuplicatedPackages" to ${JSON.stringify(options3.allowedDuplicatedPackages.concat([packageName]))}.

${versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join("\n")}`,
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/effectFnIife.ts
var effectFnIife = createDiagnostic({
  name: "effectFnIife",
  code: 46,
  description: "Effect.fn or Effect.fnUntraced is called as an IIFE (Immediately Invoked Function Expression). Use Effect.gen instead.",
  severity: "warning",
  apply: fn2("effectFnIife.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const innerCall = node.expression;
      if (!ts.isCallExpression(innerCall)) continue;
      const parsed = yield* pipe(
        typeParser.effectFnGen(innerCall),
        map34((result) => ({
          kind: "fn",
          effectModule: result.effectModule,
          generatorFunction: result.generatorFunction,
          pipeArguments: result.pipeArguments,
          traceExpression: result.traceExpression
        })),
        orElse15(
          () => pipe(
            typeParser.effectFnUntracedGen(innerCall),
            map34((result) => ({
              kind: "fnUntraced",
              effectModule: result.effectModule,
              generatorFunction: result.generatorFunction,
              pipeArguments: result.pipeArguments,
              traceExpression: void 0
            }))
          )
        ),
        orElse15(
          () => pipe(
            typeParser.effectFn(innerCall),
            map34((result) => ({
              kind: "fn",
              effectModule: result.effectModule,
              generatorFunction: void 0,
              pipeArguments: result.pipeArguments,
              traceExpression: result.traceExpression
            }))
          )
        ),
        option5
      );
      if (isNone2(parsed)) continue;
      const { effectModule, generatorFunction, kind, pipeArguments: pipeArguments2, traceExpression } = parsed.value;
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      const fixes = [];
      if (generatorFunction && generatorFunction.parameters.length === 0) {
        fixes.push({
          fixName: "effectFnIife_toEffectGen",
          description: "Convert to Effect.gen",
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const effectGenCall = ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleName),
                "gen"
              ),
              void 0,
              [generatorFunction]
            );
            let replacementNode = effectGenCall;
            if (pipeArguments2.length > 0) {
              replacementNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(effectGenCall, "pipe"),
                void 0,
                [...pipeArguments2]
              );
            }
            changeTracker.replaceNode(sourceFile, node, replacementNode);
          })
        });
      }
      const traceExpressionText = traceExpression ? sourceFile.text.slice(traceExpression.pos, traceExpression.end) : void 0;
      report({
        location: node,
        messageText: `${effectModuleName}.${kind} returns a reusable function that can take arguments, but here it's called immediately. Use Effect.gen instead${traceExpressionText ? ` with Effect.withSpan(${traceExpressionText}) piped in the end to mantain tracing spans` : ``}.`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectFnOpportunity.ts
var effectFnOpportunity = createDiagnostic({
  name: "effectFnOpportunity",
  code: 41,
  description: "Suggests using Effect.fn for functions that returns an Effect",
  severity: "suggestion",
  apply: fn2("effectFnOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const pluginOptions = yield* service2(LanguageServicePluginOptions);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const findSingleReturnStatement = (block) => {
      if (block.statements.length !== 1) return void 0;
      const statement = block.statements[0];
      if (!ts.isReturnStatement(statement)) return void 0;
      return statement;
    };
    const getBodyExpression = (fnNode) => {
      if (ts.isArrowFunction(fnNode)) {
        if (ts.isBlock(fnNode.body)) {
          return findSingleReturnStatement(fnNode.body)?.expression;
        }
        return fnNode.body;
      } else if ((ts.isFunctionExpression(fnNode) || ts.isFunctionDeclaration(fnNode)) && fnNode.body) {
        return findSingleReturnStatement(fnNode.body)?.expression;
      }
      return void 0;
    };
    const getNameIdentifier = (node) => {
      if (ts.isFunctionDeclaration(node) && node.name) {
        return node.name;
      }
      if (node.parent && ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
        return node.parent.name;
      }
      if (node.parent && ts.isPropertyAssignment(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name) || ts.isStringLiteral(name)) {
          return name;
        }
      }
      if (node.parent && ts.isPropertyDeclaration(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name)) {
          return name;
        }
      }
      return void 0;
    };
    const areParametersReferencedIn = (fnNode, nodes2) => {
      if (fnNode.parameters.length === 0 || nodes2.length === 0) return false;
      const firstParam = fnNode.parameters[0];
      const lastParam = fnNode.parameters[fnNode.parameters.length - 1];
      const paramsStart = firstParam.pos;
      const paramsEnd = lastParam.end;
      const isSymbolDeclaredInParams = (symbol3) => {
        const declarations = symbol3.declarations;
        if (!declarations) return false;
        return declarations.some((decl) => decl.pos >= paramsStart && decl.end <= paramsEnd);
      };
      const nodesToVisit = [...nodes2];
      while (nodesToVisit.length > 0) {
        const node = nodesToVisit.shift();
        if (ts.isIdentifier(node)) {
          const symbol3 = typeChecker.getSymbolAtLocation(node);
          if (symbol3 && isSymbolDeclaredInParams(symbol3)) {
            return true;
          }
        }
        if (ts.isShorthandPropertyAssignment(node)) {
          const valueSymbol = typeChecker.getShorthandAssignmentValueSymbol(node);
          if (valueSymbol && isSymbolDeclaredInParams(valueSymbol)) {
            return true;
          }
        }
        ts.forEachChild(node, (child) => {
          nodesToVisit.push(child);
          return void 0;
        });
      }
      return false;
    };
    const tryExtractWithSpanExpression = (expr) => gen3(function* () {
      if (!ts.isCallExpression(expr)) return void 0;
      const callee = expr.expression;
      const isWithSpan = yield* pipe(
        typeParser.isNodeReferenceToEffectModuleApi("withSpan")(callee),
        map34(() => true),
        orElse15(() => succeed17(false))
      );
      if (!isWithSpan) return void 0;
      if (expr.arguments.length === 0) return void 0;
      return expr.arguments[0];
    });
    const tryParseGenOpportunity = (fnNode) => gen3(function* () {
      const bodyExpression = getBodyExpression(fnNode);
      if (!bodyExpression) return yield* TypeParserIssue.issue;
      const { pipeArguments: pipeArguments2, subject } = yield* pipe(
        typeParser.pipeCall(bodyExpression),
        map34(({ args: args3, subject: subject2 }) => ({ subject: subject2, pipeArguments: args3 })),
        orElse15(() => succeed17({ subject: bodyExpression, pipeArguments: [] }))
      );
      const { effectModule, generatorFunction } = yield* typeParser.effectGen(subject);
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      let explicitTraceExpression;
      if (pipeArguments2.length > 0) {
        const lastArg = pipeArguments2[pipeArguments2.length - 1];
        const withSpanExpr = yield* tryExtractWithSpanExpression(lastArg);
        if (withSpanExpr) {
          explicitTraceExpression = withSpanExpr;
        }
      }
      return { effectModuleName, generatorFunction, pipeArguments: pipeArguments2, explicitTraceExpression };
    });
    const isInsideEffectFn = (fnNode) => {
      const parent = fnNode.parent;
      if (!parent || !ts.isCallExpression(parent)) {
        return succeed17(false);
      }
      if (parent.arguments[0] !== fnNode) {
        return succeed17(false);
      }
      return pipe(
        typeParser.effectFn(parent),
        orElse15(() => typeParser.effectFnGen(parent)),
        orElse15(() => typeParser.effectFnUntracedGen(parent)),
        map34(() => true),
        orElse15(() => succeed17(false))
      );
    };
    const parseEffectFnOpportunityTarget = (node) => gen3(function* () {
      if (!ts.isFunctionExpression(node) && !ts.isArrowFunction(node) && !ts.isFunctionDeclaration(node)) {
        return yield* TypeParserIssue.issue;
      }
      if ((ts.isFunctionExpression(node) || ts.isFunctionDeclaration(node)) && node.asteriskToken) {
        return yield* TypeParserIssue.issue;
      }
      if (ts.isFunctionExpression(node) && node.name) {
        return yield* TypeParserIssue.issue;
      }
      if (node.type) {
        return yield* TypeParserIssue.issue;
      }
      if (yield* isInsideEffectFn(node)) {
        return yield* TypeParserIssue.issue;
      }
      const functionType = typeChecker.getTypeAtLocation(node);
      if (!functionType) return yield* TypeParserIssue.issue;
      const callSignatures = typeChecker.getSignaturesOfType(functionType, ts.SignatureKind.Call);
      if (callSignatures.length !== 1) return yield* TypeParserIssue.issue;
      const signature = callSignatures[0];
      const returnType = typeChecker.getReturnTypeOfSignature(signature);
      const unionMembers = typeCheckerUtils.unrollUnionMembers(returnType);
      yield* all9(...unionMembers.map((member) => typeParser.strictEffectType(member, node)));
      const nameIdentifier = getNameIdentifier(node);
      const traceName = nameIdentifier ? ts.isIdentifier(nameIdentifier) ? ts.idText(nameIdentifier) : nameIdentifier.text : void 0;
      if (!traceName) return yield* TypeParserIssue.issue;
      const opportunity = yield* pipe(
        tryParseGenOpportunity(node),
        orElse15(() => {
          if (ts.isArrowFunction(node) && !ts.isBlock(node.body)) {
            return TypeParserIssue.issue;
          }
          const body = ts.isArrowFunction(node) ? node.body : node.body;
          if (!body || !ts.isBlock(body) || body.statements.length <= 5) {
            return TypeParserIssue.issue;
          }
          return succeed17({
            effectModuleName: sourceEffectModuleName,
            pipeArguments: [],
            generatorFunction: void 0,
            explicitTraceExpression: void 0
          });
        })
      );
      return {
        node,
        nameIdentifier,
        effectModuleName: opportunity.effectModuleName,
        inferredTraceName: traceName,
        explicitTraceExpression: opportunity.explicitTraceExpression,
        pipeArguments: opportunity.pipeArguments,
        generatorFunction: opportunity.generatorFunction,
        hasParamsInPipeArgs: areParametersReferencedIn(node, opportunity.pipeArguments)
      };
    });
    const getFunctionBodyBlock = (node) => {
      if (ts.isArrowFunction(node)) {
        if (ts.isBlock(node.body)) {
          return node.body;
        }
        return ts.factory.createBlock([ts.factory.createReturnStatement(node.body)], true);
      }
      return node.body;
    };
    const isGeneratorFunction2 = (node) => {
      if (ts.isArrowFunction(node)) return false;
      return node.asteriskToken !== void 0;
    };
    const createEffectFnNode = (originalNode, innerFunction, effectModuleName, traceNameOrExpression, pipeArguments2) => {
      const isGenerator = isGeneratorFunction2(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      let fnExpression = ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleName),
        "fn"
      );
      if (traceNameOrExpression) {
        const traceArg = typeof traceNameOrExpression === "string" ? ts.factory.createStringLiteral(traceNameOrExpression) : traceNameOrExpression;
        fnExpression = ts.factory.createCallExpression(
          fnExpression,
          void 0,
          [traceArg]
        );
      }
      const effectFnCall = ts.factory.createCallExpression(fnExpression, void 0, [newFunction, ...pipeArguments2]);
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const createEffectFnUntracedNode = (originalNode, innerFunction, effectModuleName, pipeArguments2) => {
      const isGenerator = isGeneratorFunction2(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      const effectFnCall = ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(effectModuleName), "fnUntraced"),
        void 0,
        [newFunction, ...pipeArguments2]
      );
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const target = yield* pipe(parseEffectFnOpportunityTarget(node), option5);
      if (isNone2(target)) continue;
      if (target.value.hasParamsInPipeArgs) continue;
      const {
        effectModuleName,
        explicitTraceExpression,
        inferredTraceName,
        nameIdentifier,
        node: targetNode,
        pipeArguments: pipeArguments2
      } = target.value;
      const innerFunction = target.value.generatorFunction ?? targetNode;
      const fixes = [];
      if (pluginOptions.effectFn.includes("span") && explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnWithSpan",
          description: "Convert to Effect.fn (with span from withSpan)",
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const finalPipeArguments = pipeArguments2.slice(0, -1);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              explicitTraceExpression,
              finalPipeArguments
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("untraced") && target.value.generatorFunction) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnUntraced",
          description: "Convert to Effect.fnUntraced",
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const newNode = createEffectFnUntracedNode(targetNode, innerFunction, effectModuleName, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("no-span")) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnNoSpan",
          description: "Convert to Effect.fn (no span)",
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const newNode = createEffectFnNode(targetNode, innerFunction, effectModuleName, void 0, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("inferred-span") && inferredTraceName && !explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnSpanInferred",
          description: `Convert to Effect.fn("${inferredTraceName}")`,
          apply: gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              inferredTraceName,
              pipeArguments2
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (fixes.length === 0) continue;
      const generateExpectedSignature = () => {
        const firstFix = fixes[0];
        if (!firstFix) return "Effect.fn(function*() { ... })";
        const typeParamNames = targetNode.typeParameters ? `<${targetNode.typeParameters.map((tp) => ts.idText(tp.name)).join(", ")}>` : "";
        const paramNames = targetNode.parameters.map((param) => {
          if (ts.isIdentifier(param.name)) {
            return ts.idText(param.name);
          }
          return "_";
        }).join(", ");
        const fnSignature = `function*${typeParamNames}(${paramNames}) { ... }`;
        const pipeArgsForWithSpan = pipeArguments2.slice(0, -1);
        const pipeArgsSuffix = (args3) => args3.length > 0 ? ", ...pipeTransformations" : "";
        switch (firstFix.fixName) {
          case "effectFnOpportunity_toEffectFnWithSpan": {
            const traceName = explicitTraceExpression ? sourceFile.text.slice(explicitTraceExpression.pos, explicitTraceExpression.end).trim() : void 0;
            return `${effectModuleName}.fn(${traceName})(${fnSignature}${pipeArgsSuffix(pipeArgsForWithSpan)})`;
          }
          case "effectFnOpportunity_toEffectFnUntraced":
            return `${effectModuleName}.fnUntraced(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnNoSpan":
            return `${effectModuleName}.fn(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnSpanInferred":
            return `${effectModuleName}.fn("${inferredTraceName}")(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          default:
            return `${effectModuleName}.fn(${fnSignature})`;
        }
      };
      const expectedSignature = generateExpectedSignature();
      report({
        location: nameIdentifier ?? targetNode,
        messageText: `Can be rewritten as a reusable function: ${expectedSignature}`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectGenUsesAdapter.ts
var effectGenUsesAdapter = createDiagnostic({
  name: "effectGenUsesAdapter",
  code: 23,
  description: "Warns when using the deprecated adapter parameter in Effect.gen",
  severity: "warning",
  apply: fn2("effectGenUsesAdapter.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.effectGen(node),
          map34(({ generatorFunction }) => {
            if (generatorFunction.parameters.length > 0) {
              const adapter = generatorFunction.parameters[0];
              report({
                location: adapter,
                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,
                fixes: []
              });
            }
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/effectInVoidSuccess.ts
var effectInVoidSuccess = createDiagnostic({
  name: "effectInVoidSuccess",
  code: 14,
  description: "Detects nested Effects in void success channels that may cause unexecuted effects",
  severity: "warning",
  apply: fn2("effectInVoidSuccess.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const checkForEffectInVoid = fn2("effectInVoidSuccess.checkForEffectInVoid")(function* (node, expectedType, valueNode, realType) {
      const expectedEffect = yield* typeParser.effectType(expectedType, node);
      const realEffect = yield* typeParser.effectType(realType, valueNode);
      if (expectedEffect.A.flags & ts.TypeFlags.Void) {
        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A);
        const voidedEffect = yield* firstSuccessOf2(
          voidValueTypes.map((_) => map34(typeParser.strictEffectType(_, node), () => _))
        );
        return { voidedEffect };
      }
      return yield* fail18(typeParserIssue("expectedEffect success is not void"));
    });
    const entries3 = typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries3) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForEffectInVoid(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map34(({ voidedEffect }) => {
            report(
              {
                location: node,
                messageText: `There is a nested '${typeChecker.typeToString(voidedEffect)}' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,
                fixes: []
              }
            );
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/effectMapVoid.ts
var effectMapVoid = createDiagnostic({
  name: "effectMapVoid",
  code: 40,
  description: "Suggests using Effect.asVoid instead of Effect.map(() => void 0), Effect.map(() => undefined), or Effect.map(() => {})",
  severity: "suggestion",
  apply: fn2("effectMapVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isMapCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("map")(node.expression),
          option5
        );
        if (isSome2(isMapCall)) {
          const callback = node.arguments[0];
          if (!callback) continue;
          const match18 = yield* pipe(
            typeParser.emptyFunction(callback),
            orElse15(
              () => pipe(
                typeParser.lazyExpression(callback),
                flatMap18(
                  (lazy) => tsUtils.isVoidExpression(lazy.expression) ? succeed17(lazy) : typeParserIssue("Expression is not void")
                )
              )
            ),
            option5
          );
          if (isNone2(match18)) continue;
          report({
            location: node.expression,
            messageText: "Effect.asVoid can be used instead to discard the success value",
            fixes: [{
              fixName: "effectMapVoid_fix",
              description: "Replace with Effect.asVoid",
              apply: gen3(function* () {
                const changeTracker = yield* service2(ChangeTracker);
                if (ts.isPropertyAccessExpression(node.expression)) {
                  const newNode = ts.factory.createPropertyAccessExpression(
                    node.expression.expression,
                    ts.factory.createIdentifier("asVoid")
                  );
                  changeTracker.replaceNode(sourceFile, node, newNode);
                }
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/effectSucceedWithVoid.ts
var effectSucceedWithVoid = createDiagnostic({
  name: "effectSucceedWithVoid",
  code: 47,
  description: "Suggests using Effect.void instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
  severity: "suggestion",
  apply: fn2("effectSucceedWithVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isSucceedCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("succeed")(node.expression),
          option5
        );
        if (isSome2(isSucceedCall)) {
          const argument = node.arguments[0];
          if (!argument) continue;
          if (!tsUtils.isVoidExpression(argument)) continue;
          report({
            location: node,
            messageText: "Effect.void can be used instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
            fixes: [{
              fixName: "effectSucceedWithVoid_fix",
              description: "Replace with Effect.void",
              apply: gen3(function* () {
                const changeTracker = yield* service2(ChangeTracker);
                const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
                const newNode = ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("void")
                );
                changeTracker.replaceNode(sourceFile, node, newNode);
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/floatingEffect.ts
var floatingEffect = createDiagnostic({
  name: "floatingEffect",
  code: 3,
  description: "Ensures Effects are yielded or assigned to variables, not left floating",
  severity: "error",
  apply: fn2("floatingEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    function isFloatingExpression(node) {
      if (!ts.isExpressionStatement(node)) return false;
      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false;
      const expression = node.expression;
      if (ts.isBinaryExpression(expression) && expression.operatorToken && (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken || expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)) return false;
      return true;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!isFloatingExpression(node)) continue;
      const type2 = typeCheckerUtils.getTypeAtLocation(node.expression);
      if (!type2) continue;
      const effect3 = yield* option5(typeParser.effectType(type2, node.expression));
      if (isSome2(effect3)) {
        const allowedFloatingEffects = yield* pipe(
          typeParser.fiberType(type2, node.expression),
          orElse15(() => typeParser.effectSubtype(type2, node.expression)),
          option5
        );
        if (isNone2(allowedFloatingEffects)) {
          const isStrictEffect = yield* option5(typeParser.strictEffectType(type2, node.expression));
          const name = isSome2(isStrictEffect) ? "Effect" : "Effect-able " + typeChecker.typeToString(type2);
          report({
            location: node,
            messageText: `${name} must be yielded or assigned to a variable.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/genericEffectServices.ts
var genericEffectServices = createDiagnostic({
  name: "genericEffectServices",
  code: 10,
  description: "Prevents services with type parameters that cannot be discriminated at runtime",
  severity: "warning",
  apply: fn2("genericEffectServices.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeChecker = yield* service2(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type2 = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type2, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type2, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type2, node),
          map34(() => {
            report({
              location: reportAt,
              messageText: `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,
              fixes: []
            });
          }),
          orElse15(() => sync11(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectCatch.ts
var globalErrorInEffectCatch = createDiagnostic({
  name: "globalErrorInEffectCatch",
  code: 36,
  description: "Warns when catch callbacks return global Error type instead of typed errors",
  severity: "warning",
  apply: fn2("globalErrorInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse15(() => void_8)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && typeCheckerUtils.isGlobalErrorType(returnType)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns global 'Error', which loses type safety as untagged errors merge together. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectFailure.ts
var globalErrorInEffectFailure = createDiagnostic({
  name: "globalErrorInEffectFailure",
  code: 35,
  description: "Warns when the global Error type is used in an Effect failure channel",
  severity: "warning",
  apply: fn2("globalErrorInEffectFailure.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isNewExpression(node)) {
        const newExpressionType = typeCheckerUtils.getTypeAtLocation(node);
        if (!newExpressionType || !typeCheckerUtils.isGlobalErrorType(newExpressionType)) {
          continue;
        }
        let current = node.parent;
        while (current) {
          const currentType = typeCheckerUtils.getTypeAtLocation(current);
          if (currentType) {
            const effectTypeResult = yield* pipe(
              typeParser.effectType(currentType, current),
              option5
            );
            if (effectTypeResult._tag === "Some") {
              const effectType = effectTypeResult.value;
              const failureMembers = typeCheckerUtils.unrollUnionMembers(effectType.E);
              const hasGlobalError = failureMembers.some((member) => typeCheckerUtils.isGlobalErrorType(member));
              if (hasGlobalError) {
                report({
                  location: node,
                  messageText: `Global 'Error' loses type safety as untagged errors merge together in the Effect failure channel. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                  fixes: []
                });
              }
              break;
            }
          }
          current = current.parent;
        }
      }
    }
  })
});

// src/diagnostics/importFromBarrel.ts
var importFromBarrel = createDiagnostic({
  name: "importFromBarrel",
  code: 12,
  description: "Suggests importing from specific module paths instead of barrel exports",
  severity: "off",
  apply: fn2("importFromBarrel.apply")(function* (sourceFile, report) {
    const languageServicePluginOptions = yield* service2(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return;
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const program = yield* service2(TypeScriptProgram);
    const getModuleSpecifier = makeGetModuleSpecifier(ts);
    const resolveExternalModuleName = makeResolveExternalModuleName(typeChecker);
    const packageNamesToCheck = flatten(
      languageServicePluginOptions.namespaceImportPackages.map(
        (packageName) => tsUtils.resolveModulePattern(program, sourceFile, packageName)
      )
    );
    const isImportedFromBarrelExport = (element) => {
      if (!(getModuleSpecifier && resolveExternalModuleName)) return;
      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node));
      if (!importDeclaration) return;
      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return;
      const importClause = importDeclaration.importClause;
      if (!importClause) return;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) return;
      if (!ts.isNamedImports(namedBindings)) return;
      const barrelModuleName = importDeclaration.moduleSpecifier.text;
      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return;
      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier);
      if (!moduleSymbol) return;
      if (!moduleSymbol.exports) return;
      const sourceFile2 = tsUtils.getSourceFileOfNode(importDeclaration);
      if (!sourceFile2) return;
      const nodeForSymbol = element.propertyName || element.name;
      const aliasSymbol = element.name || element.propertyName;
      const aliasedName = ts.idText(aliasSymbol);
      if (!ts.isIdentifier(nodeForSymbol)) return;
      const importedName = ts.idText(nodeForSymbol);
      if (!importedName) return;
      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName));
      if (!reexportedSymbol) return;
      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return;
      const namespaceExport = reexportedSymbol.declarations[0];
      if (!ts.isNamespaceExport(namespaceExport)) return;
      const exportDeclaration = namespaceExport.parent;
      if (!ts.isExportDeclaration(exportDeclaration)) return;
      if (!exportDeclaration.moduleSpecifier) return;
      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier);
      if (!originalModuleSymbol) return;
      if (!originalModuleSymbol.valueDeclaration) return;
      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration);
      if (!originalSourceFile) return;
      const unbarrelledFileName = getModuleSpecifier(
        program.getCompilerOptions(),
        sourceFile2,
        sourceFile2.fileName,
        originalSourceFile.fileName,
        program
      );
      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + "/") === -1) return;
      return {
        unbarrelledFileName,
        importedName,
        barrelModuleName,
        importClause,
        namedBindings,
        importDeclaration,
        aliasedName
      };
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const parent = node.parent;
      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      const result = isImportedFromBarrelExport(node);
      if (!result) continue;
      const {
        aliasedName,
        barrelModuleName,
        importClause,
        importDeclaration,
        namedBindings,
        unbarrelledFileName
      } = result;
      report({
        location: node,
        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,
        fixes: [
          {
            fixName: "replaceWithUnbarrelledImport",
            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,
            apply: gen3(function* () {
              const changeTracker = yield* service2(ChangeTracker);
              const newImport = ts.factory.createImportDeclaration(
                void 0,
                ts.factory.createImportClause(
                  importClause.isTypeOnly || node.isTypeOnly,
                  void 0,
                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))
                ),
                ts.factory.createStringLiteral(unbarrelledFileName)
              );
              if (namedBindings.elements.length === 1) {
                changeTracker.replaceNode(
                  sourceFile,
                  importDeclaration,
                  newImport
                );
              } else {
                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport);
                changeTracker.replaceNode(
                  sourceFile,
                  namedBindings,
                  ts.factory.updateNamedImports(
                    namedBindings,
                    namedBindings.elements.filter((e) => e !== node)
                  )
                );
              }
            })
          }
        ]
      });
    }
  })
});

// src/diagnostics/instanceOfSchema.ts
var instanceOfSchema = createDiagnostic({
  name: "instanceOfSchema",
  code: 45,
  description: "Suggests using Schema.is instead of instanceof for Effect Schema types",
  severity: "off",
  apply: fn2("instanceOfSchema.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
        const leftExpr = node.left;
        const rightExpr = node.right;
        const rightType = typeCheckerUtils.getTypeAtLocation(rightExpr);
        if (!rightType) {
          ts.forEachChild(node, appendNodeToVisit);
          continue;
        }
        const isSchemaType = yield* pipe(
          typeParser.effectSchemaType(rightType, rightExpr),
          option5
        );
        if (isSchemaType._tag === "Some") {
          report({
            location: node,
            messageText: "Consider using Schema.is instead of instanceof for Effect Schema types.",
            fixes: [{
              fixName: "instanceOfSchema_fix",
              description: "Replace with Schema.is",
              apply: gen3(function* () {
                const changeTracker = yield* service2(ChangeTracker);
                const schemaIsCall = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier("Schema"),
                    "is"
                  ),
                  void 0,
                  [rightExpr]
                );
                const fullCall = ts.factory.createCallExpression(
                  schemaIsCall,
                  void 0,
                  [leftExpr]
                );
                changeTracker.replaceNode(sourceFile, node, fullCall);
              })
            }]
          });
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/layerMergeAllWithDependencies.ts
var layerMergeAllWithDependencies = createDiagnostic({
  name: "layerMergeAllWithDependencies",
  code: 37,
  description: "Detects interdependencies in Layer.mergeAll calls where one layer provides a service that another layer requires",
  severity: "warning",
  apply: fn2("layerMergeAllWithDependencies.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const checkLayerMergeAll = yield* pipe(
          typeParser.isNodeReferenceToEffectLayerModuleApi("mergeAll")(node.expression),
          orElse15(() => void_8)
        );
        if (checkLayerMergeAll) {
          const layerArgs = node.arguments;
          if (layerArgs.length > 1) {
            const layerInfos = [];
            const actuallyProvidedMap = /* @__PURE__ */ new Map();
            for (const arg of layerArgs) {
              const argType = typeCheckerUtils.getTypeAtLocation(arg);
              if (!argType) continue;
              const layerTypeParsedOption = yield* option5(typeParser.layerType(argType, arg));
              if (isNone2(layerTypeParsedOption)) continue;
              const layerTypeParsed = layerTypeParsedOption.value;
              const providedMembers = typeCheckerUtils.unrollUnionMembers(layerTypeParsed.ROut);
              for (const providedType of providedMembers) {
                if (providedType.flags & ts.TypeFlags.Never) continue;
                const isPassThrough = typeChecker.isTypeAssignableTo(providedType, layerTypeParsed.RIn);
                if (!isPassThrough) {
                  actuallyProvidedMap.set(providedType, arg);
                }
              }
              layerInfos.push({
                arg,
                requirementsType: layerTypeParsed.RIn
              });
            }
            const providerToConsumers = /* @__PURE__ */ new Map();
            for (const layer12 of layerInfos) {
              for (const [providedType, providerArg] of actuallyProvidedMap) {
                if (providerArg === layer12.arg) continue;
                if (typeChecker.isTypeAssignableTo(providedType, layer12.requirementsType)) {
                  const consumers = providerToConsumers.get(providerArg) || [];
                  consumers.push({ consumer: layer12.arg, providedType });
                  providerToConsumers.set(providerArg, consumers);
                }
              }
            }
            for (const [providerArg, consumers] of providerToConsumers) {
              const providedTypes = Array.from(new Set(consumers.map((c) => typeChecker.typeToString(c.providedType)))).join(", ");
              report({
                location: providerArg,
                messageText: `This layer provides ${providedTypes} which is required by another layer in the same Layer.mergeAll call. Layer.mergeAll creates layers in parallel, so dependencies between layers will not be satisfied. Consider moving this layer into a Layer.provideMerge after the Layer.mergeAll.`,
                fixes: [{
                  fixName: "layerMergeAllWithDependencies_fix",
                  description: "Move layer to Layer.provideMerge",
                  apply: gen3(function* () {
                    const changeTracker = yield* service2(ChangeTracker);
                    const providerIndex = layerArgs.indexOf(providerArg);
                    if (providerIndex === -1) return;
                    const providerArgNode = providerArg;
                    if (providerIndex === 0 && layerArgs.length > 1) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: providerArgNode.pos,
                        end: layerArgs[1].pos
                      });
                    } else if (providerIndex > 0) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: layerArgs[providerIndex - 1].end,
                        end: providerArgNode.end
                      });
                    }
                    const provideMergeCall = ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        ts.factory.createIdentifier(layerModuleIdentifier),
                        ts.factory.createIdentifier("provideMerge")
                      ),
                      void 0,
                      [providerArgNode]
                    );
                    changeTracker.insertNodeAt(sourceFile, node.end, provideMergeCall, {
                      prefix: ".pipe("
                    });
                    changeTracker.insertText(sourceFile, node.end, ")");
                  })
                }]
              });
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/leakingRequirements.ts
var leakingRequirements = createDiagnostic({
  name: "leakingRequirements",
  code: 8,
  description: "Detects implementation services leaked in service methods",
  severity: "suggestion",
  apply: fn2("leakingRequirements.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const parseLeakedRequirements = cachedBy(
      fn2("leakingServices.checkServiceLeaking")(
        function* (service3, atLocation) {
          const properties = typeChecker.getPropertiesOfType(service3);
          if (properties.length < 1) return [];
          const memory = /* @__PURE__ */ new Map();
          let sharedRequirementsKeys = void 0;
          let effectMembers = 0;
          for (const property of properties) {
            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation);
            let effectContextType = void 0;
            yield* pipe(
              typeParser.effectType(servicePropertyType, atLocation),
              map34((_) => effectContextType = _.R),
              orElse15(() => {
                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(
                  servicePropertyType,
                  ts.SignatureKind.Call
                );
                if (servicePropertyCallSignatures.length === 1) {
                  return pipe(
                    typeParser.effectType(
                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),
                      atLocation
                    ),
                    map34((_) => {
                      effectContextType = _.R;
                    })
                  );
                }
                return void_8;
              }),
              ignore3
            );
            if (effectContextType) {
              effectMembers++;
              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                memory,
                effectContextType,
                (type2) => {
                  if (type2.flags & ts.TypeFlags.Never) return succeed17(true);
                  return pipe(
                    typeParser.scopeType(type2, atLocation),
                    map34(() => true),
                    orElse15(() => succeed17(false))
                  );
                }
              );
              if (!sharedRequirementsKeys) {
                sharedRequirementsKeys = allIndexes;
              } else {
                sharedRequirementsKeys = intersection(sharedRequirementsKeys, allIndexes);
                if (sharedRequirementsKeys.length === 0) return [];
              }
            }
          }
          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {
            return sharedRequirementsKeys.map((key) => memory.get(key)).filter(
              (type2) => {
                let symbol3 = type2.symbol;
                if (symbol3 && symbol3.flags & ts.SymbolFlags.Alias) {
                  symbol3 = typeChecker.getAliasedSymbol(symbol3) || symbol3;
                }
                if (!symbol3) return false;
                return !(symbol3?.declarations || []).some((declaration) => {
                  const declarationSource = tsUtils.getSourceFileOfNode(declaration);
                  if (!declarationSource) return false;
                  return declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(
                    "@effect-leakable-service"
                  ) > -1;
                });
              }
            );
          }
          return [];
        }
      ),
      "leakingServices.checkServiceLeaking",
      (_, service3) => service3
    );
    function reportLeakingRequirements(node, requirements) {
      if (requirements.length === 0) return;
      const requirementsStr = requirements.map((_) => typeChecker.typeToString(_)).join(" | ");
      report({
        location: node,
        messageText: `Methods of this Service require \`${requirementsStr}\` from every caller.

This leaks implementation details into the service's public type \u2014 callers shouldn't need to know *how* the service works internally, only *what* it provides.

Resolve these dependencies at Layer creation and provide them to each method, so the service's type reflects its purpose, not its implementation.

To suppress this diagnostic for specific dependency types that are intentionally passed through (e.g., HttpServerRequest), add \`@effect-leakable-service\` JSDoc to their interface declarations (e.g., the \`${typeChecker.typeToString(requirements[0])}\` interface), not to this service.

More info and examples at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,
        fixes: []
      });
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "GenericTag") {
        const nodeType = typeCheckerUtils.getTypeAtLocation(node);
        if (nodeType) typesToCheck.push([nodeType, node]);
      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type2 = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type2, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type2, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type2, node),
          flatMap18(
            ({ Service }) => pipe(
              parseLeakedRequirements(Service, node),
              map34(
                (requirements) => reportLeakingRequirements(reportAt, sort(requirements, typeCheckerUtils.deterministicTypeOrder))
              )
            )
          ),
          orElse15(() => sync11(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/missedPipeableOpportunity.ts
var missedPipeableOpportunity = createDiagnostic({
  name: "missedPipeableOpportunity",
  code: 26,
  description: "Enforces the use of pipeable style for nested function calls",
  severity: "off",
  apply: fn2("missedPipeableOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const options3 = yield* service2(LanguageServicePluginOptions);
    const isSafelyPipeableCallee = (callee) => {
      if (ts.isCallExpression(callee)) {
        return true;
      }
      if (ts.isArrowFunction(callee)) {
        return true;
      }
      if (ts.isFunctionExpression(callee)) {
        return true;
      }
      if (ts.isParenthesizedExpression(callee)) {
        return isSafelyPipeableCallee(callee.expression);
      }
      if (ts.isIdentifier(callee)) {
        const symbol3 = typeChecker.getSymbolAtLocation(callee);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isFunctionDeclaration(decl) || ts.isVariableDeclaration(decl) || ts.isImportSpecifier(decl) || ts.isImportClause(decl) || ts.isNamespaceImport(decl)) {
            return true;
          }
        }
        return false;
      }
      if (ts.isPropertyAccessExpression(callee)) {
        const subject = callee.expression;
        const symbol3 = typeChecker.getSymbolAtLocation(subject);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isNamespaceImport(decl) || ts.isSourceFile(decl) || ts.isModuleDeclaration(decl)) {
            return true;
          }
        }
        return false;
      }
      return false;
    };
    const flows = yield* typeParser.pipingFlows(false)(sourceFile);
    for (const flow2 of flows) {
      if (flow2.transformations.length < options3.pipeableMinArgCount) {
        continue;
      }
      const finalType = flow2.transformations[flow2.transformations.length - 1].outType;
      if (!finalType) {
        continue;
      }
      const callSigs = typeChecker.getSignaturesOfType(finalType, ts.SignatureKind.Call);
      if (callSigs.length > 0) {
        continue;
      }
      const isPipeableAtIndex = function* (index) {
        if (index === 0) {
          const subjectType = flow2.subject.outType;
          if (!subjectType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(subjectType, flow2.subject.node),
            option5
          );
          return result._tag === "Some";
        } else {
          const t = flow2.transformations[index - 1];
          if (!t.outType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(t.outType, flow2.node),
            option5
          );
          return result._tag === "Some";
        }
      };
      let searchStartIndex = 0;
      while (searchStartIndex <= flow2.transformations.length) {
        let firstPipeableIndex = -1;
        for (let i = searchStartIndex; i <= flow2.transformations.length; i++) {
          if (yield* isPipeableAtIndex(i)) {
            firstPipeableIndex = i;
            break;
          }
        }
        if (firstPipeableIndex === -1) {
          break;
        }
        const pipeableTransformations = [];
        for (let i = firstPipeableIndex; i < flow2.transformations.length; i++) {
          const t = flow2.transformations[i];
          if (!isSafelyPipeableCallee(t.callee)) {
            break;
          }
          pipeableTransformations.push(t);
        }
        const callKindCount = pipeableTransformations.filter((t) => t.kind === "call").length;
        if (callKindCount >= options3.pipeableMinArgCount) {
          const pipeableEndIndex = firstPipeableIndex + pipeableTransformations.length;
          const pipeableSubjectNode = firstPipeableIndex === 0 ? flow2.subject.node : typeParser.reconstructPipingFlow({
            subject: flow2.subject,
            transformations: flow2.transformations.slice(0, firstPipeableIndex)
          });
          const afterTransformations = flow2.transformations.slice(pipeableEndIndex);
          const getOriginalSubjectNode = () => {
            if (firstPipeableIndex === 0) {
              return flow2.subject.node;
            }
            let current = flow2.node;
            for (let i = flow2.transformations.length; i > firstPipeableIndex; i--) {
              const t = flow2.transformations[i - 1];
              if (t.kind === "call" && ts.isCallExpression(current) && current.arguments.length > 0) {
                current = current.arguments[0];
              } else {
                return void 0;
              }
            }
            return current;
          };
          const originalSubjectNode = getOriginalSubjectNode();
          const subjectText = originalSubjectNode ? sourceFile.text.slice(
            ts.getTokenPosOfNode(originalSubjectNode, sourceFile),
            originalSubjectNode.end
          ).trim() : "";
          report({
            location: flow2.node,
            messageText: `Nested function calls can be converted to pipeable style for better readability; consider using ${subjectText}.pipe(...) instead.`,
            fixes: [{
              fixName: "missedPipeableOpportunity_fix",
              description: "Convert to pipe style",
              apply: gen3(function* () {
                const changeTracker = yield* service2(ChangeTracker);
                const pipeArgs = pipeableTransformations.map((t) => {
                  if (t.args) {
                    return ts.factory.createCallExpression(
                      t.callee,
                      void 0,
                      t.args
                    );
                  } else {
                    return t.callee;
                  }
                });
                const pipeNode = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    pipeableSubjectNode,
                    "pipe"
                  ),
                  void 0,
                  pipeArgs
                );
                const newNode = afterTransformations.length > 0 ? typeParser.reconstructPipingFlow({
                  subject: { node: pipeNode, outType: void 0 },
                  transformations: afterTransformations
                }) : pipeNode;
                changeTracker.replaceNode(sourceFile, flow2.node, newNode);
              })
            }]
          });
          break;
        }
        searchStartIndex = firstPipeableIndex + pipeableTransformations.length + 1;
      }
    }
  })
});

// src/diagnostics/missingEffectContext.ts
var missingEffectContext = createDiagnostic({
  name: "missingEffectContext",
  code: 1,
  description: "Reports missing service requirements in Effect context channel",
  severity: "error",
  apply: fn2("missingEffectContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all9(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map34(
        ([expectedEffect, realEffect]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realEffect.R,
          expectedEffect.R
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries3 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries3) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map34(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Effect context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/missingEffectError.ts
var missingEffectError = createDiagnostic({
  name: "missingEffectError",
  code: 1,
  description: "Reports missing error types in Effect error channel",
  severity: "error",
  apply: fn2("missingEffectError.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const createDieMessage = (message) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifier),
        "dieMessage"
      ),
      void 0,
      [ts.factory.createStringLiteral(message)]
    );
    const checkForMissingErrorTypes = (node, expectedType, valueNode, realType) => pipe(
      all9(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map34(
        ([expectedEffect, realEffect]) => pipe(
          typeCheckerUtils.getMissingTypeEntriesInTargetType(
            realEffect.E,
            expectedEffect.E
          ),
          (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries3 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries3) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingErrorTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map34((result) => {
            if (result.missingErrorTypes.length === 0) return;
            const fixes = [];
            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {
              fixes.push({
                fixName: "missingEffectError_catchAll",
                description: "Catch all errors with Effect.catchAll",
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  changeTracker.insertText(
                    sourceFile,
                    ts.getTokenPosOfNode(valueNode, sourceFile),
                    effectModuleIdentifier + ".catchAll("
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ", () => ");
                  changeTracker.insertNodeAt(
                    sourceFile,
                    valueNode.end,
                    createDieMessage("TODO: catchAll not implemented")
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ")");
                })
              });
            }
            if (ts.isExpression(valueNode)) {
              const propertyAssignments = pipe(
                result.missingErrorTypes,
                map4((_) => typeChecker.getPropertyOfType(_, "_tag")),
                filter2((_) => !!_),
                map4((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),
                filter2((_) => !!(_.flags & ts.TypeFlags.Literal)),
                map4((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter2((_) => !!_ && ts.isLiteralTypeNode(_)),
                map4((_) => _.literal),
                filter2((_) => ts.isLiteralExpression(_)),
                map4((_) => _.text),
                sort(string2),
                map4(
                  (_) => ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier(_),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)
                    )
                  )
                )
              );
              if (propertyAssignments.length === result.missingErrorTypes.length) {
                fixes.push({
                  fixName: "missingEffectError_tagged",
                  description: "Catch unexpected errors with Effect.catchTag",
                  apply: gen3(function* () {
                    const changeTracker = yield* service2(ChangeTracker);
                    changeTracker.insertText(
                      sourceFile,
                      ts.getTokenPosOfNode(valueNode, sourceFile),
                      effectModuleIdentifier + ".catchTags("
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ", ");
                    changeTracker.insertNodeAt(
                      sourceFile,
                      valueNode.end,
                      ts.factory.createObjectLiteralExpression(propertyAssignments)
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ")");
                  })
                });
              }
            }
            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_));
            report(
              {
                location: node,
                messageText: `Missing '${typeNames.join(" | ")}' in the expected Effect errors.`,
                fixes
              }
            );
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/missingEffectServiceDependency.ts
var missingEffectServiceDependency = createDiagnostic({
  name: "missingEffectServiceDependency",
  code: 22,
  description: "Checks that Effect.Service dependencies satisfy all required layer inputs",
  severity: "off",
  apply: fn2("missingEffectServiceDependency.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse15(() => void_8)
        );
        if (serviceResult) {
          const { className, options: options3 } = serviceResult;
          const classSymbol = typeChecker.getSymbolAtLocation(className);
          if (classSymbol) {
            const classType = typeChecker.getTypeOfSymbol(classSymbol);
            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, "DefaultWithoutDependencies");
            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, "Default");
            if (defaultProperty) {
              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node);
              const layerResult = yield* pipe(
                typeParser.layerType(defaultType, node),
                orElse15(() => void_8)
              );
              if (layerResult) {
                const servicesMemory = /* @__PURE__ */ new Map();
                const excludeNever = (type2) => succeed17((type2.flags & ts.TypeFlags.Never) !== 0);
                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                  servicesMemory,
                  layerResult.RIn,
                  excludeNever
                );
                const providedIndexes = /* @__PURE__ */ new Set();
                let types = [];
                const optionsType = typeCheckerUtils.getTypeAtLocation(options3);
                if (optionsType) {
                  const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, "dependencies");
                  if (dependenciesProperty) {
                    const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options3);
                    const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number);
                    types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : [];
                  }
                }
                for (const depType of types) {
                  const depLayerResult = yield* pipe(
                    typeParser.layerType(depType, options3),
                    orElse15(() => void_8)
                  );
                  if (depLayerResult) {
                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                      servicesMemory,
                      depLayerResult.ROut,
                      excludeNever
                    );
                    for (const index of allIndexes) {
                      providedIndexes.add(index);
                    }
                  }
                }
                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index));
                if (missingIndexes.length > 0) {
                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index));
                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t));
                  const message = missingTypeNames.length === 1 ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies` : `Services ${missingTypeNames.map((s) => `'${s}'`).join(", ")} are required but not provided by dependencies`;
                  report({
                    location: className,
                    messageText: message,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/missingLayerContext.ts
var missingLayerContext = createDiagnostic({
  name: "missingLayerContext",
  code: 38,
  description: "Reports missing service requirements in Layer context channel",
  severity: "error",
  apply: fn2("missingLayerContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all9(
        typeParser.layerType(expectedType, node),
        typeParser.layerType(realType, valueNode)
      ),
      map34(
        ([expectedLayer, realLayer]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realLayer.RIn,
          expectedLayer.RIn
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries3 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries3) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map34(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Layer context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/missingReturnYieldStar.ts
var missingReturnYieldStar = createDiagnostic({
  name: "missingReturnYieldStar",
  code: 7,
  description: "Suggests using 'return yield*' for Effects with never success for better type narrowing",
  severity: "error",
  apply: fn2("missingReturnYieldStar.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken) {
        const type2 = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (type2) {
          const maybeEffect = yield* option5(typeParser.effectType(type2, node.expression));
          if (isSome2(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {
            const generatorFunctionOrReturnStatement = ts.findAncestor(
              node,
              (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isReturnStatement(_) || ts.isThrowStatement(_)
            );
            if (generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) && !ts.isThrowStatement(generatorFunctionOrReturnStatement)) {
              if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {
                const effectGenNode = generatorFunctionOrReturnStatement.parent;
                const effectGenLike = yield* pipe(
                  typeParser.effectGen(effectGenNode),
                  orElse15(() => typeParser.effectFnUntracedGen(effectGenNode)),
                  orElse15(() => typeParser.effectFnGen(effectGenNode)),
                  option5
                );
                if (isSome2(effectGenLike)) {
                  const fix = node.expression ? [{
                    fixName: "missingReturnYieldStar_fix",
                    description: "Add return statement",
                    apply: gen3(function* () {
                      const changeTracker = yield* service2(ChangeTracker);
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createReturnStatement(
                          node
                        )
                      );
                    })
                  }] : [];
                  report({
                    location: node,
                    messageText: `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,
                    fixes: fix
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/missingStarInYieldEffectGen.ts
var missingStarInYieldEffectGen = createDiagnostic({
  name: "missingStarInYieldEffectGen",
  code: 4,
  description: "Enforces using 'yield*' instead of 'yield' when yielding Effects in generators",
  severity: "error",
  apply: fn2("missingStarInYieldEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const brokenGenerators = /* @__PURE__ */ new Set();
    const brokenYields = /* @__PURE__ */ new Set();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken === void 0) {
        const functionStarNode = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)
        );
        if (functionStarNode && functionStarNode.parent) {
          const effectGenNode = functionStarNode.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse15(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse15(() => typeParser.effectFnGen(effectGenNode)),
            map34(({ generatorFunction }) => {
              if (generatorFunction) {
                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)));
              }
              brokenYields.add(node);
            }),
            ignore3
          );
        }
      }
    }
    brokenGenerators.forEach(
      (pos) => report({
        location: { pos, end: pos + "function".length },
        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,
        fixes: []
      })
    );
    brokenYields.forEach((node) => {
      const fix = node.expression ? [{
        fixName: "missingStarInYieldEffectGen_fix",
        description: "Replace yield with yield*",
        apply: gen3(function* () {
          const changeTracker = yield* service2(ChangeTracker);
          changeTracker.replaceNode(
            sourceFile,
            node,
            ts.factory.createYieldExpression(
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              node.expression
            )
          );
        })
      }] : [];
      report({
        location: node,
        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,
        fixes: fix
      });
    });
  })
});

// src/diagnostics/multipleEffectProvide.ts
var multipleEffectProvide = createDiagnostic({
  name: "multipleEffectProvide",
  code: 18,
  description: "Warns against chaining Effect.provide calls which can cause service lifecycle issues",
  severity: "warning",
  apply: fn2("multipleEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      let currentChunk = 0;
      const previousLayers = [[]];
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          currentChunk++;
          previousLayers.push([]);
          continue;
        }
        const isProvideCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("provide")(transformation.callee),
          option5
        );
        if (isSome2(isProvideCall)) {
          const layer12 = transformation.args[0];
          const type2 = typeCheckerUtils.getTypeAtLocation(layer12);
          const node = ts.findAncestor(transformation.callee, ts.isCallExpression);
          const isLayerType = type2 ? yield* pipe(
            typeParser.layerType(type2, layer12),
            option5
          ) : none2();
          if (isSome2(isLayerType) && node) {
            previousLayers[currentChunk].push({ layer: layer12, node });
          } else {
            currentChunk++;
            previousLayers.push([]);
          }
        } else {
          currentChunk++;
          previousLayers.push([]);
        }
      }
      for (const chunk4 of previousLayers) {
        if (chunk4.length < 2) continue;
        report({
          location: chunk4[0].node,
          messageText: "Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.",
          fixes: [{
            fixName: "multipleEffectProvide_fix",
            description: "Combine into a single provide",
            apply: gen3(function* () {
              const changeTracker = yield* service2(ChangeTracker);
              changeTracker.deleteRange(sourceFile, {
                pos: ts.getTokenPosOfNode(chunk4[0].node, sourceFile),
                end: chunk4[chunk4.length - 1].node.end
              });
              const newNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("provide")
                ),
                void 0,
                [ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(layerModuleIdentifier),
                    ts.factory.createIdentifier("mergeAll")
                  ),
                  void 0,
                  chunk4.map((c) => c.layer)
                )]
              );
              changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk4[0].node, sourceFile), newNode);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/nonObjectEffectServiceType.ts
var nonObjectEffectServiceType = createDiagnostic({
  name: "nonObjectEffectServiceType",
  code: 24,
  description: "Ensures Effect.Service types are objects, not primitives",
  severity: "error",
  apply: fn2("nonObjectEffectServiceType.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    function isPrimitiveType(type2) {
      return typeCheckerUtils.unrollUnionMembers(type2).some(
        (type3) => !!(type3.flags & ts.TypeFlags.String || type3.flags & ts.TypeFlags.Number || type3.flags & ts.TypeFlags.Boolean || type3.flags & ts.TypeFlags.StringLiteral || type3.flags & ts.TypeFlags.NumberLiteral || type3.flags & ts.TypeFlags.BooleanLiteral || type3.flags & ts.TypeFlags.Undefined || type3.flags & ts.TypeFlags.Null)
      );
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse15(() => void_8)
        );
        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {
          const options3 = serviceResult.options;
          for (const property of options3.properties) {
            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {
              continue;
            }
            const propertyName = ts.idText(property.name);
            const propertyValue = property.initializer;
            const errorToReport = {
              location: property.name,
              messageText: "Effect.Service requires the service type to be an object {} and not a primitive type. \nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.",
              fixes: []
            };
            if (propertyName === "succeed") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (valueType && isPrimitiveType(valueType)) {
                report(errorToReport);
              }
            } else if (propertyName === "sync") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
              for (const signature of signatures) {
                const returnType = typeChecker.getReturnTypeOfSignature(signature);
                if (isPrimitiveType(returnType)) {
                  report(errorToReport);
                  break;
                }
              }
            } else if (propertyName === "effect" || propertyName === "scoped") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const effectResult = yield* pipe(
                typeParser.effectType(valueType, propertyValue),
                orElse15(() => void_8)
              );
              if (effectResult) {
                if (isPrimitiveType(effectResult.A)) {
                  report(errorToReport);
                  continue;
                }
              } else {
                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
                for (const signature of signatures) {
                  const returnType = typeChecker.getReturnTypeOfSignature(signature);
                  const effectReturnResult = yield* pipe(
                    typeParser.effectType(returnType, propertyValue),
                    orElse15(() => void_8)
                  );
                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {
                    report(errorToReport);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/outdatedEffectCodegen.ts
var outdatedEffectCodegen = createDiagnostic({
  name: "outdatedEffectCodegen",
  code: 19,
  description: "Detects when generated code is outdated and needs to be regenerated",
  severity: "warning",
  apply: fn2("outdatedEffectCodegen.apply")(function* (sourceFile, _report) {
    const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
    for (const { codegen: codegen2, hash: hash2, range: range3 } of codegensWithRanges) {
      yield* pipe(
        getEditsForCodegen([codegen2], sourceFile, range3),
        map34((applicable) => {
          if (applicable.hash !== hash2) {
            _report({
              location: range3,
              messageText: `Codegen ${codegen2.name} result is outdated`,
              fixes: [
                {
                  fixName: "outdatedEffectCodegen_fix",
                  description: `Re-run ${codegen2.name}`,
                  apply: applicable.apply
                },
                {
                  fixName: "outdatedEffectCodegen_ignore",
                  description: `Ignore this ${codegen2.name} update`,
                  apply: applicable.ignore
                }
              ]
            });
          }
        }),
        orElse15(
          (e) => sync11(() => {
            _report({
              location: range3,
              messageText: `Codegen ${codegen2.name} is not applicable here: ${e.cause}`,
              fixes: []
            });
          })
        ),
        ignore3
      );
    }
  })
});

// src/diagnostics/overriddenSchemaConstructor.ts
var overriddenSchemaConstructor = createDiagnostic({
  name: "overriddenSchemaConstructor",
  code: 30,
  description: "Prevents overriding constructors in Schema classes which breaks decoding behavior",
  severity: "error",
  apply: fn2("overriddenSchemaConstructor.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    function isAllowedConstructor(node) {
      if (node.body && node.body.statements.length === 1) {
        const expressionStatement = node.body.statements[0];
        if (ts.isExpressionStatement(expressionStatement)) {
          const maybeCallSuper = expressionStatement.expression;
          if (ts.isCallExpression(maybeCallSuper)) {
            if (maybeCallSuper.expression.kind === ts.SyntaxKind.SuperKeyword) {
              const expectedNames = node.parameters.map((_) => _.name).filter(ts.isIdentifier).map((_) => ts.idText(_));
              if (expectedNames.length === 2 && expectedNames.length === node.parameters.length) {
                const givenNames = maybeCallSuper.arguments.filter(ts.isIdentifier).map((_) => ts.idText(_));
                if (givenNames.length === expectedNames.length && givenNames.every((name, index) => name === expectedNames[index])) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.heritageClauses) {
        let extendsSchema = false;
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
            for (const type2 of heritageClause.types) {
              const typeAtLocation = typeCheckerUtils.getTypeAtLocation(type2.expression);
              if (!typeAtLocation) continue;
              const isSchema2 = yield* pipe(
                typeParser.effectSchemaType(typeAtLocation, type2.expression),
                map34(() => true),
                orElse15(() => succeed17(false))
              );
              if (isSchema2) {
                extendsSchema = true;
                break;
              }
            }
          }
          if (extendsSchema) break;
        }
        if (extendsSchema) {
          const members = node.members;
          for (const member of members) {
            if (ts.isConstructorDeclaration(member)) {
              if (isAllowedConstructor(member)) {
                continue;
              }
              const fixAsStaticNew = {
                fixName: "overriddenSchemaConstructor_static",
                description: "Rewrite using the static 'new' pattern",
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  const visitor = (node2) => {
                    if (ts.isExpressionStatement(node2) && ts.isCallExpression(node2.expression) && ts.isToken(node2.expression.expression) && node2.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
                      const constructThis = ts.factory.createNewExpression(
                        ts.factory.createIdentifier("this"),
                        void 0,
                        node2.expression.arguments
                      );
                      return ts.factory.createVariableStatement(
                        void 0,
                        ts.factory.createVariableDeclarationList(
                          [ts.factory.createVariableDeclaration(
                            "_this",
                            void 0,
                            void 0,
                            constructThis
                          )],
                          ts.NodeFlags.Const
                        )
                      );
                    }
                    if (ts.isToken(node2) && node2.kind === ts.SyntaxKind.ThisKeyword) {
                      return ts.factory.createIdentifier("_this");
                    }
                    return ts.visitEachChild(node2, visitor, ts.nullTransformationContext);
                  };
                  const newBody = visitor(member.body);
                  const bodyWithReturn = ts.factory.updateBlock(
                    newBody,
                    newBody.statements.concat([
                      ts.factory.createReturnStatement(ts.factory.createIdentifier("_this"))
                    ])
                  );
                  const newMethod = ts.factory.createMethodDeclaration(
                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),
                    void 0,
                    "new",
                    void 0,
                    member.typeParameters,
                    member.parameters,
                    member.type,
                    bodyWithReturn
                  );
                  changeTracker.replaceNode(sourceFile, member, newMethod);
                })
              };
              report({
                location: member,
                messageText: "Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.",
                fixes: (member.body ? [fixAsStaticNew] : []).concat([{
                  fixName: "overriddenSchemaConstructor_fix",
                  description: "Remove the constructor override",
                  apply: gen3(function* () {
                    const changeTracker = yield* service2(ChangeTracker);
                    changeTracker.delete(sourceFile, member);
                  })
                }])
              });
              break;
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/preferSchemaOverJson.ts
var preferSchemaOverJson = createDiagnostic({
  name: "preferSchemaOverJson",
  code: 44,
  description: "Suggests using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify which may throw",
  severity: "suggestion",
  apply: fn2("preferSchemaOverJson.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const parseJsonMethod = (node) => gen3(function* () {
      if (!ts.isCallExpression(node)) return yield* fail18("node is not a call expression");
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return yield* fail18("expression is not a property access");
      const objectExpr = expression.expression;
      const methodName = ts.idText(expression.name);
      if (!ts.isIdentifier(objectExpr) || ts.idText(objectExpr) !== "JSON") {
        return yield* fail18("object is not JSON");
      }
      if (methodName !== "parse" && methodName !== "stringify") {
        return yield* fail18("method is not parse or stringify");
      }
      return { node, methodName };
    });
    const effectTrySimple = (node) => gen3(function* () {
      if (!ts.isCallExpression(node)) return yield* fail18("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail18("Effect.try has no arguments");
      const lazyFn = yield* typeParser.lazyExpression(node.arguments[0]);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const effectTryObject = (node) => gen3(function* () {
      if (!ts.isCallExpression(node)) return yield* fail18("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail18("Effect.try has no arguments");
      const arg = node.arguments[0];
      if (!ts.isObjectLiteralExpression(arg)) return yield* fail18("argument is not an object literal");
      const tryProp = arg.properties.find(
        (p3) => ts.isPropertyAssignment(p3) && ts.isIdentifier(p3.name) && ts.idText(p3.name) === "try"
      );
      if (!tryProp) return yield* fail18("object has no 'try' property");
      const lazyFn = yield* typeParser.lazyExpression(tryProp.initializer);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const jsonMethodInEffectGen = (node) => gen3(function* () {
      const jsonMethod = yield* parseJsonMethod(node);
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) {
        return yield* fail18("not inside an Effect generator");
      }
      if (scopeNode && scopeNode !== effectGen.generatorFunction) {
        return yield* fail18("inside a nested function scope");
      }
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const match18 = yield* pipe(
        firstSuccessOf2([
          effectTrySimple(node),
          effectTryObject(node),
          jsonMethodInEffectGen(node)
        ]),
        option5
      );
      if (isSome2(match18)) {
        report({
          location: match18.value.node,
          messageText: "Consider using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify",
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/redundantSchemaTagIdentifier.ts
var redundantSchemaTagIdentifier = createDiagnostic({
  name: "redundantSchemaTagIdentifier",
  code: 42,
  description: "Suggests removing redundant identifier argument when it equals the tag value in Schema.TaggedClass/TaggedError/TaggedRequest",
  severity: "suggestion",
  apply: fn2("redundantSchemaTagIdentifier.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsSchemaTaggedClass(node),
          orElse15(() => typeParser.extendsSchemaTaggedError(node)),
          orElse15(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse15(() => void_8)
        );
        if (result && result.keyStringLiteral && result.tagStringLiteral) {
          const { keyStringLiteral, tagStringLiteral } = result;
          if (keyStringLiteral.text === tagStringLiteral.text) {
            report({
              location: keyStringLiteral,
              messageText: `Identifier '${keyStringLiteral.text}' is redundant since it equals the _tag value`,
              fixes: [{
                fixName: "redundantSchemaTagIdentifier_removeIdentifier",
                description: `Remove redundant identifier '${keyStringLiteral.text}'`,
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  changeTracker.deleteRange(sourceFile, {
                    pos: ts.getTokenPosOfNode(keyStringLiteral, sourceFile),
                    end: keyStringLiteral.end
                  });
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/returnEffectInGen.ts
var returnEffectInGen = createDiagnostic({
  name: "returnEffectInGen",
  code: 11,
  description: "Warns when returning an Effect in a generator causes nested Effect<Effect<...>>",
  severity: "suggestion",
  apply: fn2("returnEffectInGen.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isReturnStatement(node) && node.expression) {
        if (ts.isYieldExpression(node.expression)) continue;
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        const type2 = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (!type2) continue;
        const maybeEffect = yield* option5(typeParser.strictEffectType(type2, node.expression));
        if (isSome2(maybeEffect)) {
          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
            const effectGenNode = generatorOrRegularFunction.parent;
            yield* pipe(
              typeParser.effectGen(effectGenNode),
              orElse15(() => typeParser.effectFnUntracedGen(effectGenNode)),
              orElse15(() => typeParser.effectFnGen(effectGenNode)),
              map34(() => {
                const fix = node.expression ? [{
                  fixName: "returnEffectInGen_fix",
                  description: "Add yield* statement",
                  apply: gen3(function* () {
                    const changeTracker = yield* service2(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node.expression,
                      ts.factory.createYieldExpression(
                        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                        node.expression
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.
Maybe you wanted to return yield* instead?
Nested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,
                  fixes: fix
                });
              }),
              ignore3
            );
          }
        }
      }
    }
  })
});

// src/diagnostics/runEffectInsideEffect.ts
var runEffectInsideEffect = createDiagnostic({
  name: "runEffectInsideEffect",
  code: 32,
  description: "Suggests using Runtime methods instead of Effect.run* inside Effect contexts",
  severity: "suggestion",
  apply: fn2("runEffectInsideEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const tsUtils = yield* service2(TypeScriptUtils);
    const parseEffectMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectModuleApi(methodName)(node),
      map34(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      if (node.arguments.length === 0) continue;
      const isEffectRunCall = yield* pipe(
        parseEffectMethod(node.expression, "runPromise"),
        orElse15(() => parseEffectMethod(node.expression, "runSync")),
        orElse15(() => parseEffectMethod(node.expression, "runFork")),
        orElse15(() => parseEffectMethod(node.expression, "runCallback")),
        option5
      );
      if (isNone2(isEffectRunCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (effectGen && effectGen.body.statements.length > 0) {
        const nodeText = sourceFile.text.substring(
          ts.getTokenPosOfNode(node.expression, sourceFile),
          node.expression.end
        );
        if (scopeNode && scopeNode !== effectGen.generatorFunction) {
          const fixAddRuntime = gen3(function* () {
            const changeTracker = yield* service2(ChangeTracker);
            const runtimeModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Runtime") || "Runtime";
            const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
            let runtimeIdentifier = void 0;
            for (const statement of effectGen.generatorFunction.body.statements) {
              if (ts.isVariableStatement(statement) && statement.declarationList.declarations.length === 1) {
                const declaration = statement.declarationList.declarations[0];
                if (declaration.initializer && ts.isYieldExpression(declaration.initializer) && declaration.initializer.asteriskToken && declaration.initializer.expression) {
                  const yieldedExpression = declaration.initializer.expression;
                  if (ts.isCallExpression(yieldedExpression)) {
                    const maybeEffectRuntime = yield* pipe(
                      typeParser.isNodeReferenceToEffectModuleApi("runtime")(yieldedExpression.expression),
                      option5
                    );
                    if (isSome2(maybeEffectRuntime) && ts.isIdentifier(declaration.name)) {
                      runtimeIdentifier = ts.idText(declaration.name);
                    }
                  }
                }
              }
            }
            if (!runtimeIdentifier) {
              changeTracker.insertNodeAt(
                sourceFile,
                effectGen.body.statements[0].pos,
                ts.factory.createVariableStatement(
                  void 0,
                  ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(
                    "effectRuntime",
                    void 0,
                    void 0,
                    ts.factory.createYieldExpression(
                      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                      ts.factory.createCallExpression(
                        ts.factory.createPropertyAccessExpression(
                          ts.factory.createIdentifier(effectModuleIdentifier),
                          "runtime"
                        ),
                        [ts.factory.createTypeReferenceNode("never")],
                        []
                      )
                    )
                  )], ts.NodeFlags.Const)
                ),
                {
                  prefix: "\n",
                  suffix: "\n"
                }
              );
            }
            changeTracker.deleteRange(sourceFile, {
              pos: ts.getTokenPosOfNode(node.expression, sourceFile),
              end: node.arguments[0].pos
            });
            changeTracker.insertText(
              sourceFile,
              node.arguments[0].pos,
              `${runtimeModuleIdentifier}.${isEffectRunCall.value.methodName}(${runtimeIdentifier || "effectRuntime"}, `
            );
          });
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. The same runtime should generally be used instead to run child effects.
Consider extracting the Runtime by using for example Effect.runtime and then use Runtime.${isEffectRunCall.value.methodName} with the extracted runtime instead.`,
            fixes: [{
              fixName: "runEffectInsideEffect_fix",
              description: "Use a runtime to run the Effect",
              apply: fixAddRuntime
            }]
          });
        } else {
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. Effects inside generators can usually just be yielded.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/schemaStructWithTag.ts
var schemaStructWithTag = createDiagnostic({
  name: "schemaStructWithTag",
  code: 34,
  description: "Suggests using Schema.TaggedStruct instead of Schema.Struct with _tag field",
  severity: "suggestion",
  apply: fn2("schemaStructWithTag.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaStructCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Struct")(node.expression),
          orElse15(() => void_8)
        );
        if (isSchemaStructCall && node.arguments.length === 1) {
          const arg = node.arguments[0];
          if (ts.isObjectLiteralExpression(arg)) {
            const tagProperty = arg.properties.find(
              (prop) => ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name) && ts.idText(prop.name) === "_tag"
            );
            if (tagProperty && ts.isCallExpression(tagProperty.initializer)) {
              const isSchemaLiteralCall = yield* pipe(
                typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(
                  tagProperty.initializer.expression
                ),
                option5
              );
              if (isSchemaLiteralCall._tag === "Some") {
                const literalCall = tagProperty.initializer;
                const literalArgs = fromIterable(literalCall.arguments);
                if (literalArgs.length === 1 && ts.isStringLiteral(literalArgs[0])) {
                  const tagValue = literalArgs[0].text;
                  const otherProperties = arg.properties.filter((prop) => prop !== tagProperty);
                  report({
                    location: node,
                    messageText: "Schema.Struct with a _tag field can be simplified to Schema.TaggedStruct to make the tag optional in the constructor.",
                    fixes: [{
                      fixName: "schemaStructWithTag_fix",
                      description: "Replace with Schema.TaggedStruct",
                      apply: gen3(function* () {
                        const changeTracker = yield* service2(ChangeTracker);
                        const newObjectLiteral = ts.factory.createObjectLiteralExpression(
                          otherProperties,
                          true
                        );
                        const newNode = ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            // Reuse the Schema identifier from the original expression
                            ts.isPropertyAccessExpression(node.expression) ? node.expression.expression : ts.factory.createIdentifier("Schema"),
                            "TaggedStruct"
                          ),
                          void 0,
                          [
                            ts.factory.createStringLiteral(tagValue),
                            newObjectLiteral
                          ]
                        );
                        changeTracker.replaceNode(sourceFile, node, newNode);
                      })
                    }]
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/schemaSyncInEffect.ts
var syncToEffectMethod = {
  decodeSync: "decode",
  decodeUnknownSync: "decodeUnknown",
  encodeSync: "encode",
  encodeUnknownSync: "encodeUnknown"
};
var schemaSyncInEffect = createDiagnostic({
  name: "schemaSyncInEffect",
  code: 43,
  description: "Suggests using Effect-based Schema methods instead of sync methods inside Effect generators",
  severity: "suggestion",
  apply: fn2("schemaSyncInEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const parseSchemaSyncMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectParseResultModuleApi(methodName)(node),
      map34(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const isSchemaSyncCall = yield* pipe(
        firstSuccessOf2(
          Object.keys(syncToEffectMethod).map((methodName) => parseSchemaSyncMethod(node.expression, methodName))
        ),
        option5
      );
      if (isNone2(isSchemaSyncCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) continue;
      if (scopeNode && scopeNode !== effectGen.generatorFunction) continue;
      const nodeText = sourceFile.text.substring(
        ts.getTokenPosOfNode(node.expression, sourceFile),
        node.expression.end
      );
      const effectMethodName = syncToEffectMethod[isSchemaSyncCall.value.methodName];
      report({
        location: node.expression,
        messageText: `Using ${nodeText} inside an Effect generator is not recommended. Use Schema.${effectMethodName} instead to get properly typed ParseError in the error channel.`,
        fixes: []
      });
    }
  })
});

// src/diagnostics/schemaUnionOfLiterals.ts
var schemaUnionOfLiterals = createDiagnostic({
  name: "schemaUnionOfLiterals",
  code: 33,
  description: "Simplifies Schema.Union of multiple Schema.Literal calls into single Schema.Literal",
  severity: "off",
  apply: fn2("schemaUnionOfLiterals.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaUnionCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Union")(node.expression),
          orElse15(() => void_8)
        );
        if (isSchemaUnionCall) {
          const args3 = fromIterable(node.arguments);
          if (args3.length >= 2) {
            const allAreCallExpressions = args3.every((arg) => ts.isCallExpression(arg));
            if (allAreCallExpressions) {
              const literalChecks = args3.map((arg) => {
                const callArg = arg;
                return pipe(
                  typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(callArg.expression),
                  map34(() => callArg)
                );
              });
              const allLiteralsResult = yield* pipe(
                all9(...literalChecks),
                option5
              );
              if (allLiteralsResult._tag === "Some") {
                const allLiteralValues = [];
                for (const literalCall of allLiteralsResult.value) {
                  for (const arg of literalCall.arguments) {
                    allLiteralValues.push(arg);
                  }
                }
                const firstLiteralCall = allLiteralsResult.value[0];
                const schemaLiteralExpression = firstLiteralCall.expression;
                report({
                  location: node,
                  messageText: "A Schema.Union of multiple Schema.Literal calls can be simplified to a single Schema.Literal call.",
                  fixes: [{
                    fixName: "schemaUnionOfLiterals_fix",
                    description: "Replace with a single Schema.Literal call",
                    apply: gen3(function* () {
                      const changeTracker = yield* service2(ChangeTracker);
                      const newNode = ts.factory.createCallExpression(
                        schemaLiteralExpression,
                        void 0,
                        allLiteralValues
                      );
                      changeTracker.replaceNode(sourceFile, node, newNode);
                    })
                  }]
                });
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/scopeInLayerEffect.ts
var scopeInLayerEffect = createDiagnostic({
  name: "scopeInLayerEffect",
  code: 13,
  description: "Suggests using Layer.scoped instead of Layer.effect when Scope is in requirements",
  severity: "warning",
  apply: fn2("scopeInLayerEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    function parseLayerEffectApiCall(node) {
      if (!ts.isCallExpression(node)) return;
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return;
      const calledModule = expression.expression;
      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return;
      const methodIdentifier = expression.name;
      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith("effect"))) return;
      return { methodIdentifier };
    }
    const reportIfLayerRequireScope = (type2, node, methodIdentifier) => {
      const entries3 = typeCheckerUtils.unrollUnionMembers(type2);
      return pipe(
        firstSuccessOf2(entries3.map((type3) => typeParser.scopeType(type3, node))),
        map34(
          () => report({
            location: node,
            messageText: `Seems like you are constructing a layer with a scope in the requirements.
Consider using "scoped" instead to get rid of the scope in the requirements.`,
            fixes: methodIdentifier ? [{
              fixName: "scopeInLayerEffect_scoped",
              description: "Use scoped for Layer creation",
              apply: gen3(function* () {
                const changeTracker = yield* service2(ChangeTracker);
                changeTracker.replaceNode(
                  sourceFile,
                  methodIdentifier,
                  ts.factory.createIdentifier("scoped")
                );
              })
            }] : []
          })
        ),
        ignore3
      );
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const layerEffectApiCall = parseLayerEffectApiCall(node);
      if (layerEffectApiCall) {
        const type2 = typeCheckerUtils.getTypeAtLocation(node);
        if (type2) {
          yield* pipe(
            typeParser.layerType(type2, node),
            flatMap18(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),
            ignore3
          );
        }
        continue;
      }
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const classType = typeChecker.getTypeOfSymbol(classSym);
          const defaultLayer = typeChecker.getPropertyOfType(classType, "Default");
          if (defaultLayer) {
            const type2 = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node);
            yield* pipe(
              typeParser.layerType(type2, node),
              flatMap18(({ RIn }) => reportIfLayerRequireScope(RIn, node, void 0)),
              ignore3
            );
            continue;
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/strictBooleanExpressions.ts
var strictBooleanExpressions = createDiagnostic({
  name: "strictBooleanExpressions",
  code: 17,
  description: "Enforces boolean types in conditional expressions for type safety",
  severity: "off",
  apply: fn2("strictBooleanExpressions.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeChecker = yield* service2(TypeCheckerApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const conditionChecks = /* @__PURE__ */ new WeakMap();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const nodes2 = [];
      if (ts.isIfStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isWhileStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isConditionalExpression(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.condition);
      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {
        conditionChecks.set(node, true);
        nodes2.push(node.operand);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      }
      for (const nodeToCheck of nodes2) {
        if (!nodeToCheck) continue;
        if (!conditionChecks.has(nodeToCheck.parent)) continue;
        if (!ts.isExpression(nodeToCheck)) continue;
        const nodeType = typeCheckerUtils.getTypeAtLocation(nodeToCheck);
        if (!nodeType) continue;
        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType);
        let typesToCheck = [constrainedType || nodeType];
        while (typesToCheck.length > 0) {
          const type2 = typesToCheck.pop();
          if (typeCheckerUtils.isUnion(type2)) {
            typesToCheck = typesToCheck.concat(type2.types);
            continue;
          }
          if (type2.flags & ts.TypeFlags.Boolean) continue;
          if (type2.flags & ts.TypeFlags.Never) continue;
          if (type2.flags & ts.TypeFlags.BooleanLiteral) continue;
          const typeName = typeChecker.typeToString(type2);
          report({
            location: nodeToCheck,
            messageText: `Unexpected \`${typeName}\` type in condition, expected strictly a boolean instead.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/strictEffectProvide.ts
var strictEffectProvide = createDiagnostic({
  name: "strictEffectProvide",
  code: 27,
  description: "Warns when using Effect.provide with layers outside of application entry points",
  severity: "off",
  apply: fn2("strictEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeParser = yield* service2(TypeParser);
    const parseEffectProvideWithLayer = (node) => gen3(function* () {
      if (!ts.isCallExpression(node) || node.arguments.length === 0) {
        return yield* typeParserIssue("Not an Effect.provide call");
      }
      yield* typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression);
      return yield* firstSuccessOf2(
        node.arguments.map((arg) => {
          const argType = typeCheckerUtils.getTypeAtLocation(arg);
          if (!argType) return typeParserIssue("Could not get argument type");
          return typeParser.layerType(argType, arg);
        })
      );
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), option5);
        if (isSome2(layerCheck)) {
          report({
            location: node,
            messageText: "Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.",
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/tryCatchInEffectGen.ts
var tryCatchInEffectGen = createDiagnostic({
  name: "tryCatchInEffectGen",
  code: 15,
  description: "Discourages try/catch in Effect generators in favor of Effect error handling",
  severity: "suggestion",
  apply: fn2("tryCatchInEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isTryStatement(node) && node.catchClause) {
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        if (!generatorOrRegularFunction) continue;
        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
          const effectGenNode = generatorOrRegularFunction.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse15(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse15(() => typeParser.effectFnGen(effectGenNode)),
            map34(() => {
              report({
                location: node,
                messageText: "Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).",
                fixes: []
              });
            }),
            ignore3
          );
        }
      }
    }
  })
});

// src/diagnostics/unknownInEffectCatch.ts
var unknownInEffectCatch = createDiagnostic({
  name: "unknownInEffectCatch",
  code: 31,
  description: "Warns when catch callbacks return unknown instead of typed errors",
  severity: "warning",
  apply: fn2("unknownInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeChecker = yield* service2(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse15(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse15(() => void_8)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && (returnType.flags & ts.TypeFlags.Unknown || returnType.flags & ts.TypeFlags.Any)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns 'unknown'. The catch callback should be used to provide typed errors.
Consider wrapping unknown errors into Effect's Data.TaggedError for example, or narrow down the type to the specific error raised.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/unnecessaryEffectGen.ts
var unnecessaryEffectGen = createDiagnostic({
  name: "unnecessaryEffectGen",
  code: 5,
  description: "Suggests removing Effect.gen when it contains only a single return statement",
  severity: "suggestion",
  apply: fn2("unnecessaryEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.unnecessaryEffectGen(node),
          map34(
            ({ replacementNode }) => report({
              location: node,
              messageText: `This Effect.gen contains a single return statement.`,
              fixes: [{
                fixName: "unnecessaryEffectGen_fix",
                description: "Remove the Effect.gen, and keep the body",
                apply: gen3(function* () {
                  const textChanges = yield* service2(
                    ChangeTracker
                  );
                  textChanges.replaceNode(sourceFile, node, yield* replacementNode);
                })
              }]
            })
          ),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryFailYieldableError.ts
var unnecessaryFailYieldableError = createDiagnostic({
  name: "unnecessaryFailYieldableError",
  code: 29,
  description: "Suggests yielding yieldable errors directly instead of wrapping with Effect.fail",
  severity: "suggestion",
  apply: fn2("unnecessaryFailYieldableError.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.asteriskToken && node.expression && ts.isCallExpression(node.expression)) {
        const callExpression = node.expression;
        yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("fail")(callExpression.expression),
          flatMap18(() => {
            if (callExpression.arguments.length > 0) {
              const failArgument = callExpression.arguments[0];
              const argumentType = typeCheckerUtils.getTypeAtLocation(failArgument);
              if (!argumentType) return void_8;
              return pipe(
                typeParser.extendsCauseYieldableError(argumentType),
                map34(
                  () => report({
                    location: node,
                    messageText: `This Effect.fail call uses a yieldable error type as argument. You can yield* the error directly instead.`,
                    fixes: [{
                      fixName: "unnecessaryFailYieldableError_fix",
                      description: "Replace yield* Effect.fail with yield*",
                      apply: gen3(function* () {
                        const changeTracker = yield* service2(ChangeTracker);
                        changeTracker.replaceNode(
                          sourceFile,
                          callExpression,
                          failArgument
                        );
                      })
                    }]
                  })
                )
              );
            }
            return void_8;
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipe.ts
var unnecessaryPipe = createDiagnostic({
  name: "unnecessaryPipe",
  code: 9,
  description: "Removes pipe calls with no arguments",
  severity: "suggestion",
  apply: fn2("unnecessaryPipe.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          map34(({ args: args3, subject }) => {
            if (args3.length === 0) {
              report({
                location: node,
                messageText: `This pipe call contains no arguments.`,
                fixes: [{
                  fixName: "unnecessaryPipe_fix",
                  description: "Remove the pipe call",
                  apply: gen3(function* () {
                    const textChanges = yield* service2(
                      ChangeTracker
                    );
                    textChanges.replaceNode(sourceFile, node, subject);
                  })
                }]
              });
            }
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipeChain.ts
var unnecessaryPipeChain = createDiagnostic({
  name: "unnecessaryPipeChain",
  code: 16,
  description: "Simplifies chained pipe calls into a single pipe call",
  severity: "suggestion",
  apply: fn2("unnecessaryPipeChain.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const typeParser = yield* service2(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          flatMap18(
            (pipeCall) => map34(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))
          ),
          map34(({ innerCall, pipeCall }) => {
            report({
              location: node,
              messageText: `Chained pipe calls can be simplified to a single pipe call`,
              fixes: [{
                fixName: "unnecessaryPipeChain_fix",
                description: "Rewrite as single pipe call",
                apply: gen3(function* () {
                  const changeTracker = yield* service2(
                    ChangeTracker
                  );
                  switch (innerCall.kind) {
                    case "pipe": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createIdentifier("pipe"),
                          void 0,
                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                    case "pipeable": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            innerCall.subject,
                            "pipe"
                          ),
                          void 0,
                          [...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                  }
                })
              }]
            });
          }),
          ignore3
        );
      }
    }
  })
});

// src/diagnostics/unsupportedServiceAccessors.ts
var unsupportedServiceAccessors = createDiagnostic({
  name: "unsupportedServiceAccessors",
  code: 21,
  description: "Warns about service accessors that need codegen due to generic/complex signatures",
  severity: "warning",
  apply: fn2("unsupportedServiceAccessors.apply")(function* (sourceFile, report) {
    const ts = yield* service2(TypeScriptApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isClassDeclaration(node)) {
        const parseResult = yield* pipe(
          parse5(node),
          orElse15(() => succeed17(null))
        );
        if (parseResult && parseResult.involvedMembers.length > 0) {
          const existingStaticMembers = /* @__PURE__ */ new Set();
          node.members?.forEach((member) => {
            if (ts.isPropertyDeclaration(member) && member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)) {
              if (member.name && ts.isIdentifier(member.name)) {
                existingStaticMembers.add(ts.idText(member.name));
              }
            }
          });
          const missingMembers = parseResult.involvedMembers.filter(
            ({ property }) => !existingStaticMembers.has(ts.symbolName(property))
          );
          if (missingMembers.length > 0) {
            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(", ");
            const suggestedFix = parseResult.kind === "effectTag" ? "\nEffect.Tag does not allow to disable accessors, so you may want to use Context.Tag instead." : "";
            report({
              location: parseResult.className,
              messageText: `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.${suggestedFix}`,
              fixes: [{
                fixName: "unsupportedServiceAccessors_enableCodegen",
                description: "Enable accessors codegen",
                apply: gen3(function* () {
                  const changeTracker = yield* service2(ChangeTracker);
                  const comment = "// @effect-codegens accessors\n";
                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment);
                })
              }]
            });
          }
        }
      }
    }
  })
});

// src/diagnostics.ts
var diagnostics = [
  anyUnknownInErrorContext,
  instanceOfSchema,
  catchAllToMapError,
  catchUnfailableEffect,
  classSelfMismatch,
  duplicatePackage,
  effectGenUsesAdapter,
  missingEffectContext,
  missingEffectError,
  missingEffectServiceDependency,
  missingLayerContext,
  floatingEffect,
  missingStarInYieldEffectGen,
  unnecessaryEffectGen,
  unnecessaryFailYieldableError,
  missingReturnYieldStar,
  leakingRequirements,
  unnecessaryPipe,
  genericEffectServices,
  returnEffectInGen,
  tryCatchInEffectGen,
  importFromBarrel,
  scopeInLayerEffect,
  effectInVoidSuccess,
  unnecessaryPipeChain,
  strictBooleanExpressions,
  multipleEffectProvide,
  outdatedEffectCodegen,
  overriddenSchemaConstructor,
  unsupportedServiceAccessors,
  nonObjectEffectServiceType,
  deterministicKeys,
  missedPipeableOpportunity,
  strictEffectProvide,
  unknownInEffectCatch,
  runEffectInsideEffect,
  schemaUnionOfLiterals,
  schemaStructWithTag,
  globalErrorInEffectCatch,
  globalErrorInEffectFailure,
  layerMergeAllWithDependencies,
  effectMapVoid,
  effectSucceedWithVoid,
  effectFnIife,
  effectFnOpportunity,
  redundantSchemaTagIdentifier,
  schemaSyncInEffect,
  preferSchemaOverJson
];

// src/cli/diagnostics.ts
var NoFilesToCheckError = class extends TaggedError("NoFilesToCheckError") {
  get message() {
    return "No files to check. Please provide an existing .ts file or a project tsconfig.json";
  }
};
var DiagnosticsFoundError = class extends TaggedError("DiagnosticsFoundError") {
  get message() {
    return `Found ${this.errorsCount} errors, ${this.warningsCount} warnings and ${this.messagesCount} messages.`;
  }
};
var categoryToSeverity = (category, tsInstance) => {
  switch (category) {
    case tsInstance.DiagnosticCategory.Error:
      return "error";
    case tsInstance.DiagnosticCategory.Warning:
      return "warning";
    default:
      return "message";
  }
};
var formatDiagnosticForJson = (diagnostic, tsInstance) => {
  if (!diagnostic.file || diagnostic.start === void 0) return void 0;
  const { character, line: line4 } = tsInstance.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
  const endPos = diagnostic.start + (diagnostic.length ?? 0);
  const { character: endCharacter, line: endLine } = tsInstance.getLineAndCharacterOfPosition(diagnostic.file, endPos);
  const diagnosticName = Object.values(diagnostics).find((_) => _.code === diagnostic.code)?.name ?? `effect(${diagnostic.code})`;
  return {
    file: diagnostic.file.fileName,
    line: line4 + 1,
    column: character + 1,
    endLine: endLine + 1,
    endColumn: endCharacter + 1,
    severity: categoryToSeverity(diagnostic.category, tsInstance),
    code: diagnostic.code,
    name: diagnosticName,
    message: tsInstance.flattenDiagnosticMessageText(diagnostic.messageText, "\n")
  };
};
var severityToGitHubCommand = (severity) => {
  switch (severity) {
    case "error":
      return "error";
    case "warning":
      return "warning";
    default:
      return "notice";
  }
};
var formatDiagnosticForGitHubActions = (diagnostic, tsInstance) => {
  const output = formatDiagnosticForJson(diagnostic, tsInstance);
  if (!output) return void 0;
  const command = severityToGitHubCommand(output.severity);
  const message = output.message.replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  return `::${command} file=${output.file},line=${output.line},col=${output.column},endLine=${output.endLine},endColumn=${output.endColumn},title=${output.name}::${message}`;
};
var parseSeverityFilter = (severityOption) => {
  if (isNone2(severityOption)) return void 0;
  const levels = severityOption.value.split(",").map((s) => s.trim().toLowerCase());
  const validLevels = /* @__PURE__ */ new Set();
  for (const level of levels) {
    if (level === "error" || level === "warning" || level === "message") {
      validLevels.add(level);
    }
  }
  return validLevels.size > 0 ? validLevels : void 0;
};
var diagnosticPrettyFormatter = gen2(function* () {
  const path2 = yield* Path2;
  return identity({
    onBegin: () => _void,
    onFile: () => _void,
    onDiagnostics: (state, _filePath, diagnostics3) => sync4(() => {
      const rawFormatted = state.tsInstance.formatDiagnosticsWithColorAndContext(diagnostics3, {
        getCanonicalFileName: (fileName) => path2.resolve(fileName),
        getCurrentDirectory: () => path2.resolve("."),
        getNewLine: () => "\n"
      });
      return Object.values(diagnostics).reduce(
        (text10, def) => text10.replace(new RegExp(`TS${def.code}:`, "g"), `effect(${def.name}):`),
        rawFormatted
      );
    }).pipe(flatMap9(log3), when2(() => diagnostics3.length > 0)),
    onEnd: (state) => log3(
      `Checked ${state.checkedCount} files out of ${state.totalFilesCount} files. 
${state.errorsCount} errors, ${state.warningsCount} warnings and ${state.messagesCount} messages.`
    )
  });
});
var diagnosticTextFormatter = gen2(function* () {
  const path2 = yield* Path2;
  return identity({
    onBegin: () => _void,
    onFile: () => _void,
    onDiagnostics: (state, _filePath, diagnostics3) => sync4(() => {
      const rawFormatted = state.tsInstance.formatDiagnostics(diagnostics3, {
        getCanonicalFileName: (fileName) => path2.resolve(fileName),
        getCurrentDirectory: () => path2.resolve("."),
        getNewLine: () => "\n"
      });
      return Object.values(diagnostics).reduce(
        (text10, def) => text10.replace(new RegExp(`TS${def.code}:`, "g"), `effect(${def.name}):`),
        rawFormatted
      );
    }).pipe(flatMap9(log3), when2(() => diagnostics3.length > 0)),
    onEnd: (state) => log3(
      `Checked ${state.checkedCount} files out of ${state.totalFilesCount} files. 
${state.errorsCount} errors, ${state.warningsCount} warnings and ${state.messagesCount} messages.`
    )
  });
});
var diagnosticJsonFormatter = gen2(function* () {
  let hasEmittedDiagnostics = false;
  return identity({
    onBegin: () => log3(`{ "diagnostics": [`),
    onFile: () => _void,
    onDiagnostics: (state, _filePath, diagnostics3) => gen2(function* () {
      for (const diagnostic of diagnostics3) {
        const jsonDiagnostic = formatDiagnosticForJson(diagnostic, state.tsInstance);
        if (jsonDiagnostic) {
          if (hasEmittedDiagnostics) yield* log3(", ");
          yield* log3(JSON.stringify(jsonDiagnostic, null, 2));
          hasEmittedDiagnostics = true;
        }
      }
    }),
    onEnd: (state) => log3(`], "summary": ${JSON.stringify(
      {
        filesChecked: state.checkedCount,
        totalFiles: state.totalFilesCount,
        errors: state.errorsCount,
        warnings: state.warningsCount,
        messages: state.messagesCount
      },
      null,
      2
    )} }`)
  });
});
var diagnosticGitHubActionsFormatter = gen2(function* () {
  return identity({
    onBegin: () => _void,
    onFile: () => _void,
    onDiagnostics: (state, _filePath, diagnostics3) => gen2(function* () {
      if (diagnostics3.length === 0) return;
      for (const diagnostic of diagnostics3) {
        const formatted = formatDiagnosticForGitHubActions(diagnostic, state.tsInstance);
        if (formatted) {
          yield* log3(formatted);
        }
      }
    }),
    onEnd: (state) => log3(
      `Checked ${state.checkedCount} files out of ${state.totalFilesCount} files. 
${state.errorsCount} errors, ${state.warningsCount} warnings and ${state.messagesCount} messages.`
    )
  });
});
var withDiagnosticsProgressFormatter = (formatter) => gen2(function* () {
  return identity({
    onBegin: (state) => sync4(() => process.stderr.write(`Starting diagnostics for ${state.totalFilesCount} files...
`)).pipe(
      flatMap9(() => formatter.onBegin(state))
    ),
    onFile: (state, filePath) => sync4(
      () => process.stderr.write(
        `[${state.currentFileIndex}/${state.totalFilesCount}] ${filePath.slice(-60).padStart(60)}\r`
      )
    ).pipe(
      flatMap9(() => formatter.onFile(state, filePath))
    ),
    onDiagnostics: (state, filePath, diagnostics3) => formatter.onDiagnostics(state, filePath, diagnostics3),
    onEnd: (state) => sync4(() => process.stderr.write("\n")).pipe(
      flatMap9(() => formatter.onEnd(state))
    )
  });
});
var BATCH_SIZE2 = 50;
var diagnostics2 = make58(
  "diagnostics",
  {
    file: file3("file").pipe(
      optional4,
      withDescription3("The full path of the file to check for diagnostics.")
    ),
    project: file3("project").pipe(
      optional4,
      withDescription3("The full path of the project tsconfig.json file to check for diagnostics.")
    ),
    format: choice3("format", ["json", "pretty", "text", "github-actions"]).pipe(
      withDefault3("pretty"),
      withDescription3(
        "Output format: json (machine-readable), pretty (colored with context), text (plain text), github-actions (workflow commands)"
      )
    ),
    strict: boolean5("strict").pipe(
      withDefault3(false),
      withDescription3("Treat warnings as errors (affects exit code)")
    ),
    severity: text8("severity").pipe(
      optional4,
      withDescription3("Filter by severity levels (comma-separated: error,warning,message)")
    ),
    progress: boolean5("progress").pipe(
      withDefault3(false),
      withDescription3("Show progress as files are checked (outputs to stderr)")
    )
  },
  fn("diagnostics")(function* ({ file: file5, format: format6, progress, project: project3, severity, strict: strict2 }) {
    const path2 = yield* Path2;
    const severityFilter = parseSeverityFilter(severity);
    const state = {
      tsInstance: yield* TypeScriptContext,
      checkedCount: 0,
      errorsCount: 0,
      warningsCount: 0,
      messagesCount: 0,
      languageService: void 0,
      totalFilesCount: 0,
      currentFileIndex: 0
    };
    const filesToCheck = isSome2(project3) ? yield* getFileNamesInTsConfig(project3.value) : /* @__PURE__ */ new Set();
    if (isSome2(file5)) {
      filesToCheck.add(path2.resolve(file5.value));
    }
    if (filesToCheck.size === 0) {
      return yield* new NoFilesToCheckError();
    }
    state.totalFilesCount = filesToCheck.size;
    let reporter;
    switch (format6) {
      case "pretty":
        reporter = yield* diagnosticPrettyFormatter;
        break;
      case "text":
        reporter = yield* diagnosticTextFormatter;
        break;
      case "json":
        reporter = yield* diagnosticJsonFormatter;
        break;
      case "github-actions":
        reporter = yield* diagnosticGitHubActionsFormatter;
        break;
      default:
        reporter = yield* diagnosticPrettyFormatter;
    }
    if (progress) {
      reporter = yield* withDiagnosticsProgressFormatter(reporter);
    }
    yield* reporter.onBegin(state);
    const disposeIfLanguageServiceChanged = (languageService) => {
      if (state.languageService !== languageService) {
        state.languageService?.dispose();
        state.languageService = languageService;
      }
    };
    for (const batch of chunksOf(filesToCheck, BATCH_SIZE2)) {
      const { service: service3 } = (0, import_project_service2.createProjectService)({ options: { loadTypeScriptPlugins: false } });
      for (const filePath of batch) {
        state.currentFileIndex++;
        yield* reporter.onFile(state, filePath);
        service3.openClientFile(filePath);
        try {
          const scriptInfo = service3.getScriptInfo(filePath);
          if (!scriptInfo) continue;
          const projectInfo = scriptInfo.getDefaultProject();
          const languageService = projectInfo.getLanguageService(true);
          disposeIfLanguageServiceChanged(languageService);
          const program = languageService.getProgram();
          if (!program) continue;
          const sourceFile = program.getSourceFile(filePath);
          if (!sourceFile) continue;
          const pluginConfig = extractEffectLspOptions(program.getCompilerOptions());
          if (!pluginConfig) continue;
          const rawResults = pipe(
            getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
            nanoLayer3,
            nanoLayer2,
            nanoLayer,
            provideService7(TypeCheckerApi, program.getTypeChecker()),
            provideService7(TypeScriptProgram, program),
            provideService7(TypeScriptApi, state.tsInstance),
            provideService7(
              LanguageServicePluginOptions,
              { ...parse4(pluginConfig), diagnosticsName: false }
            ),
            run9,
            map((_) => _.diagnostics),
            map(
              map4(
                (_) => _.category === state.tsInstance.DiagnosticCategory.Suggestion ? { ..._, category: state.tsInstance.DiagnosticCategory.Message } : _
              )
            ),
            getOrElse(() => [])
          );
          const results = severityFilter ? rawResults.filter((d) => severityFilter.has(categoryToSeverity(d.category, state.tsInstance))) : rawResults;
          state.checkedCount++;
          state.errorsCount += results.filter((_) => _.category === state.tsInstance.DiagnosticCategory.Error).length;
          state.warningsCount += results.filter(
            (_) => _.category === state.tsInstance.DiagnosticCategory.Warning
          ).length;
          state.messagesCount += results.filter(
            (_) => _.category === state.tsInstance.DiagnosticCategory.Message
          ).length;
          yield* reporter.onDiagnostics(state, filePath, results);
        } finally {
          service3.closeClientFile(filePath);
        }
      }
      yield* yieldNow4();
    }
    disposeIfLanguageServiceChanged(void 0);
    yield* reporter.onEnd(state);
    const hasFailures = state.errorsCount > 0 || strict2 && state.warningsCount > 0;
    if (hasFailures) return yield* sync4(() => process.exit(1));
  })
).pipe(
  withDescription6("Gets the effect-language-service diagnostics on the given files or project.")
);

// src/cli/layerinfo.ts
var import_project_service4 = __toESM(require_dist2());

// src/core/LayerGraph.ts
var formatSourceFileName = (sourceFile) => {
  let fileName = sourceFile.fileName;
  if (fileName.indexOf("/") > -1) {
    fileName = fileName.split("/").pop();
  }
  return fileName;
};
var formatSourceFileNameLineAndColumn = (ts, tsUtils, node, fromSourceFile) => {
  const nodeSourceFile = tsUtils.getSourceFileOfNode(node);
  const nodePosition = ts.getTokenPosOfNode(node, nodeSourceFile);
  const { character, line: line4 } = ts.getLineAndCharacterOfPosition(nodeSourceFile, nodePosition);
  if (!fromSourceFile || nodeSourceFile === fromSourceFile) return `ln ${line4 + 1} col ${character}`;
  return `in ${formatSourceFileName(nodeSourceFile)} at ln ${line4 + 1} col ${character}`;
};
var UnableToProduceLayerGraphError = class {
  constructor(message, node) {
    this.message = message;
    this.node = node;
  }
  _tag = "@effect/language-service/UnableToProduceLayerGraphError";
};
var extractLayerGraph = fn2("extractLayerGraph")(function* (node, opts) {
  const ts = yield* service2(TypeScriptApi);
  const typeChecker = yield* service2(TypeCheckerApi);
  const typeParser = yield* service2(TypeParser);
  const typeCheckerUtils = yield* service2(TypeCheckerUtils);
  const tsUtils = yield* service2(TypeScriptUtils);
  const sourceFile = tsUtils.getSourceFileOfNode(node);
  const layerModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Layer") || "Layer";
  const visitedNodes = /* @__PURE__ */ new WeakSet();
  const nodeInPipeContext = /* @__PURE__ */ new WeakSet();
  const nodeToGraph = /* @__PURE__ */ new WeakMap();
  const depthBudget = /* @__PURE__ */ new WeakMap();
  const nodeToVisit = [];
  const appendNodeToVisit = (node2, nodeDepthBudget) => {
    depthBudget.set(node2, nodeDepthBudget);
    nodeToVisit.push(node2);
    return void 0;
  };
  appendNodeToVisit(node, opts.followSymbolsDepth);
  const mutableGraph = beginMutation3(directed());
  const extractNodeInfo = fn2("extractNodeInfo")(function* (node2) {
    let provides = [];
    let requires = [];
    let actualProvides = [];
    let layerType = void 0;
    let layerTypes = void 0;
    if (nodeInPipeContext.has(node2)) {
      if (ts.isExpression(node2)) {
        const contextualType = typeChecker.getContextualType(node2);
        if (contextualType) {
          const callSignatures = typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call);
          if (callSignatures.length === 1) {
            layerType = typeChecker.getReturnTypeOfSignature(callSignatures[0]);
          }
        }
      }
    } else if (ts.isExpression(node2)) {
      layerType = typeCheckerUtils.getTypeAtLocation(node2);
    }
    if (layerType) {
      layerTypes = yield* pipe(typeParser.layerType(layerType, node2), orElse15(() => void_8));
    }
    if (!layerTypes) layerType = void 0;
    if (layerTypes) {
      provides = typeCheckerUtils.unrollUnionMembers(layerTypes.ROut).filter((_) => !(_.flags & ts.TypeFlags.Never));
      requires = typeCheckerUtils.unrollUnionMembers(layerTypes.RIn).filter((_) => !(_.flags & ts.TypeFlags.Never));
      actualProvides = provides.filter((_) => !typeChecker.isTypeAssignableTo(_, layerTypes.RIn));
    }
    let displayNode = node2;
    if (node2.parent && ts.isVariableDeclaration(node2.parent) && node2.parent.initializer === node2) {
      displayNode = node2.parent.name;
    }
    return { node: node2, displayNode, layerType, layerTypes, provides, actualProvides, requires };
  });
  const addNode2 = fn2("addNode")(function* (node2, nodeInfo) {
    const graphNode = addNode(mutableGraph, nodeInfo ? nodeInfo : yield* extractNodeInfo(node2));
    nodeToGraph.set(node2, graphNode);
    return graphNode;
  });
  const isSimpleIdentifier = (node2) => {
    return ts.isIdentifier(node2) || ts.isPropertyAccessExpression(node2) && ts.isIdentifier(node2.name) && isSimpleIdentifier(node2.expression);
  };
  const getAdjustedNode = (node2) => ts.isPropertyDeclaration(node2) || ts.isVariableDeclaration(node2) ? node2.initializer : ts.isExpression(node2) ? node2 : void 0;
  while (nodeToVisit.length > 0) {
    const node2 = nodeToVisit.pop();
    const currentDepthBudget = depthBudget.get(node2);
    const pipeArgs = yield* pipe(typeParser.pipeCall(node2), orElse15(() => void_8));
    if (pipeArgs) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2, currentDepthBudget);
        appendNodeToVisit(pipeArgs.subject, currentDepthBudget);
        pipeArgs.args.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
        pipeArgs.args.forEach((_) => nodeInPipeContext.add(_));
        visitedNodes.add(node2);
      } else {
        const childNodes = [pipeArgs.subject, ...pipeArgs.args].map((_) => nodeToGraph.get(_)).filter(
          isNumber
        ).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length === pipeArgs.args.length + 1) {
          let lastNode = null;
          for (const childNode of childNodes) {
            if (lastNode !== null) addEdge(mutableGraph, childNode, lastNode, { relationship: "pipe" });
            lastNode = childNode;
          }
          if (lastNode !== null) {
            const graphNode = yield* addNode2(node2);
            addEdge(mutableGraph, graphNode, lastNode, { relationship: "pipe" });
          }
        } else {
          childNodes.forEach((_) => removeNode(mutableGraph, _));
          const nodeInfo = yield* extractNodeInfo(node2);
          if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
        }
      }
      continue;
    }
    if (ts.isCallExpression(node2)) {
      let shouldExplode = !opts.explodeOnlyLayerCalls;
      if (opts.explodeOnlyLayerCalls) {
        const isLayerCall = ts.isPropertyAccessExpression(node2.expression) && ts.isIdentifier(node2.expression.expression) && ts.idText(node2.expression.expression) === layerModuleName;
        if (isLayerCall) shouldExplode = true;
      }
      if (shouldExplode) {
        if (!visitedNodes.has(node2)) {
          appendNodeToVisit(node2, currentDepthBudget);
          node2.arguments.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
          visitedNodes.add(node2);
        } else {
          const childNodes = node2.arguments.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
            (_) => hasNode(mutableGraph, _)
          );
          if (childNodes.length === node2.arguments.length) {
            const graphNode = yield* addNode2(node2);
            childNodes.forEach(
              (_, argumentIndex) => addEdge(mutableGraph, graphNode, _, { relationship: "call", argumentIndex })
            );
          } else {
            childNodes.forEach((_) => removeNode(mutableGraph, _));
            const nodeInfo = yield* extractNodeInfo(node2);
            if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
          }
        }
        continue;
      }
    }
    if (opts.arrayLiteralAsMerge && ts.isArrayLiteralExpression(node2)) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2, currentDepthBudget);
        node2.elements.forEach((_) => appendNodeToVisit(_, currentDepthBudget));
        visitedNodes.add(node2);
      } else {
        const childNodes = node2.elements.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length > 0) {
          const graphNode = yield* addNode2(node2);
          childNodes.forEach(
            (_, index) => addEdge(mutableGraph, graphNode, _, { relationship: "arrayLiteral", index })
          );
        }
      }
      continue;
    }
    if (currentDepthBudget > 0 && isSimpleIdentifier(node2)) {
      let symbol3 = typeChecker.getSymbolAtLocation(node2);
      if (symbol3) {
        if (symbol3.flags & ts.SymbolFlags.Alias) {
          symbol3 = typeChecker.getAliasedSymbol(symbol3) || symbol3;
        }
        if (symbol3.declarations && symbol3.declarations.length === 1) {
          const declarationNode = getAdjustedNode(symbol3.declarations[0]);
          if (declarationNode) {
            if (!visitedNodes.has(declarationNode)) {
              appendNodeToVisit(node2, currentDepthBudget);
              appendNodeToVisit(declarationNode, currentDepthBudget - 1);
              visitedNodes.add(node2);
              continue;
            }
            const childNode = nodeToGraph.get(declarationNode);
            if (isNumber(childNode)) {
              const graphNode = yield* addNode2(node2);
              addEdge(mutableGraph, graphNode, childNode, { relationship: "symbol" });
              continue;
            }
          }
        }
      }
    }
    if (ts.isExpression(node2)) {
      const nodeInfo = yield* extractNodeInfo(node2);
      if (nodeInfo.layerTypes) {
        yield* addNode2(node2, nodeInfo);
      }
      continue;
    }
    return yield* fail18(new UnableToProduceLayerGraphError("Unable to produce layer graph for node", node2));
  }
  return endMutation3(mutableGraph);
});
var formatLayerGraph = fn2("formatLayerGraph")(
  function* (layerGraph, _fromSourceFile) {
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const ts = yield* service2(TypeScriptApi);
    return toMermaid(layerGraph, {
      edgeLabel: (edge) => JSON.stringify(edge),
      nodeLabel: (graphNode) => {
        const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node);
        let text10 = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim();
        text10 += "\nprovides: " + graphNode.provides.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
          ", "
        );
        text10 += "\nrequires: " + graphNode.requires.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
          ", "
        );
        return text10;
      }
    });
  }
);
var formatNestedLayerGraph = fn2("formatNestedLayerGraph")(
  function* (layerGraph, fromSourceFile) {
    const tsUtils = yield* service2(TypeScriptUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const ts = yield* service2(TypeScriptApi);
    const mermaidSafe = (value5) => value5.replace(/\n/g, " ").replace(
      /\s+/g,
      " "
    ).substring(0, 50).replace(/"/g, "#quot;").replace(/</mg, "#lt;").replace(/>/mg, "#gt;").trim();
    const typeNameCache = /* @__PURE__ */ new Map();
    const typeName = (type2) => {
      if (typeNameCache.has(type2)) return typeNameCache.get(type2);
      const name = typeChecker.typeToString(type2, void 0, ts.TypeFormatFlags.NoTruncation);
      typeNameCache.set(type2, name);
      return name;
    };
    let result = [];
    for (const [graphNodeIndex, graphNode] of entries2(nodes(layerGraph))) {
      let subgraphDefs = [];
      for (const kind of ["requires", "provides"]) {
        const typesMermaidNodes = [];
        for (let i = 0; i < graphNode[kind].length; i++) {
          typesMermaidNodes.push(`${graphNodeIndex}_${kind}_${i}["${mermaidSafe(typeName(graphNode[kind][i]))}"]`);
        }
        if (typesMermaidNodes.length > 0) {
          subgraphDefs = [
            ...subgraphDefs,
            `subgraph ${graphNodeIndex}_${kind} [${kind === "provides" ? "Provides" : "Requires"}]`,
            ...typesMermaidNodes.map((_) => `  ${_}`),
            `end`,
            `style ${graphNodeIndex}_${kind} stroke:none`
          ];
        }
      }
      subgraphDefs = [
        `subgraph ${graphNodeIndex}_wrap[" "]`,
        ...subgraphDefs.map((_) => `  ${_}`),
        `end`,
        `style ${graphNodeIndex}_wrap fill:transparent`,
        `style ${graphNodeIndex}_wrap stroke:none`
      ];
      const tsNode = graphNode.displayNode;
      const sourceFile = tsUtils.getSourceFileOfNode(tsNode);
      const nodeText = sourceFile.text.substring(tsNode.pos, tsNode.end).trim();
      result = [
        ...result,
        `subgraph ${graphNodeIndex} ["\`${mermaidSafe(nodeText)}<br/><small>_${mermaidSafe(formatSourceFileNameLineAndColumn(ts, tsUtils, tsNode, fromSourceFile))}_</small>\`"]`,
        ...subgraphDefs.map((_) => `  ${_}`),
        `end`,
        `style ${graphNodeIndex} fill:transparent`
      ];
    }
    for (const edgeInfo of values3(edges(layerGraph))) {
      const sourceData = layerGraph.nodes.get(edgeInfo.source);
      const targetData = layerGraph.nodes.get(edgeInfo.target);
      let connected = false;
      for (const kind of ["requires", "provides"]) {
        for (let i = 0; i < sourceData[kind].length; i++) {
          const targetIdx = targetData[kind].indexOf(sourceData[kind][i]);
          if (targetIdx > -1) {
            result.push(`${edgeInfo.source}_${kind}_${i} -.-> ${edgeInfo.target}_${kind}_${targetIdx}`);
            connected = true;
          }
        }
      }
      if (!connected) {
        result.push(`${edgeInfo.source} -.-x ${edgeInfo.target}`);
      }
    }
    if (result.length === 0) return "";
    return [
      `flowchart TB`,
      ...result.map((_) => `  ${_}`)
    ].join("\n");
  }
);
var extractOutlineGraph = fn2("extractOutlineGraph")(function* (layerGraph) {
  const typeChecker = yield* service2(TypeCheckerApi);
  const mutableGraph = beginMutation3(directed());
  const providers = /* @__PURE__ */ new Map();
  const knownSymbols = /* @__PURE__ */ new WeakSet();
  const leafNodes = values3(externals(layerGraph, { direction: "outgoing" }));
  const dedupedLeafNodes = [];
  for (const leafNode of leafNodes) {
    const symbol3 = typeChecker.getSymbolAtLocation(leafNode.node);
    if (!symbol3) {
      dedupedLeafNodes.push(leafNode);
    } else if (symbol3 && !knownSymbols.has(symbol3)) {
      dedupedLeafNodes.push(leafNode);
      knownSymbols.add(symbol3);
    }
  }
  for (const leafNode of dedupedLeafNodes) {
    const nodeIndex = addNode(mutableGraph, {
      node: leafNode.node,
      displayNode: leafNode.displayNode,
      requires: leafNode.requires,
      provides: leafNode.provides,
      actualProvides: leafNode.actualProvides
    });
    for (const providedType of leafNode.actualProvides) {
      const previousProviders = providers.get(providedType) || [];
      providers.set(providedType, [...previousProviders, nodeIndex]);
    }
  }
  for (const [nodeIndex, nodeInfo] of entries2(nodes(mutableGraph))) {
    for (const requiredType of nodeInfo.requires) {
      for (const [providedType, providerNodeIndexes] of providers.entries()) {
        if (requiredType === providedType || typeChecker.isTypeAssignableTo(requiredType, providedType)) {
          for (const providerNodeIndex of providerNodeIndexes) {
            if (!hasEdge(mutableGraph, nodeIndex, providerNodeIndex)) {
              addEdge(mutableGraph, nodeIndex, providerNodeIndex, {});
            }
          }
        }
      }
    }
  }
  return endMutation3(mutableGraph);
});
var collectOutlineGraphActualProvides = fn2("collectOutlineGraphActualProvides")(
  function* (outlineGraph) {
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const seenTypes = /* @__PURE__ */ new Set();
    const result = [];
    for (const nodeInfo of values3(nodes(outlineGraph))) {
      for (const actualProvide of nodeInfo.actualProvides) {
        if (!seenTypes.has(actualProvide)) {
          seenTypes.add(actualProvide);
          result.push(actualProvide);
        }
      }
    }
    result.sort(typeCheckerUtils.deterministicTypeOrder);
    return result;
  }
);
var formatLayerOutlineGraph = fn2("formatLayerOutlineGraph")(
  function* (layerOutlineGraph, fromSourceFile) {
    const tsUtils = yield* service2(TypeScriptUtils);
    const ts = yield* service2(TypeScriptApi);
    return toMermaid(layerOutlineGraph, {
      edgeLabel: () => "",
      nodeLabel: (graphNode) => {
        const tsNode = graphNode.displayNode;
        const sourceFile = tsUtils.getSourceFileOfNode(tsNode);
        const nodeText = sourceFile.text.substring(tsNode.pos, tsNode.end).trim();
        if (sourceFile === fromSourceFile) return nodeText;
        return `${nodeText}
_${formatSourceFileNameLineAndColumn(ts, tsUtils, tsNode, fromSourceFile)}_`;
      }
    });
  }
);
var dfsPostOrderWithOrder = (graph, config2) => {
  const start4 = config2.start ?? [];
  const direction = config2.direction ?? "outgoing";
  const orderByIndex = mapInput2(config2.order, (_) => graph.nodes.get(_));
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const stack = [];
      const discovered = /* @__PURE__ */ new Set();
      const finished = /* @__PURE__ */ new Set();
      const sortedStart = sort(start4, orderByIndex);
      for (let i = sortedStart.length - 1; i >= 0; i--) {
        stack.push({ node: sortedStart[i], visitedChildren: false });
      }
      const nextMapped = () => {
        while (stack.length > 0) {
          const current = stack[stack.length - 1];
          if (!discovered.has(current.node)) {
            discovered.add(current.node);
            current.visitedChildren = false;
          }
          if (!current.visitedChildren) {
            current.visitedChildren = true;
            const neighbors = neighborsDirected(graph, current.node, direction);
            const sortedNeighbors = sort(neighbors, orderByIndex);
            for (let i = sortedNeighbors.length - 1; i >= 0; i--) {
              const neighbor = sortedNeighbors[i];
              if (!discovered.has(neighbor) && !finished.has(neighbor)) {
                stack.push({ node: neighbor, visitedChildren: false });
              }
            }
          } else {
            const nodeToEmit = stack.pop().node;
            if (!finished.has(nodeToEmit)) {
              finished.add(nodeToEmit);
              const nodeData = getNode(graph, nodeToEmit);
              if (isSome2(nodeData)) {
                return { done: false, value: f(nodeToEmit, nodeData.value) };
              }
              return nextMapped();
            }
          }
        }
        return { done: true, value: void 0 };
      };
      return { next: nextMapped };
    }
  }));
};
var convertOutlineGraphToLayerMagic = fn2("convertOutlineGraphToLayerMagic")(
  function* (outlineGraph, targetOutputs) {
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const ts = yield* service2(TypeScriptApi);
    const result = [];
    const outputTypes = flatten(map4(targetOutputs, (_) => typeCheckerUtils.unrollUnionMembers(_)));
    const missingOutputTypes = new Set(outputTypes);
    const currentRequiredTypes = /* @__PURE__ */ new Set();
    const orderByProvidedCount = mapInput2(
      reverse(number3),
      (_) => _.provides.length
    );
    const orderByRequiredCount = mapInput2(
      reverse(number3),
      (_) => _.requires.length
    );
    const layerOrder = combine2(orderByProvidedCount, orderByRequiredCount);
    const reversedGraph = mutate3(outlineGraph, reverse6);
    const rootIndexes = fromIterable(indices(externals(reversedGraph, { direction: "incoming" })));
    const allNodes = fromIterable(
      values3(dfsPostOrderWithOrder(reversedGraph, { start: rootIndexes, order: layerOrder }))
    );
    for (const nodeInfo of allNodes) {
      if (!ts.isExpression(nodeInfo.node)) continue;
      const shouldMerge = nodeInfo.actualProvides.some((_) => missingOutputTypes.has(_));
      if (shouldMerge) {
        nodeInfo.actualProvides.forEach((_) => missingOutputTypes.delete(_));
      }
      nodeInfo.provides.forEach((_) => currentRequiredTypes.delete(_));
      nodeInfo.requires.forEach((_) => currentRequiredTypes.add(_));
      result.push({
        merges: shouldMerge,
        provides: true,
        layerExpression: nodeInfo.node
      });
    }
    return {
      layerMagicNodes: result,
      missingOutputTypes
    };
  }
);
var walkLeavesMatching = (graph, predicate, config2 = {}) => {
  const start4 = config2.start ?? [];
  const direction = config2.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      let queue = [...start4];
      const discovered = /* @__PURE__ */ new Set();
      const nextMapped = () => {
        while (queue.length > 0) {
          const current = queue.shift();
          if (discovered.has(current)) continue;
          discovered.add(current);
          const neighbors = neighborsDirected(graph, current, direction);
          const neighborsMatching = [];
          for (const neighbor of neighbors) {
            const neighborNode = getNode(graph, neighbor);
            if (isSome2(neighborNode) && predicate(neighborNode.value)) {
              neighborsMatching.push(neighbor);
            }
          }
          if (neighborsMatching.length > 0) {
            queue = [...queue, ...neighborsMatching];
          } else {
            const nodeData = getNode(graph, current);
            if (isSome2(nodeData) && predicate(nodeData.value)) {
              return { done: false, value: f(current, nodeData.value) };
            }
          }
        }
        return { done: true, value: void 0 };
      };
      return { next: nextMapped };
    }
  }));
};
var extractProvidersAndRequirers = fn2("extractProvidersAndRequirers")(
  function* (layerGraph) {
    const typeCheckerUtils = yield* service2(TypeCheckerUtils);
    const typeChecker = yield* service2(TypeCheckerApi);
    const rootWalker = externals(layerGraph, { direction: "incoming" });
    const rootNodes = fromIterable(values3(rootWalker));
    const rootNodeIndexes = fromIterable(indices(rootWalker));
    const result = [];
    const walkTypes = (rootTypes, kind) => {
      const sortedTypes = pipe(fromIterable(rootTypes), sort(typeCheckerUtils.deterministicTypeOrder));
      for (const layerType of sortedTypes) {
        const tsNodes = [];
        const tsDisplayNodes = [];
        for (const layerNode of values3(
          walkLeavesMatching(
            layerGraph,
            (_) => (kind === "provided" ? _.provides : _.requires).some(
              (_2) => _2 === layerType || typeChecker.isTypeAssignableTo(_2, layerType)
            ),
            { start: rootNodeIndexes }
          )
        )) {
          tsNodes.push(layerNode.node);
          tsDisplayNodes.push(layerNode.displayNode);
        }
        result.push({
          kind,
          type: layerType,
          nodes: tsNodes,
          displayNodes: tsDisplayNodes
        });
      }
    };
    walkTypes(new Set(rootNodes.flatMap((_) => _.provides)), "provided");
    walkTypes(new Set(rootNodes.flatMap((_) => _.requires)), "required");
    return result;
  }
);
var formatLayerProvidersAndRequirersInfo = fn2("formatLayerProvidersAndRequirersInfo")(
  function* (info2, fromSourceFile) {
    const typeChecker = yield* service2(TypeCheckerApi);
    const ts = yield* service2(TypeScriptApi);
    const tsUtils = yield* service2(TypeScriptUtils);
    if (info2.length === 0) return "";
    const textualExplanation = [];
    const appendInfo = (infoNode) => {
      const typeString = typeChecker.typeToString(
        infoNode.type,
        void 0,
        ts.TypeFormatFlags.NoTruncation
      );
      const positions = infoNode.displayNodes.map((_) => {
        const sourceFile = tsUtils.getSourceFileOfNode(_);
        const nodeText = sourceFile.text.substring(_.pos, _.end).trim().replace(/\n/g, " ").substr(0, 50);
        return `${formatSourceFileNameLineAndColumn(ts, tsUtils, _, fromSourceFile)} by \`${nodeText}\``;
      });
      textualExplanation.push(`- ${typeString} ${infoNode.kind} at ${positions.join(", ")}`);
    };
    const providedItems = info2.filter((_) => _.kind === "provided");
    const requiredItems = info2.filter((_) => _.kind === "required");
    if (providedItems.length > 0) {
      for (const item of providedItems) {
        appendInfo(item);
      }
      if (textualExplanation.length > 0 && requiredItems.length > 0) textualExplanation.push("");
    }
    if (requiredItems.length > 0) {
      for (const item of requiredItems) {
        appendInfo(item);
      }
    }
    return "/**\n" + textualExplanation.map((l) => " * " + l).join("\n") + "\n */";
  }
);

// src/cli/overview.ts
var import_project_service3 = __toESM(require_dist2());

// src/cli/utils/ExportedSymbols.ts
var getLocationFromDeclaration = (declaration, tsInstance) => {
  const sourceFile = declaration.getSourceFile();
  if (!sourceFile) return void 0;
  const { character, line: line4 } = tsInstance.getLineAndCharacterOfPosition(sourceFile, declaration.getStart());
  return {
    filePath: sourceFile.fileName,
    line: line4 + 1,
    column: character + 1
  };
};
var collectSourceFileExportedSymbols = (sourceFile, tsInstance, typeChecker, maxSymbolDepth = 0) => {
  const result = [];
  const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
  if (!moduleSymbol) {
    return result;
  }
  const exports2 = typeChecker.getExportsOfModule(moduleSymbol);
  const workQueue = exports2.map((s) => {
    const declarations = s.declarations;
    const location = declarations && declarations.length > 0 ? getLocationFromDeclaration(declarations[0], tsInstance) : void 0;
    return [s, tsInstance.symbolName(s), location, 0];
  });
  const exploded = /* @__PURE__ */ new WeakSet();
  while (workQueue.length > 0) {
    const [symbol3, name, location, depth] = workQueue.shift();
    if (!location) continue;
    const type2 = typeChecker.getTypeOfSymbol(symbol3);
    if (!exploded.has(symbol3) && depth < maxSymbolDepth) {
      exploded.add(symbol3);
      const properties = typeChecker.getPropertiesOfType(type2);
      for (const propSymbol of properties) {
        const propName = tsInstance.symbolName(propSymbol);
        if (propName === "prototype") continue;
        const childName = `${name}.${propName}`;
        workQueue.push([propSymbol, childName, location, depth + 1]);
      }
    }
    const docComment = symbol3.getDocumentationComment(typeChecker);
    const description = docComment.length > 0 ? docComment.map((part) => part.text).join("") : void 0;
    result.push({
      symbol: symbol3,
      name,
      location,
      type: type2,
      description
    });
  }
  return result;
};

// src/cli/utils/Spinner.ts
var DEFAULT_FRAMES = [
  "\u280B",
  "\u2819",
  "\u2839",
  "\u2838",
  "\u283C",
  "\u2834",
  "\u2826",
  "\u2827",
  "\u2807",
  "\u280F"
];
var isWindows = typeof process !== "undefined" && process.platform === "win32";
var figures2 = {
  tick: isWindows ? "\u221A" : "\u2714",
  cross: isWindows ? "\xD7" : "\u2716"
};
var CLEAR_LINE = cat2(eraseLine3, cursorLeft3);
var CURSOR_HIDE = render3(cursorHide3, { style: "pretty" });
var CURSOR_SHOW = render3(cursorShow3, { style: "pretty" });
var renderDoc = (columns, doc, addNewline = false) => {
  const prepared = addNewline ? cat2(doc, hardLine2) : doc;
  return render3(prepared, { style: "pretty", options: { lineWidth: columns } });
};
var spinner = dual(
  2,
  (effect3, options3) => acquireUseRelease2(
    // acquire
    gen2(function* () {
      const terminal = yield* Terminal;
      yield* orDie2(terminal.display(CURSOR_HIDE));
      let index = 0;
      let currentMessage = options3.message;
      const frames = options3.frames ?? DEFAULT_FRAMES;
      const frameCount = frames.length;
      const displayDoc = (doc, addNewline = false) => gen2(function* () {
        const columns = yield* terminal.columns;
        const out = renderDoc(columns, doc, addNewline);
        yield* orDie2(terminal.display(out));
      });
      const renderFrame = gen2(function* () {
        const i = index;
        index = index + 1;
        const spinnerDoc = annotate2(text3(frames[i % frameCount]), blue3);
        const messageDoc = annotate2(text3(currentMessage), bold2);
        const line4 = hsep2([spinnerDoc, messageDoc]);
        yield* displayDoc(cat2(CLEAR_LINE, line4));
      });
      const computeFinalMessage = (exit4) => match9(exit4, {
        onFailure: (cause2) => {
          let baseMessage = currentMessage;
          if (options3.onFailure) {
            const failureOption3 = failureOption2(cause2);
            if (isSome2(failureOption3)) {
              baseMessage = options3.onFailure(failureOption3.value);
            }
          }
          if (isInterrupted2(cause2)) {
            return `${baseMessage} (interrupted)`;
          } else if (isDie2(cause2)) {
            return `${baseMessage} (died)`;
          } else {
            return baseMessage;
          }
        },
        onSuccess: (value5) => options3.onSuccess ? options3.onSuccess(value5) : currentMessage
      });
      const renderFinal = (exit4) => gen2(function* () {
        const icon = isSuccess(exit4) ? annotate2(text3(figures2.tick), green3) : annotate2(text3(figures2.cross), red4);
        const finalMessage = computeFinalMessage(exit4);
        const msgDoc = annotate2(text3(finalMessage), bold2);
        const line4 = hsep2([icon, msgDoc]);
        yield* displayDoc(cat2(CLEAR_LINE, line4), true);
      });
      const handle = {
        updateMessage: (message) => gen2(function* () {
          currentMessage = message;
          yield* renderFrame;
        })
      };
      return {
        terminal,
        handle,
        renderFinal
      };
    }),
    // use
    ({ handle }) => effect3(handle),
    // release
    ({ renderFinal, terminal }, exitValue) => gen2(function* () {
      yield* renderFinal(exitValue);
    }).pipe(
      // Ensure cursor is shown even if something above failed.
      ensuring2(orDie2(terminal.display(CURSOR_SHOW)))
    )
  )
);

// src/cli/overview.ts
var itemOrder = combine2(
  mapInput2(Order4, (_) => _.filePath),
  combine2(
    mapInput2(Order, (_) => _.line),
    combine2(
      mapInput2(Order, (_) => _.column),
      mapInput2(Order4, (_) => _.name)
    )
  )
);
var NoFilesToCheckError2 = class extends TaggedError("NoFilesToCheckError") {
  get message() {
    return "No files to check. Please provide an existing .ts file or a project tsconfig.json";
  }
};
var BATCH_SIZE3 = 50;
var typeToString = (typeChecker, tsInstance, type2) => typeChecker.typeToString(type2, void 0, tsInstance.TypeFormatFlags.NoTruncation);
function collectExportedItems(sourceFile, tsInstance, typeChecker, maxSymbolDepth = 3, includeTsInfo = false) {
  return gen3(function* () {
    const typeParser = yield* service2(TypeParser);
    const services = [];
    const layers = [];
    const errors = [];
    const exportedSymbols = collectSourceFileExportedSymbols(
      sourceFile,
      tsInstance,
      typeChecker,
      maxSymbolDepth
    );
    for (const { description, location, name, symbol: symbol3, type: type2 } of exportedSymbols) {
      const declarations = symbol3.declarations;
      const declaration = declarations && declarations.length > 0 ? declarations[0] : sourceFile;
      const contextTagResult = yield* pipe(
        typeParser.contextTag(type2, declaration),
        option5
      );
      if (isSome2(contextTagResult)) {
        const serviceType = typeToString(typeChecker, tsInstance, contextTagResult.value.Service);
        services.push({
          name,
          ...location,
          serviceType,
          description
        });
      }
      let isLayer2 = false;
      const directLayerResult = yield* pipe(
        typeParser.layerType(type2, declaration),
        option5
      );
      if (isSome2(directLayerResult)) {
        isLayer2 = true;
      } else {
        const callSignatures = typeChecker.getSignaturesOfType(type2, tsInstance.SignatureKind.Call);
        for (const sig of callSignatures) {
          const returnType = typeChecker.getReturnTypeOfSignature(sig);
          const returnLayerResult = yield* pipe(
            typeParser.layerType(returnType, declaration),
            option5
          );
          if (isSome2(returnLayerResult)) {
            isLayer2 = true;
            break;
          }
        }
      }
      if (isLayer2) {
        const layerInfo2 = {
          name,
          ...location,
          layerType: typeToString(typeChecker, tsInstance, type2),
          description,
          tsInfo: includeTsInfo ? { node: declaration, type: type2 } : void 0
        };
        layers.push(layerInfo2);
      }
      let isError = false;
      let errorType = type2;
      const directErrorResult = yield* pipe(
        typeParser.extendsCauseYieldableError(type2),
        option5
      );
      if (isSome2(directErrorResult)) {
        isError = true;
        errorType = type2;
      } else {
        const constructSignatures = typeChecker.getSignaturesOfType(type2, tsInstance.SignatureKind.Construct);
        for (const sig of constructSignatures) {
          const instanceType = typeChecker.getReturnTypeOfSignature(sig);
          const instanceErrorResult = yield* pipe(
            typeParser.extendsCauseYieldableError(instanceType),
            option5
          );
          if (isSome2(instanceErrorResult)) {
            isError = true;
            errorType = instanceType;
            break;
          }
        }
      }
      if (isError) {
        errors.push({
          name,
          ...location,
          errorType: typeToString(typeChecker, tsInstance, errorType),
          description
        });
      }
    }
    return { services, layers, errors };
  });
}
var toRelativePath = (absolutePath, cwd) => {
  if (absolutePath.startsWith(cwd)) {
    const relative = absolutePath.slice(cwd.length);
    return relative.startsWith("/") ? `.${relative}` : `./${relative}`;
  }
  return absolutePath;
};
var dimLine = (text10) => annotate2(text3(text10), blackBright2);
var renderService = (svc, cwd) => {
  const relativePath = toRelativePath(svc.filePath, cwd);
  const details = [
    dimLine(`${relativePath}:${svc.line}:${svc.column}`),
    dimLine(svc.serviceType)
  ];
  if (svc.description) {
    details.push(dimLine(svc.description));
  }
  return vsep2([
    text3(svc.name),
    indent2(vsep2(details), 2),
    empty32
  ]);
};
var renderLayer = (layer12, cwd) => {
  const relativePath = toRelativePath(layer12.filePath, cwd);
  const details = [
    dimLine(`${relativePath}:${layer12.line}:${layer12.column}`),
    dimLine(layer12.layerType)
  ];
  if (layer12.description) {
    details.push(dimLine(layer12.description));
  }
  return vsep2([
    text3(layer12.name),
    indent2(vsep2(details), 2),
    empty32
  ]);
};
var renderError4 = (error4, cwd) => {
  const relativePath = toRelativePath(error4.filePath, cwd);
  const details = [
    dimLine(`${relativePath}:${error4.line}:${error4.column}`),
    dimLine(error4.errorType)
  ];
  if (error4.description) {
    details.push(dimLine(error4.description));
  }
  return vsep2([
    text3(error4.name),
    indent2(vsep2(details), 2),
    empty32
  ]);
};
var renderOverview = (result, cwd) => {
  const lines3 = [];
  if (result.errors.length > 0) {
    lines3.push(empty32);
    lines3.push(annotate2(text3(`Yieldable Errors (${result.errors.length})`), bold2));
    const sortedErrors = sort(result.errors, itemOrder);
    const errorDocs = sortedErrors.map((error4) => renderError4(error4, cwd));
    lines3.push(indent2(vsep2(errorDocs), 2));
  }
  if (result.services.length > 0) {
    lines3.push(empty32);
    lines3.push(annotate2(text3(`Services (${result.services.length})`), bold2));
    const sortedServices = sort(result.services, itemOrder);
    const serviceDocs = sortedServices.map((svc) => renderService(svc, cwd));
    lines3.push(indent2(vsep2(serviceDocs), 2));
  }
  if (result.layers.length > 0) {
    lines3.push(empty32);
    lines3.push(annotate2(text3(`Layers (${result.layers.length})`), bold2));
    const sortedLayers = sort(result.layers, itemOrder);
    const layerDocs = sortedLayers.map((layer12) => renderLayer(layer12, cwd));
    lines3.push(indent2(vsep2(layerDocs), 2));
  }
  if (result.services.length === 0 && result.layers.length === 0 && result.errors.length === 0) {
    lines3.push(empty32);
    lines3.push(text3("No exported services, layers, or errors found."));
  }
  if (result.layers.length > 0) {
    lines3.push(empty32);
    lines3.push(
      dimLine(
        "Tip: Not sure you got your composition right? Just write all layers inside a Layer.mergeAll(...) command, and then run the layerinfo command to get the suggested composition order to use."
      )
    );
  }
  return vsep2(lines3);
};
var collectAllItems = (filesToCheck, tsInstance, maxSymbolDepth, onProgress) => gen2(function* () {
  const services = [];
  const layers = [];
  const errors = [];
  const totalFiles = filesToCheck.size;
  let processedFiles = 0;
  for (const batch of chunksOf(filesToCheck, BATCH_SIZE3)) {
    const { service: service3 } = (0, import_project_service3.createProjectService)({ options: { loadTypeScriptPlugins: false } });
    for (const filePath of batch) {
      processedFiles++;
      yield* onProgress(processedFiles, totalFiles);
      service3.openClientFile(filePath);
      try {
        const scriptInfo = service3.getScriptInfo(filePath);
        if (!scriptInfo) continue;
        const projectInfo = scriptInfo.getDefaultProject();
        const languageService = projectInfo.getLanguageService(true);
        const program = languageService.getProgram();
        if (!program) continue;
        const sourceFile = program.getSourceFile(filePath);
        if (!sourceFile) continue;
        const result = pipe(
          collectExportedItems(sourceFile, tsInstance, program.getTypeChecker(), maxSymbolDepth),
          nanoLayer3,
          nanoLayer2,
          nanoLayer,
          provideService7(TypeCheckerApi, program.getTypeChecker()),
          provideService7(TypeScriptProgram, program),
          provideService7(TypeScriptApi, tsInstance),
          run9,
          getOrElse(() => ({ services: [], layers: [], errors: [] }))
        );
        for (const svc of result.services) {
          services.push(svc);
        }
        for (const layer12 of result.layers) {
          layers.push(layer12);
        }
        for (const error4 of result.errors) {
          errors.push(error4);
        }
      } finally {
        service3.closeClientFile(filePath);
      }
    }
    yield* yieldNow4();
  }
  return { services, layers, errors };
});
var overview = make58(
  "overview",
  {
    file: file3("file").pipe(
      optional4,
      withDescription3("The full path of the file to analyze.")
    ),
    project: file3("project").pipe(
      optional4,
      withDescription3("The full path of the project tsconfig.json file to analyze.")
    ),
    maxSymbolDepth: integer5("max-symbol-depth").pipe(
      withDefault3(3),
      withDescription3(
        "Maximum depth to traverse nested symbol properties. 0 = only root exports, 1 = root + one level, etc."
      )
    )
  },
  fn("overview")(function* ({ file: file5, maxSymbolDepth, project: project3 }) {
    const path2 = yield* Path2;
    const cwd = path2.resolve(".");
    const tsInstance = yield* TypeScriptContext;
    const filesToCheck = isSome2(project3) ? yield* getFileNamesInTsConfig(project3.value) : /* @__PURE__ */ new Set();
    if (isSome2(file5)) {
      filesToCheck.add(path2.resolve(file5.value));
    }
    if (filesToCheck.size === 0) {
      return yield* new NoFilesToCheckError2();
    }
    const totalFiles = filesToCheck.size;
    const { errors, layers, services } = yield* spinner(
      (handle) => collectAllItems(
        filesToCheck,
        tsInstance,
        maxSymbolDepth,
        (current, total) => handle.updateMessage(`Processing file ${current}/${total}...`)
      ),
      {
        message: `Processing ${totalFiles} file(s)...`,
        onSuccess: () => `Processed ${totalFiles} file(s)`
      }
    );
    const doc = renderOverview({ services, layers, errors, totalFilesCount: filesToCheck.size }, cwd);
    yield* log3(render3(doc, { style: "pretty" }));
  })
).pipe(
  withDescription6("Provides an overview of Effect-related exports in the given files or project.")
);

// src/cli/layerinfo.ts
var LayerNotFoundError = class {
  constructor(name, availableLayers) {
    this.name = name;
    this.availableLayers = availableLayers;
  }
  _tag = "LayerNotFoundError";
  get message() {
    if (this.availableLayers.length === 0) {
      return `Layer "${this.name}" not found. No layers are exported from this file.`;
    }
    return `Layer "${this.name}" not found. Available layers: ${this.availableLayers.join(", ")}`;
  }
  toString() {
    return this.message;
  }
};
var toRelativePath2 = (absolutePath, cwd) => {
  if (absolutePath.startsWith(cwd)) {
    const relative = absolutePath.slice(cwd.length);
    return relative.startsWith("/") ? `.${relative}` : `./${relative}`;
  }
  return absolutePath;
};
var dimLine2 = (text10) => annotate2(text3(text10), blackBright2);
var renderLayerInfo = (result, cwd) => {
  const { layer: layer12, providersAndRequirers } = result;
  const lines3 = [];
  lines3.push(empty32);
  lines3.push(annotate2(text3(layer12.name), bold2));
  const relativePath = toRelativePath2(layer12.filePath, cwd);
  lines3.push(indent2(dimLine2(`${relativePath}:${layer12.line}:${layer12.column}`), 2));
  lines3.push(indent2(dimLine2(layer12.layerType), 2));
  if (layer12.description) {
    lines3.push(indent2(dimLine2(layer12.description), 2));
  }
  const providedItems = providersAndRequirers.filter((_) => _.kind === "provided");
  const requiredItems = providersAndRequirers.filter((_) => _.kind === "required");
  if (providedItems.length > 0) {
    lines3.push(empty32);
    lines3.push(annotate2(text3(`Provides (${providedItems.length}):`), bold2));
    for (const item of providedItems) {
      lines3.push(indent2(dimLine2(`- ${item.typeString}`), 2));
    }
  }
  if (requiredItems.length > 0) {
    lines3.push(empty32);
    lines3.push(annotate2(text3(`Requires (${requiredItems.length}):`), bold2));
    for (const item of requiredItems) {
      lines3.push(indent2(dimLine2(`- ${item.typeString}`), 2));
    }
  }
  if (providedItems.length === 0 && requiredItems.length === 0) {
    lines3.push(empty32);
    lines3.push(dimLine2("No providers or requirements detected."));
  }
  lines3.push(empty32);
  lines3.push(annotate2(text3("Suggested Composition:"), bold2));
  lines3.push(
    indent2(
      dimLine2("Not sure you got your composition right? Just write all layers inside a Layer.mergeAll(...)"),
      2
    )
  );
  lines3.push(
    indent2(
      dimLine2(
        "then run this command again and use --outputs to select which outputs to include in composition."
      ),
      2
    )
  );
  lines3.push(
    indent2(
      dimLine2("Example: --outputs 1,2,3"),
      2
    )
  );
  if (result.outputTypes.length > 0) {
    lines3.push(indent2(dimLine2(""), 2));
    for (const output of result.outputTypes) {
      const marker = output.included ? "[x]" : "[ ]";
      lines3.push(indent2(dimLine2(`${marker} ${output.index}. ${output.typeString}`), 2));
    }
  }
  if (result.suggestedComposition && result.suggestedComposition.length > 1) {
    lines3.push(indent2(dimLine2(""), 2));
    const [first3, ...rest] = result.suggestedComposition;
    lines3.push(indent2(dimLine2(`export const ${layer12.name} = ${first3.layerName}.pipe(`), 2));
    for (let i = 0; i < rest.length; i++) {
      const step3 = rest[i];
      const suffix = i === rest.length - 1 ? "" : ",";
      lines3.push(indent2(dimLine2(`Layer.${step3.operation}(${step3.layerName})${suffix}`), 4));
    }
    lines3.push(indent2(dimLine2(")"), 2));
  }
  return vsep2(lines3);
};
var collectLayerDetailsFromExpression = (layerExpression, selectedOutputIndices) => gen3(function* () {
  const typeCheckerRef = yield* service2(TypeCheckerApi);
  const tsRef = yield* service2(TypeScriptApi);
  const typeParser = yield* service2(TypeParser);
  const typeCheckerUtils = yield* service2(TypeCheckerUtils);
  const layerGraph = yield* extractLayerGraph(layerExpression, {
    arrayLiteralAsMerge: true,
    explodeOnlyLayerCalls: false,
    followSymbolsDepth: 0
  });
  const providersAndRequirers = yield* extractProvidersAndRequirers(layerGraph);
  const displayInfo = providersAndRequirers.map((item) => ({
    kind: item.kind,
    typeString: typeCheckerRef.typeToString(
      item.type,
      void 0,
      tsRef.TypeFormatFlags.NoTruncation
    )
  }));
  const compositionGraph = yield* extractLayerGraph(layerExpression, {
    arrayLiteralAsMerge: true,
    explodeOnlyLayerCalls: true,
    followSymbolsDepth: 0
  });
  const outlineGraph = yield* extractOutlineGraph(compositionGraph);
  const allActualProvides = yield* collectOutlineGraphActualProvides(outlineGraph);
  const layerType = typeCheckerRef.getTypeAtLocation(layerExpression);
  const parsedLayer = yield* pipe(
    typeParser.layerType(layerType, layerExpression),
    orElse15(() => succeed17(void 0))
  );
  const layerROutTypes = parsedLayer ? typeCheckerUtils.unrollUnionMembers(parsedLayer.ROut).filter((_) => !(_.flags & tsRef.TypeFlags.Never)) : [];
  const hasSelection = selectedOutputIndices && selectedOutputIndices.length > 0;
  const selectedSet = hasSelection ? new Set(selectedOutputIndices) : null;
  const outputTypes = allActualProvides.map((type2, idx) => {
    const index = idx + 1;
    const isInLayerROut = layerROutTypes.some(
      (rOutType) => typeCheckerRef.isTypeAssignableTo(type2, rOutType) || typeCheckerRef.isTypeAssignableTo(rOutType, type2)
    );
    return {
      index,
      typeString: typeCheckerRef.typeToString(type2, void 0, tsRef.TypeFormatFlags.NoTruncation),
      included: selectedSet ? selectedSet.has(index) : isInLayerROut
    };
  });
  const targetOutputs = hasSelection ? allActualProvides.filter((_, idx) => selectedSet.has(idx + 1)) : allActualProvides.filter(
    (type2) => layerROutTypes.some(
      (rOutType) => typeCheckerRef.isTypeAssignableTo(type2, rOutType) || typeCheckerRef.isTypeAssignableTo(rOutType, type2)
    )
  );
  const suggestedComposition = yield* pipe(
    gen3(function* () {
      if (targetOutputs.length === 0) {
        return void 0;
      }
      const { layerMagicNodes } = yield* convertOutlineGraphToLayerMagic(
        outlineGraph,
        targetOutputs
      );
      const steps = layerMagicNodes.map((node, index) => {
        const layerName = getExpressionName(tsRef, node.layerExpression);
        const operation = index === 0 ? "provide" : node.merges && node.provides ? "provideMerge" : node.merges ? "merge" : "provide";
        return { operation, layerName };
      });
      return steps.length > 1 ? steps : void 0;
    }),
    orElse15(() => succeed17(void 0))
  );
  return { providersAndRequirers: displayInfo, suggestedComposition, outputTypes };
});
function getExpressionName(tsApi, expr) {
  if (tsApi.isIdentifier(expr)) {
    return tsApi.idText(expr);
  }
  if (tsApi.isPropertyAccessExpression(expr)) {
    return `${getExpressionName(tsApi, expr.expression)}.${tsApi.idText(expr.name)}`;
  }
  if (tsApi.isCallExpression(expr)) {
    return getExpressionName(tsApi, expr.expression);
  }
  const text10 = expr.getText().replace(/\s+/g, " ");
  return text10.length > 30 ? text10.slice(0, 27) + "..." : text10;
}
var collectLayerInfoByName = (sourceFile, layerName, selectedOutputIndices) => gen3(function* () {
  const ts = yield* service2(TypeScriptApi);
  const typeChecker = yield* service2(TypeCheckerApi);
  const { layers } = yield* collectExportedItems(sourceFile, ts, typeChecker, 0, true);
  const layer12 = layers.find((l) => l.name === layerName);
  if (!layer12 || !layer12.tsInfo) {
    return yield* fail18(new LayerNotFoundError(layerName, layers.map((l) => l.name)));
  }
  const layerExpression = findLayerExpression(ts, layer12.tsInfo.node);
  if (!layerExpression) {
    return { layer: layer12, providersAndRequirers: [], suggestedComposition: void 0, outputTypes: [] };
  }
  const details = yield* pipe(
    collectLayerDetailsFromExpression(layerExpression, selectedOutputIndices),
    orElse15(
      () => succeed17({ providersAndRequirers: [], suggestedComposition: void 0, outputTypes: [] })
    )
  );
  return { layer: layer12, ...details };
});
function findLayerExpression(ts, node) {
  if (ts.isExpression(node)) {
    return node;
  }
  if (ts.isIdentifier(node)) {
    const parent = node.parent;
    if (ts.isVariableDeclaration(parent) && parent.initializer) {
      return parent.initializer;
    }
  }
  let current = node;
  while (current) {
    if (ts.isVariableDeclaration(current) && current.initializer) {
      return current.initializer;
    }
    current = current.parent;
  }
  return void 0;
}
var parseOutputIndices = (outputs) => {
  if (isNone2(outputs)) return void 0;
  const value5 = outputs.value.trim();
  if (value5 === "") return void 0;
  return value5.split(",").map((s) => parseInt(s.trim(), 10)).filter((n) => !isNaN(n) && n > 0);
};
var layerInfo = make58(
  "layerinfo",
  {
    file: file3("file").pipe(
      withDescription3("The full path of the file containing the layer.")
    ),
    name: text8("name").pipe(
      withDescription3("The name of the exported layer to inspect.")
    ),
    outputs: text8("outputs").pipe(
      withDescription3(
        "Comma-separated list of output indices to include in suggested composition (e.g., 1,2,3). If not specified, all outputs are included."
      ),
      optional4
    )
  },
  fn("layerInfo")(function* ({ file: file5, name, outputs }) {
    const path2 = yield* Path2;
    const cwd = path2.resolve(".");
    const tsInstance = yield* TypeScriptContext;
    const resolvedFile = path2.resolve(file5);
    const selectedOutputIndices = parseOutputIndices(outputs);
    const { service: service3 } = (0, import_project_service4.createProjectService)({ options: { loadTypeScriptPlugins: false } });
    service3.openClientFile(resolvedFile);
    try {
      const scriptInfo = service3.getScriptInfo(resolvedFile);
      if (!scriptInfo) {
        return yield* fail7(new LayerNotFoundError(name, []));
      }
      const projectInfo = scriptInfo.getDefaultProject();
      const languageService = projectInfo.getLanguageService(true);
      const program = languageService.getProgram();
      if (!program) {
        return yield* fail7(new LayerNotFoundError(name, []));
      }
      const sourceFile = program.getSourceFile(resolvedFile);
      if (!sourceFile) {
        return yield* fail7(new LayerNotFoundError(name, []));
      }
      const typeChecker = program.getTypeChecker();
      const layerInfoResult = pipe(
        collectLayerInfoByName(sourceFile, name, selectedOutputIndices),
        nanoLayer3,
        nanoLayer2,
        nanoLayer,
        provideService7(TypeCheckerApi, typeChecker),
        provideService7(TypeScriptProgram, program),
        provideService7(TypeScriptApi, tsInstance),
        run9
      );
      if (isLeft2(layerInfoResult)) {
        return yield* fail7(layerInfoResult.left);
      }
      const doc = renderLayerInfo(layerInfoResult.right, cwd);
      yield* log3(render3(doc, { style: "pretty" }));
    } finally {
      service3.closeClientFile(resolvedFile);
    }
  })
).pipe(
  withDescription6(
    "Shows detailed information about an exported layer in a file, showing dependencies as well helping you to get the right layer composition."
  )
);

// src/cli/patch.ts
var UnableToFindPositionToPatchError = class extends TaggedError("UnableToFindPositionToPatchError") {
  get message() {
    return `Unable to find position to patch ${this.positionToFind}`;
  }
};
var LOCAL_TYPESCRIPT_DIR2 = "./node_modules/typescript";
var dirPath2 = directory2("dir").pipe(
  withDefault3(LOCAL_TYPESCRIPT_DIR2),
  withDescription3("The directory of the typescript package to patch.")
);
var moduleNames = choice3("module", [
  "tsc",
  "typescript"
]).pipe(
  repeated4,
  withDescription3("The name of the module to patch.")
);
var force2 = boolean5("force").pipe(
  withDefault3(false),
  withDescription3("Force patch even if already patched.")
);
var getPatchedMarker = (version) => {
  return `"use effect-lsp-patch-version ${version}";`;
};
var getPatchesForModule = fn("getPatchesForModule")(
  function* (moduleName, dirPath4, version, sourceFile) {
    const ts = yield* TypeScriptContext;
    const patches = [];
    let insertClearSourceFileEffectMetadataPosition = none2();
    let insertCheckSourceFilePosition = none2();
    let insertSkipPrecedingCommentDirectivePosition = none2();
    let insertAppendMetadataRelationErrorPosition = none2();
    let insertEmitFilesAndReportErrorsDiagnosticsRange = none2();
    let nodesToCheck = [];
    function findNodeAtPositionIncludingTrivia(sourceFile2, position) {
      function find3(node) {
        if (position >= node.pos && position < node.end) {
          return ts.forEachChild(node, find3) || node;
        }
        return void 0;
      }
      return find3(sourceFile2);
    }
    function pushFunctionDeclarationNode(text10) {
      const regex = new RegExp(text10, "ig");
      let pushed = false;
      let match18;
      while ((match18 = regex.exec(sourceFile.text)) !== null) {
        const node = findNodeAtPositionIncludingTrivia(sourceFile, match18.index);
        if (node) {
          const functionDeclaration = ts.findAncestor(node, ts.isFunctionDeclaration);
          nodesToCheck.push(functionDeclaration || node);
          pushed = true;
        }
      }
      return pushed;
    }
    let requiresFullScan = false;
    if (!pushFunctionDeclarationNode("checkSourceFileWorker")) requiresFullScan = true;
    if (!pushFunctionDeclarationNode("markPrecedingCommentDirectiveLine")) requiresFullScan = true;
    if (!pushFunctionDeclarationNode("reportRelationError")) requiresFullScan = true;
    if (!pushFunctionDeclarationNode("emitFilesAndReportErrors")) requiresFullScan = true;
    if (requiresFullScan) nodesToCheck = [sourceFile];
    while (nodesToCheck.length > 0) {
      const node = nodesToCheck.shift();
      if (!node) continue;
      if (ts.isExpressionStatement(node)) {
        const expression = node.expression;
        if (ts.isCallExpression(expression)) {
          const identifier2 = expression.expression;
          if (ts.isIdentifier(identifier2) && ts.idText(identifier2) === "checkGrammarSourceFile" && ts.isBlock(node.parent) && node.parent.statements.length > 0) {
            const block = node.parent;
            const parentFunctionDeclaration = ts.findAncestor(node, ts.isFunctionDeclaration);
            if (parentFunctionDeclaration && parentFunctionDeclaration.name && ts.isIdentifier(parentFunctionDeclaration.name) && ts.idText(parentFunctionDeclaration.name) === "checkSourceFileWorker") {
              insertClearSourceFileEffectMetadataPosition = some2({ position: node.pos });
              insertCheckSourceFilePosition = some2({
                position: block.statements[block.statements.length - 1].end
              });
            }
          }
        }
      } else if (ts.isFunctionDeclaration(node)) {
        if (node.name && ts.isIdentifier(node.name) && ts.idText(node.name) === "markPrecedingCommentDirectiveLine" && node.body && node.body.statements.length > 0) {
          insertSkipPrecedingCommentDirectivePosition = some2({ position: node.body.statements[0].pos });
        }
        if (node.name && ts.isIdentifier(node.name) && ts.idText(node.name) === "reportRelationError" && node.body && node.body.statements.length > 0 && node.parameters.length >= 3) {
          const sourceIdentifier2 = node.parameters[1] && ts.isParameter(node.parameters[1]) && ts.isIdentifier(node.parameters[1].name) ? ts.idText(node.parameters[1].name) : void 0;
          const targetIdentifier2 = node.parameters[2] && ts.isParameter(node.parameters[2]) && ts.isIdentifier(node.parameters[2].name) ? ts.idText(node.parameters[2].name) : void 0;
          if (sourceIdentifier2 && targetIdentifier2) {
            insertAppendMetadataRelationErrorPosition = some2({
              position: node.body.statements[0].pos,
              sourceIdentifier: sourceIdentifier2,
              targetIdentifier: targetIdentifier2
            });
          }
        }
      } else if (ts.isReturnStatement(node)) {
        const parentBlock = node.parent;
        if (parentBlock && ts.isBlock(parentBlock)) {
          const parentFunctionDeclaration = parentBlock.parent;
          if (parentFunctionDeclaration && ts.isFunctionDeclaration(parentFunctionDeclaration) && parentFunctionDeclaration.name && ts.isIdentifier(parentFunctionDeclaration.name) && ts.idText(parentFunctionDeclaration.name) === "emitFilesAndReportErrors") {
            if (node.expression && ts.isObjectLiteralExpression(node.expression)) {
              const properties = node.expression.properties;
              for (const property of properties) {
                if (property && ts.isShorthandPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "diagnostics") {
                  insertEmitFilesAndReportErrorsDiagnosticsRange = some2({
                    pos: property.pos,
                    end: property.end
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, (child) => {
        nodesToCheck.push(child);
        return void 0;
      });
    }
    if (isNone2(insertClearSourceFileEffectMetadataPosition)) {
      return yield* fail7(
        new UnableToFindPositionToPatchError({ positionToFind: "clearSourceFileEffectMetadata" })
      );
    }
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertClearSourceFileEffectMetadataPosition.value.position,
        insertClearSourceFileEffectMetadataPosition.value.position,
        `effectLspPatchUtils().clearSourceFileEffectMetadata(node)
`,
        "\n",
        version
      )
    );
    if (isNone2(insertCheckSourceFilePosition)) {
      return yield* fail7(new UnableToFindPositionToPatchError({ positionToFind: "checkSourceFileWorker" }));
    }
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertCheckSourceFilePosition.value.position,
        insertCheckSourceFilePosition.value.position,
        `effectLspPatchUtils().checkSourceFileWorker(${moduleName === "typescript" ? "module.exports" : "effectLspTypeScriptApis()"}, host, node, compilerOptions, diagnostics.add, "${moduleName}")
`,
        "\n",
        version
      )
    );
    if (isNone2(insertAppendMetadataRelationErrorPosition)) {
      return yield* fail7(
        new UnableToFindPositionToPatchError({ positionToFind: "appendMetadataRelationError" })
      );
    }
    const { sourceIdentifier, targetIdentifier } = insertAppendMetadataRelationErrorPosition.value;
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertAppendMetadataRelationErrorPosition.value.position,
        insertAppendMetadataRelationErrorPosition.value.position,
        `effectLspPatchUtils().appendMetadataRelationError(${moduleName === "typescript" ? "module.exports" : "effectLspTypeScriptApis()"}, errorNode, ${sourceIdentifier}, ${targetIdentifier})
`,
        "\n",
        version
      )
    );
    if (isNone2(insertSkipPrecedingCommentDirectivePosition)) {
      return yield* new UnableToFindPositionToPatchError({ positionToFind: "skip preceding comment directive" });
    }
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertSkipPrecedingCommentDirectivePosition.value.position,
        insertSkipPrecedingCommentDirectivePosition.value.position,
        'if(diagnostic && diagnostic.source === "effect"){ return -1; }\n',
        "\n",
        version
      )
    );
    if (isNone2(insertEmitFilesAndReportErrorsDiagnosticsRange)) {
      return yield* new UnableToFindPositionToPatchError({ positionToFind: "extractDiagnosticsForExitStatus" });
    }
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertEmitFilesAndReportErrorsDiagnosticsRange.value.pos,
        insertEmitFilesAndReportErrorsDiagnosticsRange.value.end,
        `diagnostics: effectLspPatchUtils().extractDiagnosticsForExitStatus(${moduleName === "typescript" ? "module.exports" : "effectLspTypeScriptApis()"}, program, diagnostics, "${moduleName}")
`,
        " ",
        version
      )
    );
    let eofPos = sourceFile.text.lastIndexOf("// src/") - 1;
    if (eofPos < 0) eofPos = sourceFile.text.length;
    if (moduleName !== "typescript") {
      patches.push(
        yield* makeEffectLspPatchChange(
          sourceFile.text,
          eofPos,
          eofPos,
          yield* getTypeScriptApisUtils(dirPath4),
          "\n\n// src/@effect/language-service/effect-lsp-patch-utils.ts\n",
          version
        )
      );
    }
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        eofPos,
        eofPos,
        yield* getEffectLspPatchUtils(),
        "\n\n// src/@effect/language-service/embedded-typescript-copy.ts\n",
        version
      )
    );
    patches.push(
      yield* makeEffectLspPatchChange(
        sourceFile.text,
        insertCheckSourceFilePosition.value.position,
        insertCheckSourceFilePosition.value.position,
        getPatchedMarker(version) + "\n",
        "\n",
        version
      )
    );
    return patches;
  }
);
var printRememberDeleteTsbuildinfo = fn("printRememberDeleteTsbuildinfo")(function* () {
  yield* logInfo2(
    `If your project uses incremental builds, delete the .tsbuildinfo files and perform a full build.`
  );
});
var printRememberPrepareScript = fn("printRememberPrepareScript")(function* () {
  const packageJson = yield* getPackageJsonData(".");
  if (packageJson.scripts && "prepare" in packageJson.scripts) {
    const prepareScript = packageJson.scripts.prepare;
    if (prepareScript.toLocaleLowerCase().includes("effect-language-service")) return;
  }
  yield* logInfo2(
    `No prepare script found in package.json; to make the patch persistent across package installations and updates, add the following to your package.json scripts:
  "scripts": {
          "prepare": "effect-language-service patch"
  }`
  );
}, ignore2);
var patch9 = make58(
  "patch",
  { dirPath: dirPath2, moduleNames, force: force2 },
  fn("patch")(function* ({ dirPath: dirPath4, force: force3, moduleNames: moduleNames3 }) {
    const fs = yield* FileSystem;
    const { version: effectLspVersion } = yield* getPackageJsonData(__dirname);
    yield* logDebug2(`Searching for typescript in ${dirPath4}...`);
    const { version: typescriptVersion } = yield* getPackageJsonData(dirPath4);
    yield* logDebug2(`Found typescript version ${typescriptVersion}!`);
    const modulesToPatch = moduleNames3.length === 0 ? ["typescript", "tsc"] : moduleNames3;
    for (const moduleName of modulesToPatch) {
      yield* logDebug2(`Searching ${moduleName}...`);
      const filePath = yield* getModuleFilePath(dirPath4, moduleName);
      yield* logDebug2(`Reading ${moduleName} from ${filePath}...`);
      const sourceText = yield* getSourceFileText(filePath);
      yield* logDebug2(
        `Checking if ${filePath} is already patched with marker ${getPatchedMarker(effectLspVersion)}...`
      );
      if (!force3 && sourceText.indexOf(getPatchedMarker(effectLspVersion)) !== -1) {
        yield* logInfo2(`${filePath} is already patched with version ${effectLspVersion}, skipped.`);
        continue;
      }
      yield* logDebug2(`Parsing ${moduleName}...`);
      const sourceFile = yield* getUnpatchedSourceFile(filePath, sourceText);
      yield* logDebug2(`Collecting patches for ${moduleName}...`);
      const patches = yield* getPatchesForModule(moduleName, dirPath4, effectLspVersion, sourceFile);
      const newSourceText = yield* applyTextChanges(sourceFile.text, patches);
      yield* fs.writeFileString(filePath, newSourceText);
      yield* logInfo2(`${filePath} patched successfully.`);
    }
    yield* printRememberDeleteTsbuildinfo();
    yield* printRememberPrepareScript();
  })
).pipe(
  withDescription6(
    "Patches the typescript package with the effect-language-service, so that effect diagnostics are available at build time with tsc."
  )
);

// src/cli/quickfixes.ts
var import_project_service5 = __toESM(require_dist2());

// src/cli/setup/text-diff-renderer.ts
function getLines(text10) {
  return text10.split("\n");
}
function getLineAndCharacterOfPosition(text10, position) {
  const lines3 = text10.split("\n");
  let currentPos = 0;
  for (let lineIndex = 0; lineIndex < lines3.length; lineIndex++) {
    const lineLength = lines3[lineIndex].length;
    const lineEndPos = currentPos + lineLength;
    if (position <= lineEndPos) {
      return { line: lineIndex, character: position - currentPos };
    }
    currentPos = lineEndPos + 1;
  }
  const lastLineIndex = lines3.length - 1;
  return { line: lastLineIndex, character: lines3[lastLineIndex]?.length ?? 0 };
}
function renderLine(lineNum, symbol3, text10, color3) {
  const lineNumPart = lineNum !== void 0 ? String(lineNum).padStart(4, " ") : "    ";
  return annotate2(text3(`${lineNumPart} ${symbol3} ${text10}`), color3);
}
function renderPlainTextChange(text10, textChange) {
  const startPos = textChange.span.start;
  const endPos = textChange.span.start + textChange.span.length;
  const startLineAndChar = getLineAndCharacterOfPosition(text10, startPos);
  const endLineAndChar = getLineAndCharacterOfPosition(text10, endPos);
  const startLine = startLineAndChar.line;
  const endLine = endLineAndChar.line;
  const startCol = startLineAndChar.character;
  const endCol = endLineAndChar.character;
  const lines3 = [];
  const allLines = getLines(text10);
  if (startLine > 0) {
    const contextBefore = allLines[startLine - 1];
    lines3.push(renderLine(startLine, "|", contextBefore, blackBright2));
  }
  if (startLine <= endLine) {
    const firstLineText = allLines[startLine];
    const keptBeforeDeletion = firstLineText.slice(0, startCol);
    const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
    if (hasNonWhitespaceKept) {
      lines3.push(renderLine(startLine + 1, "|", keptBeforeDeletion, blackBright2));
    }
    const deletedOnFirstLine = startLine === endLine ? firstLineText.slice(startCol, endCol) : firstLineText.slice(startCol);
    if (deletedOnFirstLine.length > 0) {
      const spacePadding = hasNonWhitespaceKept ? " ".repeat(keptBeforeDeletion.length) : "";
      lines3.push(renderLine(void 0, "-", `${spacePadding}${deletedOnFirstLine}`, red4));
    }
  }
  for (let i = startLine + 1; i < endLine; i++) {
    const lineText = allLines[i];
    if (lineText !== void 0) {
      lines3.push(renderLine(void 0, "-", lineText, red4));
    }
  }
  if (endLine > startLine) {
    const lastLineText = allLines[endLine];
    const deletedOnLastLine = lastLineText.slice(0, endCol);
    if (deletedOnLastLine.length > 0) {
      lines3.push(renderLine(void 0, "-", deletedOnLastLine, red4));
    }
  }
  if (textChange.newText.length > 0) {
    const newTextLines = textChange.newText.split("\n");
    const firstLineText = allLines[startLine];
    const keptBeforeDeletion = firstLineText.slice(0, startCol);
    const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
    const spacePadding = hasNonWhitespaceKept ? " ".repeat(keptBeforeDeletion.length) : "";
    for (let i = 0; i < newTextLines.length; i++) {
      const newLine = newTextLines[i];
      if (i === newTextLines.length - 1 && newLine.length === 0 && newTextLines.length > 1) {
        continue;
      }
      const padding = i === 0 && hasNonWhitespaceKept ? spacePadding : "";
      lines3.push(renderLine(void 0, "+", `${padding}${newLine}`, green3));
    }
  }
  let alignmentForKeptPart = 0;
  if (textChange.newText.length > 0) {
    const newTextLines = textChange.newText.split("\n");
    const lastNewLine = newTextLines[newTextLines.length - 1];
    if (lastNewLine.length === 0 && newTextLines.length > 1) {
      alignmentForKeptPart = 0;
    } else {
      const firstLineText = allLines[startLine];
      const keptBeforeDeletion = firstLineText.slice(0, startCol);
      const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
      if (hasNonWhitespaceKept) {
        if (newTextLines.length === 1) {
          alignmentForKeptPart = keptBeforeDeletion.length + lastNewLine.length;
        } else {
          alignmentForKeptPart = lastNewLine.length;
        }
      } else {
        alignmentForKeptPart = lastNewLine.length;
      }
    }
  } else {
    alignmentForKeptPart = endCol;
  }
  if (endLine > startLine) {
    const lastLineText = allLines[endLine];
    const keptAfterDeletion = lastLineText.slice(endCol);
    if (keptAfterDeletion.trim().length > 0) {
      const alignment = " ".repeat(alignmentForKeptPart);
      lines3.push(renderLine(endLine + 1, "|", `${alignment}${keptAfterDeletion}`, blackBright2));
    }
  } else if (startLine === endLine) {
    const firstLineText = allLines[startLine];
    const keptAfterDeletion = firstLineText.slice(endCol);
    if (keptAfterDeletion.trim().length > 0) {
      const alignment = " ".repeat(alignmentForKeptPart);
      lines3.push(renderLine(startLine + 1, "|", `${alignment}${keptAfterDeletion}`, blackBright2));
    }
  }
  if (endLine + 1 < allLines.length) {
    const contextAfter = allLines[endLine + 1];
    lines3.push(renderLine(endLine + 2, "|", contextAfter, blackBright2));
  }
  return lines3;
}
function renderPlainTextFileChanges(text10, textChanges) {
  const lines3 = [];
  const sortedChanges = [...textChanges].sort((a, b) => a.span.start - b.span.start);
  for (let i = 0; i < sortedChanges.length; i++) {
    const change = sortedChanges[i];
    const changeLines = renderPlainTextChange(text10, change);
    for (const line4 of changeLines) {
      lines3.push(line4);
    }
    if (i < sortedChanges.length - 1) {
      lines3.push(text3(""));
    }
  }
  return lines3;
}

// src/cli/setup/diff-renderer.ts
function getLines2(text10) {
  return text10.split("\n");
}
function renderLine2(lineNum, symbol3, text10, color3) {
  const lineNumPart = lineNum !== void 0 ? String(lineNum).padStart(4, " ") : "    ";
  return annotate2(text3(`${lineNumPart} ${symbol3} ${text10}`), color3);
}
function renderTextChange(sourceFile, textChange) {
  const startPos = textChange.span.start;
  const endPos = textChange.span.start + textChange.span.length;
  const startLineAndChar = sourceFile.getLineAndCharacterOfPosition(startPos);
  const endLineAndChar = sourceFile.getLineAndCharacterOfPosition(endPos);
  const startLine = startLineAndChar.line;
  const endLine = endLineAndChar.line;
  const startCol = startLineAndChar.character;
  const endCol = endLineAndChar.character;
  const lines3 = [];
  const allLines = getLines2(sourceFile.text);
  if (startLine > 0) {
    const contextBefore = allLines[startLine - 1];
    lines3.push(renderLine2(startLine, "|", contextBefore, blackBright2));
  }
  if (startLine <= endLine) {
    const firstLineText = allLines[startLine];
    const keptBeforeDeletion = firstLineText.slice(0, startCol);
    const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
    if (hasNonWhitespaceKept) {
      lines3.push(renderLine2(startLine + 1, "|", keptBeforeDeletion, blackBright2));
    }
    const deletedOnFirstLine = startLine === endLine ? firstLineText.slice(startCol, endCol) : firstLineText.slice(startCol);
    if (deletedOnFirstLine.length > 0) {
      const spacePadding = hasNonWhitespaceKept ? " ".repeat(keptBeforeDeletion.length) : "";
      lines3.push(renderLine2(void 0, "-", `${spacePadding}${deletedOnFirstLine}`, red4));
    }
  }
  for (let i = startLine + 1; i < endLine; i++) {
    const lineText = allLines[i];
    if (lineText !== void 0) {
      lines3.push(renderLine2(void 0, "-", lineText, red4));
    }
  }
  if (endLine > startLine) {
    const lastLineText = allLines[endLine];
    const deletedOnLastLine = lastLineText.slice(0, endCol);
    if (deletedOnLastLine.length > 0) {
      lines3.push(renderLine2(void 0, "-", deletedOnLastLine, red4));
    }
  }
  if (textChange.newText.length > 0) {
    const newTextLines = textChange.newText.split("\n");
    const firstLineText = allLines[startLine];
    const keptBeforeDeletion = firstLineText.slice(0, startCol);
    const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
    const spacePadding = hasNonWhitespaceKept ? " ".repeat(keptBeforeDeletion.length) : "";
    for (let i = 0; i < newTextLines.length; i++) {
      const newLine = newTextLines[i];
      if (i === newTextLines.length - 1 && newLine.length === 0 && newTextLines.length > 1) {
        continue;
      }
      const padding = i === 0 && hasNonWhitespaceKept ? spacePadding : "";
      lines3.push(renderLine2(void 0, "+", `${padding}${newLine}`, green3));
    }
  }
  let alignmentForKeptPart = 0;
  if (textChange.newText.length > 0) {
    const newTextLines = textChange.newText.split("\n");
    const lastNewLine = newTextLines[newTextLines.length - 1];
    if (lastNewLine.length === 0 && newTextLines.length > 1) {
      alignmentForKeptPart = 0;
    } else {
      const firstLineText = allLines[startLine];
      const keptBeforeDeletion = firstLineText.slice(0, startCol);
      const hasNonWhitespaceKept = keptBeforeDeletion.trim().length > 0;
      if (hasNonWhitespaceKept) {
        if (newTextLines.length === 1) {
          alignmentForKeptPart = keptBeforeDeletion.length + lastNewLine.length;
        } else {
          alignmentForKeptPart = lastNewLine.length;
        }
      } else {
        alignmentForKeptPart = lastNewLine.length;
      }
    }
  } else {
    alignmentForKeptPart = endCol;
  }
  if (endLine > startLine) {
    const lastLineText = allLines[endLine];
    const keptAfterDeletion = lastLineText.slice(endCol);
    if (keptAfterDeletion.trim().length > 0) {
      const alignment = " ".repeat(alignmentForKeptPart);
      lines3.push(renderLine2(endLine + 1, "|", `${alignment}${keptAfterDeletion}`, blackBright2));
    }
  } else if (startLine === endLine) {
    const firstLineText = allLines[startLine];
    const keptAfterDeletion = firstLineText.slice(endCol);
    if (keptAfterDeletion.trim().length > 0) {
      const alignment = " ".repeat(alignmentForKeptPart);
      lines3.push(renderLine2(startLine + 1, "|", `${alignment}${keptAfterDeletion}`, blackBright2));
    }
  }
  if (endLine + 1 < allLines.length) {
    const contextAfter = allLines[endLine + 1];
    lines3.push(renderLine2(endLine + 2, "|", contextAfter, blackBright2));
  }
  return lines3;
}
function renderFileChanges(sourceFile, textChanges) {
  const lines3 = [];
  const sortedChanges = [...textChanges].sort((a, b) => a.span.start - b.span.start);
  for (let i = 0; i < sortedChanges.length; i++) {
    const change = sortedChanges[i];
    const changeLines = renderTextChange(sourceFile, change);
    for (const line4 of changeLines) {
      lines3.push(line4);
    }
    if (i < sortedChanges.length - 1) {
      lines3.push(text3(""));
    }
  }
  return lines3;
}
var renderCodeActions = (result, assessmentState) => gen2(function* () {
  if (result.codeActions.length === 0) {
    const noChanges = annotate2(
      text3("No changes needed - your configuration is already up to date!"),
      green3
    );
    const noChangesStr = noChanges.pipe(render3({ style: "pretty" }));
    yield* log3(noChangesStr);
    return;
  }
  const sourceFiles = [
    assessmentState.packageJson.sourceFile,
    assessmentState.tsconfig.sourceFile
  ];
  if (isSome2(assessmentState.vscodeSettings)) {
    sourceFiles.push(assessmentState.vscodeSettings.value.sourceFile);
  }
  const plainTextFiles = [];
  if (isSome2(assessmentState.agentsMd)) {
    plainTextFiles.push({
      path: assessmentState.agentsMd.value.path,
      text: assessmentState.agentsMd.value.text
    });
  }
  if (isSome2(assessmentState.claudeMd)) {
    plainTextFiles.push({
      path: assessmentState.claudeMd.value.path,
      text: assessmentState.claudeMd.value.text
    });
  }
  for (const codeAction of result.codeActions) {
    for (const fileChange of codeAction.changes) {
      const sourceFile = sourceFiles.find((sf) => sf.fileName === fileChange.fileName);
      const plainTextFile = plainTextFiles.find((pf) => pf.path === fileChange.fileName);
      const header = vsep2([
        empty32,
        annotate2(text3(codeAction.description), bold2),
        annotate2(text3(fileChange.fileName), cyan4),
        empty32
      ]);
      const headerStr = header.pipe(render3({ style: "pretty" }));
      yield* log3(headerStr);
      if (sourceFile) {
        const diffLines = renderFileChanges(sourceFile, fileChange.textChanges);
        const diff8 = vsep2(diffLines);
        const diffStr = diff8.pipe(render3({ style: "pretty" }));
        yield* log3(diffStr);
      } else if (plainTextFile) {
        const diffLines = renderPlainTextFileChanges(plainTextFile.text, fileChange.textChanges);
        const diff8 = vsep2(diffLines);
        const diffStr = diff8.pipe(render3({ style: "pretty" }));
        yield* log3(diffStr);
      } else {
        const noticeStr = text3("  (file will be modified)").pipe(render3({ style: "pretty" }));
        yield* log3(noticeStr);
      }
    }
  }
  if (result.messages.length > 0) {
    yield* log3("");
    for (const message of result.messages) {
      const messageDoc = message.includes("WARNING") ? annotate2(text3(message), yellow3) : text3(message);
      const messageStr = messageDoc.pipe(render3({ style: "pretty" }));
      yield* log3(messageStr);
    }
  }
});

// src/cli/quickfixes.ts
var validDiagnosticNames = new Set(diagnostics.map((_) => _.name));
var validDiagnosticCodes = new Set(diagnostics.map((_) => String(_.code)));
var diagnosticCodeByName = new Map(diagnostics.map((_) => [_.name, _.code]));
var ColumnRequiresLineError = class extends TaggedError("ColumnRequiresLineError") {
  get message() {
    return "The --column option requires --line to be specified.";
  }
};
var isSkipFix = (fixName) => fixName.endsWith("_skipNextLine") || fixName.endsWith("_skipFile");
var renderQuickFix = (sourceFile, fix) => {
  const lines3 = [];
  lines3.push(empty32);
  lines3.push(
    cat2(
      cat2(
        cat2(
          annotate2(text3("  Fix: "), bold2),
          annotate2(text3(fix.fixName), cyan4)
        ),
        text3(" - ")
      ),
      text3(fix.description)
    )
  );
  lines3.push(annotate2(text3("  " + "\u2500".repeat(60)), blackBright2));
  for (const fileChange of fix.changes) {
    if (fileChange.fileName === sourceFile.fileName) {
      for (const textChange of fileChange.textChanges) {
        const diffLines = renderTextChange(sourceFile, textChange);
        for (const diffLine of diffLines) {
          lines3.push(cat2(text3("  "), diffLine));
        }
      }
    }
  }
  return vsep2(lines3);
};
var renderDiagnosticWithFixes = (sourceFile, info2, tsInstance) => {
  const lines3 = [];
  const { character, line: line4 } = tsInstance.getLineAndCharacterOfPosition(sourceFile, info2.diagnostic.start);
  const locationStr = `${sourceFile.fileName}:${line4 + 1}:${character + 1}`;
  lines3.push(
    cat2(
      cat2(
        cat2(
          cat2(
            annotate2(text3(locationStr), cyan4),
            text3(" ")
          ),
          annotate2(text3(`effect(${info2.diagnostic.ruleName})`), yellow3)
        ),
        text3(": ")
      ),
      text3(info2.diagnostic.messageText)
    )
  );
  for (const fix of info2.fixes) {
    lines3.push(renderQuickFix(sourceFile, fix));
  }
  lines3.push(empty32);
  return vsep2(lines3);
};
var BATCH_SIZE4 = 50;
var quickfixes = make58(
  "quickfixes",
  {
    file: file3("file").pipe(
      optional4,
      withDescription3("The full path of the file to check for quick fixes.")
    ),
    project: file3("project").pipe(
      optional4,
      withDescription3("The full path of the project tsconfig.json file to check for quick fixes.")
    ),
    code: text8("code").pipe(
      withDescription3("Filter by diagnostic name or code (e.g., 'floatingEffect' or '5')."),
      mapEffect6((value5) => {
        if (validDiagnosticNames.has(value5)) {
          return succeed7(diagnosticCodeByName.get(value5));
        }
        if (validDiagnosticCodes.has(value5)) {
          return succeed7(Number(value5));
        }
        const validValues = [...validDiagnosticNames].sort().join(", ");
        return fail7(
          invalidValue2(
            p2(`Invalid diagnostic code '${value5}'. Valid values: ${validValues}`)
          )
        );
      }),
      optional4
    ),
    line: integer5("line").pipe(
      withDescription3("Filter by line number (1-based)."),
      optional4
    ),
    column: integer5("column").pipe(
      withDescription3("Filter by column number (1-based). Requires --line to be specified."),
      optional4
    ),
    fix: text8("fix").pipe(
      withDescription3("Filter by fix name (e.g., 'floatingEffect_yieldStar')."),
      optional4
    )
  },
  fn("quickfixes")(function* ({ code: code2, column: column3, file: file5, fix, line: line4, project: project3 }) {
    if (isSome2(column3) && isNone2(line4)) {
      return yield* new ColumnRequiresLineError();
    }
    const path2 = yield* Path2;
    const tsInstance = yield* TypeScriptContext;
    const filesToCheck = isSome2(project3) ? yield* getFileNamesInTsConfig(project3.value) : /* @__PURE__ */ new Set();
    if (isSome2(file5)) {
      filesToCheck.add(path2.resolve(file5.value));
    }
    if (filesToCheck.size === 0) {
      return yield* new NoFilesToCheckError();
    }
    let totalDiagnosticsWithFixes = 0;
    for (const batch of chunksOf(filesToCheck, BATCH_SIZE4)) {
      const { service: service3 } = (0, import_project_service5.createProjectService)({ options: { loadTypeScriptPlugins: false } });
      for (const filePath of batch) {
        service3.openClientFile(filePath);
        try {
          const scriptInfo = service3.getScriptInfo(filePath);
          if (!scriptInfo) continue;
          const projectInfo = scriptInfo.getDefaultProject();
          const languageService = projectInfo.getLanguageService(true);
          const program = languageService.getProgram();
          if (!program) continue;
          const sourceFile = program.getSourceFile(filePath);
          if (!sourceFile) continue;
          const pluginConfig = extractEffectLspOptions(program.getCompilerOptions());
          if (!pluginConfig) continue;
          const result = pipe(
            getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
            nanoLayer3,
            nanoLayer2,
            nanoLayer,
            provideService7(TypeCheckerApi, program.getTypeChecker()),
            provideService7(TypeScriptProgram, program),
            provideService7(TypeScriptApi, tsInstance),
            provideService7(
              LanguageServicePluginOptions,
              { ...parse4(pluginConfig), diagnosticsName: false }
            ),
            run9,
            getOrElse(() => ({ diagnostics: [], codeFixes: [] }))
          );
          const diagnosticMap = /* @__PURE__ */ new Map();
          for (const diagnostic of result.diagnostics) {
            if (diagnostic.start === void 0) continue;
            if (isSome2(code2) && diagnostic.code !== code2.value) continue;
            if (isSome2(line4)) {
              const pos = tsInstance.getLineAndCharacterOfPosition(sourceFile, diagnostic.start);
              if (pos.line !== line4.value - 1) continue;
              if (isSome2(column3) && pos.character !== column3.value - 1) continue;
            }
            const key = `${diagnostic.start}-${diagnostic.start + (diagnostic.length ?? 0)}-${diagnostic.code}`;
            const ruleName = Object.values(diagnostics).find((_) => _.code === diagnostic.code)?.name ?? `unknown(${diagnostic.code})`;
            if (!diagnosticMap.has(key)) {
              diagnosticMap.set(key, {
                diagnostic: {
                  start: diagnostic.start,
                  end: diagnostic.start + (diagnostic.length ?? 0),
                  messageText: tsInstance.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
                  code: diagnostic.code,
                  ruleName
                },
                fixes: []
              });
            }
          }
          const formatContext = tsInstance.formatting.getFormatContext(
            tsInstance.getDefaultFormatCodeSettings(),
            { getNewLine: () => "\n" }
          );
          for (const codeFix of result.codeFixes) {
            if (isSkipFix(codeFix.fixName)) continue;
            if (isSome2(fix) && codeFix.fixName !== fix.value) continue;
            const key = `${codeFix.start}-${codeFix.end}-${codeFix.code}`;
            const info2 = diagnosticMap.get(key);
            if (!info2) continue;
            const changes2 = tsInstance.textChanges.ChangeTracker.with(
              {
                formatContext,
                host: { getNewLine: () => "\n" },
                preferences: {}
              },
              (changeTracker) => pipe(
                codeFix.apply,
                provideService7(ChangeTracker, changeTracker),
                run9
              )
            );
            info2.fixes.push({
              fixName: codeFix.fixName,
              description: codeFix.description,
              changes: changes2
            });
          }
          const diagnosticsWithFixes = Array.from(diagnosticMap.values()).filter(
            (info2) => info2.fixes.length > 0
          );
          if (diagnosticsWithFixes.length === 0) continue;
          diagnosticsWithFixes.sort((a, b) => a.diagnostic.start - b.diagnostic.start);
          totalDiagnosticsWithFixes += diagnosticsWithFixes.length;
          for (const info2 of diagnosticsWithFixes) {
            const doc = renderDiagnosticWithFixes(sourceFile, info2, tsInstance);
            yield* log3(doc.pipe(render3({ style: "pretty" })));
          }
        } finally {
          service3.closeClientFile(filePath);
        }
      }
      yield* yieldNow4();
    }
    if (totalDiagnosticsWithFixes === 0) {
      yield* log3("No quick fixes available.");
    } else {
      yield* log3(
        annotate2(
          text3(`Found ${totalDiagnosticsWithFixes} diagnostic(s) with quick fixes.`),
          bold2
        ).pipe(render3({ style: "pretty" }))
      );
    }
  })
).pipe(
  withDescription6("Shows diagnostics with available quick fixes and their proposed changes.")
);

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/confirm.js
var renderBeep7 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear7(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearOutput = eraseText(options3.message, columns);
    const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
    return clearOutput.pipe(cat2(resetCurrentLine), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
var NEWLINE_REGEX5 = /\r?\n/;
function renderOutput6(confirm3, leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX5), {
    onEmpty: () => hsep2([prefix, trailingSymbol, confirm3]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(confirm3));
    }
  });
}
function renderNextFrame7(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const confirmMessage = state.value ? options3.placeholder.defaultConfirm : options3.placeholder.defaultDeny;
    const confirm3 = annotate2(text3(confirmMessage), blackBright2);
    const promptMsg = renderOutput6(confirm3, leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission7(value5, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const confirmMessage = value5 ? options3.label.confirm : options3.label.deny;
    const confirm3 = text3(confirmMessage);
    const promptMsg = renderOutput6(confirm3, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleRender6(options3) {
  return (_, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep7),
      NextFrame: ({
        state
      }) => renderNextFrame7(state, options3),
      Submit: ({
        value: value5
      }) => renderSubmission7(value5, options3)
    });
  };
}
var TRUE_VALUE_REGEX = /^y|t$/;
var FALSE_VALUE_REGEX = /^n|f$/;
function handleProcess6(input, defaultValue) {
  const value5 = getOrElse2(input.input, () => "");
  if (input.key.name === "enter" || input.key.name === "return") {
    return succeed7(Action.Submit({
      value: defaultValue
    }));
  }
  if (TRUE_VALUE_REGEX.test(value5.toLowerCase())) {
    return succeed7(Action.Submit({
      value: true
    }));
  }
  if (FALSE_VALUE_REGEX.test(value5.toLowerCase())) {
    return succeed7(Action.Submit({
      value: false
    }));
  }
  return succeed7(Action.Beep());
}
var confirm = (options3) => {
  const opts = {
    initial: false,
    ...options3,
    label: {
      confirm: "yes",
      deny: "no",
      ...options3.label
    },
    placeholder: {
      defaultConfirm: "(Y/n)",
      defaultDeny: "(y/N)",
      ...options3.placeholder
    }
  };
  const initialState3 = {
    value: opts.initial
  };
  return custom2(initialState3, {
    render: handleRender6(opts),
    process: (input) => handleProcess6(input, opts.initial),
    clear: () => handleClear7(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/internal/prompt/multi-select.js
var renderBeep8 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
var NEWLINE_REGEX6 = /\r?\n/;
function renderOutput7(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX6), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2));
    }
  });
}
function renderError5(state, pointer) {
  return match2(state.error, {
    onNone: () => empty32,
    onSome: (error4) => match3(error4.split(NEWLINE_REGEX6), {
      onEmpty: () => empty32,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => annotate2(text3(line4), combine11(italicized2, red4));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines3 = map4(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderChoiceDescription2(choice4, isHighlighted) {
  if (!choice4.disabled && choice4.description && isHighlighted) {
    return char3("-").pipe(cat2(space2), cat2(text3(choice4.description)), annotate2(blackBright2));
  }
  return empty32;
}
var metaOptionsCount = 2;
function renderChoices2(state, options3, figures4) {
  const choices = options3.choices;
  const totalChoices = choices.length;
  const selectedCount = state.selectedIndices.size;
  const allSelected = selectedCount === totalChoices;
  const selectAllText = allSelected ? options3?.selectNone ?? "Select None" : options3?.selectAll ?? "Select All";
  const inverseSelectionText = options3?.inverseSelection ?? "Inverse Selection";
  const metaOptions = [{
    title: selectAllText
  }, {
    title: inverseSelectionText
  }];
  const allChoices = [...metaOptions, ...choices];
  const toDisplay = entriesToDisplay(state.index, allChoices.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const choice4 = allChoices[index];
    const isHighlighted = state.index === index;
    let prefix = space2;
    if (index === toDisplay.startIndex && toDisplay.startIndex > 0) {
      prefix = figures4.arrowUp;
    } else if (index === toDisplay.endIndex - 1 && toDisplay.endIndex < allChoices.length) {
      prefix = figures4.arrowDown;
    }
    if (index < metaOptions.length) {
      const title = isHighlighted ? annotate2(text3(choice4.title), cyanBright2) : text3(choice4.title);
      documents.push(prefix.pipe(cat2(space2), cat2(title)));
    } else {
      const choiceIndex = index - metaOptions.length;
      const isSelected = state.selectedIndices.has(choiceIndex);
      const checkbox = isSelected ? figures4.checkboxOn : figures4.checkboxOff;
      const annotatedCheckbox = isHighlighted ? annotate2(checkbox, cyanBright2) : checkbox;
      const title = text3(choice4.title);
      const description = renderChoiceDescription2(choice4, isHighlighted);
      documents.push(prefix.pipe(cat2(space2), cat2(annotatedCheckbox), cat2(space2), cat2(title), cat2(space2), cat2(description)));
    }
  }
  return vsep2(documents);
}
function renderNextFrame8(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const choices = renderChoices2(state, options3, figures4);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures4.pointerSmall, blackBright2);
    const promptMsg = renderOutput7(leadingSymbol, trailingSymbol, options3);
    const error4 = renderError5(state, figures4.pointer);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(choices), cat2(error4), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission8(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures4 = yield* figures;
    const selectedChoices = Array.from(state.selectedIndices).sort(Order).map((index) => options3.choices[index].title);
    const selectedText = selectedChoices.join(", ");
    const selected = text3(selectedText);
    const leadingSymbol = annotate2(figures4.tick, green3);
    const trailingSymbol = annotate2(figures4.ellipsis, blackBright2);
    const promptMsg = renderOutput7(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(selected, white4)), cat2(hardLine2), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp3(state, totalChoices) {
  const newIndex = state.index === 0 ? totalChoices - 1 : state.index - 1;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      index: newIndex
    }
  }));
}
function processCursorDown3(state, totalChoices) {
  const newIndex = (state.index + 1) % totalChoices;
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      index: newIndex
    }
  }));
}
function processSpace(state, options3) {
  const selectedIndices = new Set(state.selectedIndices);
  if (state.index === 0) {
    if (state.selectedIndices.size === options3.choices.length) {
      selectedIndices.clear();
    } else {
      for (let i = 0; i < options3.choices.length; i++) {
        selectedIndices.add(i);
      }
    }
  } else if (state.index === 1) {
    for (let i = 0; i < options3.choices.length; i++) {
      if (state.selectedIndices.has(i)) {
        selectedIndices.delete(i);
      } else {
        selectedIndices.add(i);
      }
    }
  } else {
    const choiceIndex = state.index - metaOptionsCount;
    if (selectedIndices.has(choiceIndex)) {
      selectedIndices.delete(choiceIndex);
    } else {
      selectedIndices.add(choiceIndex);
    }
  }
  return succeed7(Action.NextFrame({
    state: {
      ...state,
      selectedIndices
    }
  }));
}
function handleClear8(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const text10 = "\n".repeat(Math.min(options3.choices.length + 2, options3.maxPerPage)) + options3.message + 1;
    const clearOutput = eraseText(text10, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess7(options3) {
  return (input, state) => {
    const totalChoices = options3.choices.length + metaOptionsCount;
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp3({
          ...state,
          error: none2()
        }, totalChoices);
      }
      case "j":
      case "down":
      case "tab": {
        return processCursorDown3({
          ...state,
          error: none2()
        }, totalChoices);
      }
      case "space": {
        return processSpace(state, options3);
      }
      case "enter":
      case "return": {
        const selectedCount = state.selectedIndices.size;
        if (options3.min !== void 0 && selectedCount < options3.min) {
          return succeed7(Action.NextFrame({
            state: {
              ...state,
              error: some2(`At least ${options3.min} are required`)
            }
          }));
        }
        if (options3.max !== void 0 && selectedCount > options3.max) {
          return succeed7(Action.NextFrame({
            state: {
              ...state,
              error: some2(`At most ${options3.max} choices are allowed`)
            }
          }));
        }
        const selectedValues = Array.from(state.selectedIndices).sort(Order).map((index) => options3.choices[index].value);
        return succeed7(Action.Submit({
          value: selectedValues
        }));
      }
      default: {
        return succeed7(Action.Beep());
      }
    }
  };
}
function handleRender7(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed7(renderBeep8),
      NextFrame: ({
        state: state2
      }) => renderNextFrame8(state2, options3),
      Submit: () => renderSubmission8(state, options3)
    });
  };
}
var multiSelect = (options3) => {
  const opts = {
    maxPerPage: 10,
    ...options3
  };
  const initialSelected = /* @__PURE__ */ new Set();
  for (let i = 0; i < opts.choices.length; i++) {
    const choice4 = opts.choices[i];
    if (choice4.selected === true) {
      initialSelected.add(i);
    }
  }
  return custom2({
    index: 0,
    selectedIndices: initialSelected,
    error: none2()
  }, {
    render: handleRender7(opts),
    process: handleProcess7(opts),
    clear: () => handleClear8(opts)
  });
};

// ../../node_modules/.pnpm/@effect+cli@0.73.0_@effect+platform@0.94.1_@effect+printer-ansi@0.47.0_@effect+printer@0.47.0_effect@3.19.14/node_modules/@effect/cli/dist/esm/Prompt.js
var confirm2 = confirm;
var custom3 = custom2;
var select2 = select;
var multiSelect2 = multiSelect;
var text9 = text5;

// src/cli/setup/assessment.ts
var MARKDOWN_START_MARKER = "<!-- effect-language-service:start -->";
var MARKDOWN_END_MARKER = "<!-- effect-language-service:end -->";
var MARKDOWN_DEFAULT_CONTENT = `${MARKDOWN_START_MARKER}
## Effect Language Service

The Effect Language Service comes in with a useful CLI that can help you with commands to get a better understanding your Effect Layers and Services, and to help you compose them correctly.
${MARKDOWN_END_MARKER}`;
var assessPackageJsonFromInput = (input) => gen2(function* () {
  const ts = yield* TypeScriptContext;
  const jsonSourceFile = ts.parseJsonText(input.fileName, input.text);
  const errors = [];
  const packageJson = ts.convertToObject(jsonSourceFile, errors);
  let lspVersion = none2();
  if ("@effect/language-service" in (packageJson.devDependencies ?? {})) {
    lspVersion = some2({
      dependencyType: "devDependencies",
      version: packageJson.devDependencies["@effect/language-service"]
    });
  } else if ("@effect/language-service" in (packageJson.dependencies ?? {})) {
    lspVersion = some2({
      dependencyType: "dependencies",
      version: packageJson.dependencies["@effect/language-service"]
    });
  }
  const prepareScript = "prepare" in (packageJson.scripts ?? {}) ? some2({
    script: packageJson.scripts.prepare,
    hasPatch: packageJson.scripts.prepare.toLowerCase().includes("effect-language-service")
  }) : none2();
  return {
    path: input.fileName,
    sourceFile: jsonSourceFile,
    lspVersion,
    prepareScript
  };
});
var assessTsConfigFromInput = (input) => gen2(function* () {
  const ts = yield* TypeScriptContext;
  const jsonSourceFile = ts.parseJsonText(input.fileName, input.text);
  const errors = [];
  const tsconfig = ts.convertToObject(jsonSourceFile, errors);
  const hasPlugins = tsconfig.compilerOptions?.plugins !== void 0;
  const plugins = tsconfig.compilerOptions?.plugins ?? [];
  const lspPlugin = findFirst2(plugins, (plugin) => plugin.name === "@effect/language-service");
  const currentOptions = isSome2(lspPlugin) ? some2(parse4(lspPlugin.value)) : none2();
  return {
    path: input.fileName,
    sourceFile: jsonSourceFile,
    hasPlugins,
    currentOptions
  };
});
var assessVSCodeSettingsFromInput = (input) => gen2(function* () {
  const ts = yield* TypeScriptContext;
  const jsonSourceFile = ts.parseJsonText(input.fileName, input.text);
  const errors = [];
  const settings = ts.convertToObject(jsonSourceFile, errors);
  return {
    path: input.fileName,
    sourceFile: jsonSourceFile,
    settings
  };
});
var assessMarkdownFromInput = (input) => {
  const text10 = input.text;
  const startIndex = text10.indexOf(MARKDOWN_START_MARKER);
  const endIndex = text10.indexOf(MARKDOWN_END_MARKER);
  const hasMarkers = startIndex !== -1 && endIndex !== -1 && startIndex < endIndex;
  const markerContent = hasMarkers ? some2(text10.slice(startIndex, endIndex + MARKDOWN_END_MARKER.length)) : none2();
  return {
    path: input.fileName,
    text: text10,
    hasMarkers,
    markerContent
  };
};
var assess = (input) => gen2(function* () {
  const packageJson = yield* assessPackageJsonFromInput(input.packageJson);
  const tsconfig = yield* assessTsConfigFromInput(input.tsconfig);
  const vscodeSettings = isSome2(input.vscodeSettings) ? some2(yield* assessVSCodeSettingsFromInput(input.vscodeSettings.value)) : none2();
  const agentsMd = isSome2(input.agentsMd) ? some2(assessMarkdownFromInput(input.agentsMd.value)) : none2();
  const claudeMd = isSome2(input.claudeMd) ? some2(assessMarkdownFromInput(input.claudeMd.value)) : none2();
  return {
    packageJson,
    tsconfig,
    vscodeSettings,
    agentsMd,
    claudeMd
  };
});

// src/cli/setup/changes.ts
function emptyFileChangesResult() {
  return {
    codeActions: [],
    messages: []
  };
}
var computeChanges = (assessment, target) => {
  return gen2(function* () {
    let codeActions = [];
    let messages = [];
    const packageJsonResult = yield* computePackageJsonChanges(
      assessment.packageJson,
      target.packageJson
    );
    codeActions = [...codeActions, ...packageJsonResult.codeActions];
    messages = [...messages, ...packageJsonResult.messages];
    const tsconfigResult = yield* computeTsConfigChanges(
      assessment.tsconfig,
      target.tsconfig,
      target.packageJson.lspVersion
    );
    codeActions = [...codeActions, ...tsconfigResult.codeActions];
    messages = [...messages, ...tsconfigResult.messages];
    if (target.editors.includes("vscode")) {
      if (isSome2(target.packageJson.lspVersion) && isSome2(assessment.vscodeSettings)) {
        const vscodeTarget = {
          settings: {
            "typescript.tsdk": "./node_modules/typescript/lib",
            "typescript.enablePromptUseWorkspaceTsdk": true
          }
        };
        const vscodeResult = yield* computeVSCodeSettingsChanges(
          assessment.vscodeSettings.value,
          vscodeTarget
        );
        codeActions = [...codeActions, ...vscodeResult.codeActions];
        messages = [...messages, ...vscodeResult.messages];
      }
    }
    const shouldInstallLsp = isSome2(target.packageJson.lspVersion);
    if (isSome2(assessment.agentsMd)) {
      const agentsMdResult = computeMarkdownChanges(
        assessment.agentsMd.value,
        shouldInstallLsp
      );
      codeActions = [...codeActions, ...agentsMdResult.codeActions];
      messages = [...messages, ...agentsMdResult.messages];
    }
    if (isSome2(assessment.claudeMd)) {
      const claudeMdResult = computeMarkdownChanges(
        assessment.claudeMd.value,
        shouldInstallLsp
      );
      codeActions = [...codeActions, ...claudeMdResult.codeActions];
      messages = [...messages, ...claudeMdResult.messages];
    }
    if (isSome2(target.packageJson.lspVersion) && target.editors.length > 0) {
      messages = [...messages, ""];
      if (target.editors.includes("vscode")) {
        messages = [
          ...messages,
          "VS Code / Cursor / VS Code-based editors:",
          '  1. Press "F1" and type "TypeScript: Select TypeScript version"',
          '  2. Select "Use workspace version"',
          "  3. If that option does not appear, ensure TypeScript is installed locally in node_modules",
          ""
        ];
      }
      if (target.editors.includes("nvim")) {
        messages = [
          ...messages,
          "Neovim (with nvim-vtsls):",
          "  Refer to: https://github.com/yioneko/vtsls?tab=readme-ov-file#typescript-plugin-not-activated",
          ""
        ];
      }
      if (target.editors.includes("emacs")) {
        messages = [
          ...messages,
          "Emacs:",
          "  Step-by-step instructions: https://gosha.net/2025/effect-ls-emacs/",
          ""
        ];
      }
    }
    return { codeActions, messages };
  });
};
function findPropertyInObject(tsInstance, obj, propertyName) {
  for (const prop of obj.properties) {
    if (tsInstance.isPropertyAssignment(prop)) {
      const propAssignment = prop;
      const name = propAssignment.name;
      if (tsInstance.isIdentifier(name) && tsInstance.idText(name) === propertyName) {
        return propAssignment;
      }
      if (tsInstance.isStringLiteral(name) && name.text === propertyName) {
        return propAssignment;
      }
    }
  }
  return void 0;
}
function getRootObject(tsInstance, sourceFile) {
  if (sourceFile.statements.length === 0) return void 0;
  const statement = sourceFile.statements[0];
  if (!tsInstance.isExpressionStatement(statement)) return void 0;
  const expr = statement.expression;
  if (!tsInstance.isObjectLiteralExpression(expr)) return void 0;
  return expr;
}
function deleteNodeFromList(tracker, sourceFile, nodeArray, nodeToDelete) {
  const index = nodeArray.indexOf(nodeToDelete);
  if (index === -1) return;
  if (index === 0 && nodeArray.length > 1) {
    const secondElement = nodeArray[1];
    const start4 = nodeToDelete.pos;
    const end5 = secondElement.pos;
    tracker.deleteRange(sourceFile, { pos: start4, end: end5 });
  } else if (index > 0) {
    const previousElement = nodeArray[index - 1];
    const start4 = previousElement.end;
    const end5 = nodeToDelete.end;
    tracker.deleteRange(sourceFile, { pos: start4, end: end5 });
  } else {
    tracker.delete(sourceFile, nodeToDelete);
  }
}
function insertNodeAtEndOfList(tracker, sourceFile, nodeArray, newNode) {
  if (nodeArray.length === 0) {
    tracker.insertNodeAt(sourceFile, nodeArray.pos + 1, newNode, { suffix: "\n" });
  } else {
    const lastElement = nodeArray[nodeArray.length - 1];
    tracker.insertNodeAt(sourceFile, lastElement.end, newNode, { prefix: ",\n" });
  }
}
function createMinimalHost(_ts) {
  return {
    getCompilationSettings: () => ({}),
    getScriptFileNames: () => [],
    getScriptVersion: () => "1",
    getScriptSnapshot: () => void 0,
    getCurrentDirectory: () => "",
    getDefaultLibFileName: () => "lib.d.ts",
    fileExists: () => false,
    readFile: () => void 0
  };
}
var computePackageJsonChanges = (current, target) => {
  return gen2(function* () {
    const ts = yield* TypeScriptContext;
    const descriptions = [];
    const messages = [];
    const rootObj = getRootObject(ts, current.sourceFile);
    if (!rootObj) {
      return emptyFileChangesResult();
    }
    const host = createMinimalHost(ts);
    const formatOptions = { indentSize: 2, tabSize: 2 };
    const formatContext = ts.formatting.getFormatContext(formatOptions, host);
    const preferences = {};
    const fileChanges = ts.textChanges.ChangeTracker.with(
      { host, formatContext, preferences },
      (tracker) => {
        if (isSome2(target.lspVersion)) {
          const targetDepType = target.lspVersion.value.dependencyType;
          const targetVersion = target.lspVersion.value.version;
          if (isSome2(current.lspVersion)) {
            const currentDepType = current.lspVersion.value.dependencyType;
            const currentVersion = current.lspVersion.value.version;
            if (currentDepType !== targetDepType) {
              descriptions.push(`Move @effect/language-service from ${currentDepType} to ${targetDepType}`);
              const oldDepsProperty = findPropertyInObject(ts, rootObj, currentDepType);
              if (oldDepsProperty && ts.isObjectLiteralExpression(oldDepsProperty.initializer)) {
                const lspProperty = findPropertyInObject(ts, oldDepsProperty.initializer, "@effect/language-service");
                if (lspProperty) {
                  deleteNodeFromList(tracker, current.sourceFile, oldDepsProperty.initializer.properties, lspProperty);
                }
              }
              const newDepsProperty = findPropertyInObject(ts, rootObj, targetDepType);
              const newLspProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral("@effect/language-service"),
                ts.factory.createStringLiteral(targetVersion)
              );
              if (!newDepsProperty) {
                const newDepsProp = ts.factory.createPropertyAssignment(
                  ts.factory.createStringLiteral(targetDepType),
                  ts.factory.createObjectLiteralExpression([newLspProp], false)
                );
                insertNodeAtEndOfList(tracker, current.sourceFile, rootObj.properties, newDepsProp);
              } else if (ts.isObjectLiteralExpression(newDepsProperty.initializer)) {
                insertNodeAtEndOfList(tracker, current.sourceFile, newDepsProperty.initializer.properties, newLspProp);
              }
            } else if (currentVersion !== targetVersion) {
              descriptions.push(`Update @effect/language-service from ${currentVersion} to ${targetVersion}`);
              const depsProperty = findPropertyInObject(ts, rootObj, targetDepType);
              if (depsProperty && ts.isObjectLiteralExpression(depsProperty.initializer)) {
                const lspProperty = findPropertyInObject(ts, depsProperty.initializer, "@effect/language-service");
                if (lspProperty && ts.isStringLiteral(lspProperty.initializer)) {
                  const newVersionLiteral = ts.factory.createStringLiteral(targetVersion);
                  tracker.replaceNode(current.sourceFile, lspProperty.initializer, newVersionLiteral);
                }
              }
            }
          } else {
            descriptions.push(`Add @effect/language-service@${targetVersion} to ${targetDepType}`);
            const depsProperty = findPropertyInObject(ts, rootObj, targetDepType);
            if (!depsProperty) {
              const newDepsProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral(targetDepType),
                ts.factory.createObjectLiteralExpression([
                  ts.factory.createPropertyAssignment(
                    ts.factory.createStringLiteral("@effect/language-service"),
                    ts.factory.createStringLiteral(targetVersion)
                  )
                ], false)
              );
              insertNodeAtEndOfList(tracker, current.sourceFile, rootObj.properties, newDepsProp);
            } else if (ts.isObjectLiteralExpression(depsProperty.initializer)) {
              const newLspProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral("@effect/language-service"),
                ts.factory.createStringLiteral(targetVersion)
              );
              const depsObj = depsProperty.initializer;
              insertNodeAtEndOfList(tracker, current.sourceFile, depsObj.properties, newLspProp);
            }
          }
        } else if (isSome2(current.lspVersion)) {
          descriptions.push("Remove @effect/language-service from dependencies");
          const currentDepType = current.lspVersion.value.dependencyType;
          const depsProperty = findPropertyInObject(ts, rootObj, currentDepType);
          if (depsProperty && ts.isObjectLiteralExpression(depsProperty.initializer)) {
            const lspProperty = findPropertyInObject(ts, depsProperty.initializer, "@effect/language-service");
            if (lspProperty) {
              const depsObj = depsProperty.initializer;
              deleteNodeFromList(tracker, current.sourceFile, depsObj.properties, lspProperty);
            }
          }
        }
        if (target.prepareScript && isSome2(target.lspVersion)) {
          const scriptsProperty = findPropertyInObject(ts, rootObj, "scripts");
          if (!scriptsProperty) {
            descriptions.push("Add scripts section with prepare script");
            const newScriptsProp = ts.factory.createPropertyAssignment(
              ts.factory.createStringLiteral("scripts"),
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment(
                  ts.factory.createStringLiteral("prepare"),
                  ts.factory.createStringLiteral("effect-language-service patch")
                )
              ], false)
            );
            insertNodeAtEndOfList(tracker, current.sourceFile, rootObj.properties, newScriptsProp);
          } else if (ts.isObjectLiteralExpression(scriptsProperty.initializer)) {
            const prepareProperty = findPropertyInObject(ts, scriptsProperty.initializer, "prepare");
            if (!prepareProperty) {
              descriptions.push("Add prepare script");
              const newPrepareProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral("prepare"),
                ts.factory.createStringLiteral("effect-language-service patch")
              );
              const scriptsObj = scriptsProperty.initializer;
              insertNodeAtEndOfList(tracker, current.sourceFile, scriptsObj.properties, newPrepareProp);
            } else if (isSome2(current.prepareScript) && !current.prepareScript.value.hasPatch) {
              descriptions.push("Update prepare script to include patch command");
              const currentScript = current.prepareScript.value.script;
              const newScript = `${currentScript} && effect-language-service patch`;
              const newPrepareProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral("prepare"),
                ts.factory.createStringLiteral(newScript)
              );
              tracker.replaceNode(current.sourceFile, prepareProperty, newPrepareProp);
            }
          }
        } else if (isNone2(target.lspVersion) && isSome2(current.prepareScript) && current.prepareScript.value.hasPatch) {
          const scriptsProperty = findPropertyInObject(ts, rootObj, "scripts");
          if (scriptsProperty && ts.isObjectLiteralExpression(scriptsProperty.initializer)) {
            const prepareProperty = findPropertyInObject(ts, scriptsProperty.initializer, "prepare");
            if (prepareProperty && ts.isStringLiteral(prepareProperty.initializer)) {
              const currentScript = current.prepareScript.value.script;
              const hasMultipleCommands = currentScript.includes("&&") || currentScript.includes(";");
              if (hasMultipleCommands) {
                descriptions.push("Remove effect-language-service patch command from prepare script");
                messages.push(
                  "WARNING: Your prepare script contained multiple commands. I attempted to automatically remove only the 'effect-language-service patch' command. Please verify that the prepare script is correct after this change."
                );
                const newScript = currentScript.replace(/\s*&&\s*effect-language-service\s+patch/g, "").replace(/effect-language-service\s+patch\s*&&\s*/g, "").replace(/\s*;\s*effect-language-service\s+patch/g, "").replace(/effect-language-service\s+patch\s*;\s*/g, "").trim();
                if (ts.isStringLiteral(prepareProperty.initializer)) {
                  tracker.replaceNode(
                    current.sourceFile,
                    prepareProperty.initializer,
                    ts.factory.createStringLiteral(newScript)
                  );
                }
              } else {
                descriptions.push("Remove prepare script with patch command");
                const scriptsObj = scriptsProperty.initializer;
                deleteNodeFromList(tracker, current.sourceFile, scriptsObj.properties, prepareProperty);
              }
            }
          }
        }
      }
    );
    const fileChange = fileChanges.find((fc) => fc.fileName === current.path);
    const changes2 = fileChange ? fileChange.textChanges : [];
    if (changes2.length === 0) {
      return { codeActions: [], messages };
    }
    return {
      codeActions: [{
        description: descriptions.join("; "),
        changes: [{
          fileName: current.path,
          textChanges: changes2
        }]
      }],
      messages
    };
  });
};
var computeTsConfigChanges = (current, target, lspVersion) => {
  return gen2(function* () {
    const ts = yield* TypeScriptContext;
    const descriptions = [];
    const messages = [];
    const rootObj = getRootObject(ts, current.sourceFile);
    if (!rootObj) {
      return emptyFileChangesResult();
    }
    const compilerOptionsProperty = findPropertyInObject(ts, rootObj, "compilerOptions");
    if (!compilerOptionsProperty) {
      return emptyFileChangesResult();
    }
    if (!ts.isObjectLiteralExpression(compilerOptionsProperty.initializer)) {
      return emptyFileChangesResult();
    }
    const compilerOptions = compilerOptionsProperty.initializer;
    const textChanges = ts.textChanges;
    const host = createMinimalHost(ts);
    const formatOptions = { indentSize: 2, tabSize: 2 };
    const formatContext = ts.formatting.getFormatContext(formatOptions, host);
    const preferences = {};
    const fileChanges = textChanges.ChangeTracker.with(
      { host, formatContext, preferences },
      (tracker) => {
        const pluginsProperty = findPropertyInObject(ts, compilerOptions, "plugins");
        if (isNone2(lspVersion)) {
          if (pluginsProperty && ts.isArrayLiteralExpression(pluginsProperty.initializer)) {
            const pluginsArray = pluginsProperty.initializer;
            const lspPluginElement = pluginsArray.elements.find((element) => {
              if (ts.isObjectLiteralExpression(element)) {
                const nameProperty = findPropertyInObject(ts, element, "name");
                if (nameProperty && ts.isStringLiteral(nameProperty.initializer)) {
                  return nameProperty.initializer.text === "@effect/language-service";
                }
              }
              return false;
            });
            if (lspPluginElement) {
              descriptions.push("Remove @effect/language-service plugin from tsconfig");
              deleteNodeFromList(tracker, current.sourceFile, pluginsArray.elements, lspPluginElement);
            }
          }
        } else {
          const buildPluginObject = (severities) => {
            const nameProperty = ts.factory.createPropertyAssignment(
              ts.factory.createStringLiteral("name"),
              ts.factory.createStringLiteral("@effect/language-service")
            );
            return match2(severities, {
              onNone: () => {
                return ts.factory.createObjectLiteralExpression([nameProperty], false);
              },
              onSome: (sevs) => {
                const severityProperties = Object.entries(sevs).map(
                  ([name, severity]) => ts.factory.createPropertyAssignment(
                    ts.factory.createStringLiteral(name),
                    ts.factory.createStringLiteral(severity)
                  )
                );
                const diagnosticSeverityProperty = ts.factory.createPropertyAssignment(
                  ts.factory.createStringLiteral("diagnosticSeverity"),
                  ts.factory.createObjectLiteralExpression(severityProperties, true)
                );
                return ts.factory.createObjectLiteralExpression(
                  [nameProperty, diagnosticSeverityProperty],
                  true
                );
              }
            });
          };
          const pluginObject = buildPluginObject(target.diagnosticSeverities);
          if (!pluginsProperty) {
            descriptions.push("Add plugins array with @effect/language-service plugin");
            const newPluginsProp = ts.factory.createPropertyAssignment(
              ts.factory.createStringLiteral("plugins"),
              ts.factory.createArrayLiteralExpression([pluginObject], true)
            );
            insertNodeAtEndOfList(tracker, current.sourceFile, compilerOptions.properties, newPluginsProp);
          } else if (ts.isArrayLiteralExpression(pluginsProperty.initializer)) {
            const pluginsArray = pluginsProperty.initializer;
            const lspPluginElement = pluginsArray.elements.find((element) => {
              if (ts.isObjectLiteralExpression(element)) {
                const nameProperty = findPropertyInObject(ts, element, "name");
                if (nameProperty && ts.isStringLiteral(nameProperty.initializer)) {
                  return nameProperty.initializer.text === "@effect/language-service";
                }
              }
              return false;
            });
            if (lspPluginElement) {
              if (isSome2(target.diagnosticSeverities) && ts.isObjectLiteralExpression(lspPluginElement)) {
                descriptions.push("Update @effect/language-service plugin diagnostic severities");
                const existingDiagSeverityProp = findPropertyInObject(ts, lspPluginElement, "diagnosticSeverity");
                const severityProperties = Object.entries(target.diagnosticSeverities.value).map(
                  ([name, severity]) => ts.factory.createPropertyAssignment(
                    ts.factory.createStringLiteral(name),
                    ts.factory.createStringLiteral(severity)
                  )
                );
                const newDiagnosticSeverityProperty = ts.factory.createPropertyAssignment(
                  ts.factory.createStringLiteral("diagnosticSeverity"),
                  ts.factory.createObjectLiteralExpression(severityProperties, true)
                );
                if (existingDiagSeverityProp) {
                  const newDiagnosticSeverityValue = ts.factory.createObjectLiteralExpression(severityProperties, true);
                  tracker.replaceNode(
                    current.sourceFile,
                    existingDiagSeverityProp.initializer,
                    newDiagnosticSeverityValue
                  );
                } else {
                  insertNodeAtEndOfList(
                    tracker,
                    current.sourceFile,
                    lspPluginElement.properties,
                    newDiagnosticSeverityProperty
                  );
                }
              }
            } else {
              descriptions.push("Add @effect/language-service plugin to existing plugins array");
              insertNodeAtEndOfList(tracker, current.sourceFile, pluginsArray.elements, pluginObject);
            }
          }
        }
      }
    );
    const fileChange = fileChanges.find((fc) => fc.fileName === current.path);
    const changes2 = fileChange ? fileChange.textChanges : [];
    if (changes2.length === 0) {
      return { codeActions: [], messages };
    }
    return {
      codeActions: [{
        description: descriptions.join("; "),
        changes: [{
          fileName: current.sourceFile.fileName,
          textChanges: changes2
        }]
      }],
      messages
    };
  });
};
var computeMarkdownChanges = (current, shouldInstall) => {
  const descriptions = [];
  const changes2 = [];
  if (shouldInstall) {
    if (current.hasMarkers) {
      if (isSome2(current.markerContent) && current.markerContent.value !== MARKDOWN_DEFAULT_CONTENT) {
        descriptions.push(`Update Effect Language Service section in ${current.path}`);
        const startIndex = current.text.indexOf(MARKDOWN_START_MARKER);
        const endIndex = current.text.indexOf(MARKDOWN_END_MARKER) + MARKDOWN_END_MARKER.length;
        changes2.push({
          span: { start: startIndex, length: endIndex - startIndex },
          newText: MARKDOWN_DEFAULT_CONTENT
        });
      }
    } else {
      descriptions.push(`Add Effect Language Service section to ${current.path}`);
      const suffix = current.text.endsWith("\n") ? "\n" : "\n\n";
      changes2.push({
        span: { start: current.text.length, length: 0 },
        newText: suffix + MARKDOWN_DEFAULT_CONTENT + "\n"
      });
    }
  } else {
    if (current.hasMarkers) {
      descriptions.push(`Remove Effect Language Service section from ${current.path}`);
      const startIndex = current.text.indexOf(MARKDOWN_START_MARKER);
      const endIndex = current.text.indexOf(MARKDOWN_END_MARKER) + MARKDOWN_END_MARKER.length;
      let removeStart = startIndex;
      let removeEnd = endIndex;
      if (removeStart > 0 && current.text[removeStart - 1] === "\n") {
        removeStart--;
        if (removeStart > 0 && current.text[removeStart - 1] === "\n") {
          removeStart--;
        }
      }
      if (removeEnd < current.text.length && current.text[removeEnd] === "\n") {
        removeEnd++;
      }
      changes2.push({
        span: { start: removeStart, length: removeEnd - removeStart },
        newText: ""
      });
    }
  }
  if (changes2.length === 0) {
    return { codeActions: [], messages: [] };
  }
  return {
    codeActions: [{
      description: descriptions.join("; "),
      changes: [{
        fileName: current.path,
        textChanges: changes2,
        isNewFile: false
      }]
    }],
    messages: []
  };
};
var computeVSCodeSettingsChanges = (current, target) => {
  return gen2(function* () {
    const ts = yield* TypeScriptContext;
    const descriptions = [];
    const messages = [];
    const rootObj = getRootObject(ts, current.sourceFile);
    if (!rootObj) {
      return emptyFileChangesResult();
    }
    const host = createMinimalHost(ts);
    const formatOptions = { indentSize: 2, tabSize: 2 };
    const formatContext = ts.formatting.getFormatContext(formatOptions, host);
    const preferences = {};
    const fileChanges = ts.textChanges.ChangeTracker.with(
      { host, formatContext, preferences },
      (tracker) => {
        if (rootObj.properties.length === 0) {
          const newProperties = [];
          for (const [key, value5] of Object.entries(target.settings)) {
            descriptions.push(`Add ${key} setting`);
            newProperties.push(
              ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral(key),
                typeof value5 === "string" ? ts.factory.createStringLiteral(value5) : typeof value5 === "boolean" ? value5 ? ts.factory.createTrue() : ts.factory.createFalse() : ts.factory.createNull()
              )
            );
          }
          const newRootObj = ts.factory.createObjectLiteralExpression(newProperties, true);
          tracker.replaceNode(current.sourceFile, rootObj, newRootObj);
        } else {
          for (const [key, value5] of Object.entries(target.settings)) {
            const existingProp = findPropertyInObject(ts, rootObj, key);
            if (!existingProp) {
              descriptions.push(`Add ${key} setting`);
              const newProp = ts.factory.createPropertyAssignment(
                ts.factory.createStringLiteral(key),
                typeof value5 === "string" ? ts.factory.createStringLiteral(value5) : typeof value5 === "boolean" ? value5 ? ts.factory.createTrue() : ts.factory.createFalse() : ts.factory.createNull()
              );
              insertNodeAtEndOfList(tracker, current.sourceFile, rootObj.properties, newProp);
            }
          }
        }
      }
    );
    const fileChange = fileChanges.find((fc) => fc.fileName === current.path);
    const changes2 = fileChange ? fileChange.textChanges : [];
    if (changes2.length === 0) {
      return { codeActions: [], messages };
    }
    return {
      codeActions: [{
        description: descriptions.join("; "),
        changes: [{
          fileName: current.path,
          textChanges: changes2
        }]
      }],
      messages
    };
  });
};

// src/cli/setup/errors.ts
var PackageJsonNotFoundError = class extends TaggedError("PackageJsonNotFoundError") {
  get message() {
    return `No package.json found at ${this.path}. Please run this command in the root of your project.`;
  }
};
var TsConfigNotFoundError = class extends TaggedError("TsConfigNotFoundError") {
  get message() {
    return `No tsconfig file found at ${this.path}.`;
  }
};
var FileReadError = class extends TaggedError("FileReadError") {
  get message() {
    return `Unable to read file at ${this.path}`;
  }
};

// src/cli/setup/diagnostic-info.ts
function getAllDiagnostics() {
  return diagnostics.map((diagnostic) => ({
    name: diagnostic.name,
    code: diagnostic.code,
    defaultSeverity: diagnostic.severity,
    description: diagnostic.description
  }));
}
function cycleSeverity(current, direction) {
  const order = ["off", "suggestion", "message", "warning", "error"];
  const currentIndex = order.indexOf(current);
  if (direction === "right") {
    return order[(currentIndex + 1) % order.length];
  } else {
    return order[(currentIndex - 1 + order.length) % order.length];
  }
}
var shortNames = {
  off: "off",
  suggestion: "sugg",
  message: "info",
  warning: "warn",
  error: "err"
};
var MAX_SEVERITY_LENGTH = Object.values(shortNames).reduce((max6, name) => Math.max(max6, name.length), 0);
function getSeverityShortName(severity) {
  return shortNames[severity] ?? "???";
}

// src/cli/setup/diagnostic-prompt.ts
var Action2 = taggedEnum();
var NEWLINE_REGEX7 = /\r?\n/;
function eraseText2(text10, columns) {
  if (columns === 0) {
    return cat2(eraseLine3, cursorTo3(0));
  }
  let rows = 0;
  const lines3 = text10.split(/\r?\n/);
  for (const line4 of lines3) {
    rows += 1 + Math.floor(Math.max(line4.length - 1, 0) / columns);
  }
  return eraseLines3(rows);
}
function entriesToDisplay2(cursor, total, maxVisible) {
  const max6 = maxVisible === void 0 ? total : maxVisible;
  let startIndex = Math.min(total - max6, cursor - Math.floor(max6 / 2));
  if (startIndex < 0) {
    startIndex = 0;
  }
  const endIndex = Math.min(startIndex + max6, total);
  return { startIndex, endIndex };
}
var defaultFigures2 = {
  arrowUp: text3("\u2191"),
  arrowDown: text3("\u2193"),
  tick: text3("\u2714"),
  pointerSmall: text3("\u203A")
};
var figures3 = succeed7(defaultFigures2);
var renderBeep9 = render3(beep3, { style: "pretty" });
function getSeverityStyle(severity) {
  const styles = {
    off: combine11(white4, bgBlackBright2),
    suggestion: combine11(white4, bgCyan2),
    message: combine11(white4, bgBlue2),
    warning: combine11(white4, bgYellow2),
    error: combine11(white4, bgRed2)
  };
  return styles[severity];
}
function renderOutput8(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX7), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines3 = map4(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(
        cat2(nest2(vsep2(lines3), 2)),
        cat2(space2),
        cat2(trailingSymbol),
        cat2(space2)
      );
    }
  });
}
function renderDiagnostics(state, options3, figures4, columns) {
  const diagnostics3 = options3.diagnostics;
  const toDisplay = entriesToDisplay2(state.index, diagnostics3.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const diagnostic = diagnostics3[index];
    const isHighlighted = state.index === index;
    const currentSeverity = state.severities[diagnostic.name] ?? diagnostic.defaultSeverity;
    const hasChanged = currentSeverity !== diagnostic.defaultSeverity;
    let prefix = space2;
    if (index === toDisplay.startIndex && toDisplay.startIndex > 0) {
      prefix = figures4.arrowUp;
    } else if (index === toDisplay.endIndex - 1 && toDisplay.endIndex < diagnostics3.length) {
      prefix = figures4.arrowDown;
    }
    const shortName = getSeverityShortName(currentSeverity);
    const paddedSeverity = shortName.padEnd(MAX_SEVERITY_LENGTH, " ");
    const severityDoc = annotate2(
      text3(` ${paddedSeverity} `),
      getSeverityStyle(currentSeverity)
    );
    const nameText = hasChanged ? `${diagnostic.name}*` : diagnostic.name;
    const nameDoc = isHighlighted ? annotate2(text3(nameText), cyanBright2) : text3(nameText);
    const mainLine = prefix.pipe(
      cat2(space2),
      cat2(severityDoc),
      cat2(space2),
      cat2(nameDoc)
    );
    if (isHighlighted && diagnostic.description) {
      const indentWidth = 1 + 1 + (MAX_SEVERITY_LENGTH + 2) + 1;
      const indent3 = " ".repeat(indentWidth);
      const availableWidth = columns - indentWidth;
      const truncatedDescription = availableWidth > 0 && diagnostic.description.length > availableWidth ? diagnostic.description.substring(0, availableWidth - 1) + "\u2026" : diagnostic.description;
      const descriptionDoc = annotate2(
        text3(indent3 + truncatedDescription),
        blackBright2
      );
      documents.push(vsep2([mainLine, descriptionDoc]));
    } else {
      documents.push(mainLine);
    }
  }
  return vsep2(documents);
}
function renderNextFrame9(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figs = yield* figures3;
    const diagnosticsDoc = renderDiagnostics(state, options3, figs, columns);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = figs.pointerSmall;
    const promptMsg = renderOutput8(leadingSymbol, trailingSymbol, options3);
    const helpText = annotate2(
      text3("Use \u2191/\u2193 to navigate, \u2190/\u2192 to change severity, Enter to finish"),
      blackBright2
    );
    return cursorHide3.pipe(
      cat2(promptMsg),
      cat2(hardLine2),
      cat2(helpText),
      cat2(hardLine2),
      cat2(diagnosticsDoc),
      render3({ style: "pretty", options: { lineWidth: columns } })
    );
  });
}
function renderSubmission9(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figs = yield* figures3;
    const changedCount = Object.entries(state.severities).filter(([name, severity]) => {
      const diagnostic = options3.diagnostics.find((d) => d.name === name);
      return diagnostic && severity !== diagnostic.defaultSeverity;
    }).length;
    const result = annotate2(
      text3(`${changedCount} diagnostic${changedCount === 1 ? "" : "s"} configured`),
      white4
    );
    const leadingSymbol = annotate2(figs.tick, green3);
    const trailingSymbol = text3("");
    const promptMsg = renderOutput8(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(
      cat2(space2),
      cat2(result),
      cat2(hardLine2),
      render3({ style: "pretty", options: { lineWidth: columns } })
    );
  });
}
function processCursorUp4(state, totalCount) {
  const newIndex = state.index === 0 ? totalCount - 1 : state.index - 1;
  return succeed7(Action2.NextFrame({ state: { ...state, index: newIndex } }));
}
function processCursorDown4(state, totalCount) {
  const newIndex = (state.index + 1) % totalCount;
  return succeed7(Action2.NextFrame({ state: { ...state, index: newIndex } }));
}
function processSeverityChange(state, options3, direction) {
  const diagnostic = options3.diagnostics[state.index];
  const currentSeverity = state.severities[diagnostic.name] ?? diagnostic.defaultSeverity;
  const newSeverity = cycleSeverity(currentSeverity, direction);
  return succeed7(Action2.NextFrame({
    state: {
      ...state,
      severities: { ...state.severities, [diagnostic.name]: newSeverity }
    }
  }));
}
function handleProcess8(options3) {
  return (input, state) => {
    const totalCount = options3.diagnostics.length;
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp4(state, totalCount);
      }
      case "j":
      case "down": {
        return processCursorDown4(state, totalCount);
      }
      case "left": {
        return processSeverityChange(state, options3, "left");
      }
      case "right": {
        return processSeverityChange(state, options3, "right");
      }
      case "enter":
      case "return": {
        return succeed7(Action2.Submit({ value: state.severities }));
      }
      default: {
        return succeed7(Action2.Beep());
      }
    }
  };
}
function handleClear9(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const visibleCount = Math.min(options3.diagnostics.length, options3.maxPerPage);
    const text10 = "\n".repeat(visibleCount + 2) + options3.message;
    const clearOutput = eraseText2(text10, columns);
    return clearOutput.pipe(
      cat2(clearPrompt),
      render3({ style: "pretty", options: { lineWidth: columns } })
    );
  });
}
function handleRender8(options3) {
  return (state, action) => {
    return Action2.$match(action, {
      Beep: () => succeed7(renderBeep9),
      NextFrame: ({ state: state2 }) => renderNextFrame9(state2, options3),
      Submit: () => renderSubmission9(state, options3)
    });
  };
}
function createDiagnosticPrompt(diagnostics3, initialSeverities) {
  const options3 = {
    message: "Configure Diagnostic Severities",
    diagnostics: diagnostics3,
    maxPerPage: 10
  };
  const initialState3 = {
    index: 0,
    severities: initialSeverities
  };
  return custom3(initialState3, {
    render: handleRender8(options3),
    process: handleProcess8(options3),
    clear: () => handleClear9(options3)
  });
}

// src/cli/setup/target-prompt.ts
var gatherTargetState = (assessment, context7) => gen2(function* () {
  const currentLspState = match2(assessment.packageJson.lspVersion, {
    onNone: () => "no",
    onSome: (lsp) => lsp.dependencyType
  });
  const lspDependencyType = yield* select2({
    message: "Language service installation:",
    choices: [
      {
        title: "Install in devDependencies",
        description: "This is the recommended default option",
        value: "devDependencies",
        selected: currentLspState === "no" || currentLspState === "devDependencies"
      },
      {
        title: "Install in dependencies",
        description: "We usually don't recommend this, but if you need it for any reason",
        value: "dependencies",
        selected: currentLspState === "dependencies"
      },
      {
        title: "Uninstall",
        description: "Language service won't be installed or will be removed if already present",
        value: "no"
      }
    ]
  });
  if (lspDependencyType === "no") {
    return {
      packageJson: {
        lspVersion: none2(),
        prepareScript: false
      },
      tsconfig: {
        diagnosticSeverities: none2()
      },
      vscodeSettings: none2(),
      editors: []
    };
  }
  const shouldCustomizeDiagnostics = yield* select2({
    message: "Would you like to customize the diagnostics that the language service will provide?",
    choices: [
      {
        title: "Yes",
        description: "Manually review and select which diagnostics to enable",
        value: true,
        selected: true
      },
      {
        title: "No",
        description: "Keep the defaults provided by the language service",
        value: false,
        selected: false
      }
    ]
  });
  const allDiagnostics = getAllDiagnostics();
  const initialSeverities = match2(assessment.tsconfig.currentOptions, {
    onNone: () => ({}),
    onSome: (options3) => options3.diagnosticSeverity
  });
  const diagnosticSeverities = shouldCustomizeDiagnostics ? some2(
    yield* createDiagnosticPrompt(
      allDiagnostics,
      initialSeverities
    )
  ) : none2();
  const currentPrepareState = match2(assessment.packageJson.prepareScript, {
    onNone: () => false,
    onSome: (script) => script.hasPatch
  });
  const prepareScript = yield* select2({
    message: "Enable language service diagnostics during TypeScript compilation?",
    choices: [
      {
        title: "Yes",
        description: "Enable patching - Recommended for LLMs, diagnostics will appear in tsc output and CI/CD, will patch the tsc binary and typescript library locally.",
        value: true,
        selected: currentPrepareState
      },
      {
        title: "No",
        description: "Skip patching - diagnostics only available in your editor",
        value: false,
        selected: !currentPrepareState
      }
    ]
  });
  const hasVscodeSettings = isSome2(assessment.vscodeSettings);
  const editors = yield* multiSelect2({
    message: "Which editors do you use?",
    choices: [
      {
        title: "VS Code / Cursor / VS Code-based editors",
        value: "vscode",
        selected: hasVscodeSettings
      },
      {
        title: "Neovim",
        value: "nvim"
      },
      {
        title: "Emacs",
        value: "emacs"
      }
    ]
  });
  return {
    packageJson: {
      lspVersion: some2({ dependencyType: lspDependencyType, version: context7.defaultLspVersion }),
      prepareScript
    },
    tsconfig: {
      diagnosticSeverities
    },
    vscodeSettings: none2(),
    editors
  };
});

// src/cli/setup/tsconfig-prompt.ts
var findTsConfigFiles = (currentDir) => gen2(function* () {
  const fs = yield* FileSystem;
  const path2 = yield* Path2;
  const files = yield* fs.readDirectory(currentDir);
  const tsconfigFiles = filter2(files, (file5) => {
    const fileName = file5.toLowerCase();
    return fileName.startsWith("tsconfig") && (fileName.endsWith(".json") || fileName.endsWith(".jsonc"));
  }).map((file5) => path2.join(currentDir, file5));
  return tsconfigFiles;
});
var selectTsConfigFile = (currentDir) => gen2(function* () {
  const fs = yield* FileSystem;
  const path2 = yield* Path2;
  const tsconfigFiles = yield* findTsConfigFiles(currentDir);
  let selectedTsconfigPath;
  if (tsconfigFiles.length === 0) {
    selectedTsconfigPath = yield* text9({
      message: "Enter path to your tsconfig.json file"
    });
  } else {
    const choices = [
      ...tsconfigFiles.map((file5) => ({
        title: file5,
        value: file5
      })),
      {
        title: "Enter path manually",
        value: "__manual__"
      }
    ];
    const selected = yield* select2({
      message: "Select tsconfig to configure",
      choices
    });
    if (selected === "__manual__") {
      selectedTsconfigPath = yield* text9({
        message: "Enter path to your tsconfig.json file"
      });
    } else {
      selectedTsconfigPath = selected;
    }
  }
  selectedTsconfigPath = path2.resolve(selectedTsconfigPath);
  const tsconfigExists = yield* fs.exists(selectedTsconfigPath);
  if (!tsconfigExists) {
    return yield* new TsConfigNotFoundError({ path: selectedTsconfigPath });
  }
  const tsconfigText = yield* fs.readFileString(selectedTsconfigPath).pipe(
    mapError2((cause2) => new FileReadError({ path: selectedTsconfigPath, cause: cause2 }))
  );
  return {
    fileName: selectedTsconfigPath,
    text: tsconfigText
  };
});

// src/cli/setup.ts
var createAssessmentInput = (currentDir, tsconfigInput) => gen2(function* () {
  const fs = yield* FileSystem;
  const path2 = yield* Path2;
  const packageJsonPath = path2.join(currentDir, "package.json");
  const packageJsonExists = yield* fs.exists(packageJsonPath);
  if (!packageJsonExists) {
    return yield* new PackageJsonNotFoundError({ path: packageJsonPath });
  }
  const packageJsonText = yield* fs.readFileString(packageJsonPath).pipe(
    mapError2((cause2) => new FileReadError({ path: packageJsonPath, cause: cause2 }))
  );
  const packageJsonInput = {
    fileName: packageJsonPath,
    text: packageJsonText
  };
  const vscodeSettingsPath = path2.join(currentDir, ".vscode", "settings.json");
  const vscodeSettingsExists = yield* fs.exists(vscodeSettingsPath);
  let vscodeSettingsInput = none2();
  if (vscodeSettingsExists) {
    const vscodeSettingsText = yield* fs.readFileString(vscodeSettingsPath).pipe(
      mapError2((cause2) => new FileReadError({ path: vscodeSettingsPath, cause: cause2 }))
    );
    vscodeSettingsInput = some2({
      fileName: vscodeSettingsPath,
      text: vscodeSettingsText
    });
  }
  const agentsMdLowerPath = path2.join(currentDir, "agents.md");
  const agentsMdUpperPath = path2.join(currentDir, "AGENTS.md");
  const agentsMdLowerExists = yield* fs.exists(agentsMdLowerPath);
  const agentsMdUpperExists = yield* fs.exists(agentsMdUpperPath);
  const agentsMdPath = agentsMdUpperExists ? agentsMdUpperPath : agentsMdLowerPath;
  const agentsMdExists = agentsMdUpperExists || agentsMdLowerExists;
  let agentsMdInput = none2();
  if (agentsMdExists) {
    const agentsMdStat = yield* fs.stat(agentsMdPath).pipe(option2);
    const isAgentsMdSymlink = isSome2(agentsMdStat) && agentsMdStat.value.type === "SymbolicLink";
    if (!isAgentsMdSymlink) {
      const agentsMdText = yield* fs.readFileString(agentsMdPath).pipe(
        mapError2((cause2) => new FileReadError({ path: agentsMdPath, cause: cause2 }))
      );
      agentsMdInput = some2({
        fileName: agentsMdPath,
        text: agentsMdText
      });
    }
  }
  const claudeMdLowerPath = path2.join(currentDir, "claude.md");
  const claudeMdUpperPath = path2.join(currentDir, "CLAUDE.md");
  const claudeMdLowerExists = yield* fs.exists(claudeMdLowerPath);
  const claudeMdUpperExists = yield* fs.exists(claudeMdUpperPath);
  const claudeMdPath = claudeMdUpperExists ? claudeMdUpperPath : claudeMdLowerPath;
  const claudeMdExists = claudeMdUpperExists || claudeMdLowerExists;
  let claudeMdInput = none2();
  if (claudeMdExists) {
    const claudeMdStat = yield* fs.stat(claudeMdPath).pipe(option2);
    const isClaudeMdSymlink = isSome2(claudeMdStat) && claudeMdStat.value.type === "SymbolicLink";
    if (!isClaudeMdSymlink) {
      const claudeMdText = yield* fs.readFileString(claudeMdPath).pipe(
        mapError2((cause2) => new FileReadError({ path: claudeMdPath, cause: cause2 }))
      );
      claudeMdInput = some2({
        fileName: claudeMdPath,
        text: claudeMdText
      });
    }
  }
  return {
    packageJson: packageJsonInput,
    tsconfig: tsconfigInput,
    vscodeSettings: vscodeSettingsInput,
    agentsMd: agentsMdInput,
    claudeMd: claudeMdInput
  };
});
var setup = make58(
  "setup",
  {},
  () => gen2(function* () {
    const path2 = yield* Path2;
    const currentDir = path2.resolve(process.cwd());
    const tsconfigInput = yield* selectTsConfigFile(currentDir);
    const assessmentInput = yield* createAssessmentInput(currentDir, tsconfigInput);
    const assessmentState = yield* assess(assessmentInput);
    const targetState = yield* gatherTargetState(assessmentState, {
      defaultLspVersion: `^${package_default.version}`
    });
    const result = yield* computeChanges(assessmentState, targetState);
    yield* renderCodeActions(result, assessmentState);
    if (result.codeActions.length === 0) {
      return;
    }
    const shouldProceed = yield* confirm2({
      message: "Apply all changes?",
      initial: true
    });
    if (!shouldProceed) {
      yield* log3("Setup cancelled. No changes were made.");
      return;
    }
    yield* log3("");
    yield* log3("Applying changes...");
    const fs = yield* FileSystem;
    for (const codeAction of result.codeActions) {
      for (const fileChange of codeAction.changes) {
        const fileName = fileChange.fileName;
        const fileExists = yield* fs.exists(fileName);
        if (!fileExists && fileChange.isNewFile) {
          const dirName = path2.dirname(fileName);
          yield* fs.makeDirectory(dirName, { recursive: true }).pipe(
            ignore2
            // Ignore error if directory already exists
          );
          const newContent = fileChange.textChanges.length > 0 ? fileChange.textChanges[0].newText : "";
          yield* fs.writeFileString(fileName, newContent);
        } else if (fileExists) {
          const existingContent = yield* fs.readFileString(fileName);
          const sortedChanges = [...fileChange.textChanges].sort((a, b) => b.span.start - a.span.start);
          let newContent = existingContent;
          for (const textChange of sortedChanges) {
            const start4 = textChange.span.start;
            const end5 = start4 + textChange.span.length;
            newContent = newContent.slice(0, start4) + textChange.newText + newContent.slice(end5);
          }
          yield* fs.writeFileString(fileName, newContent);
        }
      }
    }
    yield* log3("Changes applied successfully!");
    yield* log3("");
    for (const message of result.messages) {
      yield* log3(message);
    }
  })
).pipe(
  withDescription6("Setup the effect-language-service for the given project using an interactive cli.")
);

// src/cli/unpatch.ts
var LOCAL_TYPESCRIPT_DIR3 = "./node_modules/typescript";
var dirPath3 = directory2("dir").pipe(
  withDefault3(LOCAL_TYPESCRIPT_DIR3),
  withDescription3("The directory of the typescript package to patch.")
);
var moduleNames2 = choice3("module", [
  "tsc",
  "typescript"
]).pipe(
  repeated4,
  withDescription3("The name of the module to patch.")
);
var unpatch = make58(
  "unpatch",
  { dirPath: dirPath3, moduleNames: moduleNames2 },
  fn("unpatch")(function* ({ dirPath: dirPath4, moduleNames: moduleNames3 }) {
    const fs = yield* FileSystem;
    const modulesToUnpatch = moduleNames3.length === 0 ? ["typescript", "tsc"] : moduleNames3;
    for (const moduleName of modulesToUnpatch) {
      yield* logDebug2(`Resolving ${moduleName}...`);
      const filePath = yield* getModuleFilePath(dirPath4, moduleName);
      yield* logDebug2(`Reading ${moduleName} from ${filePath}...`);
      const sourceText = yield* getSourceFileText(filePath);
      yield* logDebug2(`Unpatching ${filePath}...`);
      const sourceFile = yield* getUnpatchedSourceFile(filePath, sourceText);
      yield* logDebug2(`Writing ${filePath}...`);
      yield* fs.writeFileString(filePath, sourceFile.text);
      yield* logInfo2(`${filePath} unpatched successfully.`);
    }
  })
).pipe(
  withDescription6("Unpatches the typescript package from the effect-language-service.")
);

// src/cli.ts
var cliCommand = make58(
  "effect-language-service",
  {},
  () => log3("Please select a command or run --help.")
).pipe(withSubcommands3([setup, patch9, unpatch, check2, diagnostics2, quickfixes, codegen, overview, layerInfo]));
var main = run8(cliCommand, {
  name: "effect-language-service",
  version: package_default.version
});
var cliLayers = merge7(layer11, TypeScriptContext.live(process.cwd()));
main(process.argv).pipe(
  provide2(cliLayers),
  runMain3({
    disableErrorReporting: false
  })
);
//# sourceMappingURL=cli.js.map