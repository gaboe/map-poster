"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/transform.ts
var transform_exports = {};
__export(transform_exports, {
  default: () => transform_default
});
module.exports = __toCommonJS(transform_exports);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constUndefined = /* @__PURE__ */ constant(void 0);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isFunction2 = isFunction;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        if (Number.isNaN(self.getTime())) {
          return string("Invalid Date");
        }
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys2) => {
  let h = 12289;
  for (let i = 0; i < keys2.length; i++) {
    h ^= pipe(string(keys2[i]), combine(hash(o[keys2[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        const t1 = self.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_COMMIT = "Commit";

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.19.14";
var getCurrentVersion = () => moduleVersion;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isLeft2 = isLeft;
var isRight2 = isRight;
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var getOrElse = /* @__PURE__ */ dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Order.js
var make = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string2 = /* @__PURE__ */ make((self, that) => self < that ? -1 : 1);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var getOrElse2 = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse2(constUndefined);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Record.js
var map2 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var keys = (self) => Object.keys(self);

// ../../node_modules/.pnpm/effect@3.19.14/node_modules/effect/dist/esm/Array.js
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var tailNonEmpty = (self) => self.slice(1);
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var containsWith = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence = /* @__PURE__ */ equivalence();
var intersectionWith = (isEquivalent) => {
  const has = containsWith(isEquivalent);
  return dual(2, (self, that) => {
    const bs = fromIterable(that);
    return fromIterable(self).filter((a) => has(bs, a));
  });
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence);
var empty = () => [];
var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap(identity);
var filter = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// src/core/Nano.ts
var NanoTag = class {
  constructor(key) {
    this.key = key;
  }
};
var Tag = (identifier) => new NanoTag(identifier);
var SingleShotGen2 = class _SingleShotGen {
  called = false;
  self;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var evaluate = /* @__PURE__ */ Symbol.for("Nano.evaluate");
var contA = /* @__PURE__ */ Symbol.for("Nano.contA");
var contE = /* @__PURE__ */ Symbol.for("Nano.contE");
var contAll = /* @__PURE__ */ Symbol.for("Nano.contAll");
var NanoYield = /* @__PURE__ */ Symbol.for("Nano.yield");
var args = /* @__PURE__ */ Symbol.for("Nano.args");
var NanoDefectException = class {
  constructor(message, lastSpan) {
    this.message = message;
    this.lastSpan = lastSpan;
  }
  _tag = "@effect/language-service/NanoDefectException";
};
var PrimitiveProto = {
  [Symbol.iterator]() {
    return new SingleShotGen2(this);
  }
};
var SucceedProto = {
  ...PrimitiveProto,
  _tag: "Success",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this);
  }
};
var succeed = (value) => {
  const nano = Object.create(SucceedProto);
  nano[args] = value;
  return nano;
};
var FailureProto = {
  ...PrimitiveProto,
  _tag: "Failure",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this);
  }
};
var fail = (error) => {
  const nano = Object.create(FailureProto);
  nano[args] = error;
  return nano;
};
var SuspendProto = {
  ...PrimitiveProto,
  [evaluate]() {
    return this[args]();
  }
};
var suspend = (fn2) => {
  const nano = Object.create(SuspendProto);
  nano[args] = fn2;
  return nano;
};
var NanoFiber = class {
  _stack = [];
  _yielded = void 0;
  _services = {};
  _cache = {};
  _perf = false;
  _lastSpan = "";
  runLoop(nano) {
    let current = nano;
    while (true) {
      current = current[evaluate](this);
      if (current === NanoYield) {
        return this._yielded;
      }
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[contAll] && op[contAll](this);
      if (cont) return { [symbol3]: cont };
      if (op[symbol3]) return op;
    }
  }
  yieldWith(value) {
    this._yielded = value;
    return NanoYield;
  }
};
var timings = {};
var timingsCount = {};
var WithSpanProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, name] = this[args];
    if (!fiber._perf) return fa;
    const previousSpan = fiber._lastSpan;
    fiber._lastSpan = name;
    const start = performance.now();
    timingsCount[name] = (timingsCount[name] || 0) + 1;
    return match(fa, {
      onSuccess: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        fiber._lastSpan = previousSpan;
        return succeed(_);
      },
      onFailure: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        fiber._lastSpan = previousSpan;
        return fail(_);
      }
    });
  }
};
var withSpan = (name) => (fa) => {
  const nano = Object.create(WithSpanProto);
  nano[args] = [fa, name];
  return nano;
};
var run = (nano) => {
  const fiber = new NanoFiber();
  try {
    const result = fiber.runLoop(nano);
    if (result._tag === "Success") {
      return right2(result.value);
    }
    return left2(result.value);
  } catch (e) {
    return left2(new NanoDefectException(e, fiber._lastSpan));
  }
};
var OnSuccessProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var flatMap2 = dual(2, (fa, f) => {
  const nano = Object.create(OnSuccessProto);
  nano[args] = fa;
  nano[contA] = f;
  return nano;
});
var map4 = dual(2, (fa, f) => flatMap2(fa, (_) => succeed(f(_))));
var SyncProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const value = this[args]();
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value));
  }
};
var sync = (f) => {
  const nano = Object.create(SyncProto);
  nano[args] = f;
  return nano;
};
var void_ = succeed(void 0);
var FromIteratorProto = {
  ...PrimitiveProto,
  [contA](value, fiber) {
    const state = this[args][0].next(value);
    if (state.done) return succeed(state.value);
    fiber._stack.push(this);
    return state.value;
  },
  [evaluate](fiber) {
    return this[contA](this[args][1], fiber);
  }
};
var unsafeFromIterator = (iterator, initial) => {
  const nano = Object.create(FromIteratorProto);
  nano[args] = [iterator, initial];
  return nano;
};
var gen = (...args2) => suspend(() => unsafeFromIterator(args2[0]()));
var fn = (_) => (body) => (...args2) => withSpan(_)(suspend(() => unsafeFromIterator(body(...args2))));
var MatchProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var match = (fa, opts) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = opts.onSuccess;
  nano[contE] = opts.onFailure;
  return nano;
};
var orElse2 = (f) => (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : f(_);
  return nano;
};
var firstSuccessOf = (arr) => arr.slice(1).reduce((arr2, fa) => orElse2(() => fa)(arr2), arr[0]);
var ProvideServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const prevServices = fiber._services;
    const [fa, tag, value] = this[args];
    fiber._services = {
      ...fiber._services,
      [tag.key]: value
    };
    return match(fa, {
      onSuccess: (_) => {
        fiber._services = prevServices;
        return succeed(_);
      },
      onFailure: (_) => {
        fiber._services = prevServices;
        return fail(_);
      }
    });
  }
};
var provideService = (tag, value) => (fa) => {
  const nano = Object.create(ProvideServiceProto);
  nano[args] = [fa, tag, value];
  return nano;
};
var ServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const tag = this[args];
    if (tag.key in fiber._services) {
      const value = fiber._services[tag.key];
      const cont2 = fiber.getCont(contA);
      return cont2 ? cont2[contA](value, fiber) : fiber.yieldWith(succeed(value));
    }
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](tag, fiber) : fiber.yieldWith(fail(new NanoDefectException(`Service ${tag.key} not found`, fiber._lastSpan)));
  }
};
var service = (tag) => {
  const nano = Object.create(ServiceProto);
  nano[args] = tag;
  return nano;
};
var CachedProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, type, key] = this[args];
    const cache = fiber._cache[type] || /* @__PURE__ */ new WeakMap();
    fiber._cache[type] = cache;
    const cached2 = cache.get(key);
    if (cached2) return cached2;
    return match(fa, {
      onSuccess: (_) => {
        cache.set(key, succeed(_));
        return succeed(_);
      },
      onFailure: (_) => {
        cache.set(key, fail(_));
        return fail(_);
      }
    });
  }
};
function cachedBy(fa, type, lookupKey) {
  return (...p) => {
    const nano = Object.create(CachedProto);
    nano[args] = [fa(...p), type, lookupKey(...p)];
    return nano;
  };
}
var option = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => succeed(some2(_));
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : succeed(none2());
  return nano;
};
var ignore = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => void_;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : void_;
  return nano;
};
var all = fn("all")(
  function* (...args2) {
    const results = [];
    for (const fa of args2) {
      const result = yield* fa;
      results.push(result);
    }
    return results;
  }
);

// src/core/LanguageServicePluginOptions.ts
var LanguageServicePluginOptions = Tag("PluginOptions");
function isValidSeverityLevel(value) {
  return value === "off" || value === "error" || value === "warning" || value === "message" || value === "suggestion";
}
function parseDiagnosticSeverity(config) {
  if (!isRecord(config)) return {};
  return Object.fromEntries(
    pipe(
      Object.entries(config),
      filter(([key, value]) => isString(key) && isString(value)),
      map3(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),
      filter(([_, value]) => isValidSeverityLevel(value))
    )
  );
}
var defaults = {
  refactors: true,
  diagnostics: true,
  diagnosticSeverity: {},
  diagnosticsName: true,
  missingDiagnosticNextLine: "warning",
  includeSuggestionsInTsc: true,
  quickinfo: true,
  quickinfoEffectParameters: "whentruncated",
  quickinfoMaximumLength: -1,
  completions: true,
  goto: true,
  inlays: true,
  allowedDuplicatedPackages: [],
  namespaceImportPackages: [],
  topLevelNamedReexports: "ignore",
  barrelImportPackages: [],
  importAliases: {},
  renames: true,
  noExternal: false,
  keyPatterns: [{
    target: "service",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }, {
    target: "custom",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }],
  extendedKeyDetection: false,
  ignoreEffectWarningsInTscExitCode: false,
  ignoreEffectSuggestionsInTscExitCode: true,
  pipeableMinArgCount: 2,
  effectFn: ["span"],
  layerGraphFollowDepth: 0,
  mermaidProvider: "mermaid.live"
};
function parseKeyPatterns(patterns) {
  const result = [];
  for (const entry of patterns) {
    if (!isObject(entry)) continue;
    result.push({
      target: hasProperty(entry, "target") && isString(entry.target) && ["service", "error", "custom"].includes(entry.target.toLowerCase()) ? entry.target.toLowerCase() : "service",
      pattern: hasProperty(entry, "pattern") && isString(entry.pattern) && ["package-identifier", "default", "default-hashed"].includes(entry.pattern.toLowerCase()) ? entry.pattern.toLowerCase() : "default",
      skipLeadingPath: hasProperty(entry, "skipLeadingPath") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString) ? entry.skipLeadingPath : ["src/"]
    });
  }
  return result;
}
function parse(config) {
  return {
    refactors: isObject(config) && hasProperty(config, "refactors") && isBoolean(config.refactors) ? config.refactors : defaults.refactors,
    diagnostics: isObject(config) && hasProperty(config, "diagnostics") && isBoolean(config.diagnostics) ? config.diagnostics : defaults.diagnostics,
    diagnosticSeverity: isObject(config) && hasProperty(config, "diagnosticSeverity") && isRecord(config.diagnosticSeverity) ? parseDiagnosticSeverity(config.diagnosticSeverity) : defaults.diagnosticSeverity,
    diagnosticsName: isObject(config) && hasProperty(config, "diagnosticsName") && isBoolean(config.diagnosticsName) ? config.diagnosticsName : defaults.diagnosticsName,
    missingDiagnosticNextLine: isObject(config) && hasProperty(config, "missingDiagnosticNextLine") && isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine) ? config.missingDiagnosticNextLine : defaults.missingDiagnosticNextLine,
    includeSuggestionsInTsc: isObject(config) && hasProperty(config, "includeSuggestionsInTsc") && isBoolean(config.includeSuggestionsInTsc) ? config.includeSuggestionsInTsc : defaults.includeSuggestionsInTsc,
    ignoreEffectWarningsInTscExitCode: isObject(config) && hasProperty(config, "ignoreEffectWarningsInTscExitCode") && isBoolean(config.ignoreEffectWarningsInTscExitCode) ? config.ignoreEffectWarningsInTscExitCode : defaults.ignoreEffectWarningsInTscExitCode,
    ignoreEffectSuggestionsInTscExitCode: isObject(config) && hasProperty(config, "ignoreEffectSuggestionsInTscExitCode") && isBoolean(config.ignoreEffectSuggestionsInTscExitCode) ? config.ignoreEffectSuggestionsInTscExitCode : defaults.ignoreEffectSuggestionsInTscExitCode,
    quickinfo: isObject(config) && hasProperty(config, "quickinfo") && isBoolean(config.quickinfo) ? config.quickinfo : defaults.quickinfo,
    quickinfoEffectParameters: isObject(config) && hasProperty(config, "quickinfoEffectParameters") && isString(config.quickinfoEffectParameters) && ["always", "never", "whentruncated"].includes(config.quickinfoEffectParameters.toLowerCase()) ? config.quickinfoEffectParameters.toLowerCase() : defaults.quickinfoEffectParameters,
    quickinfoMaximumLength: isObject(config) && hasProperty(config, "quickinfoMaximumLength") && isNumber(config.quickinfoMaximumLength) ? config.quickinfoMaximumLength : defaults.quickinfoMaximumLength,
    completions: isObject(config) && hasProperty(config, "completions") && isBoolean(config.completions) ? config.completions : defaults.completions,
    goto: isObject(config) && hasProperty(config, "goto") && isBoolean(config.goto) ? config.goto : defaults.goto,
    inlays: isObject(config) && hasProperty(config, "inlays") && isBoolean(config.inlays) ? config.inlays : defaults.inlays,
    allowedDuplicatedPackages: isObject(config) && hasProperty(config, "allowedDuplicatedPackages") && isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString) ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase()) : defaults.allowedDuplicatedPackages,
    namespaceImportPackages: isObject(config) && hasProperty(config, "namespaceImportPackages") && isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString) ? config.namespaceImportPackages.map((_) => _.toLowerCase()) : defaults.namespaceImportPackages,
    barrelImportPackages: isObject(config) && hasProperty(config, "barrelImportPackages") && isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString) ? config.barrelImportPackages.map((_) => _.toLowerCase()) : defaults.barrelImportPackages,
    importAliases: isObject(config) && hasProperty(config, "importAliases") && isRecord(config.importAliases) ? map2(config.importAliases, (value) => String(value)) : defaults.importAliases,
    topLevelNamedReexports: isObject(config) && hasProperty(config, "topLevelNamedReexports") && isString(config.topLevelNamedReexports) && ["ignore", "follow"].includes(config.topLevelNamedReexports.toLowerCase()) ? config.topLevelNamedReexports.toLowerCase() : defaults.topLevelNamedReexports,
    renames: isObject(config) && hasProperty(config, "renames") && isBoolean(config.renames) ? config.renames : defaults.renames,
    noExternal: isObject(config) && hasProperty(config, "noExternal") && isBoolean(config.noExternal) ? config.noExternal : defaults.noExternal,
    keyPatterns: isObject(config) && hasProperty(config, "keyPatterns") && isArray(config.keyPatterns) ? parseKeyPatterns(config.keyPatterns) : defaults.keyPatterns,
    extendedKeyDetection: isObject(config) && hasProperty(config, "extendedKeyDetection") && isBoolean(config.extendedKeyDetection) ? config.extendedKeyDetection : defaults.extendedKeyDetection,
    pipeableMinArgCount: isObject(config) && hasProperty(config, "pipeableMinArgCount") && isNumber(config.pipeableMinArgCount) ? config.pipeableMinArgCount : defaults.pipeableMinArgCount,
    effectFn: isObject(config) && hasProperty(config, "effectFn") && isArray(config.effectFn) && config.effectFn.every(isString) ? config.effectFn.map((_) => _.toLowerCase()) : defaults.effectFn,
    layerGraphFollowDepth: isObject(config) && hasProperty(config, "layerGraphFollowDepth") && isNumber(config.layerGraphFollowDepth) ? config.layerGraphFollowDepth : defaults.layerGraphFollowDepth,
    mermaidProvider: isObject(config) && hasProperty(config, "mermaidProvider") && isString(config.mermaidProvider) ? config.mermaidProvider : defaults.mermaidProvider
  };
}

// src/core/TypeScriptApi.ts
var TypeScriptApi = Tag("TypeScriptApi");
var TypeScriptProgram = Tag("TypeScriptProgram");
var ChangeTracker = Tag("ChangeTracker");
function getPackageJsonInfoCache(program) {
  try {
    if (hasProperty(program, "getModuleResolutionCache") && isFunction2(program.getModuleResolutionCache)) {
      const moduleResolutionCache = program.getModuleResolutionCache();
      if (hasProperty(moduleResolutionCache, "getPackageJsonInfoCache") && isFunction2(moduleResolutionCache.getPackageJsonInfoCache)) {
        return moduleResolutionCache.getPackageJsonInfoCache();
      }
    }
  } catch (_) {
    return void 0;
  }
  return void 0;
}
function getDirectoryPath(ts, path) {
  try {
    if (hasProperty(ts, "getDirectoryPath") && isFunction2(ts.getDirectoryPath)) {
      return ts.getDirectoryPath(path);
    }
    return path;
  } catch (_) {
    return path;
  }
}
function makeGetModuleSpecifier(ts) {
  if (!(hasProperty(ts, "moduleSpecifiers") && hasProperty(ts.moduleSpecifiers, "getModuleSpecifier") && isFunction2(ts.moduleSpecifiers.getModuleSpecifier))) return;
  const _internal = ts.moduleSpecifiers.getModuleSpecifier;
  return (compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) => {
    return _internal(
      compilerOptions,
      importingSourceFile,
      importingSourceFileName,
      toFileName,
      host,
      options
    );
  };
}
function makeGetTemporaryModuleResolutionState(ts) {
  if (hasProperty(ts, "getTemporaryModuleResolutionState") && isFunction2(ts.getTemporaryModuleResolutionState)) {
    const _internal = ts.getTemporaryModuleResolutionState;
    return (cache, program, compilerOptions) => _internal(cache, program, compilerOptions);
  }
  return void 0;
}
function makeGetPackageScopeForPath(ts) {
  if (hasProperty(ts, "getPackageScopeForPath") && isFunction2(ts.getPackageScopeForPath)) {
    const _internal = ts.getPackageScopeForPath;
    return (path, state) => _internal(path, state);
  }
}

// src/core/TypeScriptUtils.ts
var TypeScriptUtils = Tag("TypeScriptUtils");
var nanoLayer = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2((ts) => pipe(fa, provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))
);
function makeTypeScriptUtils(ts) {
  const getTemporaryModuleResolutionState = makeGetTemporaryModuleResolutionState(ts);
  const getPackageScopeForPath = makeGetPackageScopeForPath(ts);
  function parsePackageContentNameAndVersionFromScope(v) {
    if (!isObject(v)) return;
    if (!hasProperty(v, "packageJsonScope")) return;
    if (!v.packageJsonScope) return;
    const packageJsonScope = v.packageJsonScope;
    if (!hasProperty(packageJsonScope, "contents")) return;
    if (!hasProperty(packageJsonScope.contents, "packageJsonContent")) return;
    const packageJsonContent = packageJsonScope.contents.packageJsonContent;
    if (!hasProperty(packageJsonContent, "name")) return;
    if (!hasProperty(packageJsonScope, "packageDirectory")) return;
    if (!isString(packageJsonScope.packageDirectory)) return;
    const { name } = packageJsonContent;
    const version = hasProperty(packageJsonScope, "version") ? packageJsonScope.version : "";
    if (!isString(name)) return;
    if (!isString(version)) return;
    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) && hasProperty(packageJsonContent.peerDependencies, "effect");
    const referencedPackages = Object.keys({
      ...hasProperty(packageJsonContent, "dependencies") && isObject(packageJsonContent.dependencies) ? packageJsonContent.dependencies : {},
      ...hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) ? packageJsonContent.peerDependencies : {},
      ...hasProperty(packageJsonContent, "devDependencies") && isObject(packageJsonContent.devDependencies) ? packageJsonContent.devDependencies : {}
    });
    const exportsKeys = Object.keys(
      hasProperty(packageJsonContent, "exports") && isObject(packageJsonContent.exports) ? packageJsonContent.exports : {}
    );
    return {
      name: name.toLowerCase(),
      version: version.toLowerCase(),
      hasEffectInPeerDependencies,
      contents: packageJsonContent,
      packageDirectory: packageJsonScope.packageDirectory,
      referencedPackages,
      exportsKeys
    };
  }
  function resolveModuleWithPackageInfoFromSourceFile(program, sourceFile) {
    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile);
    if (!packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState) {
      const packageJsonInfoCache = getPackageJsonInfoCache(program);
      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(
        packageJsonInfoCache,
        program,
        program.getCompilerOptions()
      );
      const directoryPath = getDirectoryPath(ts, sourceFile.fileName);
      packageJsonScope = parsePackageContentNameAndVersionFromScope({
        ...sourceFile,
        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)
      });
    }
    return packageJsonScope;
  }
  function resolveModulePattern(program, sourceFile, pattern) {
    if (pattern.indexOf("*") === -1) return [pattern.toLowerCase()];
    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    const referencedPackages = [];
    for (const statement of sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {
        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase();
        const packageName = moduleSpecifier.startsWith("@") ? moduleSpecifier.split("/", 2).join("/") : moduleSpecifier.split("/", 1).join("/");
        referencedPackages.push(packageName);
      }
    }
    return pipe(
      referencedPackages.concat(packageJsonScope?.referencedPackages || []),
      dedupe,
      map3((packageName) => packageName.toLowerCase()),
      filter(
        (packageName) => pattern.endsWith("*") && packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))
      )
    );
  }
  function findNodeWithLeadingCommentAtPosition(sourceFile, position) {
    const sourceText = sourceFile.text;
    let result;
    function find(node) {
      const leading = ts.getLeadingCommentRanges(sourceText, node.pos);
      if (leading) {
        for (const commentRange of leading) {
          if (commentRange.pos <= position && position < commentRange.end) {
            result = { node, commentRange };
            return;
          }
        }
      }
      if (node.pos <= position && position < node.end) {
        ts.forEachChild(node, find);
      }
    }
    find(sourceFile);
    return result;
  }
  function collectSelfAndAncestorNodesInRange(node, textRange) {
    let result = empty();
    let parent = node;
    while (parent) {
      if (parent.end >= textRange.end) {
        result = pipe(result, append(parent));
      }
      parent = parent.parent;
    }
    return result;
  }
  function findNodeAtPosition(sourceFile, position) {
    function find(node) {
      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function findNodeAtPositionIncludingTrivia(sourceFile, position) {
    function find(node) {
      if (position >= node.pos && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function getAncestorNodesInRange(sourceFile, textRange) {
    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos);
    if (!nodeAtPosition) return empty();
    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange);
  }
  function getCommentAtPosition(sourceFile, pos) {
    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos);
    if (token === void 0 || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || "").length) {
      return;
    }
    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || "").length : token.pos;
    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos);
    return result;
  }
  function isCommentInRange(pos, end, kind, _nl, at) {
    return at >= pos && at < end ? { pos, end, kind } : void 0;
  }
  function toTextRange(positionOrRange) {
    return typeof positionOrRange === "number" ? { end: positionOrRange, pos: positionOrRange } : positionOrRange;
  }
  function isNodeInRange(textRange) {
    return (node) => node.pos <= textRange.pos && node.end >= textRange.end;
  }
  function transformAsyncAwaitToEffectGeneratorBody(body, onAwait) {
    function visitor(_) {
      if (ts.isAwaitExpression(_)) {
        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext);
        return ts.factory.createYieldExpression(
          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
          onAwait(expression)
        );
      }
      return ts.visitEachChild(_, visitor, ts.nullTransformationContext);
    }
    return visitor(body);
  }
  function transformAsyncAwaitToEffectFn(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const fnName = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node ? node.parent.name : void 0;
    let fnCall = ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectModuleName),
      "fn"
    );
    if (fnName) {
      fnCall = ts.factory.createCallExpression(
        fnCall,
        void 0,
        [ts.factory.createStringLiteral(ts.idText(fnName))]
      );
    }
    return tryPreserveDeclarationSemantics(
      node,
      ts.factory.createCallExpression(
        fnCall,
        void 0,
        [
          ts.factory.createFunctionExpression(
            void 0,
            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
            void 0,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.isBlock(generatorBody) ? generatorBody : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])
          )
        ]
      ),
      true
    );
  }
  function transformAsyncAwaitToEffectGen(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody);
    let currentFlags = ts.getCombinedModifierFlags(node);
    currentFlags &= ~ts.ModifierFlags.Async;
    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags);
    if (ts.isArrowFunction(node)) {
      return ts.factory.createArrowFunction(
        newModifiers,
        node.typeParameters,
        node.parameters,
        void 0,
        node.equalsGreaterThanToken,
        effectGenCallExp
      );
    }
    const newBody = ts.factory.createBlock([
      ts.factory.createReturnStatement(effectGenCallExp)
    ]);
    if (ts.isFunctionDeclaration(node)) {
      return ts.factory.createFunctionDeclaration(
        newModifiers,
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        void 0,
        newBody
      );
    }
    return ts.factory.createFunctionExpression(
      newModifiers,
      node.asteriskToken,
      node.name,
      node.typeParameters,
      node.parameters,
      void 0,
      newBody
    );
  }
  function findImportedModuleIdentifier(sourceFile, test) {
    for (const statement of sourceFile.statements) {
      if (!ts.isImportDeclaration(statement)) continue;
      const importClause = statement.importClause;
      if (!importClause) continue;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) continue;
      if (ts.isNamespaceImport(namedBindings)) {
        if (test(namedBindings.name, statement.moduleSpecifier, none2())) {
          return ts.idText(namedBindings.name);
        }
      } else if (ts.isNamedImports(namedBindings)) {
        for (const importSpecifier of namedBindings.elements) {
          const importProperty = fromNullable(importSpecifier.propertyName).pipe(
            orElse(() => some2(importSpecifier.name))
          );
          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {
            return ts.idText(importSpecifier.name);
          }
        }
      }
    }
  }
  function findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, packageName, moduleName) {
    return findImportedModuleIdentifier(
      sourceFile,
      (_, fromModule, importProperty) => {
        if (isNone2(importProperty) && ts.isStringLiteral(fromModule) && fromModule.text === packageName + "/" + moduleName) {
          return true;
        }
        if (isSome2(importProperty) && ts.isIdentifier(importProperty.value) && ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) && fromModule.text === packageName) {
          return true;
        }
        return false;
      }
    );
  }
  function simplifyTypeNode(typeNode) {
    function collectCallable(typeNode2) {
      if (ts.isParenthesizedTypeNode(typeNode2)) return collectCallable(typeNode2.type);
      if (ts.isFunctionTypeNode(typeNode2)) {
        return some2([
          ts.factory.createCallSignature(typeNode2.typeParameters, typeNode2.parameters, typeNode2.type)
        ]);
      }
      if (ts.isTypeLiteralNode(typeNode2)) {
        const allCallSignatures = typeNode2.members.every(ts.isCallSignatureDeclaration);
        if (allCallSignatures) {
          return some2(typeNode2.members);
        }
      }
      if (ts.isIntersectionTypeNode(typeNode2)) {
        const members = typeNode2.types.map((node) => collectCallable(node));
        if (members.every(isSome2)) {
          return some2(members.map((_) => isSome2(_) ? _.value : []).flat());
        }
      }
      return none2();
    }
    const callSignatures = collectCallable(typeNode);
    if (isSome2(callSignatures) && callSignatures.value.length > 1) {
      return ts.factory.createTypeLiteralNode(callSignatures.value);
    }
    return typeNode;
  }
  function tryPreserveDeclarationSemantics(nodeToReplace, node, dropAsync) {
    if (!ts.isExpression(node)) return node;
    if (ts.isFunctionDeclaration(nodeToReplace)) {
      if (!nodeToReplace.name) return node;
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createVariableStatement(
        newModifiers,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            nodeToReplace.name,
            void 0,
            void 0,
            node
          )],
          ts.NodeFlags.Const
        )
      );
    } else if (ts.isMethodDeclaration(nodeToReplace)) {
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createPropertyDeclaration(
        newModifiers,
        nodeToReplace.name,
        void 0,
        void 0,
        node
      );
    }
    return node;
  }
  function parseAccessedExpressionForCompletion(sourceFile, position) {
    const precedingToken = ts.findPrecedingToken(position, sourceFile, void 0, true);
    if (!precedingToken) return;
    let accessedObject = precedingToken;
    let replacementSpan = ts.createTextSpan(position, 0);
    let outerNode = precedingToken;
    if (ts.isIdentifier(precedingToken) && precedingToken.parent && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        spanStart,
        precedingToken.end - spanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken;
      outerNode = precedingToken;
    } else {
      return;
    }
    const importDeclaration = ts.findAncestor(accessedObject, ts.isImportDeclaration);
    if (importDeclaration) return;
    return { accessedObject, outerNode, replacementSpan, insideImportDeclaration: !!importDeclaration };
  }
  function parseDataForExtendsClassCompletion(sourceFile, position) {
    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return;
    const { accessedObject, outerNode, replacementSpan } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return;
    let classDeclaration = outerNode.parent;
    while (ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)) {
      if (!classDeclaration.parent) break;
      classDeclaration = classDeclaration.parent;
    }
    if (!ts.isClassDeclaration(classDeclaration)) return;
    if (!classDeclaration.name) return;
    return {
      accessedObject,
      classDeclaration,
      className: classDeclaration.name,
      replacementSpan
    };
  }
  function createEffectGenCallExpression(effectModuleIdentifierName, node) {
    const generator = ts.factory.createFunctionExpression(
      void 0,
      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
      void 0,
      [],
      [],
      void 0,
      node
      // NOTE(mattia): intended, to use same routine for both ConciseBody and Body
    );
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifierName),
        "gen"
      ),
      void 0,
      [generator]
    );
  }
  function createEffectGenCallExpressionWithBlock(effectModuleIdentifierName, statement) {
    return createEffectGenCallExpression(
      effectModuleIdentifierName,
      ts.factory.createBlock(isArray(statement) ? statement : [statement], false)
    );
  }
  function createReturnYieldStarStatement(expr) {
    return ts.factory.createReturnStatement(
      ts.factory.createYieldExpression(
        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
        expr
      )
    );
  }
  function createDataTaggedErrorDeclaration(dataModuleIdentifier, name, fields) {
    const invokeTaggedError = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(dataModuleIdentifier),
        "TaggedError"
      ),
      void 0,
      [
        ts.factory.createStringLiteral(name)
      ]
    );
    const withTypeFields = ts.factory.createExpressionWithTypeArguments(
      invokeTaggedError,
      [
        ts.factory.createTypeLiteralNode(fields)
      ]
    );
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      void 0,
      [
        ts.factory.createHeritageClause(
          ts.SyntaxKind.ExtendsKeyword,
          [
            withTypeFields
          ]
        )
      ],
      []
    );
  }
  function getSourceFileOfNode(current) {
    let node = current;
    while (node && node.kind !== ts.SyntaxKind.SourceFile) {
      node = node.parent;
    }
    return node;
  }
  function isOuterExpression(node, kinds = ts.OuterExpressionKinds.All) {
    switch (node.kind) {
      case ts.SyntaxKind.ParenthesizedExpression:
        return (kinds & ts.OuterExpressionKinds.Parentheses) !== 0;
      case ts.SyntaxKind.TypeAssertionExpression:
      case ts.SyntaxKind.AsExpression:
        return (kinds & ts.OuterExpressionKinds.TypeAssertions) !== 0;
      case ts.SyntaxKind.SatisfiesExpression:
        return (kinds & (ts.OuterExpressionKinds.TypeAssertions | ts.OuterExpressionKinds.Satisfies)) !== 0;
      case ts.SyntaxKind.ExpressionWithTypeArguments:
        return (kinds & ts.OuterExpressionKinds.ExpressionsWithTypeArguments) !== 0;
      case ts.SyntaxKind.NonNullExpression:
        return (kinds & ts.OuterExpressionKinds.NonNullAssertions) !== 0;
      case ts.SyntaxKind.PartiallyEmittedExpression:
        return (kinds & ts.OuterExpressionKinds.PartiallyEmittedExpressions) !== 0;
    }
    return false;
  }
  function skipOuterExpressions(node, kinds = ts.OuterExpressionKinds.All) {
    while (isOuterExpression(node, kinds)) {
      node = node.expression;
    }
    return node;
  }
  function isDeclarationKind(kind) {
    return kind === ts.SyntaxKind.ArrowFunction || kind === ts.SyntaxKind.BindingElement || kind === ts.SyntaxKind.ClassDeclaration || kind === ts.SyntaxKind.ClassExpression || kind === ts.SyntaxKind.ClassStaticBlockDeclaration || kind === ts.SyntaxKind.Constructor || kind === ts.SyntaxKind.EnumDeclaration || kind === ts.SyntaxKind.EnumMember || kind === ts.SyntaxKind.ExportSpecifier || kind === ts.SyntaxKind.FunctionDeclaration || kind === ts.SyntaxKind.FunctionExpression || kind === ts.SyntaxKind.GetAccessor || kind === ts.SyntaxKind.ImportClause || kind === ts.SyntaxKind.ImportEqualsDeclaration || kind === ts.SyntaxKind.ImportSpecifier || kind === ts.SyntaxKind.InterfaceDeclaration || kind === ts.SyntaxKind.JsxAttribute || kind === ts.SyntaxKind.MethodDeclaration || kind === ts.SyntaxKind.MethodSignature || kind === ts.SyntaxKind.ModuleDeclaration || kind === ts.SyntaxKind.NamespaceExportDeclaration || kind === ts.SyntaxKind.NamespaceImport || kind === ts.SyntaxKind.NamespaceExport || kind === ts.SyntaxKind.Parameter || kind === ts.SyntaxKind.PropertyAssignment || kind === ts.SyntaxKind.PropertyDeclaration || kind === ts.SyntaxKind.PropertySignature || kind === ts.SyntaxKind.SetAccessor || kind === ts.SyntaxKind.ShorthandPropertyAssignment || kind === ts.SyntaxKind.TypeAliasDeclaration || kind === ts.SyntaxKind.TypeParameter || kind === ts.SyntaxKind.VariableDeclaration || kind === ts.SyntaxKind.JSDocTypedefTag || kind === ts.SyntaxKind.JSDocCallbackTag || kind === ts.SyntaxKind.JSDocPropertyTag || kind === ts.SyntaxKind.NamedTupleMember;
  }
  function isVoidExpression(node) {
    const unwrapped = ts.isExpression(node) ? skipOuterExpressions(node) : node;
    if (ts.isVoidExpression(unwrapped) && ts.isNumericLiteral(unwrapped.expression) && unwrapped.expression.text === "0") {
      return true;
    }
    if (ts.isIdentifier(unwrapped) && ts.idText(unwrapped) === "undefined") {
      return true;
    }
    return false;
  }
  return {
    findNodeAtPositionIncludingTrivia,
    parsePackageContentNameAndVersionFromScope,
    resolveModulePattern,
    resolveModuleWithPackageInfoFromSourceFile,
    findNodeWithLeadingCommentAtPosition,
    getCommentAtPosition,
    getAncestorNodesInRange,
    toTextRange,
    isNodeInRange,
    transformAsyncAwaitToEffectFn,
    transformAsyncAwaitToEffectGen,
    createDataTaggedErrorDeclaration,
    findImportedModuleIdentifierByPackageAndNameOrBarrel,
    simplifyTypeNode,
    tryPreserveDeclarationSemantics,
    parseDataForExtendsClassCompletion,
    createEffectGenCallExpressionWithBlock,
    createReturnYieldStarStatement,
    parseAccessedExpressionForCompletion,
    getSourceFileOfNode,
    isOuterExpression,
    skipOuterExpressions,
    isDeclarationKind,
    isVoidExpression
  };
}

// src/core/LSP.ts
var RefactorNotApplicableError = class {
  _tag = "@effect/language-service/RefactorNotApplicableError";
};
function createRefactor(definition) {
  return definition;
}
function createDiagnostic(definition) {
  return definition;
}
var getSemanticDiagnosticsWithCodeFixes = fn(
  "LSP.getSemanticDiagnosticsWithCodeFixes"
)(function* (rules, sourceFile) {
  let effectDiagnostics = [];
  let effectCodeFixes = [];
  const executor = yield* createDiagnosticExecutor(sourceFile);
  for (const rule of rules) {
    const { codeFixes, diagnostics: diagnostics2 } = yield* executor.execute(rule);
    effectDiagnostics = effectDiagnostics.concat(diagnostics2);
    effectCodeFixes = effectCodeFixes.concat(codeFixes);
  }
  return {
    diagnostics: effectDiagnostics,
    codeFixes: effectCodeFixes
  };
});
function refactorNameToFullyQualifiedName(name) {
  return `@effect/language-service/refactors/${name}`;
}
var getApplicableRefactors = fn("LSP.getApplicableRefactors")(function* (refactors, sourceFile, positionOrRange) {
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  const effectRefactors = [];
  for (const refactor of refactors) {
    yield* pipe(
      refactor.apply(sourceFile, textRange),
      map4(
        (result) => effectRefactors.push({
          name: refactorNameToFullyQualifiedName(refactor.name),
          description: refactor.description,
          actions: [{
            name: refactorNameToFullyQualifiedName(refactor.name),
            description: result.description,
            kind: result.kind
          }]
        })
      ),
      ignore
    );
  }
  return effectRefactors;
});
var getEditsForRefactor = fn("LSP.getEditsForRefactor")(function* (refactors, sourceFile, positionOrRange, refactorName) {
  const refactor = refactors.find((refactor2) => refactorNameToFullyQualifiedName(refactor2.name) === refactorName);
  if (!refactor) {
    return yield* fail(new RefactorNotApplicableError());
  }
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  return yield* refactor.apply(sourceFile, textRange);
});
var getCompletionsAtPosition = fn("LSP.getCompletionsAtPosition")(function* (completions, sourceFile, position, options, formatCodeSettings) {
  let effectCompletions = [];
  for (const completion of completions) {
    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings);
    effectCompletions = effectCompletions.concat(
      result.map((_) => ({ sortText: "11", ..._ }))
    );
  }
  return effectCompletions;
});
var createDiagnosticExecutor = fn("LSP.createCommentDirectivesProcessor")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    function findParentStatementForDisableNextLine(node) {
      let result;
      function find(node2) {
        if (ts.isStatement(node2)) {
          result = node2;
          return;
        }
        if (ts.isPropertyAssignment(node2)) {
          const realStart = ts.getTokenPosOfNode(node2, sourceFile);
          const starts = sourceFile.getLineStarts().filter((start) => start >= node2.pos && start <= realStart);
          if (starts.length > 0) {
            result = node2;
            return;
          }
        }
        if (result) return;
        if (node2.parent) find(node2.parent);
      }
      find(node);
      return result || node;
    }
    const lineOverrides = {};
    const sectionOverrides = {};
    const skippedRules = [];
    const regex = /@effect-diagnostics(-next-line)?((?:\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm;
    let match2;
    while ((match2 = regex.exec(sourceFile.text)) !== null) {
      const nextLineCaptureGroup = match2[1];
      const rulesCaptureGroup = match2[2];
      if (rulesCaptureGroup) {
        const trimmedRuleString = rulesCaptureGroup.trim();
        if (trimmedRuleString) {
          const individualRules = trimmedRuleString.split(/\s+/);
          for (const rulePair of individualRules) {
            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(":");
            const ruleName = rawRuleName.startsWith("effect/") ? rawRuleName.substring("effect/".length) : rawRuleName;
            if (ruleName && ruleLevel) {
              if (ruleLevel === "skip-file") skippedRules.push(ruleName);
              const isOverrideNextLine = nextLineCaptureGroup && nextLineCaptureGroup.trim().toLowerCase() === "-next-line";
              if (isOverrideNextLine) {
                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match2.index);
                if (foundNode) {
                  lineOverrides[ruleName] = lineOverrides[ruleName] || [];
                  lineOverrides[ruleName].unshift({
                    pos: foundNode.node.pos,
                    end: foundNode.node.end,
                    level: ruleLevel,
                    commentRange: foundNode.commentRange
                  });
                }
              } else {
                sectionOverrides[ruleName] = sectionOverrides[ruleName] || [];
                sectionOverrides[ruleName].unshift({
                  pos: match2.index,
                  level: ruleLevel
                });
              }
            }
          }
        }
      }
    }
    const levelToDiagnosticCategory = {
      error: ts.DiagnosticCategory.Error,
      warning: ts.DiagnosticCategory.Warning,
      message: ts.DiagnosticCategory.Message,
      suggestion: ts.DiagnosticCategory.Suggestion
    };
    const execute = (rule) => gen(function* () {
      const diagnostics2 = [];
      const codeFixes = [];
      const ruleNameLowered = rule.name.toLowerCase();
      const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity;
      if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics: diagnostics2, codeFixes };
      if (defaultLevel === "off" && (lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0) {
        return { diagnostics: diagnostics2, codeFixes };
      }
      const fixByDisableNextLine = (node) => ({
        fixName: rule.name + "_skipNextLine",
        description: "Disable " + rule.name + " for this line",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => gen(function* () {
            const disableAtNode = findParentStatementForDisableNextLine(node);
            const start = ts.getTokenPosOfNode(disableAtNode, sourceFile);
            const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start);
            changeTracker.insertCommentBeforeLine(
              sourceFile,
              line,
              start,
              ` @effect-diagnostics-next-line ${rule.name}:off`
            );
          })
        )
      });
      const fixByDisableEntireFile = {
        fixName: rule.name + "_skipFile",
        description: "Disable " + rule.name + " for this entire file",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => sync(
            () => changeTracker.insertText(
              sourceFile,
              0,
              `/** @effect-diagnostics ${rule.name}:skip-file */
`
            )
          )
        )
      };
      const applicableDiagnostics = [];
      yield* rule.apply(sourceFile, (entry) => {
        const range = "kind" in entry.location ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end } : entry.location;
        const node = "kind" in entry.location ? entry.location : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos);
        applicableDiagnostics.push({
          range,
          messageText: pluginOptions.diagnosticsName ? `${entry.messageText}    effect(${rule.name})` : entry.messageText,
          fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])
        });
      });
      const unusedLineOverrides = new Set(lineOverrides[ruleNameLowered] || []);
      for (const emitted of applicableDiagnostics.slice(0)) {
        let newLevel = defaultLevel;
        const lineOverride = (lineOverrides[ruleNameLowered] || []).find(
          (_) => _.pos < emitted.range.pos && _.end >= emitted.range.end
        );
        if (lineOverride) {
          newLevel = lineOverride.level;
          unusedLineOverrides.delete(lineOverride);
        } else {
          const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos);
          if (sectionOverride) newLevel = sectionOverride.level;
        }
        if (!(newLevel in levelToDiagnosticCategory)) continue;
        diagnostics2.push({
          file: sourceFile,
          start: emitted.range.pos,
          length: emitted.range.end - emitted.range.pos,
          messageText: emitted.messageText,
          category: levelToDiagnosticCategory[newLevel],
          code: rule.code,
          source: "effect"
        });
        for (const fix of emitted.fixes) {
          codeFixes.push({
            ...fix,
            code: rule.code,
            start: emitted.range.pos,
            end: emitted.range.end
          });
        }
      }
      if (pluginOptions.missingDiagnosticNextLine !== "off" && unusedLineOverrides.size > 0) {
        for (const unusedLineOverride of unusedLineOverrides) {
          diagnostics2.push({
            file: sourceFile,
            start: unusedLineOverride.commentRange.pos,
            length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,
            messageText: `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,
            category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],
            code: -1,
            source: "effect"
          });
        }
      }
      return { diagnostics: diagnostics2, codeFixes };
    });
    return { execute };
  }
);
var cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (h2 >>> 0).toString(16).padStart(8, "0") + (h1 >>> 0).toString(16).padStart(8, "0");
};
var CodegenNotApplicableError = class {
  constructor(cause) {
    this.cause = cause;
  }
  _tag = "@effect/language-service/CodegenNotApplicableError";
};
function createCodegen(definition) {
  return definition;
}
var getCodegensForSourceFile = fn("LSP.getApplicableCodegens")(function* (codegens2, sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const result = [];
  const regex = /@effect-codegens((?:\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid;
  let match2;
  while ((match2 = regex.exec(sourceFile.text)) !== null) {
    const pos = match2.indices?.[0]?.[0];
    if (!pos) continue;
    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos);
    if (!commentRange) continue;
    const commentText = sourceFile.text.slice(pos, commentRange.end);
    const codegenRegex = /(\s+)(\w+)(?::(\w+))?/gmi;
    let codegenMatch;
    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {
      const whitespace = codegenMatch[1] || "";
      const codegenName = codegenMatch[2] || "";
      const codegenHash = codegenMatch[3] || "";
      const range = {
        pos: codegenMatch.index + pos + whitespace.length,
        end: codegenMatch.index + pos + codegenMatch[0].length
      };
      const codegen = codegens2.find((codegen2) => codegen2.name === codegenName);
      if (!codegen) continue;
      result.push({ codegen, hash: codegenHash, range });
    }
  }
  return result;
});
var getEditsForCodegen = fn("LSP.getEditsForCodegen")(function* (codegens2, sourceFile, textRange) {
  const applicableCodegens = yield* getCodegensForSourceFile(codegens2, sourceFile);
  const inRangeCodegens = applicableCodegens.filter(
    (codegen2) => codegen2.range.pos <= textRange.pos && codegen2.range.end >= textRange.end
  );
  if (inRangeCodegens.length !== 1) {
    return yield* fail(new CodegenNotApplicableError("zero or multiple codegens in range"));
  }
  const { codegen, range } = inRangeCodegens[0];
  const edit = yield* codegen.apply(sourceFile, range);
  const updateHashComment = pipe(
    service(ChangeTracker),
    map4((changeTracker) => {
      changeTracker.deleteRange(sourceFile, range);
      changeTracker.insertText(
        sourceFile,
        range.pos,
        edit.hash.length > 0 ? `${codegen.name}:${edit.hash}` : codegen.name
      );
    })
  );
  return {
    ...edit,
    apply: pipe(
      edit.apply,
      flatMap2(() => updateHashComment)
    ),
    ignore: updateHashComment
  };
});
var getEffectLspPatchSourceFileMetadata = (sourceFile) => {
  return sourceFile["@effect-lsp-patch/metadata"];
};

// src/core/TypeCheckerApi.ts
var TypeCheckerApi = Tag("TypeChecker");
function makeResolveExternalModuleName(typeChecker) {
  if (!(hasProperty(typeChecker, "resolveExternalModuleName") && isFunction(typeChecker.resolveExternalModuleName))) {
    return;
  }
  const _internal = typeChecker.resolveExternalModuleName;
  return (moduleSpecifier) => {
    return _internal(moduleSpecifier);
  };
}

// src/core/TypeCheckerUtils.ts
var TypeCheckerUtils = Tag("TypeCheckerUtils");
var nanoLayer2 = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2(
    (ts) => flatMap2(service(TypeCheckerApi), (typeChecker) => flatMap2(service(TypeScriptUtils), (typeScriptUtils) => pipe(fa, provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))
  )
);
function makeTypeCheckerUtils(ts, typeChecker, tsUtils) {
  const readonlyArraySymbol = typeChecker.resolveName("ReadonlyArray", void 0, ts.SymbolFlags.Type, false);
  const globalReadonlyArrayType = readonlyArraySymbol ? typeChecker.getDeclaredTypeOfSymbol(readonlyArraySymbol) : void 0;
  const errorSymbol = typeChecker.resolveName("Error", void 0, ts.SymbolFlags.Type, false);
  const globalErrorType = errorSymbol ? typeChecker.getDeclaredTypeOfSymbol(errorSymbol) : void 0;
  function isUnion(type) {
    return !!(type.flags & ts.TypeFlags.Union);
  }
  function isIndexType(type) {
    return !!(type.flags & ts.TypeFlags.Index);
  }
  function isThisTypeParameter(type) {
    return !!(type.flags & ts.TypeFlags.TypeParameter && type.isThisType);
  }
  function isReadonlyArrayType(type) {
    return type && "target" in type && type.target === globalReadonlyArrayType;
  }
  function isMissingIntrinsicType(type) {
    return (type.flags & ts.TypeFlags.Undefined) !== 0 && "debugIntrinsicName" in type && type.debugIntrinsicName === "missing";
  }
  function getTypeParameterAtPosition(signature, pos) {
    const type = typeChecker.getParameterType(signature, pos);
    if (isIndexType(type) && isThisTypeParameter(type.type)) {
      const constraint = typeChecker.getBaseConstraintOfType(type.type);
      if (constraint) {
        return typeChecker.getIndexType(constraint);
      }
    }
    return type;
  }
  const unrollUnionMembers = (type) => {
    const result = [];
    let toTest = [type];
    while (toTest.length > 0) {
      const type2 = toTest.pop();
      if (isUnion(type2)) {
        toTest = toTest.concat(type2.types);
      } else {
        result.push(type2);
      }
    }
    return result;
  };
  const getMissingTypeEntriesInTargetType = function(realType, expectedType) {
    if (realType === expectedType) return [];
    const result = [];
    let toTest = [realType];
    while (toTest.length > 0) {
      const type = toTest.pop();
      if (!type) return result;
      if (isUnion(type)) {
        toTest = toTest.concat(type.types);
      } else {
        const assignable = typeChecker.isTypeAssignableTo(type, expectedType);
        if (!assignable) {
          result.push(type);
        }
      }
    }
    return result;
  };
  const appendToUniqueTypesMap = fn(
    "TypeCheckerUtils.appendToUniqueTypesMap"
  )(
    function* (memory, initialType, shouldExclude) {
      const newIndexes = /* @__PURE__ */ new Set();
      const knownIndexes = /* @__PURE__ */ new Set();
      let toTest = [initialType];
      while (toTest.length > 0) {
        const type = toTest.pop();
        if (!type) break;
        if (yield* shouldExclude(type)) {
          continue;
        }
        if (isUnion(type)) {
          toTest = toTest.concat(type.types);
        } else {
          const foundMatch = [];
          for (const [typeId, knownType] of memory.entries()) {
            const areSame = typeChecker.isTypeAssignableTo(knownType, type) && typeChecker.isTypeAssignableTo(type, knownType);
            if (areSame) {
              foundMatch.push(typeId);
              break;
            }
          }
          if (foundMatch.length === 0) {
            const newId = "t" + (memory.size + 1);
            memory.set(newId, type);
            newIndexes.add(newId);
          } else {
            knownIndexes.add(foundMatch[0]);
          }
        }
      }
      return {
        newIndexes,
        knownIndexes,
        allIndexes: pipe(
          fromIterable(newIndexes),
          appendAll(fromIterable(knownIndexes))
        )
      };
    }
  );
  const deterministicTypeOrder = make((a, b) => {
    const aName = typeChecker.typeToString(a);
    const bName = typeChecker.typeToString(b);
    if (aName < bName) return -1;
    if (aName > bName) return 1;
    return 0;
  });
  const getAncestorConvertibleDeclaration = (node) => {
    let current = node;
    while (current) {
      if (ts.isFunctionDeclaration(current) || ts.isFunctionExpression(current) || ts.isArrowFunction(current) || ts.isMethodDeclaration(current)) {
        return current;
      }
      current = current.parent;
    }
  };
  const getInferredReturnType = (declaration) => {
    if (!declaration.body) {
      return;
    }
    let returnType;
    if (typeChecker.isImplementationOfOverload(declaration)) {
      const signatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(declaration),
        ts.SignatureKind.Call
      );
      if (signatures.length > 1) {
        returnType = typeChecker.getUnionType(
          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)
        );
      }
    }
    if (!returnType) {
      const signature = typeChecker.getSignatureFromDeclaration(declaration);
      if (signature) {
        const typePredicate = typeChecker.getTypePredicateOfSignature(signature);
        if (typePredicate && typePredicate.type) {
          return typePredicate.type;
        } else {
          returnType = typeChecker.getReturnTypeOfSignature(signature);
        }
      }
    }
    return returnType;
  };
  const expectedAndRealTypeCache = /* @__PURE__ */ new WeakMap();
  const expectedAndRealType = (sourceFile) => {
    const cached2 = expectedAndRealTypeCache.get(sourceFile);
    if (cached2) return cached2;
    const result = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isVariableDeclaration(node) && node.initializer) {
        const expectedType = typeChecker.getTypeAtLocation(node.name);
        const realType = typeChecker.getTypeAtLocation(node.initializer);
        result.push([node.name, expectedType, node.initializer, realType]);
        appendNodeToVisit(node.initializer);
        continue;
      } else if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          resolvedSignature.parameters.map((parameter, index) => {
            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node);
            const realType = typeChecker.getTypeAtLocation(node.arguments[index]);
            result.push([
              node.arguments[index],
              expectedType,
              node.arguments[index],
              realType
            ]);
          });
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {
        const parent = node.parent;
        if (ts.isObjectLiteralElement(parent)) {
          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
            const type = typeChecker.getContextualType(parent.parent);
            if (type) {
              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : void 0;
              if (name) {
                const symbol3 = typeChecker.getPropertyOfType(type, name);
                if (symbol3) {
                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol3, node);
                  const realType = typeChecker.getTypeAtLocation(node);
                  result.push([node, expectedType, node, realType]);
                }
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const expectedType = typeChecker.getTypeAtLocation(node.left);
        const realType = typeChecker.getTypeAtLocation(node.right);
        result.push([node.left, expectedType, node.right, realType]);
        appendNodeToVisit(node.right);
        continue;
      } else if (ts.isReturnStatement(node) && node.expression) {
        const parentDeclaration = getAncestorConvertibleDeclaration(node);
        if (parentDeclaration) {
          const expectedType = getInferredReturnType(parentDeclaration);
          const realType = typeChecker.getTypeAtLocation(node.expression);
          if (expectedType) {
            result.push([node, expectedType, node, realType]);
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = typeChecker.getContextualType(body);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = getInferredReturnType(node);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isSatisfiesExpression(node)) {
        const expectedType = typeChecker.getTypeAtLocation(node.type);
        const realType = typeChecker.getTypeAtLocation(node.expression);
        result.push([node.expression, expectedType, node.expression, realType]);
        appendNodeToVisit(node.expression);
        continue;
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
    expectedAndRealTypeCache.set(sourceFile, result);
    return result;
  };
  function typeToSimplifiedTypeNode(type, enclosingNode, flags) {
    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0);
  }
  function isGlobalErrorType(type) {
    if (!globalErrorType) return false;
    return typeChecker.isTypeAssignableTo(type, globalErrorType) && typeChecker.isTypeAssignableTo(globalErrorType, type);
  }
  function typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, depth) {
    const fallbackStandard = () => {
      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags);
      if (!typeNode) return void 0;
      return tsUtils.simplifyTypeNode(typeNode);
    };
    if (depth > 20) return fallbackStandard();
    const members = unrollUnionMembers(type);
    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {
      const typeNodes = [];
      members.sort(deterministicTypeOrder);
      for (const member of members) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      const intersectionType = type;
      const typeNodes = [];
      for (const member of intersectionType.types) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Object && type.objectFlags & ts.ObjectFlags.Reference) {
      const typeReference = type;
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isTypeReferenceNode(standard2)) return standard2;
      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard2;
      if (standard2.typeArguments?.length !== typeReference.typeArguments?.length) return standard2;
      const typeParametersCount = (typeReference.target.typeParameters || []).length;
      for (let i = typeParametersCount - 1; i >= 0; i--) {
        const typeParameter = typeReference.target.typeParameters[i];
        const typeArgument = typeReference.typeArguments[i];
        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter);
        if (defaultType !== typeArgument || i === 0) {
          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(
            standard2,
            standard2.typeName,
            ts.factory.createNodeArray((standard2.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))
          ));
        }
      }
      return standard2;
    }
    if (type.flags & ts.TypeFlags.Object) {
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isFunctionTypeNode(standard2)) return standard2;
      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
      if (signatures.length !== 1) return standard2;
      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
      if (!returnType) return standard2;
      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1);
      if (!returnTypeNode) return standard2;
      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(
        standard2,
        standard2.typeParameters,
        standard2.parameters,
        returnTypeNode
      ));
    }
    return fallbackStandard();
  }
  function getTypeAtLocation(node) {
    if (node.parent && ts.isJsxSelfClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxClosingElement(node.parent) && node.parent.tagName === node) return;
    if (node.parent && ts.isJsxAttribute(node.parent) && node.parent.name === node) return;
    if (ts.isExpression(node) || ts.isTypeNode(node)) {
      return typeChecker.getTypeAtLocation(node);
    }
  }
  return {
    isUnion,
    isReadonlyArrayType,
    isMissingIntrinsicType,
    getTypeParameterAtPosition,
    getMissingTypeEntriesInTargetType,
    unrollUnionMembers,
    appendToUniqueTypesMap,
    deterministicTypeOrder,
    getInferredReturnType,
    expectedAndRealType,
    typeToSimplifiedTypeNode,
    isGlobalErrorType,
    getTypeAtLocation
  };
}

// src/core/TypeParser.ts
var TypeParser = Tag("@effect/language-service/TypeParser");
var nanoLayer3 = (fa) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const program = yield* service(TypeScriptProgram);
  return yield* pipe(
    fa,
    provideService(TypeParser, make2(ts, tsUtils, typeChecker, typeCheckerUtils, program))
  );
});
var TypeParserIssue = class _TypeParserIssue {
  _tag = "@effect/language-service/TypeParserIssue";
  static issue = fail(new _TypeParserIssue());
};
function typeParserIssue(_message, _type, _node) {
  return TypeParserIssue.issue;
}
function make2(ts, tsUtils, typeChecker, typeCheckerUtils, program) {
  const getSourceFilePackageInfo = cachedBy(
    fn("TypeParser.getSourceFilePackageInfo")(function* (sourceFile) {
      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    }),
    `TypeParser.getSourceFilePackageInfo`,
    (sourceFile) => sourceFile
  );
  const getSourceFilesDeclaringSymbolModule = (packageName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolModule")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const sourceFile of symbol3.declarations) {
        if (!ts.isSourceFile(sourceFile)) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push(sourceFile);
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no source file declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,
    (symbol3) => symbol3
  );
  const isSymbolReferenceToPackageModule = (givenSymbol, packageName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolModule(packageName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_))
        )
      )
    );
  };
  const isNodeReferenceToPackageModule = (givenNode, packageName, isCorrectSourceFile) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolReferenceToPackageModule(symbol3, packageName, isCorrectSourceFile);
  };
  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (packageName, memberName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember")(function* (symbol3) {
      const result = [];
      if (!symbol3) return result;
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const declaration of symbol3.declarations) {
        const sourceFile = tsUtils.getSourceFileOfNode(declaration);
        if (!sourceFile) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (memberSymbol) {
          if (memberSymbol === symbol3) {
            result.push({ memberSymbol, moduleSymbol, sourceFile });
          } else if (memberSymbol.flags & ts.SymbolFlags.Alias) {
            const aliased = typeChecker.getAliasedSymbol(memberSymbol);
            if (aliased === symbol3) {
              result.push({ memberSymbol, moduleSymbol, sourceFile });
            }
          }
        }
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,
    (sym) => sym
  );
  const isSymbolExportOfPackageModule = (givenSymbol, packageName, memberName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))
        )
      )
    );
  };
  const isNodeReferenceToExportOfPackageModule = (givenNode, packageName, isCorrectSourceFile, memberName) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolExportOfPackageModule(symbol3, packageName, memberName, isCorrectSourceFile);
  };
  const findSymbolsMatchingPackageAndExportedName = (packageName, exportedSymbolName) => cachedBy(
    fn("TypeParser.findSymbolsMatchingPackageAndExportedName")(function* () {
      const result = [];
      for (const sourceFile of program.getSourceFiles()) {
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const symbol3 = typeChecker.tryGetMemberInModuleExports(exportedSymbolName, moduleSymbol);
        if (!symbol3) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push([symbol3, sourceFile]);
      }
      return result;
    }),
    `TypeParser.findSymbolsMatchingPackageAndExportedName(${packageName}, ${exportedSymbolName})`,
    () => program
  );
  const isCauseTypeSourceFile = cachedBy(
    fn("TypeParser.isCauseTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const causeTypeSymbol = typeChecker.tryGetMemberInModuleExports("Cause", moduleSymbol);
      if (!causeTypeSymbol) return yield* typeParserIssue("Cause type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(causeTypeSymbol);
      yield* pipeableType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isCauseTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const extendsCauseYieldableError = cachedBy(
    fn("TypeParser.extendsCauseYieldableError")(function* (givenType) {
      if (givenType.flags & ts.TypeFlags.Never) {
        return yield* typeParserIssue("Type is never", givenType);
      }
      if (givenType.flags & ts.TypeFlags.Any) {
        return yield* typeParserIssue("Type is any", givenType);
      }
      const symbols = yield* findSymbolsMatchingPackageAndExportedName("effect", "YieldableError")();
      for (const [symbol3, sourceFile] of symbols) {
        const causeFile = yield* pipe(isCauseTypeSourceFile(sourceFile), orElse2(() => void_));
        if (!causeFile) continue;
        const type = typeChecker.getDeclaredTypeOfSymbol(symbol3);
        if (!type) continue;
        if (typeChecker.isTypeAssignableTo(givenType, type)) {
          return type;
        }
      }
      return yield* typeParserIssue("Type does not extend Cause.YieldableError", givenType);
    }),
    "TypeParser.extendsCauseYieldableError",
    (type) => type
  );
  function covariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Covariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  function contravariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Contravariant type has no call signature", type);
    }
    return succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0));
  }
  function invariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Invariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  const pipeableType = cachedBy(
    function(type, atLocation) {
      const pipeSymbol = typeChecker.getPropertyOfType(type, "pipe");
      if (!pipeSymbol) {
        return typeParserIssue("Type has no 'pipe' property", type, atLocation);
      }
      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation);
      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call);
      if (signatures.length === 0) {
        return typeParserIssue("'pipe' property is not callable", type, atLocation);
      }
      return succeed(type);
    },
    "TypeParser.pipeableType",
    (type) => type
  );
  const varianceStructCovariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return covariantTypeArgument(propertyType);
  };
  const varianceStructContravariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return contravariantTypeArgument(propertyType);
  };
  const varianceStructInvariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return invariantTypeArgument(propertyType);
  };
  const effectVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructCovariantType(type, atLocation, "_A"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, E, R]) => ({ A, E, R })
  );
  const layerVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructContravariantType(type, atLocation, "_ROut"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_RIn")
    ),
    ([ROut, E, RIn]) => ({ ROut, E, RIn })
  );
  const effectType = cachedBy(
    fn("TypeParser.effectType")(function* (type, atLocation) {
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no effect variance struct", type, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("EffectTypeId") - ts.symbolName(a).indexOf("EffectTypeId")
      );
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectType",
    (type) => type
  );
  const strictEffectType = cachedBy(
    fn("TypeParser.strictEffectType")(function* (type, atLocation) {
      if (!(type.symbol && ts.symbolName(type.symbol) === "Effect" && !type.aliasSymbol)) {
        return yield* typeParserIssue("Type name should be Effect with no alias symbol", type, atLocation);
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.strictEffectType",
    (type) => type
  );
  const isEffectTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports("Effect", moduleSymbol);
      if (!effectTypeSymbol) return yield* typeParserIssue("Effect type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol);
      yield* effectType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,
    (node) => node
  );
  const layerType = cachedBy(
    fn("TypeParser.layerType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no layer variance struct", type, atLocation);
      }
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("LayerTypeId") - ts.symbolName(a).indexOf("LayerTypeId")
      );
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return layerVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.layerType",
    (type) => type
  );
  const fiberType = cachedBy(
    fn("TypeParser.fiberType")(function* (type, atLocation) {
      const awaitSymbol = typeChecker.getPropertyOfType(type, "await");
      const pollSymbol = typeChecker.getPropertyOfType(type, "poll");
      if (!awaitSymbol || !pollSymbol) {
        return yield* typeParserIssue(
          "Type is not a fiber because it does not have 'await' or 'poll' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.fiberType",
    (type) => type
  );
  const effectSubtype = cachedBy(
    fn("TypeParser.effectSubtype")(function* (type, atLocation) {
      const tagSymbol = typeChecker.getPropertyOfType(type, "_tag");
      const getSymbol = typeChecker.getPropertyOfType(type, "get");
      if (!(tagSymbol || getSymbol)) {
        return yield* typeParserIssue(
          "Type is not a subtype of effect because it does not have '_tag' or 'get' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.effectSubtype",
    (type) => type
  );
  const isEffectContextSourceFile = cachedBy(
    fn("TypeParser.isEffectContextSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const contextSymbol = typeChecker.tryGetMemberInModuleExports("Context", moduleSymbol);
      if (!contextSymbol) return yield* typeParserIssue("Context not found", void 0, sourceFile);
      const tagSymbol = typeChecker.tryGetMemberInModuleExports("Tag", moduleSymbol);
      if (!tagSymbol) return yield* typeParserIssue("Tag not found", void 0, sourceFile);
      const tagType = typeChecker.getDeclaredTypeOfSymbol(tagSymbol);
      yield* contextTag(tagType, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectContextSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectContextModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectContextModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectContextSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectContextModuleApi(${memberName})`,
    (node) => node
  );
  const importedContextModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectContextSourceFile),
      map4(() => node)
    ),
    "TypeParser.importedContextModule",
    (node) => node
  );
  const importedEffectModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectTypeSourceFile),
      map4(() => node)
    ),
    "TypeParser.importedEffectModule",
    (node) => node
  );
  const isEffectDataSourceFile = cachedBy(
    fn("TypeParser.isEffectDataSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const taggedEnumSymbol = typeChecker.tryGetMemberInModuleExports("TaggedEnum", moduleSymbol);
      if (!taggedEnumSymbol) return yield* typeParserIssue("TaggedEnum not found", void 0, sourceFile);
      const taggedErrorSymbol = typeChecker.tryGetMemberInModuleExports("TaggedError", moduleSymbol);
      if (!taggedErrorSymbol) return yield* typeParserIssue("TaggedError not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectDataSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectDataModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectDataModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectDataSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectDataModuleApi(${memberName})`,
    (node) => node
  );
  const importedDataModule = cachedBy(
    (node) => pipe(
      isNodeReferenceToPackageModule(node, "effect", isEffectDataSourceFile),
      map4(() => node)
    ),
    "TypeParser.importedDataModule",
    (node) => node
  );
  const effectGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue("Node is not a generator function", void 0, node);
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("gen")(propertyAccess),
        map4(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectGen",
    (node) => node
  );
  const effectFnUntracedGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = node.expression;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fnUntraced")(propertyAccess),
        map4(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2
        }))
      );
    },
    "TypeParser.effectFnUntracedGen",
    (node) => node
  );
  const effectFnGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue(
          "Node is not a function expression",
          void 0,
          node
        );
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map4(() => ({
          node,
          generatorFunction,
          effectModule: propertyAccess.expression,
          body: generatorFunction.body,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFnGen",
    (node) => node
  );
  const findEnclosingScopes = fn("TypeParser.findEnclosingScopes")(function* (startNode) {
    let currentParent = startNode.parent;
    let scopeNode = void 0;
    let effectGenResult = void 0;
    while (currentParent) {
      const nodeToCheck = currentParent;
      if (!scopeNode) {
        if (ts.isFunctionExpression(nodeToCheck) || ts.isFunctionDeclaration(nodeToCheck) || ts.isMethodDeclaration(nodeToCheck) || ts.isArrowFunction(nodeToCheck) || ts.isGetAccessorDeclaration(nodeToCheck) || ts.isSetAccessorDeclaration(nodeToCheck)) {
          scopeNode = nodeToCheck;
        }
      }
      if (!effectGenResult) {
        const isEffectGen = yield* pipe(
          effectGen(nodeToCheck),
          map4((result) => ({
            node: result.node,
            effectModule: result.effectModule,
            generatorFunction: result.generatorFunction,
            body: result.body
          })),
          orElse2(
            () => pipe(
              effectFnUntracedGen(nodeToCheck),
              map4((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          orElse2(
            () => pipe(
              effectFnGen(nodeToCheck),
              map4((result) => ({
                node: result.node,
                effectModule: result.effectModule,
                generatorFunction: result.generatorFunction,
                body: result.body,
                pipeArguments: result.pipeArguments
              }))
            )
          ),
          option
        );
        if (isSome2(isEffectGen)) {
          effectGenResult = isEffectGen.value;
        }
      }
      if (scopeNode && effectGenResult) {
        break;
      }
      currentParent = nodeToCheck.parent;
    }
    return { scopeNode, effectGen: effectGenResult };
  });
  const effectFn = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const regularFunction = node.arguments[0];
      if (!ts.isFunctionExpression(regularFunction) && !ts.isArrowFunction(regularFunction)) {
        return typeParserIssue("Node is not a function expression or arrow function", void 0, node);
      }
      if (ts.isFunctionExpression(regularFunction) && regularFunction.asteriskToken !== void 0) {
        return typeParserIssue("Node is a generator function, not a regular function", void 0, node);
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const traceExpression = ts.isCallExpression(node.expression) && node.expression.arguments.length > 0 ? node.expression.arguments[0] : void 0;
      const propertyAccess = expressionToTest;
      const pipeArguments2 = node.arguments.slice(1);
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map4(() => ({
          node,
          effectModule: propertyAccess.expression,
          regularFunction,
          pipeArguments: pipeArguments2,
          traceExpression
        }))
      );
    },
    "TypeParser.effectFn",
    (node) => node
  );
  const unnecessaryEffectGen2 = cachedBy(
    fn("TypeParser.unnecessaryEffectGen")(function* (node) {
      const { body } = yield* effectGen(node);
      if (body.statements.length !== 1) {
        return yield* typeParserIssue(
          "Generator body should have a single statement",
          void 0,
          node
        );
      }
      let explicitReturn = false;
      let nodeToCheck = body.statements[0];
      while (nodeToCheck) {
        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {
          nodeToCheck = nodeToCheck.expression;
          explicitReturn = true;
          continue;
        }
        if (ts.isExpressionStatement(nodeToCheck)) {
          nodeToCheck = nodeToCheck.expression;
          continue;
        }
        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {
          const yieldedExpression = nodeToCheck.expression;
          const type = typeCheckerUtils.getTypeAtLocation(yieldedExpression);
          if (!type) continue;
          const { A: successType } = yield* effectType(type, yieldedExpression);
          let replacementNode = succeed(yieldedExpression);
          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {
            replacementNode = pipe(
              gen(function* () {
                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
                  node.getSourceFile(),
                  "effect",
                  "Effect"
                ) || "Effect";
                return ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(effectIdentifier),
                    "asVoid"
                  ),
                  void 0,
                  [
                    yieldedExpression
                  ]
                );
              }),
              provideService(TypeScriptApi, ts)
            );
          }
          return { node, body, yieldedExpression, replacementNode };
        }
        break;
      }
      return yield* typeParserIssue(
        "Not an handled node",
        void 0,
        node
      );
    }),
    "TypeParser.unnecessaryEffectGen",
    (node) => node
  );
  const effectSchemaVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructInvariantType(type, atLocation, "_A"),
      varianceStructInvariantType(type, atLocation, "_I"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, I, R]) => ({ A, I, R })
  );
  const effectSchemaType = cachedBy(
    fn("TypeParser.effectSchemaType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const ast = typeChecker.getPropertyOfType(type, "ast");
      if (!ast) return yield* typeParserIssue("Has no 'ast' property", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no schema variance struct", type, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return effectSchemaVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.effectSchemaType",
    (type) => type
  );
  const isEffectSchemaTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSchemaTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const typeSymbol = typeChecker.tryGetMemberInModuleExports("Schema", moduleSymbol);
      if (!typeSymbol) return yield* typeParserIssue("Schema type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol);
      yield* effectSchemaType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectSchemaTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSchemaModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSchemaModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectSchemaTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,
    (node) => node
  );
  const isEffectParseResultSourceFile = cachedBy(
    fn("TypeParser.isEffectParseResultSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const parseIssueSymbol = typeChecker.tryGetMemberInModuleExports("ParseIssue", moduleSymbol);
      if (!parseIssueSymbol) return yield* typeParserIssue("ParseIssue type not found", void 0, sourceFile);
      const decodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("decodeSync", moduleSymbol);
      if (!decodeSyncSymbol) return yield* typeParserIssue("decodeSync not found", void 0, sourceFile);
      const encodeSyncSymbol = typeChecker.tryGetMemberInModuleExports("encodeSync", moduleSymbol);
      if (!encodeSyncSymbol) return yield* typeParserIssue("encodeSync not found", void 0, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectParseResultSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectParseResultModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectParseResultModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectParseResultSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectParseResultModuleApi(${memberName})`,
    (node) => node
  );
  const contextTagVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructInvariantType(type, atLocation, "_Identifier"),
      varianceStructInvariantType(type, atLocation, "_Service")
    ),
    ([Identifier, Service]) => ({ Identifier, Service })
  );
  const contextTag = cachedBy(
    fn("TypeParser.contextTag")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.length === 0) {
        return yield* typeParserIssue("Type has no tag variance struct", type, atLocation);
      }
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      return yield* firstSuccessOf(propertiesSymbols.map((propertySymbol) => {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        return contextTagVarianceStruct(propertyType, atLocation);
      }));
    }),
    "TypeParser.contextTag",
    (type) => type
  );
  const effectFunctionImportedName = cachedBy(
    fn("TypeParser.effectFunctionImportedName")(function* (sourceFile) {
      return tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Function");
    }),
    "TypeParser.effectFunctionImportedName",
    (node) => node
  );
  const pipeCall = cachedBy(
    function(node) {
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "pipe") {
        const baseExpression = node.expression.expression;
        return pipe(
          effectFunctionImportedName(tsUtils.getSourceFileOfNode(node)),
          flatMap2((functionIdentifier) => {
            if (functionIdentifier && ts.isIdentifier(baseExpression) && ts.idText(baseExpression) === functionIdentifier) {
              if (node.arguments.length === 0) {
                return typeParserIssue("Node is not a pipe call", void 0, node);
              }
              const [subject, ...args2] = node.arguments;
              return succeed({
                node,
                subject,
                args: args2,
                kind: "pipe"
              });
            }
            return succeed({
              node,
              subject: baseExpression,
              args: Array.from(node.arguments),
              kind: "pipeable"
            });
          })
        );
      }
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === "pipe" && node.arguments.length > 0) {
        const [subject, ...args2] = node.arguments;
        return succeed({ node, subject, args: args2, kind: "pipe" });
      }
      return typeParserIssue("Node is not a pipe call", void 0, node);
    },
    "TypeParser.pipeCall",
    (node) => node
  );
  const singleArgCall = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length !== 1) {
        return typeParserIssue("Node must have exactly one argument", void 0, node);
      }
      return succeed({
        node,
        callee: node.expression,
        subject: node.arguments[0]
      });
    },
    "TypeParser.singleArgCall",
    (node) => node
  );
  const scopeType = cachedBy(
    fn("TypeParser.scopeType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration
      );
      if (propertiesSymbols.some((s) => ts.symbolName(s).indexOf("ScopeTypeId") !== -1)) {
        return type;
      }
      return yield* typeParserIssue("Type has no scope type id", type, atLocation);
    }),
    "TypeParser.scopeType",
    (type) => type
  );
  const promiseLike = cachedBy(
    function(type, atLocation) {
      const thenProperty = type.getProperty("then");
      if (!thenProperty) return typeParserIssue("not a promise - missing then property", type, atLocation);
      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation);
      if (!thenType) return typeParserIssue("not a promise - missing then property", type, atLocation);
      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {
        const parameter = callSignature.parameters[0];
        if (!parameter) continue;
        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0);
        if (!parameterType) continue;
        let callbackCallSignatures = [];
        let toTest = [parameterType];
        while (toTest.length > 0) {
          const type2 = toTest.shift();
          if (!type2) continue;
          const callSignatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
          callbackCallSignatures = callbackCallSignatures.concat(callSignatures);
          if (typeCheckerUtils.isUnion(type2)) {
            toTest = toTest.concat(type2.types);
          }
        }
        for (const callableType of callbackCallSignatures) {
          const callbackParameter = callableType.parameters[0];
          if (!callbackParameter) {
            continue;
          }
          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0);
          if (!callbackParameterType) {
            continue;
          }
          return succeed({
            type: callbackParameterType
          });
        }
      }
      return typeParserIssue("not a promise", type, atLocation);
    },
    "TypeParser.promiseLike",
    (type) => type
  );
  const extendsSchemaClass = cachedBy(
    fn("TypeParser.extendsSchemaClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.Class", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedClass = cachedBy(
    fn("TypeParser.extendsSchemaTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {
              const schemaTaggedClassTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments && schemaTaggedClassTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(schemaTaggedClassTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedClassTCall.arguments[0]) ? schemaTaggedClassTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedError = cachedBy(
    fn("TypeParser.extendsSchemaTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedErrorTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments && schemaTaggedErrorTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedError")(schemaTaggedErrorTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0]) ? schemaTaggedErrorTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedError",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedRequest = cachedBy(
    fn("TypeParser.extendsSchemaTaggedRequest")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedRequestTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedRequestTCall) && schemaTaggedRequestTCall.typeArguments && schemaTaggedRequestTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(schemaTaggedRequestTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0,
                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0]) ? schemaTaggedRequestTCall.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedRequest", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedRequest",
    (atLocation) => atLocation
  );
  const extendsDataTaggedError = cachedBy(
    fn("TypeParser.extendsDataTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedErrorCall = expression;
              const dataIdentifier = dataTaggedErrorCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedError") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedErrorCall.arguments[0]) ? dataTaggedErrorCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedError",
    (atLocation) => atLocation
  );
  const extendsDataTaggedClass = cachedBy(
    fn("TypeParser.extendsDataTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedClassCall = expression;
              const dataIdentifier = dataTaggedClassCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedClass") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedClassCall.arguments[0]) ? dataTaggedClassCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedClass",
    (atLocation) => atLocation
  );
  const extendsContextTag = cachedBy(
    fn("TypeParser.extendsContextTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const contextTagCall = wholeCall.expression;
              if (ts.isCallExpression(contextTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const contextTagIdentifier = contextTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                if (ts.isPropertyAccessExpression(contextTagIdentifier) && ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === "Tag") {
                  const parsedContextModule = yield* pipe(
                    importedContextModule(contextTagIdentifier.expression),
                    option
                  );
                  if (isSome2(parsedContextModule)) {
                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                    if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                    const type = typeChecker.getTypeOfSymbol(classSym);
                    const tagType = yield* contextTag(type, atLocation);
                    return {
                      className: atLocation.name,
                      selfTypeNode,
                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0]) ? contextTagCall.arguments[0] : void 0,
                      args: contextTagCall.arguments,
                      Identifier: tagType.Identifier,
                      Tag: parsedContextModule.value
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Context.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsContextTag",
    (atLocation) => atLocation
  );
  const extendsEffectTag = cachedBy(
    fn("TypeParser.extendsEffectTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
      if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
      const type = typeChecker.getTypeOfSymbol(classSym);
      const tagType = yield* contextTag(type, atLocation);
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectTagCall = wholeCall.expression;
              if (ts.isCallExpression(effectTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const effectTagIdentifier = effectTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                const isEffectTag = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Tag")(effectTagIdentifier),
                  option
                );
                if (isSome2(isEffectTag)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0]) ? effectTagCall.arguments[0] : void 0,
                    args: effectTagCall.arguments,
                    Identifier: tagType.Identifier,
                    Service: tagType.Service
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsEffectTag",
    (atLocation) => atLocation
  );
  const extendsEffectService = cachedBy(
    fn("TypeParser.extendsEffectService")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectServiceCall = wholeCall.expression;
              if (ts.isCallExpression(effectServiceCall) && effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0) {
                const effectServiceIdentifier = effectServiceCall.expression;
                const selfTypeNode = effectServiceCall.typeArguments[0];
                const isEffectService = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Service")(effectServiceIdentifier),
                  option
                );
                if (isSome2(isEffectService)) {
                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                  if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                  const type = typeChecker.getTypeOfSymbol(classSym);
                  const parsedContextTag = yield* pipe(
                    contextTag(type, atLocation),
                    option
                  );
                  if (isSome2(parsedContextTag)) {
                    let accessors2 = void 0;
                    let dependencies = void 0;
                    if (wholeCall.arguments.length >= 2) {
                      const args2 = wholeCall.arguments[1];
                      if (ts.isObjectLiteralExpression(args2)) {
                        for (const property of args2.properties) {
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "accessors" && property.initializer && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                            accessors2 = true;
                          }
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "dependencies" && property.initializer && ts.isArrayLiteralExpression(property.initializer)) {
                            dependencies = property.initializer.elements;
                          }
                        }
                      }
                    }
                    return {
                      ...parsedContextTag.value,
                      className: atLocation.name,
                      selfTypeNode,
                      args: wholeCall.arguments,
                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0]) ? wholeCall.arguments[0] : void 0,
                      options: wholeCall.arguments[1],
                      accessors: accessors2,
                      dependencies
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Service", void 0, atLocation);
    }),
    "TypeParser.extendsEffectService",
    (atLocation) => atLocation
  );
  const isEffectSqlModelTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSqlModelTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const classSymbol = typeChecker.tryGetMemberInModuleExports("Class", moduleSymbol);
      if (!classSymbol) return yield* typeParserIssue("Model's Class type not found", void 0, sourceFile);
      const makeRepositorySymbol = typeChecker.tryGetMemberInModuleExports("makeRepository", moduleSymbol);
      if (!makeRepositorySymbol) {
        return yield* typeParserIssue("Model's makeRepository type not found", void 0, sourceFile);
      }
      const makeDataLoadersSymbol = typeChecker.tryGetMemberInModuleExports("makeDataLoaders", moduleSymbol);
      if (!makeDataLoadersSymbol) {
        return yield* typeParserIssue("Model's makeDataLoaders type not found", void 0, sourceFile);
      }
      return sourceFile;
    }),
    "TypeParser.isEffectSqlModelTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSqlModelModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSqlModelModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "@effect/sql",
        isEffectSqlModelTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectSqlModelModuleApi(${memberName})`,
    (node) => node
  );
  const extendsEffectSqlModelClass = cachedBy(
    fn("TypeParser.extendsEffectSqlModelClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSqlModelModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend @effect/sql's Model.Class", void 0, atLocation);
    }),
    "TypeParser.extendsEffectSqlModelClass",
    (atLocation) => atLocation
  );
  const isEffectLayerTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectLayerTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const layerTypeSymbol = typeChecker.tryGetMemberInModuleExports("Layer", moduleSymbol);
      if (!layerTypeSymbol) return yield* typeParserIssue("Layer type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(layerTypeSymbol);
      yield* layerType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectLayerTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectLayerModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectLayerModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(
        node,
        "effect",
        isEffectLayerTypeSourceFile,
        memberName
      );
    }),
    `TypeParser.isNodeReferenceToEffectLayerModuleApi(${memberName})`,
    (node) => node
  );
  const lazyExpression = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      if (node.parameters.length !== 0) {
        return typeParserIssue("Function must have zero parameters", void 0, node);
      }
      if (node.typeParameters && node.typeParameters.length > 0) {
        return typeParserIssue("Function must have no type parameters", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (ts.isArrowFunction(node) && !ts.isBlock(body)) {
        return succeed({
          node,
          body,
          expression: body,
          returnType
        });
      }
      if (ts.isBlock(body)) {
        if (body.statements.length !== 1) {
          return typeParserIssue("Block must have exactly one statement", void 0, node);
        }
        const stmt = body.statements[0];
        if (!ts.isReturnStatement(stmt)) {
          return typeParserIssue("Statement must be a return statement", void 0, node);
        }
        if (!stmt.expression) {
          return typeParserIssue("Return statement must have an expression", void 0, node);
        }
        return succeed({
          node,
          body,
          expression: stmt.expression,
          returnType
        });
      }
      return typeParserIssue("Invalid function body", void 0, node);
    },
    "TypeParser.lazyExpression",
    (node) => node
  );
  const emptyFunction = cachedBy(
    function(node) {
      if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return typeParserIssue("Node is not an arrow function or function expression", void 0, node);
      }
      const body = node.body;
      const returnType = node.type;
      if (!ts.isBlock(body)) {
        return typeParserIssue("Body must be a block", void 0, node);
      }
      if (body.statements.length !== 0) {
        return typeParserIssue("Block must have zero statements", void 0, node);
      }
      return succeed({
        node,
        body,
        returnType
      });
    },
    "TypeParser.emptyFunction",
    (node) => node
  );
  const pipingFlows = (includeEffectFn) => cachedBy(
    fn("TypeParser.pipingFlows")(function* (sourceFile) {
      const result = [];
      const workQueue = [[sourceFile, void 0]];
      while (workQueue.length > 0) {
        const [node, parentFlow] = workQueue.pop();
        if (ts.isCallExpression(node)) {
          const parsed = yield* pipe(
            pipeCall(node),
            map4((p) => ({ _tag: "pipe", ...p })),
            orElse2(
              () => pipe(
                singleArgCall(node),
                map4((s) => ({ _tag: "call", ...s }))
              )
            ),
            option
          );
          if (isSome2(parsed)) {
            const result2 = parsed.value;
            let transformations;
            let flowNode;
            let childrenToTraverse = [];
            if (result2._tag === "pipe") {
              const signature = typeChecker.getResolvedSignature(result2.node);
              const typeArguments = signature ? typeChecker.getTypeArgumentsForResolvedSignature(signature) : void 0;
              transformations = [];
              for (let i = 0; i < result2.args.length; i++) {
                const arg = result2.args[i];
                const outType = typeArguments?.[i + 1];
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    // e.g., Effect.map
                    args: Array.from(arg.arguments),
                    // e.g., [(x) => x + 1]
                    outType,
                    kind: result2.kind
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    // e.g., Effect.asVoid
                    args: void 0,
                    outType,
                    kind: result2.kind
                  });
                }
              }
              flowNode = result2.node;
              childrenToTraverse = result2.args;
            } else {
              const callSignature = typeChecker.getResolvedSignature(node);
              const outType = callSignature ? typeChecker.getReturnTypeOfSignature(callSignature) : void 0;
              transformations = [{
                callee: result2.callee,
                args: void 0,
                outType,
                kind: "call"
              }];
              flowNode = node;
            }
            if (parentFlow) {
              parentFlow.transformations.unshift(...transformations);
              parentFlow.subject = {
                node: result2.subject,
                outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
              };
              workQueue.push([result2.subject, parentFlow]);
            } else {
              const newFlow = {
                node: flowNode,
                subject: {
                  node: result2.subject,
                  outType: typeCheckerUtils.getTypeAtLocation(result2.subject)
                },
                transformations
              };
              workQueue.push([result2.subject, newFlow]);
            }
            for (const child of childrenToTraverse) {
              ts.forEachChild(child, (c) => {
                workQueue.push([c, void 0]);
              });
            }
            continue;
          }
          if (includeEffectFn) {
            const effectFnGenParsed = yield* pipe(effectFnGen(node), option);
            const effectFnUntracedGenParsed = isNone2(effectFnGenParsed) ? yield* pipe(effectFnUntracedGen(node), option) : none2();
            const effectFnNonGenParsed = isNone2(effectFnGenParsed) && isNone2(effectFnUntracedGenParsed) ? yield* pipe(effectFn(node), option) : none2();
            const isEffectFnGen = isSome2(effectFnGenParsed);
            const isEffectFnUntracedGen = isSome2(effectFnUntracedGenParsed);
            const isEffectFnNonGen = isSome2(effectFnNonGenParsed);
            const transformationKind = isEffectFnUntracedGen ? "effectFnUntraced" : "effectFn";
            if (isEffectFnGen || isEffectFnUntracedGen) {
              const effectFnParsed = isEffectFnGen ? effectFnGenParsed : effectFnUntracedGenParsed;
              if (isSome2(effectFnParsed) && effectFnParsed.value.pipeArguments.length > 0) {
                const fnResult = effectFnParsed.value;
                const pipeArgs = fnResult.pipeArguments;
                const transformations = [];
                let subjectType;
                for (let i = 0; i < pipeArgs.length; i++) {
                  const arg = pipeArgs[i];
                  const contextualType = typeChecker.getContextualType(arg);
                  const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                  const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                  if (i === 0 && callSigs.length > 0) {
                    const params = callSigs[0].parameters;
                    if (params.length > 0) {
                      subjectType = typeChecker.getTypeOfSymbol(params[0]);
                    }
                  }
                  if (ts.isCallExpression(arg)) {
                    transformations.push({
                      callee: arg.expression,
                      args: Array.from(arg.arguments),
                      outType,
                      kind: transformationKind
                    });
                  } else {
                    transformations.push({
                      callee: arg,
                      args: void 0,
                      outType,
                      kind: transformationKind
                    });
                  }
                }
                const newFlow = {
                  node,
                  subject: {
                    node,
                    outType: subjectType
                  },
                  transformations
                };
                result.push(newFlow);
                workQueue.push([fnResult.body, void 0]);
                for (const arg of pipeArgs) {
                  ts.forEachChild(arg, (c) => {
                    workQueue.push([c, void 0]);
                  });
                }
                continue;
              }
            }
            if (isEffectFnNonGen && isSome2(effectFnNonGenParsed) && effectFnNonGenParsed.value.pipeArguments.length > 0) {
              const fnResult = effectFnNonGenParsed.value;
              const pipeArgs = fnResult.pipeArguments;
              const transformations = [];
              let subjectType;
              for (let i = 0; i < pipeArgs.length; i++) {
                const arg = pipeArgs[i];
                const contextualType = typeChecker.getContextualType(arg);
                const callSigs = contextualType ? typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call) : [];
                const outType = callSigs.length > 0 ? typeChecker.getReturnTypeOfSignature(callSigs[0]) : void 0;
                if (i === 0 && callSigs.length > 0) {
                  const params = callSigs[0].parameters;
                  if (params.length > 0) {
                    subjectType = typeChecker.getTypeOfSymbol(params[0]);
                  }
                }
                if (ts.isCallExpression(arg)) {
                  transformations.push({
                    callee: arg.expression,
                    args: Array.from(arg.arguments),
                    outType,
                    kind: "effectFn"
                  });
                } else {
                  transformations.push({
                    callee: arg,
                    args: void 0,
                    outType,
                    kind: "effectFn"
                  });
                }
              }
              const newFlow = {
                node,
                subject: {
                  node,
                  outType: subjectType
                },
                transformations
              };
              result.push(newFlow);
              const regularFn = fnResult.regularFunction;
              if (ts.isArrowFunction(regularFn)) {
                if (ts.isBlock(regularFn.body)) {
                  workQueue.push([regularFn.body, void 0]);
                } else {
                  workQueue.push([regularFn.body, void 0]);
                }
              } else if (regularFn.body) {
                workQueue.push([regularFn.body, void 0]);
              }
              for (const arg of pipeArgs) {
                ts.forEachChild(arg, (c) => {
                  workQueue.push([c, void 0]);
                });
              }
              continue;
            }
          }
        }
        if (parentFlow && parentFlow.transformations.length > 0) {
          result.push(parentFlow);
        }
        ts.forEachChild(node, (child) => {
          workQueue.push([child, void 0]);
        });
      }
      result.sort((a, b) => a.node.pos - b.node.pos);
      return result;
    }),
    `TypeParser.pipingFlows(${includeEffectFn})`,
    (sourceFile) => sourceFile
  );
  const reconstructPipingFlow = (flow2) => {
    if (flow2.transformations.length > 0 && flow2.transformations.every((t) => t.kind === "effectFn" || t.kind === "effectFnUntraced")) {
      return flow2.subject.node;
    }
    let result = flow2.subject.node;
    for (const t of flow2.transformations) {
      if (t.kind === "call") {
        result = ts.factory.createCallExpression(
          t.callee,
          void 0,
          [result]
        );
      } else if (t.kind === "effectFn" || t.kind === "effectFnUntraced") {
        continue;
      } else {
        if (t.args) {
          const transformCall = ts.factory.createCallExpression(
            t.callee,
            void 0,
            t.args
          );
          result = ts.factory.createCallExpression(
            transformCall,
            void 0,
            [result]
          );
        } else {
          result = ts.factory.createCallExpression(
            t.callee,
            void 0,
            [result]
          );
        }
      }
    }
    return result;
  };
  return {
    isNodeReferenceToEffectModuleApi,
    isNodeReferenceToEffectSchemaModuleApi,
    isNodeReferenceToEffectParseResultModuleApi,
    isNodeReferenceToEffectDataModuleApi,
    isNodeReferenceToEffectContextModuleApi,
    isNodeReferenceToEffectSqlModelModuleApi,
    isNodeReferenceToEffectLayerModuleApi,
    effectType,
    strictEffectType,
    layerType,
    fiberType,
    effectSubtype,
    importedEffectModule,
    effectGen,
    effectFnUntracedGen,
    effectFnGen,
    findEnclosingScopes,
    effectFn,
    extendsCauseYieldableError,
    unnecessaryEffectGen: unnecessaryEffectGen2,
    effectSchemaType,
    contextTag,
    pipeableType,
    pipeCall,
    singleArgCall,
    scopeType,
    promiseLike,
    extendsEffectTag,
    extendsEffectService,
    extendsContextTag,
    extendsSchemaClass,
    extendsSchemaTaggedClass,
    extendsSchemaTaggedError,
    extendsDataTaggedError,
    extendsDataTaggedClass,
    extendsSchemaTaggedRequest,
    extendsEffectSqlModelClass,
    lazyExpression,
    emptyFunction,
    pipingFlows,
    reconstructPipingFlow
  };
}

// src/diagnostics/anyUnknownInErrorContext.ts
var anyUnknownInErrorContext = createDiagnostic({
  name: "anyUnknownInErrorContext",
  code: 28,
  description: "Detects 'any' or 'unknown' types in Effect error or requirements channels",
  severity: "off",
  apply: fn("anyUnknownInErrorContext.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const isAnyOrUnknown = (type) => (type.flags & ts.TypeFlags.Any) > 0 || (type.flags & ts.TypeFlags.Unknown) > 0;
    const matchingNodes = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.pop();
      if (ts.isTypeNode(node)) continue;
      if (ts.isTypeAliasDeclaration(node)) continue;
      if (ts.isInterfaceDeclaration(node)) continue;
      if (ts.isAsExpression(node) && node.type && node.type.kind === ts.SyntaxKind.AnyKeyword) {
        continue;
      }
      if (ts.isParameter(node) || ts.isPropertyDeclaration(node) || ts.isVariableDeclaration(node)) {
        if (node.type) {
          const typeNode = node.type;
          const type2 = typeCheckerUtils.getTypeAtLocation(node.type);
          if (!type2) continue;
          const expectedEffect = yield* pipe(
            typeParser.strictEffectType(type2, node.type),
            orElse2(() => typeParser.layerType(type2, typeNode)),
            orElse2(() => void_)
          );
          if (expectedEffect) continue;
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isExpression(node)) continue;
      let type = typeCheckerUtils.getTypeAtLocation(node);
      if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          type = typeChecker.getReturnTypeOfSignature(resolvedSignature);
        }
      }
      if (!type) continue;
      yield* pipe(
        typeParser.strictEffectType(type, node),
        orElse2(() => pipe(typeParser.layerType(type, node), map4(({ E, RIn }) => ({ E, R: RIn })))),
        map4((effectOrLayer) => {
          const { E, R } = effectOrLayer;
          const hasAnyUnknownR = isAnyOrUnknown(R);
          const hasAnyUnknownE = isAnyOrUnknown(E);
          if (hasAnyUnknownR || hasAnyUnknownE) {
            const channels = [];
            if (hasAnyUnknownR) {
              const typeName = R.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the requirements channel`);
            }
            if (hasAnyUnknownE) {
              const typeName = E.flags & ts.TypeFlags.Any ? "any" : "unknown";
              channels.push(`${typeName} in the error channel`);
            }
            const nodeStart = ts.getTokenPosOfNode(node, sourceFile);
            const nodeEnd = node.end;
            for (let i = matchingNodes.length - 1; i >= 0; i--) {
              const existing = matchingNodes[i];
              const existingStart = ts.getTokenPosOfNode(existing.node, sourceFile);
              const existingEnd = existing.node.end;
              if (existingStart <= nodeStart && existingEnd >= nodeEnd) {
                matchingNodes.splice(i, 1);
              }
            }
            const suggestions = [`This has ${channels.join(" and ")} which is not recommended.`];
            if (hasAnyUnknownR) {
              suggestions.push(`Only service identifiers should appear in the requirements channel.`);
            }
            if (hasAnyUnknownE) {
              suggestions.push(
                `Having an unknown or any error type is not useful. Consider instead using specific error types baked by Data.TaggedError for example.`
              );
            }
            channels.push(`If you plan to later on manually cast the type, you can safely disable this diagnostic.`);
            const messageText = suggestions.join("\n");
            matchingNodes.push({ messageText, node, type });
          }
        }),
        ignore
      );
    }
    for (const { messageText, node } of matchingNodes) {
      report({
        location: node,
        messageText,
        fixes: []
      });
    }
  })
});

// src/diagnostics/catchAllToMapError.ts
var catchAllToMapError = createDiagnostic({
  name: "catchAllToMapError",
  code: 39,
  description: "Suggests using Effect.mapError instead of Effect.catchAll when the callback only wraps the error with Effect.fail",
  severity: "suggestion",
  apply: fn("catchAllToMapError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const getFunctionBody = (node) => {
      if (ts.isArrowFunction(node)) {
        return node.body;
      }
      if (ts.isFunctionExpression(node)) {
        return node.body;
      }
      return void 0;
    };
    const getEffectFailCallInfo = (body) => {
      return gen(function* () {
        if (ts.isCallExpression(body)) {
          const isFailCall = yield* pipe(
            typeParser.isNodeReferenceToEffectModuleApi("fail")(body.expression),
            option
          );
          if (isSome2(isFailCall) && body.arguments.length >= 1) {
            return some2({ failCall: body, failArg: body.arguments[0] });
          }
        }
        if (ts.isBlock(body)) {
          const statements = body.statements;
          if (statements.length === 1) {
            const stmt = statements[0];
            if (ts.isReturnStatement(stmt) && stmt.expression && ts.isCallExpression(stmt.expression)) {
              const isFailCall = yield* pipe(
                typeParser.isNodeReferenceToEffectModuleApi("fail")(stmt.expression.expression),
                option
              );
              if (isSome2(isFailCall) && stmt.expression.arguments.length >= 1) {
                return some2({ failCall: stmt.expression, failArg: stmt.expression.arguments[0] });
              }
            }
          }
        }
        return none2();
      });
    };
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchAllCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("catchAll")(transformation.callee),
          option
        );
        if (isNone2(isCatchAllCall)) {
          continue;
        }
        const callback = transformation.args[0];
        if (!callback) continue;
        const functionBody = getFunctionBody(callback);
        if (!functionBody) continue;
        const failCallInfo = yield* getEffectFailCallInfo(functionBody);
        if (isNone2(failCallInfo)) continue;
        const { failArg, failCall } = failCallInfo.value;
        report({
          location: transformation.callee,
          messageText: `You can use Effect.mapError instead of Effect.catchAll + Effect.fail to transform the error type.`,
          fixes: [{
            fixName: "catchAllToMapError_fix",
            description: "Replace with Effect.mapError",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              if (ts.isPropertyAccessExpression(transformation.callee)) {
                changeTracker.replaceNode(
                  sourceFile,
                  transformation.callee.name,
                  ts.factory.createIdentifier("mapError")
                );
              }
              changeTracker.replaceNode(sourceFile, failCall, failArg);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/catchUnfailableEffect.ts
var catchUnfailableEffect = createDiagnostic({
  name: "catchUnfailableEffect",
  code: 2,
  description: "Warns when using error handling on Effects that never fail (error type is 'never')",
  severity: "suggestion",
  apply: fn("catchUnfailableEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const catchFunctions = ["catchAll", "catch", "catchIf", "catchSome", "catchTag", "catchTags"];
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      for (let i = 0; i < flow2.transformations.length; i++) {
        const transformation = flow2.transformations[i];
        if (!transformation.args || transformation.args.length === 0) {
          continue;
        }
        const isCatchCall = yield* pipe(
          firstSuccessOf(
            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(transformation.callee))
          ),
          option
        );
        if (isNone2(isCatchCall)) {
          continue;
        }
        const inputType = i === 0 ? flow2.subject.outType : flow2.transformations[i - 1].outType;
        if (!inputType) {
          continue;
        }
        const effectType = yield* pipe(
          typeParser.effectType(inputType, transformation.callee),
          option
        );
        if (isSome2(effectType)) {
          const { E } = effectType.value;
          if (E.flags & ts.TypeFlags.Never) {
            report({
              location: transformation.callee,
              messageText: `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,
              fixes: []
            });
          }
        }
      }
    }
  })
});

// src/diagnostics/classSelfMismatch.ts
var classSelfMismatch = createDiagnostic({
  name: "classSelfMismatch",
  code: 20,
  description: "Ensures Self type parameter matches the class name in Service/Tag/Schema classes",
  severity: "error",
  apply: fn("classSelfMismatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => typeParser.extendsContextTag(node)),
          orElse2(() => typeParser.extendsEffectTag(node)),
          orElse2(() => typeParser.extendsSchemaClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => typeParser.extendsEffectSqlModelClass(node)),
          orElse2(() => void_)
        );
        if (result) {
          const { className, selfTypeNode } = result;
          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end);
          if (ts.isTypeReferenceNode(selfTypeNode)) {
            if (ts.isIdentifier(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName);
            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName.right);
            }
          }
          const expectedName = ts.idText(className);
          if (actualName !== expectedName) {
            report({
              location: selfTypeNode,
              messageText: `Self type parameter should be '${expectedName}'`,
              fixes: [{
                fixName: "classSelfMismatch_fix",
                description: `Replace '${actualName}' with '${expectedName}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : void 0;
                  const newTypeReference = ts.factory.createTypeReferenceNode(
                    ts.factory.createIdentifier(expectedName),
                    typeArgs
                  );
                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/core/KeyBuilder.ts
var makeKeyBuilder = fn("KeyBuilder")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const program = yield* service(TypeScriptProgram);
    const options = yield* service(LanguageServicePluginOptions);
    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    function createString2(classNameText, kind) {
      if (!packageInfo) return;
      for (const keyPattern of options.keyPatterns) {
        if (keyPattern.target !== kind) continue;
        const lastIndex = sourceFile.fileName.lastIndexOf("/");
        let onlyFileName = lastIndex === -1 ? "" : sourceFile.fileName.slice(lastIndex + 1);
        const lastExtensionIndex = onlyFileName.lastIndexOf(".");
        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex);
        if (onlyFileName.toLowerCase().endsWith("/index")) onlyFileName = onlyFileName.slice(0, -6);
        if (onlyFileName.startsWith("/")) onlyFileName = onlyFileName.slice(1);
        let subDirectory = getDirectoryPath(ts, sourceFile.fileName);
        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue;
        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length);
        if (!subDirectory.endsWith("/")) subDirectory = subDirectory + "/";
        if (subDirectory.startsWith("/")) subDirectory = subDirectory.slice(1);
        for (const prefix of keyPattern.skipLeadingPath) {
          if (subDirectory.startsWith(prefix)) {
            subDirectory = subDirectory.slice(prefix.length);
            break;
          }
        }
        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(
          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
        );
        if (keyPattern.pattern === "package-identifier") {
          parts = [packageInfo.name, onlyFileName].concat(
            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
          );
        }
        parts = parts.map((part) => part.startsWith("/") ? part.slice(1) : part).map(
          (part) => part.endsWith("/") ? part.slice(0, -1) : part
        );
        const fullKey = parts.filter((_) => String(_).trim().length > 0).join("/");
        return keyPattern.pattern === "default-hashed" ? cyrb53(fullKey) : fullKey;
      }
    }
    return {
      createString: createString2
    };
  }
);
var keyBuilderCache = /* @__PURE__ */ new Map();
var getOrMakeKeyBuilder = fn("getOrMakeKeyBuilder")(function* (sourceFile) {
  while (keyBuilderCache.size > 5) {
    const oldest = keyBuilderCache.keys().next().value;
    if (oldest) keyBuilderCache.delete(oldest);
  }
  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) || (yield* makeKeyBuilder(sourceFile));
  keyBuilderCache.set(sourceFile.fileName, keyBuilder);
  return keyBuilder;
});
function createString(sourceFile, identifier, kind) {
  return map4(
    getOrMakeKeyBuilder(sourceFile),
    (identifierBuilder) => identifierBuilder.createString(identifier, kind)
  );
}

// src/diagnostics/deterministicKeys.ts
var deterministicKeys = createDiagnostic({
  name: "deterministicKeys",
  code: 25,
  description: "Enforces deterministic naming for service/tag/error identifiers based on class names",
  severity: "off",
  apply: fn("deterministicKeys.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeScriptUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    const parseExtendsCustom = cachedBy(
      fn("parseExtendsCustom")(function* (classDeclaration) {
        if (!options.extendedKeyDetection) {
          return yield* typeParserIssue("Extended key detection is disabled", void 0, classDeclaration);
        }
        if (!classDeclaration.name) {
          return yield* typeParserIssue("Class has no name", void 0, classDeclaration);
        }
        if (!ts.isIdentifier(classDeclaration.name)) {
          return yield* typeParserIssue("Class name is not an identifier", void 0, classDeclaration);
        }
        const heritageClauses = classDeclaration.heritageClauses;
        if (!heritageClauses) {
          return yield* typeParserIssue("Class has no heritage clauses", void 0, classDeclaration);
        }
        const nodeToVisit2 = [...classDeclaration.heritageClauses];
        const appendNodeToVisit2 = (node) => {
          nodeToVisit2.push(node);
          return void 0;
        };
        while (nodeToVisit2.length > 0) {
          const node = nodeToVisit2.shift();
          if (ts.isCallExpression(node)) {
            for (let i = 0; i < node.arguments.length; i++) {
              const arg = node.arguments[i];
              if (!ts.isStringLiteral(arg)) continue;
              const resolvedSignature = typeChecker.getResolvedSignature(node);
              if (resolvedSignature) {
                const parameter = resolvedSignature.parameters[i];
                if (!parameter) continue;
                if (parameter.declarations) {
                  for (const declaration of parameter.declarations) {
                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration);
                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end);
                    if (paramText.toLowerCase().includes("@effect-identifier")) {
                      return { className: classDeclaration.name, keyStringLiteral: arg, target: "custom" };
                    }
                  }
                }
              }
            }
          }
          ts.forEachChild(node, appendNodeToVisit2);
        }
        return yield* typeParserIssue(
          "Class does not extend any custom pattern",
          void 0,
          classDeclaration
        );
      }),
      "deterministicKeys.parseExtendsCustom",
      (classDeclaration) => classDeclaration
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          pipe(
            typeParser.extendsEffectService(node),
            orElse2(() => typeParser.extendsContextTag(node)),
            orElse2(() => typeParser.extendsEffectTag(node)),
            map4(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "service" }))
          ),
          orElse2(
            () => pipe(
              typeParser.extendsDataTaggedError(node),
              orElse2(() => typeParser.extendsSchemaTaggedError(node)),
              map4(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "error" }))
            )
          ),
          orElse2(() => parseExtendsCustom(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral) {
          const { className, keyStringLiteral, target } = result;
          const classNameText = ts.idText(className);
          const expectedKey = yield* createString(sourceFile, classNameText, target);
          if (!expectedKey) continue;
          const actualIdentifier = keyStringLiteral.text;
          if (actualIdentifier !== expectedKey) {
            report({
              location: keyStringLiteral,
              messageText: `Key should be '${expectedKey}'`,
              fixes: [{
                fixName: "deterministicKeys_fix",
                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey);
                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/duplicatePackage.ts
var checkedPackagesCache = /* @__PURE__ */ new Map();
var programResolvedCacheSize = /* @__PURE__ */ new Map();
var duplicatePackage = createDiagnostic({
  name: "duplicatePackage",
  code: 6,
  description: "Detects when multiple versions of the same Effect package are loaded",
  severity: "warning",
  apply: fn("duplicatePackage.apply")(function* (sourceFile, report) {
    const program = yield* service(TypeScriptProgram);
    const tsUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    if (sourceFile.statements.length < 1) return;
    let resolvedPackages = checkedPackagesCache.get(sourceFile.fileName) || {};
    const newResolvedModuleSize = hasProperty(program, "resolvedModules") && hasProperty(program.resolvedModules, "size") && isNumber(program.resolvedModules.size) ? program.resolvedModules.size : 0;
    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1;
    if (newResolvedModuleSize !== oldResolvedSize) {
      const seenPackages = /* @__PURE__ */ new Set();
      resolvedPackages = {};
      program.getSourceFiles().map((_) => {
        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_);
        if (!packageInfo) return;
        const packageNameAndVersion = packageInfo.name + "@" + packageInfo.version;
        if (seenPackages.has(packageNameAndVersion)) return;
        seenPackages.add(packageNameAndVersion);
        if (!(packageInfo.name === "effect" || packageInfo.hasEffectInPeerDependencies)) return;
        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return;
        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {};
        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory;
      });
      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages);
      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize);
    }
    for (const packageName of Object.keys(resolvedPackages)) {
      if (Object.keys(resolvedPackages[packageName]).length > 1) {
        const versions = Object.keys(resolvedPackages[packageName]);
        report({
          location: sourceFile.statements[0],
          messageText: `Package ${packageName} is referenced multiple times with different versions (${versions.join(", ")}) and may cause unexpected type errors.
Cleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.
If this is intended set the LSP config "allowedDuplicatedPackages" to ${JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))}.

${versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join("\n")}`,
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/effectFnIife.ts
var effectFnIife = createDiagnostic({
  name: "effectFnIife",
  code: 46,
  description: "Effect.fn or Effect.fnUntraced is called as an IIFE (Immediately Invoked Function Expression). Use Effect.gen instead.",
  severity: "warning",
  apply: fn("effectFnIife.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const innerCall = node.expression;
      if (!ts.isCallExpression(innerCall)) continue;
      const parsed = yield* pipe(
        typeParser.effectFnGen(innerCall),
        map4((result) => ({
          kind: "fn",
          effectModule: result.effectModule,
          generatorFunction: result.generatorFunction,
          pipeArguments: result.pipeArguments,
          traceExpression: result.traceExpression
        })),
        orElse2(
          () => pipe(
            typeParser.effectFnUntracedGen(innerCall),
            map4((result) => ({
              kind: "fnUntraced",
              effectModule: result.effectModule,
              generatorFunction: result.generatorFunction,
              pipeArguments: result.pipeArguments,
              traceExpression: void 0
            }))
          )
        ),
        orElse2(
          () => pipe(
            typeParser.effectFn(innerCall),
            map4((result) => ({
              kind: "fn",
              effectModule: result.effectModule,
              generatorFunction: void 0,
              pipeArguments: result.pipeArguments,
              traceExpression: result.traceExpression
            }))
          )
        ),
        option
      );
      if (isNone2(parsed)) continue;
      const { effectModule, generatorFunction, kind, pipeArguments: pipeArguments2, traceExpression } = parsed.value;
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      const fixes = [];
      if (generatorFunction && generatorFunction.parameters.length === 0) {
        fixes.push({
          fixName: "effectFnIife_toEffectGen",
          description: "Convert to Effect.gen",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const effectGenCall = ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleName),
                "gen"
              ),
              void 0,
              [generatorFunction]
            );
            let replacementNode = effectGenCall;
            if (pipeArguments2.length > 0) {
              replacementNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(effectGenCall, "pipe"),
                void 0,
                [...pipeArguments2]
              );
            }
            changeTracker.replaceNode(sourceFile, node, replacementNode);
          })
        });
      }
      const traceExpressionText = traceExpression ? sourceFile.text.slice(traceExpression.pos, traceExpression.end) : void 0;
      report({
        location: node,
        messageText: `${effectModuleName}.${kind} returns a reusable function that can take arguments, but here it's called immediately. Use Effect.gen instead${traceExpressionText ? ` with Effect.withSpan(${traceExpressionText}) piped in the end to mantain tracing spans` : ``}.`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectFnOpportunity.ts
var effectFnOpportunity = createDiagnostic({
  name: "effectFnOpportunity",
  code: 41,
  description: "Suggests using Effect.fn for functions that returns an Effect",
  severity: "suggestion",
  apply: fn("effectFnOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    const sourceEffectModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const findSingleReturnStatement = (block) => {
      if (block.statements.length !== 1) return void 0;
      const statement = block.statements[0];
      if (!ts.isReturnStatement(statement)) return void 0;
      return statement;
    };
    const getBodyExpression = (fnNode) => {
      if (ts.isArrowFunction(fnNode)) {
        if (ts.isBlock(fnNode.body)) {
          return findSingleReturnStatement(fnNode.body)?.expression;
        }
        return fnNode.body;
      } else if ((ts.isFunctionExpression(fnNode) || ts.isFunctionDeclaration(fnNode)) && fnNode.body) {
        return findSingleReturnStatement(fnNode.body)?.expression;
      }
      return void 0;
    };
    const getNameIdentifier = (node) => {
      if (ts.isFunctionDeclaration(node) && node.name) {
        return node.name;
      }
      if (node.parent && ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
        return node.parent.name;
      }
      if (node.parent && ts.isPropertyAssignment(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name) || ts.isStringLiteral(name)) {
          return name;
        }
      }
      if (node.parent && ts.isPropertyDeclaration(node.parent)) {
        const name = node.parent.name;
        if (ts.isIdentifier(name)) {
          return name;
        }
      }
      return void 0;
    };
    const areParametersReferencedIn = (fnNode, nodes) => {
      if (fnNode.parameters.length === 0 || nodes.length === 0) return false;
      const firstParam = fnNode.parameters[0];
      const lastParam = fnNode.parameters[fnNode.parameters.length - 1];
      const paramsStart = firstParam.pos;
      const paramsEnd = lastParam.end;
      const isSymbolDeclaredInParams = (symbol3) => {
        const declarations = symbol3.declarations;
        if (!declarations) return false;
        return declarations.some((decl) => decl.pos >= paramsStart && decl.end <= paramsEnd);
      };
      const nodesToVisit = [...nodes];
      while (nodesToVisit.length > 0) {
        const node = nodesToVisit.shift();
        if (ts.isIdentifier(node)) {
          const symbol3 = typeChecker.getSymbolAtLocation(node);
          if (symbol3 && isSymbolDeclaredInParams(symbol3)) {
            return true;
          }
        }
        if (ts.isShorthandPropertyAssignment(node)) {
          const valueSymbol = typeChecker.getShorthandAssignmentValueSymbol(node);
          if (valueSymbol && isSymbolDeclaredInParams(valueSymbol)) {
            return true;
          }
        }
        ts.forEachChild(node, (child) => {
          nodesToVisit.push(child);
          return void 0;
        });
      }
      return false;
    };
    const tryExtractWithSpanExpression = (expr) => gen(function* () {
      if (!ts.isCallExpression(expr)) return void 0;
      const callee = expr.expression;
      const isWithSpan = yield* pipe(
        typeParser.isNodeReferenceToEffectModuleApi("withSpan")(callee),
        map4(() => true),
        orElse2(() => succeed(false))
      );
      if (!isWithSpan) return void 0;
      if (expr.arguments.length === 0) return void 0;
      return expr.arguments[0];
    });
    const tryParseGenOpportunity = (fnNode) => gen(function* () {
      const bodyExpression = getBodyExpression(fnNode);
      if (!bodyExpression) return yield* TypeParserIssue.issue;
      const { pipeArguments: pipeArguments2, subject } = yield* pipe(
        typeParser.pipeCall(bodyExpression),
        map4(({ args: args2, subject: subject2 }) => ({ subject: subject2, pipeArguments: args2 })),
        orElse2(() => succeed({ subject: bodyExpression, pipeArguments: [] }))
      );
      const { effectModule, generatorFunction } = yield* typeParser.effectGen(subject);
      const effectModuleName = ts.isIdentifier(effectModule) ? ts.idText(effectModule) : sourceEffectModuleName;
      let explicitTraceExpression;
      if (pipeArguments2.length > 0) {
        const lastArg = pipeArguments2[pipeArguments2.length - 1];
        const withSpanExpr = yield* tryExtractWithSpanExpression(lastArg);
        if (withSpanExpr) {
          explicitTraceExpression = withSpanExpr;
        }
      }
      return { effectModuleName, generatorFunction, pipeArguments: pipeArguments2, explicitTraceExpression };
    });
    const isInsideEffectFn = (fnNode) => {
      const parent = fnNode.parent;
      if (!parent || !ts.isCallExpression(parent)) {
        return succeed(false);
      }
      if (parent.arguments[0] !== fnNode) {
        return succeed(false);
      }
      return pipe(
        typeParser.effectFn(parent),
        orElse2(() => typeParser.effectFnGen(parent)),
        orElse2(() => typeParser.effectFnUntracedGen(parent)),
        map4(() => true),
        orElse2(() => succeed(false))
      );
    };
    const parseEffectFnOpportunityTarget = (node) => gen(function* () {
      if (!ts.isFunctionExpression(node) && !ts.isArrowFunction(node) && !ts.isFunctionDeclaration(node)) {
        return yield* TypeParserIssue.issue;
      }
      if ((ts.isFunctionExpression(node) || ts.isFunctionDeclaration(node)) && node.asteriskToken) {
        return yield* TypeParserIssue.issue;
      }
      if (ts.isFunctionExpression(node) && node.name) {
        return yield* TypeParserIssue.issue;
      }
      if (node.type) {
        return yield* TypeParserIssue.issue;
      }
      if (yield* isInsideEffectFn(node)) {
        return yield* TypeParserIssue.issue;
      }
      const functionType = typeChecker.getTypeAtLocation(node);
      if (!functionType) return yield* TypeParserIssue.issue;
      const callSignatures = typeChecker.getSignaturesOfType(functionType, ts.SignatureKind.Call);
      if (callSignatures.length !== 1) return yield* TypeParserIssue.issue;
      const signature = callSignatures[0];
      const returnType = typeChecker.getReturnTypeOfSignature(signature);
      const unionMembers = typeCheckerUtils.unrollUnionMembers(returnType);
      yield* all(...unionMembers.map((member) => typeParser.strictEffectType(member, node)));
      const nameIdentifier = getNameIdentifier(node);
      const traceName = nameIdentifier ? ts.isIdentifier(nameIdentifier) ? ts.idText(nameIdentifier) : nameIdentifier.text : void 0;
      if (!traceName) return yield* TypeParserIssue.issue;
      const opportunity = yield* pipe(
        tryParseGenOpportunity(node),
        orElse2(() => {
          if (ts.isArrowFunction(node) && !ts.isBlock(node.body)) {
            return TypeParserIssue.issue;
          }
          const body = ts.isArrowFunction(node) ? node.body : node.body;
          if (!body || !ts.isBlock(body) || body.statements.length <= 5) {
            return TypeParserIssue.issue;
          }
          return succeed({
            effectModuleName: sourceEffectModuleName,
            pipeArguments: [],
            generatorFunction: void 0,
            explicitTraceExpression: void 0
          });
        })
      );
      return {
        node,
        nameIdentifier,
        effectModuleName: opportunity.effectModuleName,
        inferredTraceName: traceName,
        explicitTraceExpression: opportunity.explicitTraceExpression,
        pipeArguments: opportunity.pipeArguments,
        generatorFunction: opportunity.generatorFunction,
        hasParamsInPipeArgs: areParametersReferencedIn(node, opportunity.pipeArguments)
      };
    });
    const getFunctionBodyBlock = (node) => {
      if (ts.isArrowFunction(node)) {
        if (ts.isBlock(node.body)) {
          return node.body;
        }
        return ts.factory.createBlock([ts.factory.createReturnStatement(node.body)], true);
      }
      return node.body;
    };
    const isGeneratorFunction = (node) => {
      if (ts.isArrowFunction(node)) return false;
      return node.asteriskToken !== void 0;
    };
    const createEffectFnNode = (originalNode, innerFunction, effectModuleName, traceNameOrExpression, pipeArguments2) => {
      const isGenerator = isGeneratorFunction(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      let fnExpression = ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleName),
        "fn"
      );
      if (traceNameOrExpression) {
        const traceArg = typeof traceNameOrExpression === "string" ? ts.factory.createStringLiteral(traceNameOrExpression) : traceNameOrExpression;
        fnExpression = ts.factory.createCallExpression(
          fnExpression,
          void 0,
          [traceArg]
        );
      }
      const effectFnCall = ts.factory.createCallExpression(fnExpression, void 0, [newFunction, ...pipeArguments2]);
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const createEffectFnUntracedNode = (originalNode, innerFunction, effectModuleName, pipeArguments2) => {
      const isGenerator = isGeneratorFunction(innerFunction);
      const newFunction = ts.factory.createFunctionExpression(
        void 0,
        isGenerator ? ts.factory.createToken(ts.SyntaxKind.AsteriskToken) : void 0,
        void 0,
        originalNode.typeParameters,
        originalNode.parameters,
        void 0,
        getFunctionBodyBlock(innerFunction)
      );
      const effectFnCall = ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(effectModuleName), "fnUntraced"),
        void 0,
        [newFunction, ...pipeArguments2]
      );
      if (ts.isFunctionDeclaration(originalNode)) {
        return tsUtils.tryPreserveDeclarationSemantics(originalNode, effectFnCall, false);
      }
      return effectFnCall;
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const target = yield* pipe(parseEffectFnOpportunityTarget(node), option);
      if (isNone2(target)) continue;
      if (target.value.hasParamsInPipeArgs) continue;
      const {
        effectModuleName,
        explicitTraceExpression,
        inferredTraceName,
        nameIdentifier,
        node: targetNode,
        pipeArguments: pipeArguments2
      } = target.value;
      const innerFunction = target.value.generatorFunction ?? targetNode;
      const fixes = [];
      if (pluginOptions.effectFn.includes("span") && explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnWithSpan",
          description: "Convert to Effect.fn (with span from withSpan)",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const finalPipeArguments = pipeArguments2.slice(0, -1);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              explicitTraceExpression,
              finalPipeArguments
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("untraced") && target.value.generatorFunction) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnUntraced",
          description: "Convert to Effect.fnUntraced",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnUntracedNode(targetNode, innerFunction, effectModuleName, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("no-span")) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnNoSpan",
          description: "Convert to Effect.fn (no span)",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnNode(targetNode, innerFunction, effectModuleName, void 0, pipeArguments2);
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (pluginOptions.effectFn.includes("inferred-span") && inferredTraceName && !explicitTraceExpression) {
        fixes.push({
          fixName: "effectFnOpportunity_toEffectFnSpanInferred",
          description: `Convert to Effect.fn("${inferredTraceName}")`,
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const newNode = createEffectFnNode(
              targetNode,
              innerFunction,
              effectModuleName,
              inferredTraceName,
              pipeArguments2
            );
            changeTracker.replaceNode(sourceFile, targetNode, newNode);
          })
        });
      }
      if (fixes.length === 0) continue;
      const generateExpectedSignature = () => {
        const firstFix = fixes[0];
        if (!firstFix) return "Effect.fn(function*() { ... })";
        const typeParamNames = targetNode.typeParameters ? `<${targetNode.typeParameters.map((tp) => ts.idText(tp.name)).join(", ")}>` : "";
        const paramNames = targetNode.parameters.map((param) => {
          if (ts.isIdentifier(param.name)) {
            return ts.idText(param.name);
          }
          return "_";
        }).join(", ");
        const fnSignature = `function*${typeParamNames}(${paramNames}) { ... }`;
        const pipeArgsForWithSpan = pipeArguments2.slice(0, -1);
        const pipeArgsSuffix = (args2) => args2.length > 0 ? ", ...pipeTransformations" : "";
        switch (firstFix.fixName) {
          case "effectFnOpportunity_toEffectFnWithSpan": {
            const traceName = explicitTraceExpression ? sourceFile.text.slice(explicitTraceExpression.pos, explicitTraceExpression.end).trim() : void 0;
            return `${effectModuleName}.fn(${traceName})(${fnSignature}${pipeArgsSuffix(pipeArgsForWithSpan)})`;
          }
          case "effectFnOpportunity_toEffectFnUntraced":
            return `${effectModuleName}.fnUntraced(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnNoSpan":
            return `${effectModuleName}.fn(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          case "effectFnOpportunity_toEffectFnSpanInferred":
            return `${effectModuleName}.fn("${inferredTraceName}")(${fnSignature}${pipeArgsSuffix(pipeArguments2)})`;
          default:
            return `${effectModuleName}.fn(${fnSignature})`;
        }
      };
      const expectedSignature = generateExpectedSignature();
      report({
        location: nameIdentifier ?? targetNode,
        messageText: `Can be rewritten as a reusable function: ${expectedSignature}`,
        fixes
      });
    }
  })
});

// src/diagnostics/effectGenUsesAdapter.ts
var effectGenUsesAdapter = createDiagnostic({
  name: "effectGenUsesAdapter",
  code: 23,
  description: "Warns when using the deprecated adapter parameter in Effect.gen",
  severity: "warning",
  apply: fn("effectGenUsesAdapter.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.effectGen(node),
          map4(({ generatorFunction }) => {
            if (generatorFunction.parameters.length > 0) {
              const adapter = generatorFunction.parameters[0];
              report({
                location: adapter,
                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,
                fixes: []
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectInVoidSuccess.ts
var effectInVoidSuccess = createDiagnostic({
  name: "effectInVoidSuccess",
  code: 14,
  description: "Detects nested Effects in void success channels that may cause unexecuted effects",
  severity: "warning",
  apply: fn("effectInVoidSuccess.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForEffectInVoid = fn("effectInVoidSuccess.checkForEffectInVoid")(function* (node, expectedType, valueNode, realType) {
      const expectedEffect = yield* typeParser.effectType(expectedType, node);
      const realEffect = yield* typeParser.effectType(realType, valueNode);
      if (expectedEffect.A.flags & ts.TypeFlags.Void) {
        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A);
        const voidedEffect = yield* firstSuccessOf(
          voidValueTypes.map((_) => map4(typeParser.strictEffectType(_, node), () => _))
        );
        return { voidedEffect };
      }
      return yield* fail(typeParserIssue("expectedEffect success is not void"));
    });
    const entries = typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForEffectInVoid(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4(({ voidedEffect }) => {
            report(
              {
                location: node,
                messageText: `There is a nested '${typeChecker.typeToString(voidedEffect)}' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,
                fixes: []
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectMapVoid.ts
var effectMapVoid = createDiagnostic({
  name: "effectMapVoid",
  code: 40,
  description: "Suggests using Effect.asVoid instead of Effect.map(() => void 0), Effect.map(() => undefined), or Effect.map(() => {})",
  severity: "suggestion",
  apply: fn("effectMapVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isMapCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("map")(node.expression),
          option
        );
        if (isSome2(isMapCall)) {
          const callback = node.arguments[0];
          if (!callback) continue;
          const match2 = yield* pipe(
            typeParser.emptyFunction(callback),
            orElse2(
              () => pipe(
                typeParser.lazyExpression(callback),
                flatMap2(
                  (lazy) => tsUtils.isVoidExpression(lazy.expression) ? succeed(lazy) : typeParserIssue("Expression is not void")
                )
              )
            ),
            option
          );
          if (isNone2(match2)) continue;
          report({
            location: node.expression,
            messageText: "Effect.asVoid can be used instead to discard the success value",
            fixes: [{
              fixName: "effectMapVoid_fix",
              description: "Replace with Effect.asVoid",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                if (ts.isPropertyAccessExpression(node.expression)) {
                  const newNode = ts.factory.createPropertyAccessExpression(
                    node.expression.expression,
                    ts.factory.createIdentifier("asVoid")
                  );
                  changeTracker.replaceNode(sourceFile, node, newNode);
                }
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/effectSucceedWithVoid.ts
var effectSucceedWithVoid = createDiagnostic({
  name: "effectSucceedWithVoid",
  code: 47,
  description: "Suggests using Effect.void instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
  severity: "suggestion",
  apply: fn("effectSucceedWithVoid.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isSucceedCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("succeed")(node.expression),
          option
        );
        if (isSome2(isSucceedCall)) {
          const argument = node.arguments[0];
          if (!argument) continue;
          if (!tsUtils.isVoidExpression(argument)) continue;
          report({
            location: node,
            messageText: "Effect.void can be used instead of Effect.succeed(undefined) or Effect.succeed(void 0)",
            fixes: [{
              fixName: "effectSucceedWithVoid_fix",
              description: "Replace with Effect.void",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
                const newNode = ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("void")
                );
                changeTracker.replaceNode(sourceFile, node, newNode);
              })
            }]
          });
        }
      }
    }
  })
});

// src/diagnostics/floatingEffect.ts
var floatingEffect = createDiagnostic({
  name: "floatingEffect",
  code: 3,
  description: "Ensures Effects are yielded or assigned to variables, not left floating",
  severity: "error",
  apply: fn("floatingEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isFloatingExpression(node) {
      if (!ts.isExpressionStatement(node)) return false;
      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false;
      const expression = node.expression;
      if (ts.isBinaryExpression(expression) && expression.operatorToken && (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken || expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)) return false;
      return true;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!isFloatingExpression(node)) continue;
      const type = typeCheckerUtils.getTypeAtLocation(node.expression);
      if (!type) continue;
      const effect = yield* option(typeParser.effectType(type, node.expression));
      if (isSome2(effect)) {
        const allowedFloatingEffects = yield* pipe(
          typeParser.fiberType(type, node.expression),
          orElse2(() => typeParser.effectSubtype(type, node.expression)),
          option
        );
        if (isNone2(allowedFloatingEffects)) {
          const isStrictEffect = yield* option(typeParser.strictEffectType(type, node.expression));
          const name = isSome2(isStrictEffect) ? "Effect" : "Effect-able " + typeChecker.typeToString(type);
          report({
            location: node,
            messageText: `${name} must be yielded or assigned to a variable.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/genericEffectServices.ts
var genericEffectServices = createDiagnostic({
  name: "genericEffectServices",
  code: 10,
  description: "Prevents services with type parameters that cannot be discriminated at runtime",
  severity: "warning",
  apply: fn("genericEffectServices.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          map4(() => {
            report({
              location: reportAt,
              messageText: `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,
              fixes: []
            });
          }),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectCatch.ts
var globalErrorInEffectCatch = createDiagnostic({
  name: "globalErrorInEffectCatch",
  code: 36,
  description: "Warns when catch callbacks return global Error type instead of typed errors",
  severity: "warning",
  apply: fn("globalErrorInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse2(() => void_)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && typeCheckerUtils.isGlobalErrorType(returnType)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns global 'Error', which loses type safety as untagged errors merge together. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/globalErrorInEffectFailure.ts
var globalErrorInEffectFailure = createDiagnostic({
  name: "globalErrorInEffectFailure",
  code: 35,
  description: "Warns when the global Error type is used in an Effect failure channel",
  severity: "warning",
  apply: fn("globalErrorInEffectFailure.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isNewExpression(node)) {
        const newExpressionType = typeCheckerUtils.getTypeAtLocation(node);
        if (!newExpressionType || !typeCheckerUtils.isGlobalErrorType(newExpressionType)) {
          continue;
        }
        let current = node.parent;
        while (current) {
          const currentType = typeCheckerUtils.getTypeAtLocation(current);
          if (currentType) {
            const effectTypeResult = yield* pipe(
              typeParser.effectType(currentType, current),
              option
            );
            if (effectTypeResult._tag === "Some") {
              const effectType = effectTypeResult.value;
              const failureMembers = typeCheckerUtils.unrollUnionMembers(effectType.E);
              const hasGlobalError = failureMembers.some((member) => typeCheckerUtils.isGlobalErrorType(member));
              if (hasGlobalError) {
                report({
                  location: node,
                  messageText: `Global 'Error' loses type safety as untagged errors merge together in the Effect failure channel. Consider using a tagged error and optionally wrapping the original in a 'cause' property.`,
                  fixes: []
                });
              }
              break;
            }
          }
          current = current.parent;
        }
      }
    }
  })
});

// src/diagnostics/importFromBarrel.ts
var importFromBarrel = createDiagnostic({
  name: "importFromBarrel",
  code: 12,
  description: "Suggests importing from specific module paths instead of barrel exports",
  severity: "off",
  apply: fn("importFromBarrel.apply")(function* (sourceFile, report) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return;
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const program = yield* service(TypeScriptProgram);
    const getModuleSpecifier = makeGetModuleSpecifier(ts);
    const resolveExternalModuleName = makeResolveExternalModuleName(typeChecker);
    const packageNamesToCheck = flatten(
      languageServicePluginOptions.namespaceImportPackages.map(
        (packageName) => tsUtils.resolveModulePattern(program, sourceFile, packageName)
      )
    );
    const isImportedFromBarrelExport = (element) => {
      if (!(getModuleSpecifier && resolveExternalModuleName)) return;
      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node));
      if (!importDeclaration) return;
      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return;
      const importClause = importDeclaration.importClause;
      if (!importClause) return;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) return;
      if (!ts.isNamedImports(namedBindings)) return;
      const barrelModuleName = importDeclaration.moduleSpecifier.text;
      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return;
      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier);
      if (!moduleSymbol) return;
      if (!moduleSymbol.exports) return;
      const sourceFile2 = tsUtils.getSourceFileOfNode(importDeclaration);
      if (!sourceFile2) return;
      const nodeForSymbol = element.propertyName || element.name;
      const aliasSymbol = element.name || element.propertyName;
      const aliasedName = ts.idText(aliasSymbol);
      if (!ts.isIdentifier(nodeForSymbol)) return;
      const importedName = ts.idText(nodeForSymbol);
      if (!importedName) return;
      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName));
      if (!reexportedSymbol) return;
      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return;
      const namespaceExport = reexportedSymbol.declarations[0];
      if (!ts.isNamespaceExport(namespaceExport)) return;
      const exportDeclaration = namespaceExport.parent;
      if (!ts.isExportDeclaration(exportDeclaration)) return;
      if (!exportDeclaration.moduleSpecifier) return;
      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier);
      if (!originalModuleSymbol) return;
      if (!originalModuleSymbol.valueDeclaration) return;
      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration);
      if (!originalSourceFile) return;
      const unbarrelledFileName = getModuleSpecifier(
        program.getCompilerOptions(),
        sourceFile2,
        sourceFile2.fileName,
        originalSourceFile.fileName,
        program
      );
      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + "/") === -1) return;
      return {
        unbarrelledFileName,
        importedName,
        barrelModuleName,
        importClause,
        namedBindings,
        importDeclaration,
        aliasedName
      };
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const parent = node.parent;
      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      const result = isImportedFromBarrelExport(node);
      if (!result) continue;
      const {
        aliasedName,
        barrelModuleName,
        importClause,
        importDeclaration,
        namedBindings,
        unbarrelledFileName
      } = result;
      report({
        location: node,
        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,
        fixes: [
          {
            fixName: "replaceWithUnbarrelledImport",
            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const newImport = ts.factory.createImportDeclaration(
                void 0,
                ts.factory.createImportClause(
                  importClause.isTypeOnly || node.isTypeOnly,
                  void 0,
                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))
                ),
                ts.factory.createStringLiteral(unbarrelledFileName)
              );
              if (namedBindings.elements.length === 1) {
                changeTracker.replaceNode(
                  sourceFile,
                  importDeclaration,
                  newImport
                );
              } else {
                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport);
                changeTracker.replaceNode(
                  sourceFile,
                  namedBindings,
                  ts.factory.updateNamedImports(
                    namedBindings,
                    namedBindings.elements.filter((e) => e !== node)
                  )
                );
              }
            })
          }
        ]
      });
    }
  })
});

// src/diagnostics/instanceOfSchema.ts
var instanceOfSchema = createDiagnostic({
  name: "instanceOfSchema",
  code: 45,
  description: "Suggests using Schema.is instead of instanceof for Effect Schema types",
  severity: "off",
  apply: fn("instanceOfSchema.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
        const leftExpr = node.left;
        const rightExpr = node.right;
        const rightType = typeCheckerUtils.getTypeAtLocation(rightExpr);
        if (!rightType) {
          ts.forEachChild(node, appendNodeToVisit);
          continue;
        }
        const isSchemaType = yield* pipe(
          typeParser.effectSchemaType(rightType, rightExpr),
          option
        );
        if (isSchemaType._tag === "Some") {
          report({
            location: node,
            messageText: "Consider using Schema.is instead of instanceof for Effect Schema types.",
            fixes: [{
              fixName: "instanceOfSchema_fix",
              description: "Replace with Schema.is",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const schemaIsCall = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier("Schema"),
                    "is"
                  ),
                  void 0,
                  [rightExpr]
                );
                const fullCall = ts.factory.createCallExpression(
                  schemaIsCall,
                  void 0,
                  [leftExpr]
                );
                changeTracker.replaceNode(sourceFile, node, fullCall);
              })
            }]
          });
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/layerMergeAllWithDependencies.ts
var layerMergeAllWithDependencies = createDiagnostic({
  name: "layerMergeAllWithDependencies",
  code: 37,
  description: "Detects interdependencies in Layer.mergeAll calls where one layer provides a service that another layer requires",
  severity: "warning",
  apply: fn("layerMergeAllWithDependencies.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const checkLayerMergeAll = yield* pipe(
          typeParser.isNodeReferenceToEffectLayerModuleApi("mergeAll")(node.expression),
          orElse2(() => void_)
        );
        if (checkLayerMergeAll) {
          const layerArgs = node.arguments;
          if (layerArgs.length > 1) {
            const layerInfos = [];
            const actuallyProvidedMap = /* @__PURE__ */ new Map();
            for (const arg of layerArgs) {
              const argType = typeCheckerUtils.getTypeAtLocation(arg);
              if (!argType) continue;
              const layerTypeParsedOption = yield* option(typeParser.layerType(argType, arg));
              if (isNone2(layerTypeParsedOption)) continue;
              const layerTypeParsed = layerTypeParsedOption.value;
              const providedMembers = typeCheckerUtils.unrollUnionMembers(layerTypeParsed.ROut);
              for (const providedType of providedMembers) {
                if (providedType.flags & ts.TypeFlags.Never) continue;
                const isPassThrough = typeChecker.isTypeAssignableTo(providedType, layerTypeParsed.RIn);
                if (!isPassThrough) {
                  actuallyProvidedMap.set(providedType, arg);
                }
              }
              layerInfos.push({
                arg,
                requirementsType: layerTypeParsed.RIn
              });
            }
            const providerToConsumers = /* @__PURE__ */ new Map();
            for (const layer of layerInfos) {
              for (const [providedType, providerArg] of actuallyProvidedMap) {
                if (providerArg === layer.arg) continue;
                if (typeChecker.isTypeAssignableTo(providedType, layer.requirementsType)) {
                  const consumers = providerToConsumers.get(providerArg) || [];
                  consumers.push({ consumer: layer.arg, providedType });
                  providerToConsumers.set(providerArg, consumers);
                }
              }
            }
            for (const [providerArg, consumers] of providerToConsumers) {
              const providedTypes = Array.from(new Set(consumers.map((c) => typeChecker.typeToString(c.providedType)))).join(", ");
              report({
                location: providerArg,
                messageText: `This layer provides ${providedTypes} which is required by another layer in the same Layer.mergeAll call. Layer.mergeAll creates layers in parallel, so dependencies between layers will not be satisfied. Consider moving this layer into a Layer.provideMerge after the Layer.mergeAll.`,
                fixes: [{
                  fixName: "layerMergeAllWithDependencies_fix",
                  description: "Move layer to Layer.provideMerge",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    const providerIndex = layerArgs.indexOf(providerArg);
                    if (providerIndex === -1) return;
                    const providerArgNode = providerArg;
                    if (providerIndex === 0 && layerArgs.length > 1) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: providerArgNode.pos,
                        end: layerArgs[1].pos
                      });
                    } else if (providerIndex > 0) {
                      changeTracker.deleteRange(sourceFile, {
                        pos: layerArgs[providerIndex - 1].end,
                        end: providerArgNode.end
                      });
                    }
                    const provideMergeCall = ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        ts.factory.createIdentifier(layerModuleIdentifier),
                        ts.factory.createIdentifier("provideMerge")
                      ),
                      void 0,
                      [providerArgNode]
                    );
                    changeTracker.insertNodeAt(sourceFile, node.end, provideMergeCall, {
                      prefix: ".pipe("
                    });
                    changeTracker.insertText(sourceFile, node.end, ")");
                  })
                }]
              });
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/leakingRequirements.ts
var leakingRequirements = createDiagnostic({
  name: "leakingRequirements",
  code: 8,
  description: "Detects implementation services leaked in service methods",
  severity: "suggestion",
  apply: fn("leakingRequirements.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseLeakedRequirements = cachedBy(
      fn("leakingServices.checkServiceLeaking")(
        function* (service2, atLocation) {
          const properties = typeChecker.getPropertiesOfType(service2);
          if (properties.length < 1) return [];
          const memory = /* @__PURE__ */ new Map();
          let sharedRequirementsKeys = void 0;
          let effectMembers = 0;
          for (const property of properties) {
            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation);
            let effectContextType = void 0;
            yield* pipe(
              typeParser.effectType(servicePropertyType, atLocation),
              map4((_) => effectContextType = _.R),
              orElse2(() => {
                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(
                  servicePropertyType,
                  ts.SignatureKind.Call
                );
                if (servicePropertyCallSignatures.length === 1) {
                  return pipe(
                    typeParser.effectType(
                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),
                      atLocation
                    ),
                    map4((_) => {
                      effectContextType = _.R;
                    })
                  );
                }
                return void_;
              }),
              ignore
            );
            if (effectContextType) {
              effectMembers++;
              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                memory,
                effectContextType,
                (type) => {
                  if (type.flags & ts.TypeFlags.Never) return succeed(true);
                  return pipe(
                    typeParser.scopeType(type, atLocation),
                    map4(() => true),
                    orElse2(() => succeed(false))
                  );
                }
              );
              if (!sharedRequirementsKeys) {
                sharedRequirementsKeys = allIndexes;
              } else {
                sharedRequirementsKeys = intersection(sharedRequirementsKeys, allIndexes);
                if (sharedRequirementsKeys.length === 0) return [];
              }
            }
          }
          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {
            return sharedRequirementsKeys.map((key) => memory.get(key)).filter(
              (type) => {
                let symbol3 = type.symbol;
                if (symbol3 && symbol3.flags & ts.SymbolFlags.Alias) {
                  symbol3 = typeChecker.getAliasedSymbol(symbol3) || symbol3;
                }
                if (!symbol3) return false;
                return !(symbol3?.declarations || []).some((declaration) => {
                  const declarationSource = tsUtils.getSourceFileOfNode(declaration);
                  if (!declarationSource) return false;
                  return declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(
                    "@effect-leakable-service"
                  ) > -1;
                });
              }
            );
          }
          return [];
        }
      ),
      "leakingServices.checkServiceLeaking",
      (_, service2) => service2
    );
    function reportLeakingRequirements(node, requirements) {
      if (requirements.length === 0) return;
      const requirementsStr = requirements.map((_) => typeChecker.typeToString(_)).join(" | ");
      report({
        location: node,
        messageText: `Methods of this Service require \`${requirementsStr}\` from every caller.

This leaks implementation details into the service's public type \u2014 callers shouldn't need to know *how* the service works internally, only *what* it provides.

Resolve these dependencies at Layer creation and provide them to each method, so the service's type reflects its purpose, not its implementation.

To suppress this diagnostic for specific dependency types that are intentionally passed through (e.g., HttpServerRequest), add \`@effect-leakable-service\` JSDoc to their interface declarations (e.g., the \`${typeChecker.typeToString(requirements[0])}\` interface), not to this service.

More info and examples at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,
        fixes: []
      });
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "GenericTag") {
        const nodeType = typeCheckerUtils.getTypeAtLocation(node);
        if (nodeType) typesToCheck.push([nodeType, node]);
      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          flatMap2(
            ({ Service }) => pipe(
              parseLeakedRequirements(Service, node),
              map4(
                (requirements) => reportLeakingRequirements(reportAt, sort(requirements, typeCheckerUtils.deterministicTypeOrder))
              )
            )
          ),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missedPipeableOpportunity.ts
var missedPipeableOpportunity = createDiagnostic({
  name: "missedPipeableOpportunity",
  code: 26,
  description: "Enforces the use of pipeable style for nested function calls",
  severity: "off",
  apply: fn("missedPipeableOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const options = yield* service(LanguageServicePluginOptions);
    const isSafelyPipeableCallee = (callee) => {
      if (ts.isCallExpression(callee)) {
        return true;
      }
      if (ts.isArrowFunction(callee)) {
        return true;
      }
      if (ts.isFunctionExpression(callee)) {
        return true;
      }
      if (ts.isParenthesizedExpression(callee)) {
        return isSafelyPipeableCallee(callee.expression);
      }
      if (ts.isIdentifier(callee)) {
        const symbol3 = typeChecker.getSymbolAtLocation(callee);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isFunctionDeclaration(decl) || ts.isVariableDeclaration(decl) || ts.isImportSpecifier(decl) || ts.isImportClause(decl) || ts.isNamespaceImport(decl)) {
            return true;
          }
        }
        return false;
      }
      if (ts.isPropertyAccessExpression(callee)) {
        const subject = callee.expression;
        const symbol3 = typeChecker.getSymbolAtLocation(subject);
        if (!symbol3) return false;
        if (symbol3.flags & (ts.SymbolFlags.Module | ts.SymbolFlags.Namespace | ts.SymbolFlags.ValueModule)) {
          return true;
        }
        const declarations = symbol3.declarations;
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isNamespaceImport(decl) || ts.isSourceFile(decl) || ts.isModuleDeclaration(decl)) {
            return true;
          }
        }
        return false;
      }
      return false;
    };
    const flows = yield* typeParser.pipingFlows(false)(sourceFile);
    for (const flow2 of flows) {
      if (flow2.transformations.length < options.pipeableMinArgCount) {
        continue;
      }
      const finalType = flow2.transformations[flow2.transformations.length - 1].outType;
      if (!finalType) {
        continue;
      }
      const callSigs = typeChecker.getSignaturesOfType(finalType, ts.SignatureKind.Call);
      if (callSigs.length > 0) {
        continue;
      }
      const isPipeableAtIndex = function* (index) {
        if (index === 0) {
          const subjectType = flow2.subject.outType;
          if (!subjectType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(subjectType, flow2.subject.node),
            option
          );
          return result._tag === "Some";
        } else {
          const t = flow2.transformations[index - 1];
          if (!t.outType) return false;
          const result = yield* pipe(
            typeParser.pipeableType(t.outType, flow2.node),
            option
          );
          return result._tag === "Some";
        }
      };
      let searchStartIndex = 0;
      while (searchStartIndex <= flow2.transformations.length) {
        let firstPipeableIndex = -1;
        for (let i = searchStartIndex; i <= flow2.transformations.length; i++) {
          if (yield* isPipeableAtIndex(i)) {
            firstPipeableIndex = i;
            break;
          }
        }
        if (firstPipeableIndex === -1) {
          break;
        }
        const pipeableTransformations = [];
        for (let i = firstPipeableIndex; i < flow2.transformations.length; i++) {
          const t = flow2.transformations[i];
          if (!isSafelyPipeableCallee(t.callee)) {
            break;
          }
          pipeableTransformations.push(t);
        }
        const callKindCount = pipeableTransformations.filter((t) => t.kind === "call").length;
        if (callKindCount >= options.pipeableMinArgCount) {
          const pipeableEndIndex = firstPipeableIndex + pipeableTransformations.length;
          const pipeableSubjectNode = firstPipeableIndex === 0 ? flow2.subject.node : typeParser.reconstructPipingFlow({
            subject: flow2.subject,
            transformations: flow2.transformations.slice(0, firstPipeableIndex)
          });
          const afterTransformations = flow2.transformations.slice(pipeableEndIndex);
          const getOriginalSubjectNode = () => {
            if (firstPipeableIndex === 0) {
              return flow2.subject.node;
            }
            let current = flow2.node;
            for (let i = flow2.transformations.length; i > firstPipeableIndex; i--) {
              const t = flow2.transformations[i - 1];
              if (t.kind === "call" && ts.isCallExpression(current) && current.arguments.length > 0) {
                current = current.arguments[0];
              } else {
                return void 0;
              }
            }
            return current;
          };
          const originalSubjectNode = getOriginalSubjectNode();
          const subjectText = originalSubjectNode ? sourceFile.text.slice(
            ts.getTokenPosOfNode(originalSubjectNode, sourceFile),
            originalSubjectNode.end
          ).trim() : "";
          report({
            location: flow2.node,
            messageText: `Nested function calls can be converted to pipeable style for better readability; consider using ${subjectText}.pipe(...) instead.`,
            fixes: [{
              fixName: "missedPipeableOpportunity_fix",
              description: "Convert to pipe style",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const pipeArgs = pipeableTransformations.map((t) => {
                  if (t.args) {
                    return ts.factory.createCallExpression(
                      t.callee,
                      void 0,
                      t.args
                    );
                  } else {
                    return t.callee;
                  }
                });
                const pipeNode = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    pipeableSubjectNode,
                    "pipe"
                  ),
                  void 0,
                  pipeArgs
                );
                const newNode = afterTransformations.length > 0 ? typeParser.reconstructPipingFlow({
                  subject: { node: pipeNode, outType: void 0 },
                  transformations: afterTransformations
                }) : pipeNode;
                changeTracker.replaceNode(sourceFile, flow2.node, newNode);
              })
            }]
          });
          break;
        }
        searchStartIndex = firstPipeableIndex + pipeableTransformations.length + 1;
      }
    }
  })
});

// src/diagnostics/missingEffectContext.ts
var missingEffectContext = createDiagnostic({
  name: "missingEffectContext",
  code: 1,
  description: "Reports missing service requirements in Effect context channel",
  severity: "error",
  apply: fn("missingEffectContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map4(
        ([expectedEffect, realEffect]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realEffect.R,
          expectedEffect.R
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Effect context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectError.ts
var missingEffectError = createDiagnostic({
  name: "missingEffectError",
  code: 1,
  description: "Reports missing error types in Effect error channel",
  severity: "error",
  apply: fn("missingEffectError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const createDieMessage = (message) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifier),
        "dieMessage"
      ),
      void 0,
      [ts.factory.createStringLiteral(message)]
    );
    const checkForMissingErrorTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map4(
        ([expectedEffect, realEffect]) => pipe(
          typeCheckerUtils.getMissingTypeEntriesInTargetType(
            realEffect.E,
            expectedEffect.E
          ),
          (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingErrorTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4((result) => {
            if (result.missingErrorTypes.length === 0) return;
            const fixes = [];
            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {
              fixes.push({
                fixName: "missingEffectError_catchAll",
                description: "Catch all errors with Effect.catchAll",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.insertText(
                    sourceFile,
                    ts.getTokenPosOfNode(valueNode, sourceFile),
                    effectModuleIdentifier + ".catchAll("
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ", () => ");
                  changeTracker.insertNodeAt(
                    sourceFile,
                    valueNode.end,
                    createDieMessage("TODO: catchAll not implemented")
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ")");
                })
              });
            }
            if (ts.isExpression(valueNode)) {
              const propertyAssignments = pipe(
                result.missingErrorTypes,
                map3((_) => typeChecker.getPropertyOfType(_, "_tag")),
                filter((_) => !!_),
                map3((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),
                filter((_) => !!(_.flags & ts.TypeFlags.Literal)),
                map3((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_ && ts.isLiteralTypeNode(_)),
                map3((_) => _.literal),
                filter((_) => ts.isLiteralExpression(_)),
                map3((_) => _.text),
                sort(string2),
                map3(
                  (_) => ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier(_),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)
                    )
                  )
                )
              );
              if (propertyAssignments.length === result.missingErrorTypes.length) {
                fixes.push({
                  fixName: "missingEffectError_tagged",
                  description: "Catch unexpected errors with Effect.catchTag",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.insertText(
                      sourceFile,
                      ts.getTokenPosOfNode(valueNode, sourceFile),
                      effectModuleIdentifier + ".catchTags("
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ", ");
                    changeTracker.insertNodeAt(
                      sourceFile,
                      valueNode.end,
                      ts.factory.createObjectLiteralExpression(propertyAssignments)
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ")");
                  })
                });
              }
            }
            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_));
            report(
              {
                location: node,
                messageText: `Missing '${typeNames.join(" | ")}' in the expected Effect errors.`,
                fixes
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectServiceDependency.ts
var missingEffectServiceDependency = createDiagnostic({
  name: "missingEffectServiceDependency",
  code: 22,
  description: "Checks that Effect.Service dependencies satisfy all required layer inputs",
  severity: "off",
  apply: fn("missingEffectServiceDependency.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult) {
          const { className, options } = serviceResult;
          const classSymbol = typeChecker.getSymbolAtLocation(className);
          if (classSymbol) {
            const classType = typeChecker.getTypeOfSymbol(classSymbol);
            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, "DefaultWithoutDependencies");
            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, "Default");
            if (defaultProperty) {
              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node);
              const layerResult = yield* pipe(
                typeParser.layerType(defaultType, node),
                orElse2(() => void_)
              );
              if (layerResult) {
                const servicesMemory = /* @__PURE__ */ new Map();
                const excludeNever = (type) => succeed((type.flags & ts.TypeFlags.Never) !== 0);
                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                  servicesMemory,
                  layerResult.RIn,
                  excludeNever
                );
                const providedIndexes = /* @__PURE__ */ new Set();
                let types = [];
                const optionsType = typeCheckerUtils.getTypeAtLocation(options);
                if (optionsType) {
                  const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, "dependencies");
                  if (dependenciesProperty) {
                    const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options);
                    const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number);
                    types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : [];
                  }
                }
                for (const depType of types) {
                  const depLayerResult = yield* pipe(
                    typeParser.layerType(depType, options),
                    orElse2(() => void_)
                  );
                  if (depLayerResult) {
                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                      servicesMemory,
                      depLayerResult.ROut,
                      excludeNever
                    );
                    for (const index of allIndexes) {
                      providedIndexes.add(index);
                    }
                  }
                }
                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index));
                if (missingIndexes.length > 0) {
                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index));
                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t));
                  const message = missingTypeNames.length === 1 ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies` : `Services ${missingTypeNames.map((s) => `'${s}'`).join(", ")} are required but not provided by dependencies`;
                  report({
                    location: className,
                    messageText: message,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/missingLayerContext.ts
var missingLayerContext = createDiagnostic({
  name: "missingLayerContext",
  code: 38,
  description: "Reports missing service requirements in Layer context channel",
  severity: "error",
  apply: fn("missingLayerContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.layerType(expectedType, node),
        typeParser.layerType(realType, valueNode)
      ),
      map4(
        ([expectedLayer, realLayer]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realLayer.RIn,
          expectedLayer.RIn
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Layer context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingReturnYieldStar.ts
var missingReturnYieldStar = createDiagnostic({
  name: "missingReturnYieldStar",
  code: 7,
  description: "Suggests using 'return yield*' for Effects with never success for better type narrowing",
  severity: "error",
  apply: fn("missingReturnYieldStar.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken) {
        const type = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (type) {
          const maybeEffect = yield* option(typeParser.effectType(type, node.expression));
          if (isSome2(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {
            const generatorFunctionOrReturnStatement = ts.findAncestor(
              node,
              (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isReturnStatement(_) || ts.isThrowStatement(_)
            );
            if (generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) && !ts.isThrowStatement(generatorFunctionOrReturnStatement)) {
              if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {
                const effectGenNode = generatorFunctionOrReturnStatement.parent;
                const effectGenLike = yield* pipe(
                  typeParser.effectGen(effectGenNode),
                  orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
                  orElse2(() => typeParser.effectFnGen(effectGenNode)),
                  option
                );
                if (isSome2(effectGenLike)) {
                  const fix = node.expression ? [{
                    fixName: "missingReturnYieldStar_fix",
                    description: "Add return statement",
                    apply: gen(function* () {
                      const changeTracker = yield* service(ChangeTracker);
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createReturnStatement(
                          node
                        )
                      );
                    })
                  }] : [];
                  report({
                    location: node,
                    messageText: `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,
                    fixes: fix
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/missingStarInYieldEffectGen.ts
var missingStarInYieldEffectGen = createDiagnostic({
  name: "missingStarInYieldEffectGen",
  code: 4,
  description: "Enforces using 'yield*' instead of 'yield' when yielding Effects in generators",
  severity: "error",
  apply: fn("missingStarInYieldEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const brokenGenerators = /* @__PURE__ */ new Set();
    const brokenYields = /* @__PURE__ */ new Set();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken === void 0) {
        const functionStarNode = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)
        );
        if (functionStarNode && functionStarNode.parent) {
          const effectGenNode = functionStarNode.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map4(({ generatorFunction }) => {
              if (generatorFunction) {
                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)));
              }
              brokenYields.add(node);
            }),
            ignore
          );
        }
      }
    }
    brokenGenerators.forEach(
      (pos) => report({
        location: { pos, end: pos + "function".length },
        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,
        fixes: []
      })
    );
    brokenYields.forEach((node) => {
      const fix = node.expression ? [{
        fixName: "missingStarInYieldEffectGen_fix",
        description: "Replace yield with yield*",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(
            sourceFile,
            node,
            ts.factory.createYieldExpression(
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              node.expression
            )
          );
        })
      }] : [];
      report({
        location: node,
        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,
        fixes: fix
      });
    });
  })
});

// src/diagnostics/multipleEffectProvide.ts
var multipleEffectProvide = createDiagnostic({
  name: "multipleEffectProvide",
  code: 18,
  description: "Warns against chaining Effect.provide calls which can cause service lifecycle issues",
  severity: "warning",
  apply: fn("multipleEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const flows = yield* typeParser.pipingFlows(true)(sourceFile);
    for (const flow2 of flows) {
      let currentChunk = 0;
      const previousLayers = [[]];
      for (const transformation of flow2.transformations) {
        if (!transformation.args || transformation.args.length === 0) {
          currentChunk++;
          previousLayers.push([]);
          continue;
        }
        const isProvideCall = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("provide")(transformation.callee),
          option
        );
        if (isSome2(isProvideCall)) {
          const layer = transformation.args[0];
          const type = typeCheckerUtils.getTypeAtLocation(layer);
          const node = ts.findAncestor(transformation.callee, ts.isCallExpression);
          const isLayerType = type ? yield* pipe(
            typeParser.layerType(type, layer),
            option
          ) : none2();
          if (isSome2(isLayerType) && node) {
            previousLayers[currentChunk].push({ layer, node });
          } else {
            currentChunk++;
            previousLayers.push([]);
          }
        } else {
          currentChunk++;
          previousLayers.push([]);
        }
      }
      for (const chunk of previousLayers) {
        if (chunk.length < 2) continue;
        report({
          location: chunk[0].node,
          messageText: "Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.",
          fixes: [{
            fixName: "multipleEffectProvide_fix",
            description: "Combine into a single provide",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.deleteRange(sourceFile, {
                pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),
                end: chunk[chunk.length - 1].node.end
              });
              const newNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("provide")
                ),
                void 0,
                [ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(layerModuleIdentifier),
                    ts.factory.createIdentifier("mergeAll")
                  ),
                  void 0,
                  chunk.map((c) => c.layer)
                )]
              );
              changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode);
            })
          }]
        });
      }
    }
  })
});

// src/diagnostics/nonObjectEffectServiceType.ts
var nonObjectEffectServiceType = createDiagnostic({
  name: "nonObjectEffectServiceType",
  code: 24,
  description: "Ensures Effect.Service types are objects, not primitives",
  severity: "error",
  apply: fn("nonObjectEffectServiceType.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isPrimitiveType(type) {
      return typeCheckerUtils.unrollUnionMembers(type).some(
        (type2) => !!(type2.flags & ts.TypeFlags.String || type2.flags & ts.TypeFlags.Number || type2.flags & ts.TypeFlags.Boolean || type2.flags & ts.TypeFlags.StringLiteral || type2.flags & ts.TypeFlags.NumberLiteral || type2.flags & ts.TypeFlags.BooleanLiteral || type2.flags & ts.TypeFlags.Undefined || type2.flags & ts.TypeFlags.Null)
      );
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {
          const options = serviceResult.options;
          for (const property of options.properties) {
            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {
              continue;
            }
            const propertyName = ts.idText(property.name);
            const propertyValue = property.initializer;
            const errorToReport = {
              location: property.name,
              messageText: "Effect.Service requires the service type to be an object {} and not a primitive type. \nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.",
              fixes: []
            };
            if (propertyName === "succeed") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (valueType && isPrimitiveType(valueType)) {
                report(errorToReport);
              }
            } else if (propertyName === "sync") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
              for (const signature of signatures) {
                const returnType = typeChecker.getReturnTypeOfSignature(signature);
                if (isPrimitiveType(returnType)) {
                  report(errorToReport);
                  break;
                }
              }
            } else if (propertyName === "effect" || propertyName === "scoped") {
              const valueType = typeCheckerUtils.getTypeAtLocation(propertyValue);
              if (!valueType) continue;
              const effectResult = yield* pipe(
                typeParser.effectType(valueType, propertyValue),
                orElse2(() => void_)
              );
              if (effectResult) {
                if (isPrimitiveType(effectResult.A)) {
                  report(errorToReport);
                  continue;
                }
              } else {
                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
                for (const signature of signatures) {
                  const returnType = typeChecker.getReturnTypeOfSignature(signature);
                  const effectReturnResult = yield* pipe(
                    typeParser.effectType(returnType, propertyValue),
                    orElse2(() => void_)
                  );
                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {
                    report(errorToReport);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/refactors/writeTagClassAccessors.ts
var generate = fn("writeTagClassAccessors.generate")(function* (sourceFile, service2, className, atLocation, involvedMembers) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const changeTracker = yield* service(ChangeTracker);
  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1;
  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Effect"
  ) || "Effect";
  const createFunctionProperty = (className2, propertyName, type, forceAny) => {
    const arrowBody = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectIdentifier),
        "andThen"
      ),
      void 0,
      [
        ts.factory.createIdentifier(ts.idText(className2)),
        ts.factory.createArrowFunction(
          void 0,
          void 0,
          [ts.factory.createParameterDeclaration(
            void 0,
            void 0,
            "_",
            void 0,
            forceAny ? ts.factory.createTypeReferenceNode("any") : void 0
          )],
          void 0,
          void 0,
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createIdentifier("_"),
              propertyName
            ),
            void 0,
            [
              ts.factory.createSpreadElement(ts.factory.createIdentifier("args"))
            ]
          )
        )
      ]
    );
    return ts.factory.createPropertyDeclaration(
      [
        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),
        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)
      ],
      propertyName,
      void 0,
      type,
      ts.factory.createArrowFunction(
        void 0,
        void 0,
        [ts.factory.createParameterDeclaration(
          void 0,
          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),
          "args",
          void 0,
          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode("any")) : void 0
        )],
        void 0,
        void 0,
        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode("any")) : arrowBody
      )
    );
  };
  const generateReturnType = (type, atLocation2, className2) => pipe(
    typeParser.effectType(type, atLocation2),
    flatMap2((returnedEffect) => {
      const contextType = returnedEffect.R.flags & ts.TypeFlags.Never ? ts.factory.createTypeReferenceNode(ts.idText(className2)) : ts.factory.createUnionTypeNode(
        [
          ts.factory.createTypeReferenceNode(ts.idText(className2)),
          typeChecker.typeToTypeNode(returnedEffect.R, atLocation2, ts.NodeBuilderFlags.NoTruncation)
        ]
      );
      const successType = typeChecker.typeToTypeNode(
        returnedEffect.A,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!successType) return fail("error generating success type");
      const failureType = typeChecker.typeToTypeNode(
        returnedEffect.E,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!failureType) return fail("error generating failure type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [successType, failureType, contextType]
      );
      return succeed(typeNode);
    }),
    orElse2(
      () => pipe(
        typeParser.promiseLike(type, atLocation2),
        flatMap2(({ type: type2 }) => {
          const successType = typeChecker.typeToTypeNode(
            type2,
            atLocation2,
            ts.NodeBuilderFlags.NoTruncation
          );
          if (!successType) return fail("error generating success type");
          return succeed(ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectIdentifier),
              ts.factory.createIdentifier("Effect")
            ),
            [
              successType,
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier("Cause"),
                  ts.factory.createIdentifier("UnknownException")
                )
              ),
              ts.factory.createTypeReferenceNode(ts.idText(className2))
            ]
          ));
        })
      )
    ),
    orElse2(() => {
      const successType = typeChecker.typeToTypeNode(type, atLocation2, ts.NodeBuilderFlags.NoTruncation);
      if (!successType) return fail("error generating success type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [
          successType,
          ts.factory.createTypeReferenceNode("never"),
          ts.factory.createTypeReferenceNode(ts.idText(className2))
        ]
      );
      return succeed(typeNode);
    })
  );
  const proxySignature = (signature, atLocation2, className2) => gen(function* () {
    const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(
      signature,
      ts.SyntaxKind.FunctionType,
      atLocation2,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!signatureDeclaration) return yield* fail("error generating signature");
    const returnType = yield* generateReturnType(
      typeChecker.getReturnTypeOfSignature(signature),
      atLocation2,
      className2
    );
    return ts.factory.createFunctionTypeNode(
      signatureDeclaration.typeParameters,
      signatureDeclaration.parameters,
      returnType
    );
  });
  for (const { property, propertyType } of involvedMembers) {
    const callSignatures = [];
    let propertyDeclaration = void 0;
    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {
      yield* pipe(
        proxySignature(signature, atLocation, className),
        map4((sig) => {
          callSignatures.push(sig);
        }),
        ignore
      );
    }
    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures);
    const type = tsUtils.simplifyTypeNode(allSignatures);
    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1);
    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {
      const symbol3 = typeChecker.getSymbolAtLocation(p.name);
      return symbol3 && ts.symbolName(symbol3) === ts.symbolName(property);
    });
    if (oldProperty) {
      const start = ts.getTokenPosOfNode(oldProperty, sourceFile);
      changeTracker.deleteRange(sourceFile, {
        pos: start,
        end: oldProperty.end
      });
      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration);
    } else {
      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: "\n" });
    }
  }
});
var parse2 = fn("writeTagClassAccessors.parse")(function* (node) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  if (!ts.isClassDeclaration(node)) return yield* fail("not a class declaration");
  const { Service, accessors: accessors2, className, kind } = yield* pipe(
    map4(typeParser.extendsEffectService(node), (_) => ({ kind: "effectService", ..._ })),
    orElse2(
      () => map4(typeParser.extendsEffectTag(node), (_) => ({ kind: "effectTag", accessors: true, ..._ }))
    ),
    orElse2(() => fail("not a class extending Effect.Service call"))
  );
  if (accessors2 !== true) return yield* fail("accessors are not enabled in the Effect.Service call");
  const involvedMembers = [];
  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter(
    (_) => !(_.flags & ts.TypeFlags.Number || _.flags & ts.TypeFlags.String || _.flags & ts.TypeFlags.Boolean || _.flags & ts.TypeFlags.Literal)
  );
  if (nonPrimitiveServices.length === 0) return yield* fail("Service type is a primitive type");
  for (const serviceShape of nonPrimitiveServices) {
    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {
      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node);
      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call);
      if (callSignatures.length > 0) {
        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0);
        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType });
      }
    }
  }
  const hash2 = involvedMembers.map(({ property, propertyType }) => {
    return ts.symbolName(property) + ": " + typeChecker.typeToString(propertyType);
  }).concat([ts.idText(className)]).join("\n");
  return { Service, className, atLocation: node, hash: cyrb53(hash2), involvedMembers, kind };
});
var writeTagClassAccessors = createRefactor({
  name: "writeTagClassAccessors",
  description: "Implement accessors methods with generics or multiple signatures",
  apply: fn("writeTagClassAccessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseNode = (node) => pipe(
      parse2(node),
      map4(({ Service, atLocation, className, involvedMembers }) => ({
        kind: "refactor.rewrite.effect.writeTagClassAccessors",
        description: "Implement Service accessors",
        apply: pipe(
          generate(sourceFile, Service, className, atLocation, involvedMembers),
          provideService(TypeScriptUtils, tsUtils),
          provideService(TypeParser, typeParser),
          provideService(TypeCheckerApi, typeChecker),
          provideService(TypeScriptApi, ts)
        )
      }))
    );
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(parentNodes.map(parseNode)),
      orElse2(() => fail(new RefactorNotApplicableError()))
    );
  })
});

// src/codegens/accessors.ts
var accessors = createCodegen({
  name: "accessors",
  apply: fn("accessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse2(nodeAndCommentRange.node),
      map4(
        (_) => ({
          hash: _.hash,
          description: "Generate accessors for the service",
          apply: pipe(
            generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeParser, typeParser),
            provideService(TypeCheckerUtils, typeCheckerUtils)
          )
        })
      ),
      orElse2((cause) => fail(new CodegenNotApplicableError(cause)))
    );
  })
});

// src/codegens/annotate.ts
var annotate = createCodegen({
  name: "annotate",
  apply: fn("annotate.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const parse3 = (node) => gen(function* () {
      let variableDeclarations = [];
      const result = [];
      if (ts.isVariableStatement(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarationList.declarations];
      } else if (ts.isVariableDeclarationList(node)) {
        variableDeclarations = [...variableDeclarations, ...node.declarations];
      } else if (ts.isVariableDeclaration(node)) {
        variableDeclarations = [...variableDeclarations, node];
      }
      if (variableDeclarations.length === 0) {
        return yield* fail(new CodegenNotApplicableError("not a variable declaration"));
      }
      for (const variableDeclaration of variableDeclarations) {
        if (!variableDeclaration.initializer) continue;
        const initializerType = typeCheckerUtils.getTypeAtLocation(variableDeclaration.initializer);
        if (!initializerType) continue;
        const enclosingNode = ts.findAncestor(variableDeclaration, (_) => tsUtils.isDeclarationKind(_.kind)) || sourceFile;
        const initializerTypeNode = fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
          initializerType,
          enclosingNode,
          ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.IgnoreErrors
        )).pipe(
          getOrUndefined
        );
        if (!initializerTypeNode) continue;
        const typeNodeString = typeChecker.typeToString(initializerType, void 0, ts.TypeFormatFlags.NoTruncation);
        const hash3 = cyrb53(typeNodeString);
        result.push({ variableDeclaration, initializerTypeNode, hash: hash3 });
      }
      if (result.length === 0) {
        return yield* fail(new CodegenNotApplicableError("no variable declarations with initializers"));
      }
      const hash2 = cyrb53(result.map((_) => _.hash).join("/"));
      return {
        hash: hash2,
        result
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse3(nodeAndCommentRange.node),
      map4(
        (_) => ({
          hash: _.hash,
          description: "Annotate with type",
          apply: gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            for (const { initializerTypeNode, variableDeclaration } of _.result) {
              if (variableDeclaration.type) {
                changeTracker.deleteRange(sourceFile, {
                  pos: variableDeclaration.name.end,
                  end: variableDeclaration.type.end
                });
              }
              changeTracker.insertNodeAt(
                sourceFile,
                variableDeclaration.name.end,
                initializerTypeNode,
                {
                  prefix: ": "
                }
              );
            }
          })
        })
      )
    );
  })
});

// src/utils/StructuralSchemaGen.ts
var UnsupportedTypeError = class {
  constructor(type, reason) {
    this.type = type;
    this.reason = reason;
  }
  _tag = "@effect/language-service/UnsupportedTypeError";
  toString() {
    return `Unsupported type: ${this.reason}`;
  }
};
var StructuralSchemaGenContext = Tag("StructuralSchemaGenContext");
var makeStructuralSchemaGenContext = fn("StructuralSchemaGen.makeContext")(
  function* (sourceFile, schemaIdentifier) {
    const ts = yield* service(TypeScriptApi);
    const program = yield* service(TypeScriptProgram);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const effectSchemaIdentifier = schemaIdentifier || "Schema";
    return identity({
      ts,
      program,
      typeChecker,
      typeCheckerUtils,
      sourceFile,
      createApiPropertyAccess: (apiName) => ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaIdentifier),
        apiName
      ),
      createApiCall: (apiName, args2) => ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          ts.factory.createIdentifier(effectSchemaIdentifier),
          apiName
        ),
        [],
        args2
      ),
      hoistedSchemas: /* @__PURE__ */ new Map(),
      typeToStatementIndex: /* @__PURE__ */ new Map(),
      nameToType: /* @__PURE__ */ new Map(),
      usedGlobalIdentifiers: /* @__PURE__ */ new Map(),
      schemaStatements: [],
      rangesToDelete: []
    });
  }
);
var pushHoistedStatement = fn("StructuralSchemaGen.pushHoistedStatement")(
  function* (ctx, name, type, statement, createReference) {
    ctx.usedGlobalIdentifiers.set(name, (ctx.usedGlobalIdentifiers.get(name) || 0) + 1);
    ctx.schemaStatements.push(statement);
    ctx.typeToStatementIndex.set(type, ctx.schemaStatements.length - 1);
    ctx.hoistedSchemas.set(type, createReference);
  }
);
var pushHoistedVariableStatement = fn("StructuralSchemaGen.pushHoistedVariableStatement")(
  function* (ts, ctx, name, type, result) {
    return yield* pushHoistedStatement(
      ctx,
      name,
      type,
      ts.factory.createVariableStatement(
        void 0,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(ts.factory.createIdentifier(name), void 0, void 0, result)],
          ts.NodeFlags.Const
        )
      ),
      () => ts.factory.createIdentifier(name)
    );
  }
);
var createProcessingContext = (maxDepth = 200) => ({
  depth: 0,
  maxDepth,
  hoistName: void 0
});
var processType = fn(
  "StructuralSchemaGen.processType"
)(
  function* (type, context) {
    const processingContext = context || createProcessingContext();
    const { hoistedSchemas, nameToType, ts, typeChecker, usedGlobalIdentifiers } = yield* service(
      StructuralSchemaGenContext
    );
    if (processingContext.depth >= processingContext.maxDepth) {
      return yield* fail(new UnsupportedTypeError(type, "Maximum depth exceeded"));
    }
    let hoistName = fromIterable(nameToType.entries()).find(([_, existingType]) => existingType === type)?.[0];
    if (!hoistName && type && type.symbol && type.symbol.declarations && type.symbol.declarations.length === 1) {
      const declaration = type.symbol.declarations[0];
      if (ts.isInterfaceDeclaration(declaration)) {
        hoistName = ts.idText(declaration.name);
      } else if (declaration.parent && ts.isTypeAliasDeclaration(declaration.parent)) {
        hoistName = ts.idText(declaration.parent.name);
      }
      if (hoistName) {
        const existingType = nameToType.get(hoistName);
        const isSame = existingType && typeChecker.isTypeAssignableTo(type, existingType) && typeChecker.isTypeAssignableTo(existingType, type);
        if (!isSame) {
          const usedCount = usedGlobalIdentifiers.get(hoistName) || 0;
          usedGlobalIdentifiers.set(hoistName, usedCount + 1);
          hoistName = usedCount > 0 ? hoistName + "_" + usedCount : hoistName;
        }
      }
    }
    const nestedContext = {
      ...processingContext,
      depth: processingContext.depth + 1,
      hoistName
    };
    for (const [hoistedType, hoistedSchema] of hoistedSchemas.entries()) {
      if (hoistedType === type || typeChecker.isTypeAssignableTo(type, hoistedType) && typeChecker.isTypeAssignableTo(hoistedType, type)) {
        return hoistedSchema();
      }
    }
    const [schemaExpr, skipHoisting] = yield* processTypeImpl(type, nestedContext);
    if (!skipHoisting && hoistName) {
      const ctx = yield* service(StructuralSchemaGenContext);
      yield* pushHoistedVariableStatement(ts, ctx, hoistName, type, schemaExpr);
      return ctx.hoistedSchemas.get(type)();
    }
    return schemaExpr;
  }
);
var processTypeImpl = fn(
  "StructuralSchemaGen.processTypeImpl"
)(
  function* (type, context) {
    const { createApiCall, createApiPropertyAccess, ts, typeChecker, typeCheckerUtils } = yield* service(
      StructuralSchemaGenContext
    );
    if (type.flags & ts.TypeFlags.String) {
      return [createApiPropertyAccess("String"), true];
    }
    if (type.flags & ts.TypeFlags.Number) {
      return [createApiPropertyAccess("Number"), true];
    }
    if (type.flags & ts.TypeFlags.Boolean) {
      return [createApiPropertyAccess("Boolean"), true];
    }
    if (type.flags & ts.TypeFlags.BigInt) {
      return [createApiPropertyAccess("BigInt"), true];
    }
    if (type.flags & ts.TypeFlags.Void) {
      return [createApiPropertyAccess("Void"), true];
    }
    if (type.flags & ts.TypeFlags.Undefined) {
      return [createApiPropertyAccess("Undefined"), true];
    }
    if (type.flags & ts.TypeFlags.Null) {
      return [createApiPropertyAccess("Null"), true];
    }
    if (type.flags & ts.TypeFlags.Never) {
      return [createApiPropertyAccess("Never"), true];
    }
    if (type.flags & ts.TypeFlags.Any) {
      return [createApiPropertyAccess("Any"), true];
    }
    if (type.flags & ts.TypeFlags.Unknown) {
      return [createApiPropertyAccess("Unknown"), true];
    }
    if (type.flags & ts.TypeFlags.StringLiteral) {
      const literalType = type;
      return [createApiCall("Literal", [ts.factory.createStringLiteral(literalType.value)]), true];
    }
    if (type.flags & ts.TypeFlags.NumberLiteral) {
      const literalType = type;
      return [createApiCall("Literal", [ts.factory.createNumericLiteral(literalType.value)]), true];
    }
    if (type.flags & ts.TypeFlags.BooleanLiteral) {
      const value = type.intrinsicName === "true";
      return [createApiCall("Literal", [value ? ts.factory.createTrue() : ts.factory.createFalse()]), true];
    }
    if (typeCheckerUtils.isUnion(type)) {
      return yield* processUnionType(type.types, context);
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      return yield* processIntersectionType(type, context);
    }
    if (typeChecker.isArrayType(type)) {
      return yield* processArrayType(type, context);
    }
    if (typeChecker.isTupleType(type)) {
      return yield* processTupleType(type, context);
    }
    if (type.flags & ts.TypeFlags.Object) {
      const symbol3 = type.symbol || type.aliasSymbol;
      if (symbol3) {
        const typeName = typeChecker.symbolToString(symbol3);
        if (typeName === "Date") {
          return [createApiPropertyAccess("Date"), false];
        }
        if (typeName === "ReadonlyArray" || typeName === "Array") {
          return yield* processArrayType(type, context);
        }
      }
      const objectType = type;
      return yield* processObjectType(objectType, context);
    }
    return yield* fail(
      new UnsupportedTypeError(
        type,
        `Type with flags ${type.flags} is not supported`
      )
    );
  }
);
var processUnionType = fn(
  "StructuralSchemaGen.processUnionType"
)(
  function* (types, context) {
    const { createApiCall, ts } = yield* service(StructuralSchemaGenContext);
    const allLiterals = types.every(
      (t) => t.flags & ts.TypeFlags.StringLiteral || t.flags & ts.TypeFlags.NumberLiteral || t.flags & ts.TypeFlags.BooleanLiteral
    );
    if (allLiterals) {
      const literals = yield* all(
        ...types.map((t) => processType(t, context))
      );
      const literalValues = literals.map((expr) => {
        if (ts.isCallExpression(expr) && expr.arguments.length > 0) {
          return expr.arguments[0];
        }
        return expr;
      }).filter((arg) => arg !== void 0);
      return [createApiCall("Literal", literalValues), false];
    }
    const members = yield* all(
      ...types.map((t) => processType(t, context))
    );
    if (members.length === 1) {
      return [members[0], false];
    }
    return [createApiCall("Union", members), false];
  }
);
var processIntersectionType = fn(
  "StructuralSchemaGen.processIntersectionType"
)(
  function* (type, context) {
    const { createApiCall, ts } = yield* service(StructuralSchemaGenContext);
    const [firstSchema, ...otherSchemas] = yield* all(
      ...type.types.map((t) => processType(t, context))
    );
    if (otherSchemas.length === 0) {
      return [firstSchema, false];
    }
    return [
      ts.factory.createCallExpression(
        ts.factory.createPropertyAccessExpression(
          firstSchema,
          "pipe"
        ),
        [],
        otherSchemas.map((schema) => createApiCall("extend", [schema]))
      ),
      false
    ];
  }
);
var processArrayType = fn(
  "StructuralSchemaGen.processArrayType"
)(
  function* (type, context) {
    const { createApiCall, typeChecker, typeCheckerUtils } = yield* service(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type);
    if (typeArgs.length === 0) {
      return yield* fail(new UnsupportedTypeError(type, "Array type has no type arguments"));
    }
    const elementSchema = yield* processType(typeArgs[0], context);
    const expr = createApiCall("Array", [elementSchema]);
    if (typeCheckerUtils.isReadonlyArrayType(type)) return [expr, false];
    return [createApiCall("mutable", [expr]), false];
  }
);
var processTupleType = fn(
  "StructuralSchemaGen.processTupleType"
)(
  function* (type, context) {
    const { createApiCall, typeChecker } = yield* service(StructuralSchemaGenContext);
    const typeArgs = typeChecker.getTypeArguments(type);
    const elementSchemas = yield* all(
      ...typeArgs.map((t) => processType(t, context))
    );
    return [createApiCall("Tuple", elementSchemas), false];
  }
);
var processObjectType = fn(
  "StructuralSchemaGen.processObjectType"
)(
  function* (type, context) {
    const {
      createApiCall,
      createApiPropertyAccess,
      program,
      ts,
      typeChecker,
      typeCheckerUtils
    } = yield* service(
      StructuralSchemaGenContext
    );
    let hasRecords = false;
    const properties = typeChecker.getPropertiesOfType(type);
    const propertyAssignments = [];
    for (const property of properties) {
      const propertyName = typeChecker.symbolToString(property);
      const propertyType = typeChecker.getTypeOfSymbol(property);
      const isOptional = (property.flags & ts.SymbolFlags.Optional) !== 0;
      let schemaExpr;
      if (isOptional) {
        if (program.getCompilerOptions().exactOptionalPropertyTypes) {
          if (typeCheckerUtils.isUnion(propertyType)) {
            const typeWithoutMissing = propertyType.types.filter((t) => !typeCheckerUtils.isMissingIntrinsicType(t));
            const [result, _] = yield* processUnionType(typeWithoutMissing, context);
            schemaExpr = createApiCall("optionalWith", [
              result,
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("exact", ts.factory.createTrue())
              ])
            ]);
          }
        } else {
          schemaExpr = yield* processType(propertyType, context);
          schemaExpr = createApiCall("optional", [schemaExpr]);
        }
      }
      if (!schemaExpr) {
        schemaExpr = yield* processType(propertyType, context);
      }
      const propertyNameNode = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName) ? ts.factory.createIdentifier(propertyName) : ts.factory.createStringLiteral(propertyName);
      propertyAssignments.push(
        ts.factory.createPropertyAssignment(
          propertyNameNode,
          schemaExpr
        )
      );
    }
    const indexInfos = typeChecker.getIndexInfosOfType(type);
    const args2 = [
      ts.factory.createObjectLiteralExpression(propertyAssignments, propertyAssignments.length > 0)
    ];
    for (const indexInfo of indexInfos) {
      hasRecords = true;
      const keyType = indexInfo.keyType;
      const valueType = indexInfo.type;
      const keySchema = yield* processType(keyType, context);
      const valueSchema = yield* processType(valueType, context);
      args2.push(
        ts.factory.createObjectLiteralExpression([
          ts.factory.createPropertyAssignment("key", keySchema),
          ts.factory.createPropertyAssignment("value", valueSchema)
        ])
      );
    }
    if (!hasRecords && context.hoistName) {
      const ctx = yield* service(StructuralSchemaGenContext);
      yield* pushHoistedStatement(
        ctx,
        context.hoistName,
        type,
        ts.factory.createClassDeclaration(
          void 0,
          ts.factory.createIdentifier(context.hoistName),
          [],
          [ts.factory.createHeritageClause(
            ts.SyntaxKind.ExtendsKeyword,
            [
              ts.factory.createExpressionWithTypeArguments(
                ts.factory.createCallExpression(
                  ts.factory.createCallExpression(
                    createApiPropertyAccess("Class"),
                    [ts.factory.createTypeReferenceNode(
                      context.hoistName
                    )],
                    [ts.factory.createStringLiteral(context.hoistName)]
                  ),
                  [],
                  args2
                ),
                []
              )
            ]
          )],
          []
        ),
        () => ts.factory.createIdentifier(context.hoistName)
      );
      return [ctx.hoistedSchemas.get(type)(), true];
    }
    return [createApiCall("Struct", args2), propertyAssignments.length === 0];
  }
);
var findNodeToProcess = fn("StructuralSchemaGen.findNodeToProcess")(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),
      filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),
      filter((node) => (node.typeParameters || []).length === 0),
      map3((node) => ({
        node,
        identifier: node.name,
        type: typeCheckerUtils.getTypeAtLocation(node.name),
        isExported: node.modifiers ? (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 : false
      })),
      filter(({ type }) => !!type),
      head
    );
  }
);
var process = fn("StructuralSchemaGen.process")(
  function* (sourceFile, scope, typeMap, isExported, handleCodegeneratedComments) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Schema") || "Schema";
    const ctx = yield* makeStructuralSchemaGenContext(sourceFile, schemaIdentifier);
    for (const [name, type] of typeMap.entries()) {
      ctx.nameToType.set(name, type);
    }
    if (handleCodegeneratedComments) {
      for (const declaration of sourceFile.statements) {
        const nodeText = sourceFile.text.slice(declaration.pos, declaration.end);
        if (!nodeText.toLowerCase().includes("@effect-schema-codegenerated")) continue;
        const interleavingRange = ctx.rangesToDelete.find(
          (range) => range.pos < declaration.end && range.end > declaration.pos
        );
        if (interleavingRange) {
          interleavingRange.pos = Math.min(interleavingRange.pos, declaration.pos);
          interleavingRange.end = Math.max(interleavingRange.end, declaration.end);
        } else {
          ctx.rangesToDelete.push({
            pos: declaration.pos,
            end: declaration.end
          });
        }
      }
    }
    for (const symbol3 of typeChecker.getSymbolsInScope(scope, ts.SymbolFlags.Value)) {
      const name = typeChecker.symbolToString(symbol3);
      ctx.usedGlobalIdentifiers.set(name, 1);
      const type = typeChecker.getTypeOfSymbolAtLocation(symbol3, sourceFile);
      if (type) {
        const schemaType = yield* pipe(
          typeParser.effectSchemaType(type, scope),
          orElse2(() => void_)
        );
        if (schemaType) {
          ctx.hoistedSchemas.set(
            schemaType.A,
            () => {
              const expression = typeChecker.symbolToExpression(
                symbol3,
                ts.SymbolFlags.Value,
                scope,
                ts.NodeBuilderFlags.NoTruncation
              );
              if (expression) {
                return expression;
              }
              return ts.factory.createIdentifier(name);
            }
          );
        }
      }
    }
    const results = yield* pipe(
      all(
        ...fromIterable(ctx.nameToType.entries()).map(
          ([name, type]) => pipe(
            processType(type),
            orElse2(
              (error) => succeed(ts.addSyntheticLeadingComment(
                ts.factory.createIdentifier(""),
                ts.SyntaxKind.MultiLineCommentTrivia,
                " " + String(error) + " ",
                true
              ))
            ),
            map4((_) => ({ requestedName: name, type, result: _ }))
          )
        )
      ),
      provideService(StructuralSchemaGenContext, ctx)
    );
    for (const { requestedName, result, type } of results) {
      const statementIndex = ctx.typeToStatementIndex.get(type);
      if (statementIndex !== void 0) continue;
      ctx.schemaStatements.push(ts.factory.createVariableStatement(
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            ts.factory.createIdentifier(requestedName),
            void 0,
            void 0,
            result
          )],
          ts.NodeFlags.Const
        )
      ));
      ctx.typeToStatementIndex.set(type, ctx.schemaStatements.length - 1);
    }
    if (isExported) {
      const statementsToExport = pipe(
        fromIterable(ctx.nameToType),
        map3(([_, type]) => ctx.typeToStatementIndex.get(type)),
        filter((index) => index !== void 0),
        dedupe
      );
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        if (!statementsToExport.includes(i)) continue;
        const statement = ctx.schemaStatements[i];
        if (ts.isVariableStatement(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateVariableStatement(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.declarationList
          );
        } else if (ts.isClassDeclaration(statement)) {
          ctx.schemaStatements[i] = ts.factory.updateClassDeclaration(
            statement,
            ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
            statement.name,
            statement.typeParameters,
            statement.heritageClauses,
            statement.members
          );
        }
      }
    }
    if (handleCodegeneratedComments) {
      for (let i = 0; i < ctx.schemaStatements.length; i++) {
        const statement = ctx.schemaStatements[i];
        ctx.schemaStatements[i] = ts.addSyntheticLeadingComment(
          statement,
          ts.SyntaxKind.SingleLineCommentTrivia,
          " @effect-schema-codegenerated: This schema will be re-generated by the effect-schema-codegens command, remove this comment to disable re-generation.",
          true
        );
      }
    }
    return ctx;
  }
);
var applyAtNode = fn("StructuralSchemaGen.applyAtNode")(
  function* (sourceFile, node, identifier, type, isExported) {
    const changeTracker = yield* service(ChangeTracker);
    const ts = yield* service(TypeScriptApi);
    const ctx = yield* process(sourceFile, node, /* @__PURE__ */ new Map([[ts.idText(identifier), type]]), isExported, false);
    for (const statement of ctx.schemaStatements) {
      changeTracker.insertNodeAt(sourceFile, node.pos, statement, { prefix: "\n", suffix: "\n" });
    }
  }
);

// src/codegens/typeToSchema.ts
var typeToSchema = createCodegen({
  name: "typeToSchema",
  apply: fn("typeToSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const program = yield* service(TypeScriptProgram);
    const inThisFile = yield* getCodegensForSourceFile([typeToSchema], sourceFile);
    if (inThisFile.length > 1) {
      return yield* fail(
        new CodegenNotApplicableError("the typeToSchema codegen can be used only once per file")
      );
    }
    const parse3 = (node) => gen(function* () {
      if (!ts.isTypeAliasDeclaration(node)) {
        return yield* fail(
          new CodegenNotApplicableError(
            "this codegen is applicable only to a type alias where each object member is a schema to generate. e.g. `type ToGenerate = { UserSchema: User, TodoSchema: Todo}`"
          )
        );
      }
      const type = typeCheckerUtils.getTypeAtLocation(node.name);
      if (!type) {
        return yield* fail(
          new CodegenNotApplicableError(
            "error getting the type to process"
          )
        );
      }
      const nameToType = /* @__PURE__ */ new Map();
      const typeProperties = typeChecker.getPropertiesOfType(type);
      for (const symProp of typeProperties) {
        const symName = ts.symbolName(symProp);
        const propType = typeChecker.getTypeOfSymbolAtLocation(symProp, node);
        if (propType) nameToType.set(symName, propType);
      }
      const hash2 = pipe(
        fromIterable(nameToType),
        map3(([name, type2]) => {
          const typeString = typeChecker.typeToString(
            type2,
            node,
            ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.UseStructuralFallback
          );
          return name + ": " + typeString;
        }),
        join("\n"),
        cyrb53
      );
      return {
        hash: hash2,
        nameToType
      };
    });
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) {
      return yield* fail(new CodegenNotApplicableError("no node and comment range affected"));
    }
    return yield* pipe(
      parse3(nodeAndCommentRange.node),
      map4(
        (_) => ({
          hash: _.hash,
          description: "Generate Schemas from types",
          apply: pipe(
            gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const ctx = yield* process(
                sourceFile,
                nodeAndCommentRange.node,
                _.nameToType,
                true,
                true
              );
              const pos = sourceFile.end;
              for (const range of ctx.rangesToDelete) {
                changeTracker.deleteRange(sourceFile, range);
              }
              for (const statement of ctx.schemaStatements) {
                changeTracker.insertNodeAt(sourceFile, pos, statement, { prefix: "\n", suffix: "\n" });
              }
            }),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeCheckerUtils, typeCheckerUtils),
            provideService(TypeParser, typeParser),
            provideService(TypeScriptProgram, program)
          )
        })
      )
    );
  })
});

// src/codegens.ts
var codegens = [accessors, annotate, typeToSchema];

// src/diagnostics/outdatedEffectCodegen.ts
var outdatedEffectCodegen = createDiagnostic({
  name: "outdatedEffectCodegen",
  code: 19,
  description: "Detects when generated code is outdated and needs to be regenerated",
  severity: "warning",
  apply: fn("outdatedEffectCodegen.apply")(function* (sourceFile, _report) {
    const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
    for (const { codegen, hash: hash2, range } of codegensWithRanges) {
      yield* pipe(
        getEditsForCodegen([codegen], sourceFile, range),
        map4((applicable) => {
          if (applicable.hash !== hash2) {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} result is outdated`,
              fixes: [
                {
                  fixName: "outdatedEffectCodegen_fix",
                  description: `Re-run ${codegen.name}`,
                  apply: applicable.apply
                },
                {
                  fixName: "outdatedEffectCodegen_ignore",
                  description: `Ignore this ${codegen.name} update`,
                  apply: applicable.ignore
                }
              ]
            });
          }
        }),
        orElse2(
          (e) => sync(() => {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,
              fixes: []
            });
          })
        ),
        ignore
      );
    }
  })
});

// src/diagnostics/overriddenSchemaConstructor.ts
var overriddenSchemaConstructor = createDiagnostic({
  name: "overriddenSchemaConstructor",
  code: 30,
  description: "Prevents overriding constructors in Schema classes which breaks decoding behavior",
  severity: "error",
  apply: fn("overriddenSchemaConstructor.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    function isAllowedConstructor(node) {
      if (node.body && node.body.statements.length === 1) {
        const expressionStatement = node.body.statements[0];
        if (ts.isExpressionStatement(expressionStatement)) {
          const maybeCallSuper = expressionStatement.expression;
          if (ts.isCallExpression(maybeCallSuper)) {
            if (maybeCallSuper.expression.kind === ts.SyntaxKind.SuperKeyword) {
              const expectedNames = node.parameters.map((_) => _.name).filter(ts.isIdentifier).map((_) => ts.idText(_));
              if (expectedNames.length === 2 && expectedNames.length === node.parameters.length) {
                const givenNames = maybeCallSuper.arguments.filter(ts.isIdentifier).map((_) => ts.idText(_));
                if (givenNames.length === expectedNames.length && givenNames.every((name, index) => name === expectedNames[index])) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.heritageClauses) {
        let extendsSchema = false;
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
            for (const type of heritageClause.types) {
              const typeAtLocation = typeCheckerUtils.getTypeAtLocation(type.expression);
              if (!typeAtLocation) continue;
              const isSchema = yield* pipe(
                typeParser.effectSchemaType(typeAtLocation, type.expression),
                map4(() => true),
                orElse2(() => succeed(false))
              );
              if (isSchema) {
                extendsSchema = true;
                break;
              }
            }
          }
          if (extendsSchema) break;
        }
        if (extendsSchema) {
          const members = node.members;
          for (const member of members) {
            if (ts.isConstructorDeclaration(member)) {
              if (isAllowedConstructor(member)) {
                continue;
              }
              const fixAsStaticNew = {
                fixName: "overriddenSchemaConstructor_static",
                description: "Rewrite using the static 'new' pattern",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const visitor = (node2) => {
                    if (ts.isExpressionStatement(node2) && ts.isCallExpression(node2.expression) && ts.isToken(node2.expression.expression) && node2.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
                      const constructThis = ts.factory.createNewExpression(
                        ts.factory.createIdentifier("this"),
                        void 0,
                        node2.expression.arguments
                      );
                      return ts.factory.createVariableStatement(
                        void 0,
                        ts.factory.createVariableDeclarationList(
                          [ts.factory.createVariableDeclaration(
                            "_this",
                            void 0,
                            void 0,
                            constructThis
                          )],
                          ts.NodeFlags.Const
                        )
                      );
                    }
                    if (ts.isToken(node2) && node2.kind === ts.SyntaxKind.ThisKeyword) {
                      return ts.factory.createIdentifier("_this");
                    }
                    return ts.visitEachChild(node2, visitor, ts.nullTransformationContext);
                  };
                  const newBody = visitor(member.body);
                  const bodyWithReturn = ts.factory.updateBlock(
                    newBody,
                    newBody.statements.concat([
                      ts.factory.createReturnStatement(ts.factory.createIdentifier("_this"))
                    ])
                  );
                  const newMethod = ts.factory.createMethodDeclaration(
                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),
                    void 0,
                    "new",
                    void 0,
                    member.typeParameters,
                    member.parameters,
                    member.type,
                    bodyWithReturn
                  );
                  changeTracker.replaceNode(sourceFile, member, newMethod);
                })
              };
              report({
                location: member,
                messageText: "Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.",
                fixes: (member.body ? [fixAsStaticNew] : []).concat([{
                  fixName: "overriddenSchemaConstructor_fix",
                  description: "Remove the constructor override",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.delete(sourceFile, member);
                  })
                }])
              });
              break;
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/preferSchemaOverJson.ts
var preferSchemaOverJson = createDiagnostic({
  name: "preferSchemaOverJson",
  code: 44,
  description: "Suggests using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify which may throw",
  severity: "suggestion",
  apply: fn("preferSchemaOverJson.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const parseJsonMethod = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail("node is not a call expression");
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return yield* fail("expression is not a property access");
      const objectExpr = expression.expression;
      const methodName = ts.idText(expression.name);
      if (!ts.isIdentifier(objectExpr) || ts.idText(objectExpr) !== "JSON") {
        return yield* fail("object is not JSON");
      }
      if (methodName !== "parse" && methodName !== "stringify") {
        return yield* fail("method is not parse or stringify");
      }
      return { node, methodName };
    });
    const effectTrySimple = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail("Effect.try has no arguments");
      const lazyFn = yield* typeParser.lazyExpression(node.arguments[0]);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const effectTryObject = (node) => gen(function* () {
      if (!ts.isCallExpression(node)) return yield* fail("node is not a call expression");
      yield* typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression);
      if (node.arguments.length === 0) return yield* fail("Effect.try has no arguments");
      const arg = node.arguments[0];
      if (!ts.isObjectLiteralExpression(arg)) return yield* fail("argument is not an object literal");
      const tryProp = arg.properties.find(
        (p) => ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) && ts.idText(p.name) === "try"
      );
      if (!tryProp) return yield* fail("object has no 'try' property");
      const lazyFn = yield* typeParser.lazyExpression(tryProp.initializer);
      const jsonMethod = yield* parseJsonMethod(lazyFn.expression);
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const jsonMethodInEffectGen = (node) => gen(function* () {
      const jsonMethod = yield* parseJsonMethod(node);
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) {
        return yield* fail("not inside an Effect generator");
      }
      if (scopeNode && scopeNode !== effectGen.generatorFunction) {
        return yield* fail("inside a nested function scope");
      }
      return { node: jsonMethod.node, methodName: jsonMethod.methodName };
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const match2 = yield* pipe(
        firstSuccessOf([
          effectTrySimple(node),
          effectTryObject(node),
          jsonMethodInEffectGen(node)
        ]),
        option
      );
      if (isSome2(match2)) {
        report({
          location: match2.value.node,
          messageText: "Consider using Effect Schema for JSON operations instead of JSON.parse/JSON.stringify",
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/redundantSchemaTagIdentifier.ts
var redundantSchemaTagIdentifier = createDiagnostic({
  name: "redundantSchemaTagIdentifier",
  code: 42,
  description: "Suggests removing redundant identifier argument when it equals the tag value in Schema.TaggedClass/TaggedError/TaggedRequest",
  severity: "suggestion",
  apply: fn("redundantSchemaTagIdentifier.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsSchemaTaggedClass(node),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral && result.tagStringLiteral) {
          const { keyStringLiteral, tagStringLiteral } = result;
          if (keyStringLiteral.text === tagStringLiteral.text) {
            report({
              location: keyStringLiteral,
              messageText: `Identifier '${keyStringLiteral.text}' is redundant since it equals the _tag value`,
              fixes: [{
                fixName: "redundantSchemaTagIdentifier_removeIdentifier",
                description: `Remove redundant identifier '${keyStringLiteral.text}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.deleteRange(sourceFile, {
                    pos: ts.getTokenPosOfNode(keyStringLiteral, sourceFile),
                    end: keyStringLiteral.end
                  });
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/returnEffectInGen.ts
var returnEffectInGen = createDiagnostic({
  name: "returnEffectInGen",
  code: 11,
  description: "Warns when returning an Effect in a generator causes nested Effect<Effect<...>>",
  severity: "suggestion",
  apply: fn("returnEffectInGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isReturnStatement(node) && node.expression) {
        if (ts.isYieldExpression(node.expression)) continue;
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        const type = typeCheckerUtils.getTypeAtLocation(node.expression);
        if (!type) continue;
        const maybeEffect = yield* option(typeParser.strictEffectType(type, node.expression));
        if (isSome2(maybeEffect)) {
          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
            const effectGenNode = generatorOrRegularFunction.parent;
            yield* pipe(
              typeParser.effectGen(effectGenNode),
              orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
              orElse2(() => typeParser.effectFnGen(effectGenNode)),
              map4(() => {
                const fix = node.expression ? [{
                  fixName: "returnEffectInGen_fix",
                  description: "Add yield* statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node.expression,
                      ts.factory.createYieldExpression(
                        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                        node.expression
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.
Maybe you wanted to return yield* instead?
Nested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,
                  fixes: fix
                });
              }),
              ignore
            );
          }
        }
      }
    }
  })
});

// src/diagnostics/runEffectInsideEffect.ts
var runEffectInsideEffect = createDiagnostic({
  name: "runEffectInsideEffect",
  code: 32,
  description: "Suggests using Runtime methods instead of Effect.run* inside Effect contexts",
  severity: "suggestion",
  apply: fn("runEffectInsideEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseEffectMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectModuleApi(methodName)(node),
      map4(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      if (node.arguments.length === 0) continue;
      const isEffectRunCall = yield* pipe(
        parseEffectMethod(node.expression, "runPromise"),
        orElse2(() => parseEffectMethod(node.expression, "runSync")),
        orElse2(() => parseEffectMethod(node.expression, "runFork")),
        orElse2(() => parseEffectMethod(node.expression, "runCallback")),
        option
      );
      if (isNone2(isEffectRunCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (effectGen && effectGen.body.statements.length > 0) {
        const nodeText = sourceFile.text.substring(
          ts.getTokenPosOfNode(node.expression, sourceFile),
          node.expression.end
        );
        if (scopeNode && scopeNode !== effectGen.generatorFunction) {
          const fixAddRuntime = gen(function* () {
            const changeTracker = yield* service(ChangeTracker);
            const runtimeModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Runtime") || "Runtime";
            const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Effect") || "Effect";
            let runtimeIdentifier = void 0;
            for (const statement of effectGen.generatorFunction.body.statements) {
              if (ts.isVariableStatement(statement) && statement.declarationList.declarations.length === 1) {
                const declaration = statement.declarationList.declarations[0];
                if (declaration.initializer && ts.isYieldExpression(declaration.initializer) && declaration.initializer.asteriskToken && declaration.initializer.expression) {
                  const yieldedExpression = declaration.initializer.expression;
                  if (ts.isCallExpression(yieldedExpression)) {
                    const maybeEffectRuntime = yield* pipe(
                      typeParser.isNodeReferenceToEffectModuleApi("runtime")(yieldedExpression.expression),
                      option
                    );
                    if (isSome2(maybeEffectRuntime) && ts.isIdentifier(declaration.name)) {
                      runtimeIdentifier = ts.idText(declaration.name);
                    }
                  }
                }
              }
            }
            if (!runtimeIdentifier) {
              changeTracker.insertNodeAt(
                sourceFile,
                effectGen.body.statements[0].pos,
                ts.factory.createVariableStatement(
                  void 0,
                  ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(
                    "effectRuntime",
                    void 0,
                    void 0,
                    ts.factory.createYieldExpression(
                      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                      ts.factory.createCallExpression(
                        ts.factory.createPropertyAccessExpression(
                          ts.factory.createIdentifier(effectModuleIdentifier),
                          "runtime"
                        ),
                        [ts.factory.createTypeReferenceNode("never")],
                        []
                      )
                    )
                  )], ts.NodeFlags.Const)
                ),
                {
                  prefix: "\n",
                  suffix: "\n"
                }
              );
            }
            changeTracker.deleteRange(sourceFile, {
              pos: ts.getTokenPosOfNode(node.expression, sourceFile),
              end: node.arguments[0].pos
            });
            changeTracker.insertText(
              sourceFile,
              node.arguments[0].pos,
              `${runtimeModuleIdentifier}.${isEffectRunCall.value.methodName}(${runtimeIdentifier || "effectRuntime"}, `
            );
          });
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. The same runtime should generally be used instead to run child effects.
Consider extracting the Runtime by using for example Effect.runtime and then use Runtime.${isEffectRunCall.value.methodName} with the extracted runtime instead.`,
            fixes: [{
              fixName: "runEffectInsideEffect_fix",
              description: "Use a runtime to run the Effect",
              apply: fixAddRuntime
            }]
          });
        } else {
          report({
            location: node.expression,
            messageText: `Using ${nodeText} inside an Effect is not recommended. Effects inside generators can usually just be yielded.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/schemaStructWithTag.ts
var schemaStructWithTag = createDiagnostic({
  name: "schemaStructWithTag",
  code: 34,
  description: "Suggests using Schema.TaggedStruct instead of Schema.Struct with _tag field",
  severity: "suggestion",
  apply: fn("schemaStructWithTag.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaStructCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Struct")(node.expression),
          orElse2(() => void_)
        );
        if (isSchemaStructCall && node.arguments.length === 1) {
          const arg = node.arguments[0];
          if (ts.isObjectLiteralExpression(arg)) {
            const tagProperty = arg.properties.find(
              (prop) => ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name) && ts.idText(prop.name) === "_tag"
            );
            if (tagProperty && ts.isCallExpression(tagProperty.initializer)) {
              const isSchemaLiteralCall = yield* pipe(
                typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(
                  tagProperty.initializer.expression
                ),
                option
              );
              if (isSchemaLiteralCall._tag === "Some") {
                const literalCall = tagProperty.initializer;
                const literalArgs = fromIterable(literalCall.arguments);
                if (literalArgs.length === 1 && ts.isStringLiteral(literalArgs[0])) {
                  const tagValue = literalArgs[0].text;
                  const otherProperties = arg.properties.filter((prop) => prop !== tagProperty);
                  report({
                    location: node,
                    messageText: "Schema.Struct with a _tag field can be simplified to Schema.TaggedStruct to make the tag optional in the constructor.",
                    fixes: [{
                      fixName: "schemaStructWithTag_fix",
                      description: "Replace with Schema.TaggedStruct",
                      apply: gen(function* () {
                        const changeTracker = yield* service(ChangeTracker);
                        const newObjectLiteral = ts.factory.createObjectLiteralExpression(
                          otherProperties,
                          true
                        );
                        const newNode = ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            // Reuse the Schema identifier from the original expression
                            ts.isPropertyAccessExpression(node.expression) ? node.expression.expression : ts.factory.createIdentifier("Schema"),
                            "TaggedStruct"
                          ),
                          void 0,
                          [
                            ts.factory.createStringLiteral(tagValue),
                            newObjectLiteral
                          ]
                        );
                        changeTracker.replaceNode(sourceFile, node, newNode);
                      })
                    }]
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/schemaSyncInEffect.ts
var syncToEffectMethod = {
  decodeSync: "decode",
  decodeUnknownSync: "decodeUnknown",
  encodeSync: "encode",
  encodeUnknownSync: "encodeUnknown"
};
var schemaSyncInEffect = createDiagnostic({
  name: "schemaSyncInEffect",
  code: 43,
  description: "Suggests using Effect-based Schema methods instead of sync methods inside Effect generators",
  severity: "suggestion",
  apply: fn("schemaSyncInEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const parseSchemaSyncMethod = (node, methodName) => pipe(
      typeParser.isNodeReferenceToEffectParseResultModuleApi(methodName)(node),
      map4(() => ({ node, methodName }))
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!ts.isCallExpression(node)) continue;
      const isSchemaSyncCall = yield* pipe(
        firstSuccessOf(
          Object.keys(syncToEffectMethod).map((methodName) => parseSchemaSyncMethod(node.expression, methodName))
        ),
        option
      );
      if (isNone2(isSchemaSyncCall)) continue;
      const { effectGen, scopeNode } = yield* typeParser.findEnclosingScopes(node);
      if (!effectGen || effectGen.body.statements.length === 0) continue;
      if (scopeNode && scopeNode !== effectGen.generatorFunction) continue;
      const nodeText = sourceFile.text.substring(
        ts.getTokenPosOfNode(node.expression, sourceFile),
        node.expression.end
      );
      const effectMethodName = syncToEffectMethod[isSchemaSyncCall.value.methodName];
      report({
        location: node.expression,
        messageText: `Using ${nodeText} inside an Effect generator is not recommended. Use Schema.${effectMethodName} instead to get properly typed ParseError in the error channel.`,
        fixes: []
      });
    }
  })
});

// src/diagnostics/schemaUnionOfLiterals.ts
var schemaUnionOfLiterals = createDiagnostic({
  name: "schemaUnionOfLiterals",
  code: 33,
  description: "Simplifies Schema.Union of multiple Schema.Literal calls into single Schema.Literal",
  severity: "off",
  apply: fn("schemaUnionOfLiterals.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node)) {
        const isSchemaUnionCall = yield* pipe(
          typeParser.isNodeReferenceToEffectSchemaModuleApi("Union")(node.expression),
          orElse2(() => void_)
        );
        if (isSchemaUnionCall) {
          const args2 = fromIterable(node.arguments);
          if (args2.length >= 2) {
            const allAreCallExpressions = args2.every((arg) => ts.isCallExpression(arg));
            if (allAreCallExpressions) {
              const literalChecks = args2.map((arg) => {
                const callArg = arg;
                return pipe(
                  typeParser.isNodeReferenceToEffectSchemaModuleApi("Literal")(callArg.expression),
                  map4(() => callArg)
                );
              });
              const allLiteralsResult = yield* pipe(
                all(...literalChecks),
                option
              );
              if (allLiteralsResult._tag === "Some") {
                const allLiteralValues = [];
                for (const literalCall of allLiteralsResult.value) {
                  for (const arg of literalCall.arguments) {
                    allLiteralValues.push(arg);
                  }
                }
                const firstLiteralCall = allLiteralsResult.value[0];
                const schemaLiteralExpression = firstLiteralCall.expression;
                report({
                  location: node,
                  messageText: "A Schema.Union of multiple Schema.Literal calls can be simplified to a single Schema.Literal call.",
                  fixes: [{
                    fixName: "schemaUnionOfLiterals_fix",
                    description: "Replace with a single Schema.Literal call",
                    apply: gen(function* () {
                      const changeTracker = yield* service(ChangeTracker);
                      const newNode = ts.factory.createCallExpression(
                        schemaLiteralExpression,
                        void 0,
                        allLiteralValues
                      );
                      changeTracker.replaceNode(sourceFile, node, newNode);
                    })
                  }]
                });
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/scopeInLayerEffect.ts
var scopeInLayerEffect = createDiagnostic({
  name: "scopeInLayerEffect",
  code: 13,
  description: "Suggests using Layer.scoped instead of Layer.effect when Scope is in requirements",
  severity: "warning",
  apply: fn("scopeInLayerEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    function parseLayerEffectApiCall(node) {
      if (!ts.isCallExpression(node)) return;
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return;
      const calledModule = expression.expression;
      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return;
      const methodIdentifier = expression.name;
      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith("effect"))) return;
      return { methodIdentifier };
    }
    const reportIfLayerRequireScope = (type, node, methodIdentifier) => {
      const entries = typeCheckerUtils.unrollUnionMembers(type);
      return pipe(
        firstSuccessOf(entries.map((type2) => typeParser.scopeType(type2, node))),
        map4(
          () => report({
            location: node,
            messageText: `Seems like you are constructing a layer with a scope in the requirements.
Consider using "scoped" instead to get rid of the scope in the requirements.`,
            fixes: methodIdentifier ? [{
              fixName: "scopeInLayerEffect_scoped",
              description: "Use scoped for Layer creation",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                changeTracker.replaceNode(
                  sourceFile,
                  methodIdentifier,
                  ts.factory.createIdentifier("scoped")
                );
              })
            }] : []
          })
        ),
        ignore
      );
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const layerEffectApiCall = parseLayerEffectApiCall(node);
      if (layerEffectApiCall) {
        const type = typeCheckerUtils.getTypeAtLocation(node);
        if (type) {
          yield* pipe(
            typeParser.layerType(type, node),
            flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),
            ignore
          );
        }
        continue;
      }
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const classType = typeChecker.getTypeOfSymbol(classSym);
          const defaultLayer = typeChecker.getPropertyOfType(classType, "Default");
          if (defaultLayer) {
            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node);
            yield* pipe(
              typeParser.layerType(type, node),
              flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, void 0)),
              ignore
            );
            continue;
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/strictBooleanExpressions.ts
var strictBooleanExpressions = createDiagnostic({
  name: "strictBooleanExpressions",
  code: 17,
  description: "Enforces boolean types in conditional expressions for type safety",
  severity: "off",
  apply: fn("strictBooleanExpressions.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const conditionChecks = /* @__PURE__ */ new WeakMap();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const nodes = [];
      if (ts.isIfStatement(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.expression);
      } else if (ts.isWhileStatement(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.expression);
      } else if (ts.isConditionalExpression(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.condition);
      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {
        conditionChecks.set(node, true);
        nodes.push(node.operand);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes.push(node.left);
        nodes.push(node.right);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes.push(node.left);
        nodes.push(node.right);
      }
      for (const nodeToCheck of nodes) {
        if (!nodeToCheck) continue;
        if (!conditionChecks.has(nodeToCheck.parent)) continue;
        if (!ts.isExpression(nodeToCheck)) continue;
        const nodeType = typeCheckerUtils.getTypeAtLocation(nodeToCheck);
        if (!nodeType) continue;
        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType);
        let typesToCheck = [constrainedType || nodeType];
        while (typesToCheck.length > 0) {
          const type = typesToCheck.pop();
          if (typeCheckerUtils.isUnion(type)) {
            typesToCheck = typesToCheck.concat(type.types);
            continue;
          }
          if (type.flags & ts.TypeFlags.Boolean) continue;
          if (type.flags & ts.TypeFlags.Never) continue;
          if (type.flags & ts.TypeFlags.BooleanLiteral) continue;
          const typeName = typeChecker.typeToString(type);
          report({
            location: nodeToCheck,
            messageText: `Unexpected \`${typeName}\` type in condition, expected strictly a boolean instead.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/strictEffectProvide.ts
var strictEffectProvide = createDiagnostic({
  name: "strictEffectProvide",
  code: 27,
  description: "Warns when using Effect.provide with layers outside of application entry points",
  severity: "off",
  apply: fn("strictEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const parseEffectProvideWithLayer = (node) => gen(function* () {
      if (!ts.isCallExpression(node) || node.arguments.length === 0) {
        return yield* typeParserIssue("Not an Effect.provide call");
      }
      yield* typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression);
      return yield* firstSuccessOf(
        node.arguments.map((arg) => {
          const argType = typeCheckerUtils.getTypeAtLocation(arg);
          if (!argType) return typeParserIssue("Could not get argument type");
          return typeParser.layerType(argType, arg);
        })
      );
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), option);
        if (isSome2(layerCheck)) {
          report({
            location: node,
            messageText: "Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.",
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/tryCatchInEffectGen.ts
var tryCatchInEffectGen = createDiagnostic({
  name: "tryCatchInEffectGen",
  code: 15,
  description: "Discourages try/catch in Effect generators in favor of Effect error handling",
  severity: "suggestion",
  apply: fn("tryCatchInEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isTryStatement(node) && node.catchClause) {
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        if (!generatorOrRegularFunction) continue;
        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
          const effectGenNode = generatorOrRegularFunction.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map4(() => {
              report({
                location: node,
                messageText: "Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).",
                fixes: []
              });
            }),
            ignore
          );
        }
      }
    }
  })
});

// src/diagnostics/unknownInEffectCatch.ts
var unknownInEffectCatch = createDiagnostic({
  name: "unknownInEffectCatch",
  code: 31,
  description: "Warns when catch callbacks return unknown instead of typed errors",
  severity: "warning",
  apply: fn("unknownInEffectCatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const isEffectWithCatch = yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("tryPromise")(node.expression),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("try")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMap")(node.expression)),
          orElse2(() => typeParser.isNodeReferenceToEffectModuleApi("tryMapPromise")(node.expression)),
          orElse2(() => void_)
        );
        if (isEffectWithCatch) {
          const signature = typeChecker.getResolvedSignature(node);
          if (signature) {
            const objectType = typeChecker.getParameterType(signature, 0);
            const catchFunctionSymbol = typeChecker.getPropertyOfType(objectType, "catch");
            if (catchFunctionSymbol) {
              const catchFunctionType = typeChecker.getTypeOfSymbolAtLocation(catchFunctionSymbol, node);
              const signatures = typeChecker.getSignaturesOfType(catchFunctionType, ts.SignatureKind.Call);
              if (signatures.length > 0) {
                const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
                if (returnType && (returnType.flags & ts.TypeFlags.Unknown || returnType.flags & ts.TypeFlags.Any)) {
                  const nodeText = sourceFile.text.substring(
                    ts.getTokenPosOfNode(node.expression, sourceFile),
                    node.expression.end
                  );
                  report({
                    location: node.expression,
                    messageText: `The 'catch' callback in ${nodeText} returns 'unknown'. The catch callback should be used to provide typed errors.
Consider wrapping unknown errors into Effect's Data.TaggedError for example, or narrow down the type to the specific error raised.`,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/unnecessaryEffectGen.ts
var unnecessaryEffectGen = createDiagnostic({
  name: "unnecessaryEffectGen",
  code: 5,
  description: "Suggests removing Effect.gen when it contains only a single return statement",
  severity: "suggestion",
  apply: fn("unnecessaryEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.unnecessaryEffectGen(node),
          map4(
            ({ replacementNode }) => report({
              location: node,
              messageText: `This Effect.gen contains a single return statement.`,
              fixes: [{
                fixName: "unnecessaryEffectGen_fix",
                description: "Remove the Effect.gen, and keep the body",
                apply: gen(function* () {
                  const textChanges = yield* service(
                    ChangeTracker
                  );
                  textChanges.replaceNode(sourceFile, node, yield* replacementNode);
                })
              }]
            })
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryFailYieldableError.ts
var unnecessaryFailYieldableError = createDiagnostic({
  name: "unnecessaryFailYieldableError",
  code: 29,
  description: "Suggests yielding yieldable errors directly instead of wrapping with Effect.fail",
  severity: "suggestion",
  apply: fn("unnecessaryFailYieldableError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.asteriskToken && node.expression && ts.isCallExpression(node.expression)) {
        const callExpression = node.expression;
        yield* pipe(
          typeParser.isNodeReferenceToEffectModuleApi("fail")(callExpression.expression),
          flatMap2(() => {
            if (callExpression.arguments.length > 0) {
              const failArgument = callExpression.arguments[0];
              const argumentType = typeCheckerUtils.getTypeAtLocation(failArgument);
              if (!argumentType) return void_;
              return pipe(
                typeParser.extendsCauseYieldableError(argumentType),
                map4(
                  () => report({
                    location: node,
                    messageText: `This Effect.fail call uses a yieldable error type as argument. You can yield* the error directly instead.`,
                    fixes: [{
                      fixName: "unnecessaryFailYieldableError_fix",
                      description: "Replace yield* Effect.fail with yield*",
                      apply: gen(function* () {
                        const changeTracker = yield* service(ChangeTracker);
                        changeTracker.replaceNode(
                          sourceFile,
                          callExpression,
                          failArgument
                        );
                      })
                    }]
                  })
                )
              );
            }
            return void_;
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipe.ts
var unnecessaryPipe = createDiagnostic({
  name: "unnecessaryPipe",
  code: 9,
  description: "Removes pipe calls with no arguments",
  severity: "suggestion",
  apply: fn("unnecessaryPipe.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          map4(({ args: args2, subject }) => {
            if (args2.length === 0) {
              report({
                location: node,
                messageText: `This pipe call contains no arguments.`,
                fixes: [{
                  fixName: "unnecessaryPipe_fix",
                  description: "Remove the pipe call",
                  apply: gen(function* () {
                    const textChanges = yield* service(
                      ChangeTracker
                    );
                    textChanges.replaceNode(sourceFile, node, subject);
                  })
                }]
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipeChain.ts
var unnecessaryPipeChain = createDiagnostic({
  name: "unnecessaryPipeChain",
  code: 16,
  description: "Simplifies chained pipe calls into a single pipe call",
  severity: "suggestion",
  apply: fn("unnecessaryPipeChain.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          flatMap2(
            (pipeCall) => map4(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))
          ),
          map4(({ innerCall, pipeCall }) => {
            report({
              location: node,
              messageText: `Chained pipe calls can be simplified to a single pipe call`,
              fixes: [{
                fixName: "unnecessaryPipeChain_fix",
                description: "Rewrite as single pipe call",
                apply: gen(function* () {
                  const changeTracker = yield* service(
                    ChangeTracker
                  );
                  switch (innerCall.kind) {
                    case "pipe": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createIdentifier("pipe"),
                          void 0,
                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                    case "pipeable": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            innerCall.subject,
                            "pipe"
                          ),
                          void 0,
                          [...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                  }
                })
              }]
            });
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unsupportedServiceAccessors.ts
var unsupportedServiceAccessors = createDiagnostic({
  name: "unsupportedServiceAccessors",
  code: 21,
  description: "Warns about service accessors that need codegen due to generic/complex signatures",
  severity: "warning",
  apply: fn("unsupportedServiceAccessors.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isClassDeclaration(node)) {
        const parseResult = yield* pipe(
          parse2(node),
          orElse2(() => succeed(null))
        );
        if (parseResult && parseResult.involvedMembers.length > 0) {
          const existingStaticMembers = /* @__PURE__ */ new Set();
          node.members?.forEach((member) => {
            if (ts.isPropertyDeclaration(member) && member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)) {
              if (member.name && ts.isIdentifier(member.name)) {
                existingStaticMembers.add(ts.idText(member.name));
              }
            }
          });
          const missingMembers = parseResult.involvedMembers.filter(
            ({ property }) => !existingStaticMembers.has(ts.symbolName(property))
          );
          if (missingMembers.length > 0) {
            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(", ");
            const suggestedFix = parseResult.kind === "effectTag" ? "\nEffect.Tag does not allow to disable accessors, so you may want to use Context.Tag instead." : "";
            report({
              location: parseResult.className,
              messageText: `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.${suggestedFix}`,
              fixes: [{
                fixName: "unsupportedServiceAccessors_enableCodegen",
                description: "Enable accessors codegen",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const comment = "// @effect-codegens accessors\n";
                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment);
                })
              }]
            });
          }
        }
      }
    }
  })
});

// src/diagnostics.ts
var diagnostics = [
  anyUnknownInErrorContext,
  instanceOfSchema,
  catchAllToMapError,
  catchUnfailableEffect,
  classSelfMismatch,
  duplicatePackage,
  effectGenUsesAdapter,
  missingEffectContext,
  missingEffectError,
  missingEffectServiceDependency,
  missingLayerContext,
  floatingEffect,
  missingStarInYieldEffectGen,
  unnecessaryEffectGen,
  unnecessaryFailYieldableError,
  missingReturnYieldStar,
  leakingRequirements,
  unnecessaryPipe,
  genericEffectServices,
  returnEffectInGen,
  tryCatchInEffectGen,
  importFromBarrel,
  scopeInLayerEffect,
  effectInVoidSuccess,
  unnecessaryPipeChain,
  strictBooleanExpressions,
  multipleEffectProvide,
  outdatedEffectCodegen,
  overriddenSchemaConstructor,
  unsupportedServiceAccessors,
  nonObjectEffectServiceType,
  deterministicKeys,
  missedPipeableOpportunity,
  strictEffectProvide,
  unknownInEffectCatch,
  runEffectInsideEffect,
  schemaUnionOfLiterals,
  schemaStructWithTag,
  globalErrorInEffectCatch,
  globalErrorInEffectFailure,
  layerMergeAllWithDependencies,
  effectMapVoid,
  effectSucceedWithVoid,
  effectFnIife,
  effectFnOpportunity,
  redundantSchemaTagIdentifier,
  schemaSyncInEffect,
  preferSchemaOverJson
];

// src/transform.ts
function transform_default(program, pluginConfig, { addDiagnostic, ts: tsInstance }) {
  return (_) => {
    return (sourceFile) => {
      pipe(
        getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
        nanoLayer3,
        nanoLayer2,
        nanoLayer,
        provideService(TypeCheckerApi, program.getTypeChecker()),
        provideService(TypeScriptProgram, program),
        provideService(TypeScriptApi, tsInstance),
        provideService(
          LanguageServicePluginOptions,
          parse(pluginConfig)
        ),
        run,
        map((_2) => _2.diagnostics),
        map(
          filter(
            (_2) => _2.category === tsInstance.DiagnosticCategory.Error || _2.category === tsInstance.DiagnosticCategory.Warning
          )
        ),
        getOrElse(() => []),
        map3(addDiagnostic)
      );
      return sourceFile;
    };
  };
}
//# sourceMappingURL=transform.js.map